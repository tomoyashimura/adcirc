NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME : /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

  COMPILER OPTIONS : -stdlib=compat -DADCNETCDF -I/include -DHAVE_NETCDF4 -DDATETIME -c -I. -I/S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep -O3 -fextend-source -report-all -finline-functions -finline-max-function-size=200 -finline-file=/S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/nodalattr.F -DES_TUNE -DADCNETCDF -I/include -DHAVE_NETCDF4 -DDATETIME -DREAL8 -DLINUX -DCSCA -DCMPI -I /S/home01/G6012/d0954/DATA/model_run/adcirc_src/work/odir4/ -I/S/home01/G6012/d0954/util/datetime/datetime-fortran/include -o /S/home01/G6012/d0954/DATA/model_run/adcirc_src/work/odir4/wind.o -fpp -DMPI_REAL2=NEC_MPI_BINARY16 -Dmpi_real2=NEC_MPI_BINARY16 -DNEC_MPI_FLOAT16_INT=NEC_MPI_BINARY16_INT -Dnec_mpi_float16_int=NEC_MPI_BINARY16_INT -DMPI_2REAL2=NEC_MPI_2BINARY16 -Dmpi_2real2=NEC_MPI_2BINARY16 -proginf -I/opt/nec/ve/mpi/3.6.0/lib64/ve/module -I/opt/nec/ve/mpi/3.6.0/include

  PARAMETER :

      Optimization Options :
        -On                                      : 3
        -fargument-alias                         : disable
        -fargument-noalias                       : enable
        -fassociative-math                       : enable
        -faggressive-associative-math            : disable
        -fassume-contiguous                      : disable
        -fcopyin-intent-out                      : enable
        -fcse-after-vectorization                : enable
        -ffast-formatted-io                      : enable
        -ffast-math                              : enable
        -ffast-math-check                        : disable
        -fignore-asynchronous                    : disable
        -fignore-induction-variable-overflow     : disable
        -fignore-volatile                        : disable
        -fivdep                                  : disable
        -fivdep-omp-worksharing-loop             : disable
        -floop-collapse                          : enable
        -floop-count                             : 5000
        -floop-fusion                            : enable
        -floop-interchange                       : enable
        -floop-normalize                         : enable
        -floop-split                             : disable
        -floop-strip-mine                        : enable
        -floop-unroll                            : enable
        -floop-unroll-complete                   : 4
        -floop-unroll-complete-nest              : 3
        -floop-unroll-max-times                  : auto
        -fmatrix-multiply                        : enable
        -fmove-loop-invariants                   : enable
        -fmove-loop-invariants-if                : enable
        -fmove-loop-invariants-unsafe            : disable
        -fmove-nested-loop-invariants-outer      : enable
        -fnamed-alias                            : disable
        -fnamed-noalias                          : enable
        -fnamed-noalias-aggressive               : disable
        -fouterloop-unroll                       : enable
        -fouterloop-unroll-max-size              : 4
        -fouterloop-unroll-max-times             : 4
        -fprecise-math                           : disable
        -freciprocal-math                        : enable
        -freorder-logical-expression             : enable
        -freplace-loop-equation                  : disable
        -freplace-matmul-to-matrix-multiply      : enable
        -marray-io                               : enable
        -mconditional-index-test                 : enable
        -mlist-vector                            : disable
        -mretain-'keyword'                       : all
        -msched-'keyword'                        : block
        -mstack-arrays                           : enable
        -mvector                                 : enable
        -mvector-advance-gather                  : enable
        -mvector-advance-gather-limit            : 56
        -mvector-assignment-threshold            : 64
        -mvector-dependency-test                 : enable
        -mvector-floating-divide-instruction     : disable
        -mvector-fma                             : enable
        -mvector-intrinsic-check                 : disable
        -mvector-iteration                       : enable
        -mvector-iteration-unsafe                : enable
        -mvector-loop-count-test                 : disable
        -mvector-low-precise-divide-function     : disable
        -mvector-merge-conditional               : enable
        -mvector-neighbors                       : disable
        -mvector-packed                          : disable
        -mvector-power-to-explog                 : disable
        -mvector-power-to-sqrt                   : enable
        -mvector-reduction                       : enable
        -mvector-shortloop-reduction             : disable
        -mvector-sqrt-instruction                : disable
        -mvector-threshold                       : 5
        -mwork-vector-kind=none                  : disable

      Parallelization Options :
        -fopenmp                                 : disable
        -mparallel                               : disable
        -mparallel-innerloop                     : disable
        -mparallel-omp-routine                   : enable
        -mparallel-outerloop-strip-mine          : disable
        -mparallel-sections                      : disable
        -mparallel-threshold                     : 2000
        -mschedule-dynamic                       : disable
        -mschedule-runtime                       : disable
        -mschedule-static                        : disable
        -mschedule-chunk-size                    : 0
        -pthread                                 : disable

      Inlining Options :
        -finline-copy-arguments                  : enable
        -finline-functions                       : enable
        -finline-max-depth                       : 2
        -finline-max-function-size               : 200
        -finline-max-times                       : 6

      Code Generation Options :
        -finstrument-functions                   : disable
        -fpic | -fPIC                            : disable
        -ftrace                                  : disable
        -march                                   : ve1
        -mfp16-format                            : none
        -p                                       : disable

      Debugging Options :
        -fbounds-check                           : disable
        -fcheck=all                              : disable
        -fcheck=alias                            : disable
        -fcheck=bits                             : disable
        -fcheck=bounds                           : disable
        -fcheck=dangling                         : disable
        -fcheck=do                               : disable
        -fcheck=iovf                             : disable
        -fcheck=pointer                          : disable
        -fcheck=present                          : disable
        -fcheck=recursion                        : disable
        -g                                       : disable
        -minit-stack                             : no
        -mmemory-trace                           : disable
        -mmemory-trace-full                      : disable
        -traceback                               : disable

      Language Options :
        -bss                                     : disable
        -fdefault-integer                        : 4
        -fdefault-double                         : 8
        -fdefault-real                           : 4
        -fextend-source                          : enable
        -ffree-form                              : disable
        -ffixed-form                             : enable
        -ff90-sign                               : disable
        -fmax-continuation-lines                 : 1023
        -frealloc-lhs-array                      : enable
        -frealloc-lhs-scalar                     : enable
        -save                                    : disable
        -std                                     : Fortran 2008

      Message Options :
        -Wall                                    : disable
        -Werror                                  : disable
        -Wextension                              : enable
        -Wobsolescent                            : enable
        -Woverflow                               : disable
        -Woverflow-errors                        : disable
        -fdiag-inline                            : 1
        -fdiag-parallel                          : 1
        -fdiag-vector                            : 1
        -pedantic-errors                         : disable
        -w                                       : disable

      List Output Options :
        -report-file                             : not specified
        -report-append-mode                      : disable
        -report-all                              : enable
        -report-cg                               : enable
        -report-diagnostics                      : enable
        -report-format                           : enable
        -report-inline                           : enable
        -report-option                           : enable
        -report-vector                           : enable

      Directory Options :
        -fintrinsic-modules-path                 : /opt/nec/ve/nfort/5.2.0/include
        -module                                  : not specified

      Miscellaneous Options :
        -v                                       : disable


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITWINDMODULE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   325: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
   343: vec( 101): Vectorized loop.
   344: vec( 101): Vectorized loop.
   347: vec( 101): Vectorized loop.
   348: vec( 101): Vectorized loop.
   349: vec( 101): Vectorized loop.
   350: vec( 101): Vectorized loop.
   352: inl(1222): Inlined: WIND::CHECKWINDDRAGTYPE
   353: inl(1219): Nesting level too deep for automatic expansion.: WIND::MAPWINDDRAGFUNCTIONPOINTER
   359: vec( 103): Unvectorized loop.
   359: vec( 108): Unvectorizable loop structure.
   371: vec( 101): Vectorized loop.
   372: vec( 101): Vectorized loop.
   384: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
   393: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITWINDMODULE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   320:                 subroutine initWindModule()
   321:                 use mesh, only : np
   322:                 use global, only: NWS
   323:                 implicit none
   324:            
   325:                 call setMessageSource("initWindModule")
   326:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
   327:                 call allMessage(DEBUG,"Enter.")
   328:           #endif
   329:                 allocate ( wvnx1(np),wvny1(np) )
   330:                 allocate ( wvnx2(np),wvny2(np) )
   331:                 allocate ( prn1(np) )
   332:                 allocate ( prn2(np) )
   333:           
   334:                 if (NWS.eq.-14) allocate ( HasData(np) )
   335:           C     WJP: this is the value used in the surface stress computation
   336:           C     (can contol through the rhoAir parameter in namelist)
   337:                 airwaterdensityrat = rhoAir / rhoWat0
   338:           
   339:           C.... tcm v49.16 20100617 added
   340:           C.... convert background pressure from millibars to meters of water
   341:                 rhoWat0g = rhoWat0 * g
   342:                 PRBCKGRND_MH2O = 100.0D0 * PRBCKGRND / rhoWat0g
   343: V======>        prn1 = PRBCKGRND_MH2O
   344: V======>        prn2 = PRBCKGRND_MH2O
   345:           
   346:                 ! dw
   347: V======>        wvnx1 = 0.0
   348: V======>        wvny1 = 0.0
   349: V======>        wvnx2 = 0.0
   350: V======>        wvny2 = 0.0
   351:           
   352:         I       CALL checkWindDragType()
   353:                 CALL mapWindDragFunctionPointer()
   354:           
   355:                 if (NWS.eq.0) return
   356:           
   357:                 ! Make logicals here if NWS is not 0
   358:                 garatt = .false.; swell = .false.; powell = .false.
   359:                 SELECT CASE(TRIM(DragLawString))
   360:                    CASE("Garratt","GARRATT","garratt","default")
   361:                        garatt = .true.
   362:                        write(16,*) 'Garratt drag law used'
   363:           #ifdef CSWAN
   364:                    CASE("Swell","SWELL","swell")
   365:                        swell   = .true.
   366:                        write(16,*) 'Swell drag law used'
   367:           #endif
   368:                    CASE("Powell","POWELL","powell")
   369:                        if (NWS.eq.12.or.NWS.eq.29.or.NWS.eq.30) then
   370:                           powell  = .true.
   371:                           allocate(Pweight(3,np)); Pweight = 0d0
   372:                           allocate(foundSector(np)); foundSector = .false.
   373:                           write(16,*) 'Powell drag law used'
   374:                        else
   375:                           garatt = .true.
   376:                           write(16,*) 'Garratt drag law used because NWS ',
   377:                &                      'incompatible with Powell'
   378:                        endif
   379:                    CASE DEFAULT
   380:                       WRITE(16,*) 'ERROR: Wind drag law not recognized:'
   381:                       WRITE(16,'(A10)') DragLawString
   382:                       WRITE(16,*) 'Execution will now be terminated.'
   383:           #ifdef CMPI
   384:                       call msg_fini()
   385:           #endif
   386:                       CALL EXIT(1)
   387: V======>  C
   388: V======>        END SELECT
   389:           
   390:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
   391:                 call allMessage(DEBUG,"Return.")
   392:           #endif
   393:                 call unsetMessageSource()
   394:           
   395:           !     ----------------------------------------------------------------
   396:                 END SUBROUTINE initWindModule
   397:           !     ----------------------------------------------------------------
   398:           
   399:           C----------------------------------------------------------------------
   400:           C     Sets an integer for the drag law to be used later in checks
   401:           C     This is simpler than checking a string
   402:           C----------------------------------------------------------------------


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITWINDMODULE
INLINE LIST

  ROOT: WIND::INITWINDMODULE (wind.F:320)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:325)
     *** Source for routine not found.
  -> INLINE: WIND::CHECKWINDDRAGTYPE (wind.F:352)
   -> NOINLINE: GLOBAL::TOLOWERCASE (wind.F:408)
      *** Source for routine not found.
  -> NOINLINE: WIND::MAPWINDDRAGFUNCTIONPOINTER (wind.F:353)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: MESSENGER::MSG_FINI (wind.F:384)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:393)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITWINDMODULE
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:343)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:343)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:343)
  LOOP END

  LOOP BEGIN: (wind.F:344)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:344)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:344)
  LOOP END

  LOOP BEGIN: (wind.F:347)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:347)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:347)
  LOOP END

  LOOP BEGIN: (wind.F:348)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:348)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:348)
  LOOP END

  LOOP BEGIN: (wind.F:349)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:349)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:349)
  LOOP END

  LOOP BEGIN: (wind.F:350)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:350)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:350)
  LOOP END

  LOOP BEGIN: (wind.F:408)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:408)
  LOOP END

  LOOP BEGIN: (wind.F:408)
    <Unvectorized loop.>
    *** Unvectorizable data type. : DRAGLAWLOWERCASE (wind.F:408)
  LOOP END

  LOOP BEGIN: (wind.F:409)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:409)
  LOOP END

  LOOP BEGIN: (wind.F:359)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:359)
  LOOP END

  LOOP BEGIN: (wind.F:371)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:371)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:371)
  LOOP END

  LOOP BEGIN: (wind.F:372)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:372)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:372)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITWINDMODULE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 40 [s0-s12 s15-s16 s18-s20 s23-s34 s54-s63]
      Vector registers         :  8 [v56-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1344 bytes
      Register spill area      :   16 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1088 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:343)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:344)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:347)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:348)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:349)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:350)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:408)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:408)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:409)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:359)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:371)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:372)
    *** Estimated execution cycle                       : 63
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CHECKWINDDRAGTYPE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   408: inl(1212): Source for routine not found.: GLOBAL::TOLOWERCASE
   408: vec( 103): Unvectorized loop.
   408: vec( 118): Unvectorizable data type.: DRAGLAWLOWERCASE
   409: vec( 103): Unvectorized loop.
   409: vec( 108): Unvectorizable loop structure.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CHECKWINDDRAGTYPE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   403:                 SUBROUTINE checkWindDragType()
   404:           C----------------------------------------------------------------------
   405:                     USE GLOBAL,ONLY: toLowercase
   406:                     IMPLICIT NONE
   407:                     CHARACTER(LEN(dragLawString)) :: dragLawLowercase
   408: +======>            draglawlowercase = toLowercase(dragLawString)
   409:                     SELECT CASE(TRIM(draglawlowercase))
   410:                     CASE("default","garratt")
   411:                       draglawtype = DRAGLAW_GARRATT
   412:                     CASE("powell")
   413:                       draglawtype = DRAGLAW_POWELL
   414:                     CASE("swell")
   415:                       draglawtype = DRAGLAW_SWELL
   416:                     CASE DEFAULT
   417:                       draglawtype = DRAGLAW_GARRATT
   418:                     END SELECT
   419:           C----------------------------------------------------------------------
   420:                 END SUBROUTINE checkWindDragType
   421:           C----------------------------------------------------------------------
   422:           
   423:           !     ----------------------------------------------------------------
   424:           !>    @brief Maps the function pointer used in the calculation of
   425:           !>    wind drag. This is used so that the logical statements required
   426:           !>    to select the wind drag are only executed once at startup
   427:           !     ----------------------------------------------------------------


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CHECKWINDDRAGTYPE
INLINE LIST

  ROOT: WIND::CHECKWINDDRAGTYPE (wind.F:403)
  -> NOINLINE: GLOBAL::TOLOWERCASE (wind.F:408)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CHECKWINDDRAGTYPE
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:408)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:408)
  LOOP END

  LOOP BEGIN: (wind.F:408)
    <Unvectorized loop.>
    *** Unvectorizable data type. : DRAGLAWLOWERCASE (wind.F:408)
  LOOP END

  LOOP BEGIN: (wind.F:409)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:409)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CHECKWINDDRAGTYPE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 21 [s0-s3 s8-s12 s15-s16 s18-s19 s23-s25 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 256 bytes
      Register spill area      :   0 bytes
      Parameter area           :  32 bytes
      Register save area       : 176 bytes
      User data area           :  48 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:408)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:408)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:409)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::MAPWINDDRAGFUNCTIONPOINTER
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   441: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
   448: vec( 103): Unvectorized loop.
   448: vec( 108): Unvectorizable loop structure.
   450: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::MAPWINDDRAGFUNCTIONPOINTER
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   428:                 SUBROUTINE mapWindDragFunctionPointer()
   429:           !     ----------------------------------------------------------------
   430:                     IMPLICIT NONE
   431:           #ifdef POWELL
   432:                     f_computeWindDrag => PowellWindDrag
   433:           #else
   434:                     SELECT CASE(DragLawType)
   435:                     CASE(DRAGLAW_GARRATT)
   436:                         f_computeWindDrag => CappedGarrattWindDrag
   437:                     CASE(DRAGLAW_POWELL)
   438:                         f_computeWindDrag => PowellWindDrag
   439:                     CASE(DRAGLAW_SWELL)
   440:           #ifndef CSWAN
   441:                         call allMessage(WARNING,"SWAN Model not enabled."//
   442:                &              "Drag formulation will be Garratt.")
   443:                         f_computeWindDrag => CappedGarrattWindDrag
   444:           #else
   445:                         f_computeWindDrag => SwanWindDrag
   446:           #endif
   447:                     CASE DEFAULT
   448:                         call allMessage(ERROR,"Wind drag law not recognized"//TRIM(DragLawString))
   449:           #ifdef CMPI
   450:                         call msg_fini()
   451:           #endif
   452:                         CALL EXIT(1)
   453:                     END SELECT
   454:           #endif
   455:           !     ----------------------------------------------------------------
   456:                 END SUBROUTINE mapWindDragFunctionPointer


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::MAPWINDDRAGFUNCTIONPOINTER
INLINE LIST

  ROOT: WIND::MAPWINDDRAGFUNCTIONPOINTER (wind.F:428)
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:441)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:448)
     *** Source for routine not found.
  -> NOINLINE: MESSENGER::MSG_FINI (wind.F:450)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::MAPWINDDRAGFUNCTIONPOINTER
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:448)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:448)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::MAPWINDDRAGFUNCTIONPOINTER
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 24 [s0-s2 s8-s12 s15-s16 s18 s23-s31 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 240 bytes
      Register spill area      :   0 bytes
      Parameter area           :  24 bytes
      Register save area       : 176 bytes
      User data area           :  32 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:448)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDDRAG
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  No diagnostic message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDDRAG
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   466:                 REAL(8) FUNCTION WindDrag(WindSpeed, NodeNumber)
   467:                   USE GLOBAL,ONLY: windDragOut
   468:                   IMPLICIT NONE
   469:                   REAL(8) :: WindSpeed
   470:                   INTEGER  :: NodeNumber
   471:                   WindDrag = f_computeWindDrag(windSpeed,NodeNumber)
   472:                   windDragOut(nodeNumber) = windDrag
   473:                   RETURN
   474:           !     ----------------------------------------------------------------
   475:                 END FUNCTION WindDrag


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDDRAG
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDDRAG
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDDRAG
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 14 [s0-s1 s8-s12 s15-s16 s23-s24 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 192 bytes
      Register spill area      :   0 bytes
      Parameter area           :  16 bytes
      Register save area       : 176 bytes
      User data area           :   0 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GARRATTWINDDRAG
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  No diagnostic message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GARRATTWINDDRAG
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   511:                  FUNCTION GarrattWindDrag(WindSpeed,NodeNumber) RESULT(Drag)
   512:           !     ----------------------------------------------------------------
   513:                      IMPLICIT NONE
   514:                      REAL(8),INTENT(IN)  :: WindSpeed
   515:                      INTEGER,INTENT(IN)  :: NodeNumber
   516:                      REAL(8)             :: Drag
   517:                      Drag = 0.001d0*(0.75d0+0.067d0*WindSpeed)
   518:                  END FUNCTION GarrattWindDrag


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GARRATTWINDDRAG
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GARRATTWINDDRAG
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GARRATTWINDDRAG
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         :  7 [s0 s8-s11 s62-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 0 bytes
      Register spill area      : 0 bytes
      Parameter area           : 0 bytes
      Register save area       : 0 bytes
      User data area           : 0 bytes
      Others                   : 0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CAPPEDGARRATTWINDDRAG
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   534: inl(1222): Inlined: WIND::GARRATTWINDDRAG


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CAPPEDGARRATTWINDDRAG
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   528:                  FUNCTION CappedGarrattWindDrag(WindSpeed,NodeNumber) RESULT(WindDrag)
   529:           !     ----------------------------------------------------------------
   530:                      IMPLICIT NONE
   531:                      REAL(8),INTENT(IN)  :: WindSpeed
   532:                      INTEGER,INTENT(IN)  :: NodeNumber
   533:                      REAL(8)             :: WindDrag
   534:         I            WindDrag = MIN(GarrattWindDrag(WindSpeed,NodeNumber),WindDragLimit)
   535:           !     ----------------------------------------------------------------
   536:                  END FUNCTION CappedGarrattWindDrag


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CAPPEDGARRATTWINDDRAG
INLINE LIST

  ROOT: WIND::CAPPEDGARRATTWINDDRAG (wind.F:528)
  -> INLINE: WIND::GARRATTWINDDRAG (wind.F:534)


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CAPPEDGARRATTWINDDRAG
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CAPPEDGARRATTWINDDRAG
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         :  7 [s0 s8-s11 s62-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 0 bytes
      Register spill area      : 0 bytes
      Parameter area           : 0 bytes
      Register save area       : 0 bytes
      User data area           : 0 bytes
      Others                   : 0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POWELLWINDDRAG
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   579: inl(1222): Inlined: WIND::CAPPEDGARRATTWINDDRAG
   534: inl(1222): Inlined: WIND::GARRATTWINDDRAG
   581: opt(1418): Constant-length loop is expanded.
   611: vec( 103): Unvectorized loop.
   613: opt(1019): Feedback of scalar value from one loop pass to another.: DIR1
   613: vec( 121): Unvectorizable dependency.
   614: opt(1019): Feedback of scalar value from one loop pass to another.: DIR2
   614: vec( 121): Unvectorizable dependency.
   616: vec( 121): Unvectorizable dependency.
   617: vec( 121): Unvectorizable dependency.
   619: vec( 121): Unvectorizable dependency.
   620: vec( 121): Unvectorizable dependency.
   622: vec( 121): Unvectorizable dependency.
   623: vec( 121): Unvectorizable dependency.
   625: vec( 121): Unvectorizable dependency.
   626: vec( 121): Unvectorizable dependency.
   628: vec( 121): Unvectorizable dependency.
   629: vec( 121): Unvectorizable dependency.
   633: vec( 121): Unvectorizable dependency.
   635: vec( 121): Unvectorizable dependency.
   641: opt(1418): Constant-length loop is expanded.
   641: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: WEIGHT
   645: opt(1418): Constant-length loop is expanded.
   645: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: WEIGHT
   647: opt(1019): Feedback of scalar value from one loop pass to another.: IW1
   647: vec( 121): Unvectorizable dependency.
   648: opt(1019): Feedback of scalar value from one loop pass to another.: IW2
   648: vec( 121): Unvectorizable dependency.
   650: vec( 121): Unvectorizable dependency.
   651: vec( 121): Unvectorizable dependency.
   653: vec( 121): Unvectorizable dependency.
   654: vec( 121): Unvectorizable dependency.
   656: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: WEIGHT
   657: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: WEIGHT
   665: inl(1222): Inlined: WIND::CAPPEDGARRATTWINDDRAG
   666: opt(1418): Constant-length loop is expanded.
   669: inl(1222): Inlined: WIND::GARRATTWINDDRAG


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POWELLWINDDRAG
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   548:                 FUNCTION PowellWindDrag(WindSpeed,NodeNumber) RESULT(PowellDrag)
   549:           !     ----------------------------------------------------------------
   550:                     USE GLOBAL, ONLY: DEG2RAD
   551:                     USE MESH, ONLY : SFEA, SLAM
   552:                     IMPLICIT NONE
   553:                     INTRINSIC           :: ATAN2
   554:                     INTRINSIC           :: MOD
   555:                     REAL(8),INTENT(IN)  :: WindSpeed
   556:                     INTEGER,INTENT(IN)  :: NodeNumber
   557:                     INTEGER             :: IS
   558:                     INTEGER             :: IW1,IW2,IW3
   559:                     LOGICAL             :: FoundSector
   560:                     REAL(8)             :: Dir1
   561:                     REAL(8)             :: Dir2
   562:                     REAL(8)             :: Drag(3)
   563:                     REAL(8)             :: NodeDirection
   564:                     REAL(8)             :: NodeLat
   565:                     REAL(8)             :: NodeLon
   566:                     REAL(8)             :: StormDirection
   567:                     REAL(8)             :: Weight(3)
   568:                     REAL(8)             :: PowellDrag
   569:                     REAL(8)             :: rawGarrattWindDrag
   570:           
   571:           !.. Check whether we have previously found the eye.
   572:                    IF((EyeLat(1).EQ.0.D0).OR.(EyeLon(1).EQ.0.D0).OR.
   573:                &      (EyeLat(2).EQ.0.D0).OR.(EyeLon(2).EQ.0.D0).OR.
   574:                &      (EyeLat(3).EQ.0.D0).OR.(EyeLon(3).EQ.0.D0))THEN
   575:                       FoundEye = .FALSE.
   576:                    ENDIF
   577:           !.. If the eye has not been found then apply Garratt.
   578:                    IF(.NOT.FoundEye)THEN
   579:         I             PowellDrag = CappedGarrattWindDrag(WindSpeed,NodeNumber)
   580:                       FoundSector = .FALSE.
   581: *======>              Weight = 0.D0
   582:                    ELSE
   583:           !.. We have found the eye!
   584:           !.. Compute the storm's direction.  We use the convention of northward
   585:           !.. being zero degrees, and then cycling clockwise.
   586:                       Dir1 = ATAN2(EyeLat(2)-EyeLat(1),EyeLon(2)-EyeLon(1))
   587:                       Dir2 = ATAN2(EyeLat(3)-EyeLat(2),EyeLon(3)-EyeLon(2))
   588:                       StormDirection = ATAN2(SIN(Dir1)+SIN(Dir2),COS(Dir1)+COS(Dir2))
   589:                       StormDirection = StormDirection/DEG2RAD
   590:                       StormDirection = 90.D0 - StormDirection
   591:                       IF(StormDirection.LT.0.D0)THEN
   592:                          StormDirection = StormDirection + 360.D0
   593:                       ENDIF
   594:           !.. Compute the direction of node relative to the eye.
   595:                       NodeLon = SLAM(NodeNumber)/DEG2RAD
   596:                       NodeLat = SFEA(NodeNumber)/DEG2RAD
   597:                       NodeDirection = ATAN2(NodeLat-EyeLat(3),NodeLon-EyeLon(3))
   598:                       NodeDirection = NodeDirection/DEG2RAD
   599:                       NodeDirection = 90.D0 - NodeDirection
   600:                       IF(NodeDirection.LT.0.D0)THEN
   601:                          NodeDirection = NodeDirection + 360.D0
   602:                       ENDIF
   603:           !.. Compute the weights for the sector in which the node is located.
   604:           !..     0- 40 : Transition from left (3) to right (1).
   605:           !..    40-130 : Right (1).
   606:           !..   130-170 : Transition from right (1) to rear (2).
   607:           !..   170-220 : Rear (2).
   608:           !..   220-260 : Transition from rear (2) to left (3).
   609:           !..   260-  0 : Left (3).
   610:                       FoundSector = .FALSE.
   611: +------>              DO IS=1,6
   612: |                        IF(IS.EQ.1)THEN
   613: |                           Dir1 = MOD(StormDirection+  0.D0,360.D0)
   614: |                           Dir2 = MOD(StormDirection+ 40.D0,360.D0)
   615: |                        ELSEIF(IS.EQ.2)THEN
   616: |                           Dir1 = MOD(StormDirection+ 40.D0,360.D0)
   617: |                           Dir2 = MOD(StormDirection+130.D0,360.D0)
   618: |                        ELSEIF(IS.EQ.3)THEN
   619: |                           Dir1 = MOD(StormDirection+130.D0,360.D0)
   620: |                           Dir2 = MOD(StormDirection+170.D0,360.D0)
   621: |                        ELSEIF(IS.EQ.4)THEN
   622: |                           Dir1 = MOD(StormDirection+170.D0,360.D0)
   623: |                           Dir2 = MOD(StormDirection+220.D0,360.D0)
   624: |                        ELSEIF(IS.EQ.5)THEN
   625: |                           Dir1 = MOD(StormDirection+220.D0,360.D0)
   626: |                           Dir2 = MOD(StormDirection+260.D0,360.D0)
   627: |                        ELSEIF(IS.EQ.6)THEN
   628: |                           Dir1 = MOD(StormDirection+260.D0,360.D0)
   629: |                           Dir2 = MOD(StormDirection+  0.D0,360.D0)
   630: |                        ENDIF
   631: |                        IF(Dir1.GT.Dir2)THEN
   632: |                           IF((Dir1.LE.NodeDirection).AND.(NodeDirection.LE.360.D0))THEN
   633: |                              Dir2 = Dir2 + 360.D0
   634: |                           ELSEIF((0.D0.LE.NodeDirection).AND.(NodeDirection.LE.Dir2))THEN
   635: |                              Dir1 = Dir1 - 360.D0
   636: |                           ENDIF
   637: |                        ENDIF
   638: |                        IF((Dir1.LE.NodeDirection).AND.(NodeDirection.LE.Dir2))THEN
   639: |                           IF(MOD(IS,2).EQ.0)THEN
   640: |                              FoundSector = .TRUE.
   641: |*=====>                       Weight = 0.D0
   642: |                              Weight(IS/2) = 1.D0
   643: |                           ELSE
   644: |                              FoundSector = .TRUE.
   645: |*=====>                       Weight = 0.D0
   646: |                              IF(IS.EQ.1)THEN
   647: |                                 IW1 = 3
   648: |                                 IW2 = 1
   649: |                              ELSEIF(IS.EQ.3)THEN
   650: |                                 IW1 = 1
   651: |                                 IW2 = 2
   652: |                              ELSEIF(IS.EQ.5)THEN
   653: |                                 IW1 = 2
   654: |                                 IW2 = 3
   655: |                              ENDIF
   656: |                              Weight(IW1) = 1.D0 + (0.D0-1.D0)/(Dir2-Dir1)*(NodeDirection-Dir1)
   657: |                              Weight(IW2) = 0.D0 + (1.D0-0.D0)/(Dir2-Dir1)*(NodeDirection-Dir1)
   658: |                           ENDIF
   659: |                        ENDIF
   660: +------               ENDDO
   661:           
   662:           
   663:           !.. Apply garratt wind drag in case of emergency
   664:                       IF(.NOT.FoundSector)THEN
   665:         I                PowellDrag = CappedGarrattWindDrag(WindSpeed,NodeNumber)
   666: *======>                 Weight = 0.D0
   667:                          RETURN
   668:                       ELSE
   669:         I                rawGarrattWindDrag = GarrattWindDrag(WindSpeed,NodeNumber)
   670:           !.. Determine the wind drag for sector 1 (right).
   671:                          Drag(1) = rawGarrattWindDrag
   672:                          IF(WindSpeed.LE.35.0D0)THEN
   673:                             IF(Drag(1).GT.0.0020D0)THEN
   674:                                Drag(1) = 0.0020D0
   675:                             ENDIF
   676:                          ELSEIF(WindSpeed.LE.45.0D0)THEN
   677:                             Drag(1) = 0.0020D0 + (0.0030D0-0.0020D0)/(45.0D0-35.0D0)*(WindSpeed-35.0D0)
   678:                          ELSE
   679:                             Drag(1) = 0.0030D0
   680:                          ENDIF
   681:           !.. Determine the wind drag for sector 2 (rear).
   682:                          Drag(2) = rawGarrattWindDrag
   683:                          IF(WindSpeed.LE.35.0D0)THEN
   684:                             IF(Drag(2).GT.0.0020D0)THEN
   685:                                Drag(2) = 0.0020D0
   686:                             ENDIF
   687:                          ELSEIF(WindSpeed.LE.45.0D0)THEN
   688:                             Drag(2) = 0.0020D0 + (0.0010D0-0.0020D0)/(45.0D0-35.0D0)*(WindSpeed-35.0D0)
   689:                          ELSE
   690:                             Drag(2) = 0.0010D0
   691:                          ENDIF
   692:           !.. Determine the wind drag for sector 3 (left).
   693:                          Drag(3) = rawGarrattWindDrag
   694:                          IF(Drag(3).GT.0.0018D0)THEN
   695:                             IF(WindSpeed.LE.25.0D0)THEN
   696:                                Drag(3) = 0.0018D0
   697:                             ELSEIF(WindSpeed.LE.30.0D0)THEN
   698:                                Drag(3) = 0.0018D0 + (0.0045D0-0.0018D0)/(30.0D0-25.0D0)*(WindSpeed-25.0D0)
   699:                             ELSEIF(WindSpeed.LE.45.0D0)THEN
   700:                                Drag(3) = 0.0045D0 + (0.0010D0-0.0045D0)/(45.0D0-30.0D0)*(WindSpeed-30.0D0)
   701:                             ELSE
   702:                                Drag(3) = 0.0010D0
   703:                             ENDIF
   704:                          ENDIF
   705:           !.. Apply a weighted average.
   706:                          PowellDrag = Weight(1)*Drag(1) + Weight(2)*Drag(2) + Weight(3)*Drag(3)
   707:                       ENDIF
   708:                    ENDIF
   709:           !     ----------------------------------------------------------------
   710:                 END FUNCTION PowellWindDrag


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POWELLWINDDRAG
INLINE LIST

  ROOT: WIND::POWELLWINDDRAG (wind.F:548)
  -> INLINE: WIND::CAPPEDGARRATTWINDDRAG (wind.F:579)
   -> INLINE: WIND::GARRATTWINDDRAG (wind.F:534)
  -> INLINE: WIND::CAPPEDGARRATTWINDDRAG (wind.F:665)
   -> INLINE: WIND::GARRATTWINDDRAG (wind.F:534)
  -> INLINE: WIND::GARRATTWINDDRAG (wind.F:669)


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POWELLWINDDRAG
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:611)
    <Unvectorized loop.>
    *** Unvectorizable dependency. (wind.F:628)
    *** Unvectorizable dependency. (wind.F:629)
    *** Unvectorizable dependency. (wind.F:625)
    *** Unvectorizable dependency. (wind.F:626)
    *** Unvectorizable dependency. (wind.F:622)
    *** Unvectorizable dependency. (wind.F:623)
    *** Unvectorizable dependency. (wind.F:619)
    *** Unvectorizable dependency. (wind.F:620)
    *** Unvectorizable dependency. (wind.F:616)
    *** Unvectorizable dependency. (wind.F:617)
    *** Unvectorizable dependency. (wind.F:613)
    *** Unvectorizable dependency. (wind.F:614)
    *** Unvectorizable dependency. (wind.F:635)
    *** Unvectorizable dependency. (wind.F:633)
    *** Dependency unknown. Unvectorizable dependency is assumed. : WEIGHT (wind.F:645)
    *** Unvectorizable dependency. (wind.F:653)
    *** Unvectorizable dependency. (wind.F:654)
    *** Unvectorizable dependency. (wind.F:650)
    *** Unvectorizable dependency. (wind.F:651)
    *** Unvectorizable dependency. (wind.F:647)
    *** Unvectorizable dependency. (wind.F:648)
    *** Dependency unknown. Unvectorizable dependency is assumed. : WEIGHT (wind.F:656)
    *** Dependency unknown. Unvectorizable dependency is assumed. : WEIGHT (wind.F:657)
    *** Dependency unknown. Unvectorizable dependency is assumed. : WEIGHT (wind.F:641)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POWELLWINDDRAG
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 48 [s0-s1 s8-s12 s15-s16 s18-s19 s21-s34 s41-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 304 bytes
      Register spill area      :  32 bytes
      Parameter area           :  16 bytes
      Register save area       : 176 bytes
      User data area           :  80 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:611)
    *** Estimated execution cycle                       : 146
    *** The number of SCALAR REGISTER TRANSFER          : 4
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDICEDRAG
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   731: vec( 103): Unvectorized loop.
   731: vec( 108): Unvectorizable loop structure.
   781: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDICEDRAG
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   725:                 REAL(8) FUNCTION WindIceDrag(WindDrag,PercentIce)
   726:                 implicit none
   727:                 REAL(8) :: PercentIce
   728:                 REAL(8) :: pic, WindDrag, IceDrag, Cform
   729:                 REAL(8) :: Cskin = 1.5d-3, Cform_max = 3.67d-3, beta = 0.6d0
   730:           C
   731:                 SELECT CASE(TRIM(DragLawString))
   732:           C
   733:                 CASE("RaysIce")
   734:           C........If there is virtually no ice, then
   735:           C........just use the non-ice drag values
   736:                    if (PercentIce .lt. 1.d0) then
   737:                       WindIceDrag = WindDrag
   738:                    else
   739:                       pic = PercentIce*0.01d0
   740:                       IceDrag = (0.125d0 + 0.5d0*pic*(1.0d0-pic))*0.01d0
   741:                       WindIceDrag = max(IceDrag,WindDrag)
   742:                    endif
   743:           
   744:                 CASE("IceCube")
   745:           C........This formula is a cubic function such that
   746:           C....... When pic = 0 the drag coefficient is equal to
   747:           C....... the minimum value for Garratt (.000075), when pic = 50
   748:           C....... it has a value of 0.0025 and a zero gradient, and
   749:           C....... when pic = 100 it has a value of 0.00125.
   750:           C....... This represents a smoother transition between Garratt
   751:           C....... and Ray's Ice for low ice values and low winds
   752:           
   753:                    IF (PercentIce.lt.0.d0) then
   754:                       WindIceDrag = WindDrag
   755:                    ELSE
   756:                       pic = PercentIce*0.01d0
   757:                       IceDrag = (0.075d0 + 0.75d0*pic - 0.9d0*pic*pic
   758:                &              + 0.2d0*pic*pic*pic)*0.01d0
   759:                       WindIceDrag = max(IceDrag,WindDrag)
   760:                    ENDIF
   761:            
   762:                 CASE("Lupkes","default","Powell")
   763:           C........This formula is a function that explicitly
   764:           C....... combines air-sea drag (Garratt) with sea-ice skin drag and
   765:           C....... sea-ice form drag components with area fraction weights
   766:           C....... see: Lüpkes, et al. (2012), JGR: doi:10.1029/2012JD017630. &
   767:           C....... Joyce et al. (2019), OM: doi:10.1016/j.ocemod.2019.101421
   768:                    IF (PercentIce.lt.0.d0) then
   769:                       WindIceDrag = WindDrag
   770:                    ELSE
   771:                       pic = min(PercentIce*0.01d0,1d0)
   772:                       Cform = Cform_max*(1d0-pic)**beta
   773:                       WindIceDrag = WindDrag*(1d0 - pic) + (Cskin + Cform)*pic
   774:                    ENDIF
   775:           
   776:                 CASE DEFAULT
   777:                    WRITE(16,*) 'ERROR: Ice drag law not recognized:'
   778:                    WRITE(16,'(A10)') DragLawString
   779:                    WRITE(16,*) 'Execution will now be terminated.'
   780:           #ifdef CMPI
   781:                    call msg_fini()
   782:           #endif
   783:                    CALL EXIT(1)
   784:           C
   785:                 END SELECT
   786:                 IF(WindIceDrag.gt.WindDragLimit) WindIceDrag=WindDragLimit
   787:           C
   788:                 RETURN
   789:           C     ----------------------------------------------------------------
   790:                 END FUNCTION WindIceDrag
   791:           C     ----------------------------------------------------------------
   792:           
   793:           C     ----------------------------------------------------------------
   794:           C     S U B R O U T I N E   G E T   B L E N D   F A C T O R
   795:           C     ----------------------------------------------------------------
   796:           C     jgf49.1001 Subroutine to get the blending factor for combining
   797:           C     NWS19 and NWS12 (from NAM) met data.
   798:           C     ----------------------------------------------------------------
   799:                 SUBROUTINE getBlendFactor(i, bf)
   800:                 USE MESH, ONLY : SLAM, SFEA
   801:                 IMPLICIT NONE
   802:                 INTEGER, intent(in) :: i  ! node number
   803:                 REAL(8), intent(out):: bf       ! blend factor, 0 to 1
   804:                 REAL(8) XCOOR ! longitude of node in degrees
   805:                 REAL(8) YCOOR ! latitude of node in degrees
   806:           C     distance from center of vortex to mesh node:
   807:                 REAL(8) DX    ! longitude distance in radians
   808:                 REAL(8) DY    ! latitude distance in radians
   809:                 REAL(8) rad   ! point-to-point distance over a sphere, in meters
   810:                 REAL(8) vortexOnly ! radial distance to edge of pure vortex, meters
   811:                 REAL(8) backgroundOnly ! radial dist to undisturbed background, meters


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDICEDRAG
INLINE LIST

  ROOT: WIND::WINDICEDRAG (wind.F:725)
  -> NOINLINE: MESSENGER::MSG_FINI (wind.F:781)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDICEDRAG
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:731)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:731)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDICEDRAG
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 28 [s0-s12 s15-s16 s18-s19 s23-s28 s33 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1280 bytes
      Register spill area      :    0 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1040 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:731)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETBLENDFACTOR
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   821: inl(1212): Source for routine not found.: GLOBAL::SPHERICALDISTANCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETBLENDFACTOR
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   799:                 SUBROUTINE getBlendFactor(i, bf)
   800:                 USE MESH, ONLY : SLAM, SFEA
   801:                 IMPLICIT NONE
   802:                 INTEGER, intent(in) :: i  ! node number
   803:                 REAL(8), intent(out):: bf       ! blend factor, 0 to 1
   804:                 REAL(8) XCOOR ! longitude of node in degrees
   805:                 REAL(8) YCOOR ! latitude of node in degrees
   806:           C     distance from center of vortex to mesh node:
   807:                 REAL(8) DX    ! longitude distance in radians
   808:                 REAL(8) DY    ! latitude distance in radians
   809:                 REAL(8) rad   ! point-to-point distance over a sphere, in meters
   810:                 REAL(8) vortexOnly ! radial distance to edge of pure vortex, meters
   811:                 REAL(8) backgroundOnly ! radial dist to undisturbed background, meters
   812:           C
   813:                 XCOOR=SLAM(I)*RAD2DEG
   814:                 YCOOR=SFEA(I)*RAD2DEG
   815:           C
   816:                 DX=(XCOOR-vortexLon)*DEG2RAD
   817:                 DY=(YCOOR-vortexLat)*DEG2RAD
   818:           C
   819:           C     compute the distance from the center of the storm to the mesh
   820:           C     node along a sphere
   821:                 rad = sphericalDistance(DX, DY, vortexLat, YCOOR)
   822:           C
   823:           C     compute the radial distances to the various regions, in meters
   824:                 vortexOnly = pureVortex * vortexRMW
   825:                &           * 1.852000003180799d0 * 1000.0d0
   826:                 backgroundOnly = pureBackground * vortexRMW
   827:                &           * 1.852000003180799d0 * 1000.0d0
   828:           C     determine which interpolation region this mesh node falls in
   829:                 IF ( rad.le.vortexOnly ) bf = 1.0d0
   830:                 IF ( rad.ge.backgroundOnly ) bf = 0.0d0
   831:           C     interpolate linearly based on radial distance in the blended region
   832:                 IF ( (rad.gt.vortexOnly).and.(rad.lt.backgroundOnly) ) THEN
   833:                    bf = (backgroundOnly-rad)/(backgroundOnly-vortexOnly)
   834:           Cjgfdebug         WRITE(16,*) "bf is ", bf
   835:                    IF ( (bf.gt.1.0d0).or.(bf.lt.0.0d0) ) THEN
   836:                       bf = 0.0d0
   837:                    ENDIF
   838:                 ENDIF
   839:           Cjgfdebug      WRITE(16,*) vortexLat, vortexLon, vortexRMW, rad, bf
   840:                 RETURN
   841:           C     ----------------------------------------------------------------
   842:                 END SUBROUTINE getBlendFactor


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETBLENDFACTOR
INLINE LIST

  ROOT: WIND::GETBLENDFACTOR (wind.F:799)
  -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:821)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETBLENDFACTOR
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETBLENDFACTOR
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 18 [s0-s3 s8-s12 s15-s16 s23-s24 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 240 bytes
      Register spill area      :   0 bytes
      Parameter area           :  32 bytes
      Register save area       : 176 bytes
      User data area           :  32 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::TIMECONV
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   856: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
   875: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
   877: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::TIMECONV
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   851:                 SUBROUTINE TIMECONV(IYR,IMO,IDAY,IHR,IMIN,SEC,TIMESEC)
   852:                 IMPLICIT NONE
   853:                 INTEGER IYR,IMO,IDAY,IHR,IMIN,ILEAP
   854:                 REAL*8 TIMESEC,SEC
   855:           C
   856:                 call setMessageSource("timeConv")
   857:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
   858:                 call allMessage(DEBUG,"Enter.")
   859:           #endif
   860:                 TIMESEC = (IDAY-1)*86400 + IHR*3600 + IMIN*60 + SEC
   861:                 IF(IMO.GE.2)  TIMESEC = TIMESEC + 31*86400
   862:                 ILEAP = (IYR/4)*4
   863:                 IF((ILEAP.EQ.IYR).AND.(IMO.GE.3)) TIMESEC = TIMESEC + 29*86400
   864:                 IF((ILEAP.NE.IYR).AND.(IMO.GE.3)) TIMESEC = TIMESEC + 28*86400
   865:                 IF(IMO.GE.4)  TIMESEC = TIMESEC + 31*86400
   866:                 IF(IMO.GE.5)  TIMESEC = TIMESEC + 30*86400
   867:                 IF(IMO.GE.6)  TIMESEC = TIMESEC + 31*86400
   868:                 IF(IMO.GE.7)  TIMESEC = TIMESEC + 30*86400
   869:                 IF(IMO.GE.8)  TIMESEC = TIMESEC + 31*86400
   870:                 IF(IMO.GE.9)  TIMESEC = TIMESEC + 31*86400
   871:                 IF(IMO.GE.10) TIMESEC = TIMESEC + 30*86400
   872:                 IF(IMO.GE.11) TIMESEC = TIMESEC + 31*86400
   873:                 IF(IMO.EQ.12) TIMESEC = TIMESEC + 30*86400
   874:                 IF(IMO.GT.12) THEN
   875:                    call allMessage(ERROR,
   876:                &     'Fatal error in subroutine timeconv: month > 12.')
   877:         I          call windTerminate()
   878:           
   879:                 ENDIF
   880:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
   881:                 call allMessage(DEBUG,"Return.")
   882:           #endif
   883:                 call unsetMessageSource()
   884:           
   885:                 RETURN
   886:           C-----------------------------------------------------------------------
   887:                 END SUBROUTINE TIMECONV


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::TIMECONV
INLINE LIST

  ROOT: WIND::TIMECONV (wind.F:851)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:856)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:875)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:877)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:883)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::TIMECONV
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:04 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::TIMECONV
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 26 [s0-s6 s8-s12 s15-s16 s23-s30 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 272 bytes
      Register spill area      :   0 bytes
      Parameter area           :  24 bytes
      Register save area       : 176 bytes
      User data area           :  64 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETMETEOROLOGICALFORCING
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   934: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
   951: vec( 103): Unvectorized loop.
   951: vec( 180): I/O statement obstructs vectorization.
   952: opt(1118): This I/O statement inhibits optimization of loop.
   972: vec( 103): Unvectorized loop.
   972: vec( 180): I/O statement obstructs vectorization.
   976: opt(1118): This I/O statement inhibits optimization of loop.
   980: vec( 101): Vectorized loop.
   981: vec( 128): Fused multiply-add operation applied.
   982: vec( 128): Fused multiply-add operation applied.
   987: vec( 128): Fused multiply-add operation applied.
   989: vec( 128): Fused multiply-add operation applied.
  1003: vec( 101): Vectorized loop.
  1007: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS3GET
  1010: vec( 103): Unvectorized loop.
  1010: vec( 110): Vectorization obstructive procedure reference.:  
  1010: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1014: inl(1222): Inlined: WIND::WINDDRAG
  1017: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1020: inl(1222): Inlined: WIND::WINDDRAG
  1023: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3476: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  1026: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1044: vec( 101): Vectorized loop.
  1049: inl(1222): Inlined: WIND::NWS4GET
  1052: vec( 103): Unvectorized loop.
  1052: vec( 110): Vectorization obstructive procedure reference.:  
  1052: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1056: inl(1222): Inlined: WIND::WINDDRAG
  1059: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1062: inl(1222): Inlined: WIND::WINDDRAG
  1065: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1068: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1090: vec( 103): Unvectorized loop.
  1090: vec( 180): I/O statement obstructs vectorization.
  1094: opt(1118): This I/O statement inhibits optimization of loop.
  1098: vec( 103): Unvectorized loop.
  1098: vec( 110): Vectorization obstructive procedure reference.:  
  1098: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1102: inl(1222): Inlined: WIND::WINDDRAG
  1105: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1108: inl(1222): Inlined: WIND::WINDDRAG
  1111: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1114: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1139: vec( 101): Vectorized loop.
  1145: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS6GET
  1148: vec( 103): Unvectorized loop.
  1148: vec( 110): Vectorization obstructive procedure reference.:  
  1148: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1152: inl(1222): Inlined: WIND::WINDDRAG
  1155: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1158: inl(1222): Inlined: WIND::WINDDRAG
  1161: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1164: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1188: vec( 101): Vectorized loop.
  1193: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS7GET
  1196: vec( 101): Vectorized loop.
  1197: vec( 128): Fused multiply-add operation applied.
  1198: vec( 128): Fused multiply-add operation applied.
  1203: vec( 128): Fused multiply-add operation applied.
  1205: vec( 128): Fused multiply-add operation applied.
  1214: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::HOLLANDGET
  1215: vec( 103): Unvectorized loop.
  1215: vec( 110): Vectorization obstructive procedure reference.:  
  1215: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1219: inl(1222): Inlined: WIND::WINDDRAG
  1221: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1224: inl(1222): Inlined: WIND::WINDDRAG
  1227: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1230: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1253: vec( 101): Vectorized loop.
  1259: vec( 101): Vectorized loop.
  1260: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS10GET
  1266: vec( 103): Unvectorized loop.
  1266: vec( 110): Vectorization obstructive procedure reference.:  
  1266: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1270: inl(1222): Inlined: WIND::WINDDRAG
  1273: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1276: inl(1222): Inlined: WIND::WINDDRAG
  1279: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1284: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1286: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1310: vec( 101): Vectorized loop.
  1320: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS11GET
  1323: vec( 103): Unvectorized loop.
  1323: vec( 110): Vectorization obstructive procedure reference.:  
  1323: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1327: inl(1222): Inlined: WIND::WINDDRAG
  1330: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1333: inl(1222): Inlined: WIND::WINDDRAG
  1336: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1339: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1359: vec( 101): Vectorized loop.
  1365: inl(1212): Source for routine not found.: OWIWIND::NWS12GET
  1373: vec( 101): Vectorized loop.
  1374: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS14GET
  1382: inl(1212): Source for routine not found.: OWIWIND::FINDSTORMCENTER
  1400: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1400: vec( 101): Vectorized loop.
  1402: opt(3014): Moved reference within a conditional branch.
  1403: opt(3014): Moved reference within a conditional branch.
  1404: opt(3014): Moved reference within a conditional branch.
  1415: vec( 103): Unvectorized loop.
  1415: vec( 110): Vectorization obstructive procedure reference.:  
  1415: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1424: inl(1222): Inlined: WIND::WINDDRAG
  1426: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1430: inl(1222): Inlined: WIND::WINDDRAG
  1433: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1439: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1442: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1473: vec( 101): Vectorized loop.
  1478: inl(1212): Source for routine not found.: OWIWIND_NETCDF::NWS13GET
  1484: vec( 103): Unvectorized loop.
  1484: vec( 110): Vectorization obstructive procedure reference.:  
  1484: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1488: inl(1222): Inlined: WIND::WINDDRAG
  1490: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1493: inl(1222): Inlined: WIND::WINDDRAG
  1496: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1498: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1514: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS19GET
  1515: vec( 103): Unvectorized loop.
  1515: vec( 110): Vectorization obstructive procedure reference.:  
  1515: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1519: inl(1222): Inlined: WIND::WINDDRAG
  1521: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1524: inl(1222): Inlined: WIND::WINDDRAG
  1527: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1532: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1544: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS20GET
  1545: vec( 103): Unvectorized loop.
  1545: vec( 110): Vectorization obstructive procedure reference.:  
  1545: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1549: inl(1222): Inlined: WIND::WINDDRAG
  1551: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1554: inl(1222): Inlined: WIND::WINDDRAG
  1557: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1562: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1579: vec( 101): Vectorized loop.
  1598: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  1600: vec( 103): Unvectorized loop.
  1600: vec( 110): Vectorization obstructive procedure reference.:  
  1600: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SPHERICALDISTANCE
  1605: inl(1222): Inlined: WIND::WINDDRAG
  1608: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1620: inl(1222): Inlined: WIND::WINDDRAG
  1622: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1625: inl(1222): Inlined: WIND::WINDDRAG
   821: inl(1212): Source for routine not found.: GLOBAL::SPHERICALDISTANCE
  1628: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1629: inl(1222): Inlined: WIND::GETBLENDFACTOR
  1646: inl(1214): Expansion routine is too big for automatic expansion.: WIND::NWS15GET
  1647: vec( 103): Unvectorized loop.
  1647: vec( 110): Vectorization obstructive procedure reference.:  
  1647: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1651: inl(1222): Inlined: WIND::WINDDRAG
  1653: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1657: inl(1222): Inlined: WIND::WINDDRAG
  1660: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1662: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1676: vec( 101): Vectorized loop.
  1681: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS16GET
  1684: vec( 103): Unvectorized loop.
  1684: vec( 110): Vectorization obstructive procedure reference.:  
  1684: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1689: inl(1222): Inlined: WIND::WINDDRAG
  1691: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1695: inl(1222): Inlined: WIND::WINDDRAG
  1698: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1701: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1715: vec( 101): Vectorized loop.
  1727: vec( 101): Vectorized loop.
  1738: vec( 101): Vectorized loop.
  1752: vec( 103): Unvectorized loop.
  1752: vec( 110): Vectorization obstructive procedure reference.:  
  1752: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  1756: inl(1222): Inlined: WIND::WINDDRAG
  1759: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  1762: inl(1222): Inlined: WIND::WINDDRAG
  1765: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  1769: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  1788: vec( 101): Vectorized loop.
  1789: opt(1112): Loop fused with previous loop.
  1790: inl(1212): Source for routine not found.: MESH::DRVMAP2DSPVEC


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETMETEOROLOGICALFORCING
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   900:                 subroutine getMeteorologicalForcing(nws, wsx2, wsy2, pr2,
   901:                &   wvnxout, wvnyout, timeloc)
   902:                 use owiwind,only : nws12get, findStormCenter    ! sb added 09/xx/2006
   903:                 use global, only : ciceout, h0, eta2, ncice, rampmete,
   904:                &   sponge, res_bc_flag, IDEN, SigTS, cice1, cice2, IFSPROTS
   905:                 USE ADC_CONSTANTS, only: g
   906:                 use nodalAttributes, only : applyDirectionalWindReduction,
   907:                &   loadCanopyCoef, loadDirEffRLen, applyCanopyCoefficient
   908:                 use mesh, only : dp, ics, np, uvectmp, vvectmp, DRVMAP2DSPVEC
   909:           #ifdef ADCNETCDF
   910:                 USE OWIWIND_NETCDF, ONLY: NWS13GET
   911:           #endif
   912:                 implicit none
   913:                 integer, intent(in) :: nws
   914:                 real(8), intent(out) :: wsx2(:)
   915:                 real(8), intent(out) :: wsy2(:)
   916:                 real(8), intent(out) :: pr2(:)
   917:                 real(8), intent(out) :: wvnxout(:)
   918:                 real(8), intent(out) :: wvnyout(:)
   919:                 real(8), intent(in) :: timeloc
   920:                 real(8) :: windx ! wind vel (m/s) in x-dir
   921:                 real(8) :: windy ! wind vel (m/s) in y-dir
   922:           
   923:                 real(8) :: prdiff
   924:                 real(8) :: vortexPRDIFF
   925:                 real(8) :: wDragCo
   926:                 real(8) :: windMag
   927:                 real(8) :: wtratio ! used to time interpolated between met datasets
   928:                 real(8) :: cicenow, icedragco, ctratio, icemag, icex, icey
   929:                 integer :: nhg ! node number temp
   930:                 real(8) :: bf ! blend factor for multiple sets of wind data
   931:                 integer :: i ! node loop counter
   932:                 real(8) :: wtratio_12, wtratio_14 ! used to time interpolated between met datasets
   933:           
   934:                 call setMessageSource("getMeteorologicalForcing")
   935:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
   936:                 call allMessage(DEBUG,"Enter.")
   937:           #endif
   938:           
   939:           
   940:           C------------------------MET FORCING---------------------------------------
   941:           C
   942:           C...  UPDATE THE WIND STRESS AND SURFACE PRESSURE AND READ IN NEW VALUES
   943:           C...  FROM UNIT 22.  APPLY Ramp FUNCTION.
   944:           C
   945:           C  tcm v49.16 20100617 -- Changed pressure ramping so that we apply the ramp
   946:           C     to the difference between the background pressure and the forced pressure,
   947:           C     then add that ramped difference back to the background pressure
   948:           C
   949:           C     No wind, radiation stress or atmospheric pressure forcings are used.
   950:                 IF(NWS.EQ.1) THEN
   951: +------>           DO I=1,NP
   952: |                     READ(22,*) NHG,WSX2(I),WSY2(I),PR2(I) !read in
   953: |                     WSX2(I)=RampMete*WSX2(I) ! apply ramp function
   954: |                     WSY2(I)=RampMete*WSY2(I)
   955: |         C  tcm v49.16 20100617
   956: |         !            PR2(I)=RampMete*PR2(I)
   957: |                     PRDIFF = RampMete*(PR2(I)-PRBCKGRND_MH2O)
   958: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
   959: |                     wvnxout(i)=WSX2(i) ! for met recording station output
   960: |                     wvnyout(i)=WSY2(i)
   961: +------            END DO
   962:                 ENDIF
   963:           
   964:           C     Wind stress and atmospheric pressure are read in at all grid nodes
   965:           C     at a time interval that does not equal the model time
   966:           C     step. Interpolation in time is used to synchronize the wind and
   967:           C     pressure information with the model time step.
   968:                 IF(ABS(NWS).EQ.2) THEN
   969:                    IF(TimeLoc.GT.WTIME2) THEN !determine if met file time incr. is exceeded
   970:                       WTIME1=WTIME2
   971:                       WTIME2=WTIME2+WTIMINC
   972: +------>              DO I=1,NP
   973: |                        WVNX1(I)=WVNX2(I) ! move current data to old
   974: |                        WVNY1(I)=WVNY2(I)
   975: |                        PRN1(I)=PRN2(I)
   976: |                        READ(22,*) NHG,WVNX2(I),WVNY2(I),PRN2(I) ! read in
   977: +------               END DO
   978:                    ENDIF
   979:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC ! interpolate
   980: V------>           DO I=1,NP
   981: |       F             WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
   982: |       F             WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
   983: |                     WSX2(I) = RampMete*WindX !apply ramp
   984: |                     WSY2(I) = RampMete*WindY
   985: |         C  tcm v49.16 20100617
   986: |         !            PR2(I)=RampMete*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
   987: |       F             PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
   988: |              &                          -PRBCKGRND_MH2O)
   989: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
   990: |                     wvnxout(i)=WSX2(i) !for met recording sta. output
   991: |                     wvnyout(i)=WSY2(i)
   992: V------            END DO
   993:                 ENDIF
   994:           
   995:           C     Wind velocity in US Navy Fleet Numeric format interpolated in
   996:           C     space onto the ADCIRC grid and in time to synchronize the wind and
   997:           C     pressure information with the model time step. Garratt's formula
   998:           C     is used to compute wind stress from the wind velocity.
   999:                 IF(NWS.EQ.3) THEN
  1000:                    IF(TimeLoc.GT.WTIME2) THEN
  1001:                       WTIME1=WTIME2
  1002:                       WTIME2=WTIME2+WTIMINC
  1003: V------>              DO I=1,NP
  1004: |                        WVNX1(I)=WVNX2(I)
  1005: |                        WVNY1(I)=WVNY2(I)
  1006: V------               END DO
  1007:                       CALL NWS3GET()
  1008:                    ENDIF
  1009:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1010: +------>           DO I=1,NP
  1011: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1012: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1013: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1014: |       I             WDragCo = WindDrag(WindMag, I)
  1015: |         C     jgf46.00 Add directional wind reduction.
  1016: |                     IF (LoadDirEffRLen) THEN
  1017: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1018: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1019: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1020: |       I                WDragCo = WindDrag(WindMag, I)
  1021: |                     ENDIF
  1022: |                     IF (LoadCanopyCoef)
  1023: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1024: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1025: |                     IF(NCICE.NE.0) THEN
  1026: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1027: |                     ENDIF
  1028: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1029: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1030: |                     WVNXOUT(I)=RampMete*WindX
  1031: |                     WVNYOUT(I)=RampMete*WindY
  1032: +------            END DO
  1033:                 ENDIF
  1034:           
  1035:           C     Wind velocity and atmospheric pressure are read in (PBL/JAG
  1036:           C     format) at selected ADCIRC grid nodes. Interpolation in time is
  1037:           C     used to synchronize the wind and pressure information with the
  1038:           C     model time step. Garratt's formula is used to compute wind stress
  1039:           C     from wind velocity.
  1040:                 IF(ABS(NWS).EQ.4) THEN
  1041:                    IF(TimeLoc.GT.WTIME2) THEN
  1042:                       WTIME1=WTIME2
  1043:                       WTIME2=WTIME2+WTIMINC
  1044: V------>              DO I=1,NP
  1045: |                        WVNX1(I)=WVNX2(I)
  1046: |                        WVNY1(I)=WVNY2(I)
  1047: |                        PRN1(I)=PRN2(I)
  1048: V------               END DO
  1049:         I             CALL NWS4GET()
  1050:                    ENDIF
  1051:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1052: +------>           DO I=1,NP
  1053: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1054: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1055: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1056: |       I             WDragCo = WindDrag(WindMag, I)
  1057: |         C     jgf46.00 Add directional wind reduction.
  1058: |                     IF (LoadDirEffRLen) THEN
  1059: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1060: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1061: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1062: |       I                WDragCo = WindDrag(WindMag, I)
  1063: |                     ENDIF
  1064: |                     IF (LoadCanopyCoef)
  1065: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1066: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1067: |                     IF(NCICE.NE.0) THEN
  1068: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1069: |                     ENDIF
  1070: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1071: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1072: |         C  tcm v49.16 20100617
  1073: |         !            PR2(I)=RampMete*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1074: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1075: |              &                           -PRBCKGRND_MH2O)
  1076: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1077: |                     WVNXOUT(I)=RampMete*WindX
  1078: |                     WVNYOUT(I)=RampMete*WindY
  1079: +------            END DO
  1080:                 ENDIF
  1081:           
  1082:           C     Wind velocity and atmospheric pressure are read in at all grid
  1083:           C     nodes. Interpolation in time is used to synchronize the wind and
  1084:           C     pressure information with the model time step. Garratt's formula
  1085:           C     is used to compute wind stress from wind velocity.
  1086:                 IF(ABS(NWS).EQ.5) THEN
  1087:                    IF(TimeLoc.GT.WTIME2) THEN
  1088:                       WTIME1=WTIME2
  1089:                       WTIME2=WTIME2+WTIMINC
  1090: +------>              DO I=1,NP
  1091: |                        WVNX1(I)=WVNX2(I)
  1092: |                        WVNY1(I)=WVNY2(I)
  1093: |                        PRN1(I)=PRN2(I)
  1094: |                        READ(22,*) NHG,WVNX2(I),WVNY2(I),PRN2(I)
  1095: +------               END DO
  1096:                    ENDIF
  1097:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1098: +------>           DO I=1,NP
  1099: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1100: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1101: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1102: |       I             WDragCo = WindDrag(WindMag, I)
  1103: |         C     jgf46.00 Add directional wind reduction.
  1104: |                     IF (LoadDirEffRLen) THEN
  1105: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1106: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1107: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1108: |       I                WDragCo = WindDrag(WindMag, I)
  1109: |                     ENDIF
  1110: |                     IF (LoadCanopyCoef)
  1111: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1112: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1113: |                     IF(NCICE.NE.0) THEN
  1114: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1115: |                     ENDIF
  1116: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1117: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1118: |         C  tcm v49.16 20100617
  1119: |         !            PR2(I)=RampMete*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1120: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1121: |              &                           -PRBCKGRND_MH2O)
  1122: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1123: |                     WVNXOUT(I)=RampMete*WindX
  1124: |                     WVNYOUT(I)=RampMete*WindY
  1125: +------            END DO
  1126:                 ENDIF
  1127:           
  1128:           C     Wind velocity and atmospheric pressure are read in for a
  1129:           C     rectangular grid (either in Longitude, Latitude or Cartesian
  1130:           C     coordinates, consistent with the grid coordinates) and
  1131:           C     interpolated in space onto the ADCIRC grid and in time to
  1132:           C     synchronize the wind and pressure information with the model time
  1133:           C     step. Garratt's formula is used to compute wind stress from the
  1134:           C     wind velocity.
  1135:                 IF(NWS.EQ.6) THEN
  1136:                    IF(TimeLoc.GT.WTIME2) THEN
  1137:                       WTIME1=WTIME2
  1138:                       WTIME2=WTIME2+WTIMINC
  1139: V------>              DO I=1,NP
  1140: |                        WVNX1(I)=WVNX2(I)
  1141: |                        WVNY1(I)=WVNY2(I)
  1142: |                        PRN1(I)=PRN2(I)
  1143: V------               END DO
  1144:                       NWSGGWI=NWSGGWI+1
  1145:                       CALL NWS6GET()
  1146:                    ENDIF
  1147:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1148: +------>           DO I=1,NP
  1149: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1150: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1151: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1152: |       I             WDragCo = WindDrag(WindMag, I)
  1153: |         C     jgf46.00 Add directional wind reduction.
  1154: |                     IF (LoadDirEffRLen) THEN
  1155: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1156: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1157: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1158: |       I                WDragCo = WindDrag(WindMag, I)
  1159: |                     ENDIF
  1160: |                     IF (LoadCanopyCoef)
  1161: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1162: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1163: |                     IF(NCICE.NE.0) THEN
  1164: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1165: |                     ENDIF
  1166: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1167: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1168: |         C  tcm v49.16 20100617
  1169: |         !            PR2(I)=RampMete*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1170: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1171: |              &                           -PRBCKGRND_MH2O)
  1172: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1173: |                     WVNXOUT(I)=RampMete*WindX
  1174: |                     WVNYOUT(I)=RampMete*WindY
  1175: +------            END DO
  1176:                 ENDIF
  1177:           
  1178:           C     jgf46.01 New option to read in surface wind stress and atmospheric
  1179:           C     pressure for a rectangular grid (either in Longitude, Latitude or
  1180:           C     Cartesian coordinates, consistent with the grid coordinates) and
  1181:           C     interpolate in space onto the ADCIRC grid. Interpolation in time
  1182:           C     is used to synchronize the wind and pressure information with the
  1183:           C     model time step.
  1184:                 IF(ABS(NWS).EQ.7) THEN
  1185:                    IF(TimeLoc.GT.WTIME2) THEN
  1186:                       WTIME1=WTIME2
  1187:                       WTIME2=WTIME2+WTIMINC
  1188: V------>              DO I=1,NP
  1189: |                        WVNX1(I)=WVNX2(I)
  1190: |                        WVNY1(I)=WVNY2(I)
  1191: |                        PRN1(I)=PRN2(I)
  1192: V------               END DO
  1193:                       CALL NWS7GET()
  1194:                    ENDIF
  1195:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1196: V------>           DO I=1,NP
  1197: |       F             WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1198: |       F             WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1199: |                     WSX2(I) = RampMete*WindX !apply ramp
  1200: |                     WSY2(I) = RampMete*WindY
  1201: |         C  tcm v49.16 20100617
  1202: |         !            PR2(I)=RampMete*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1203: |       F             PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1204: |              &                           -PRBCKGRND_MH2O)
  1205: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1206: |                     wvnxout(i)=WSX2(i) !for met recording sta. output
  1207: |                     wvnyout(i)=WSY2(i)
  1208: V------            END DO
  1209:                 ENDIF
  1210:           
  1211:           C     jgf46.02 New option to read in hurricane locations and generate
  1212:           C     generate hurricane winds from the Holland Wind Model.
  1213:                 IF(ABS(NWS).EQ.8) THEN
  1214:                    call HollandGet(wvnx2,wvny2,prn2,timeloc)
  1215: +------>           DO I=1,NP
  1216: |                     WindX = WVNX2(I)
  1217: |                     WindY = WVNY2(I)
  1218: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1219: |       I             WDragCo = WindDrag(WindMag, I)
  1220: |                     IF (LoadDirEffRLen) THEN
  1221: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1222: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1223: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1224: |       I                WDragCo = WindDrag(WindMag, I)
  1225: |                     ENDIF
  1226: |                     IF (LoadCanopyCoef)
  1227: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1228: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1229: |                     IF(NCICE.NE.0) THEN
  1230: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1231: |                     ENDIF
  1232: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1233: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1234: |         C  tcm v49.16 20100617
  1235: |         !            PR2(I)=RampMete*PRN2(I)
  1236: |                     PRDIFF = RampMete*(PRN2(I)-PRBCKGRND_MH2O)
  1237: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1238: |                     WVNXOUT(I)=RampMete*WindX
  1239: |                     WVNYOUT(I)=RampMete*WindY
  1240: +------            ENDDO
  1241:                 ENDIF
  1242:           C
  1243:           C     Wind velocity (10 m) and atmospheric pressure are read in from a
  1244:           C     sequence of National Weather Service (NWS) Aviation (AVN) model
  1245:           C     output files. Each AVN file is assumed to contain data on a
  1246:           C     Gaussian longitude, latitude grid at a single time. Consecutive
  1247:           C     files in the sequence are separated by N hours in time. Garratt's
  1248:           C     formula is used to compute wind stress from the wind velocity.
  1249:                 IF(NWS.EQ.10) THEN
  1250:                    IF(TimeLoc.GT.WTIME2) THEN
  1251:                       WTIME1=WTIME2
  1252:                       WTIME2=WTIME2+WTIMINC
  1253: V------>              DO I=1,NP
  1254: |                        WVNX1(I)=WVNX2(I)
  1255: |                        WVNY1(I)=WVNY2(I)
  1256: |                        PRN1(I)=PRN2(I)
  1257: V------               END DO
  1258:                       IF (NCICE.eq.10) THEN
  1259: V======>                 cice1 = cice2
  1260:                          call nws10get(wvnx2,wvny2,prn2,cice2)
  1261:                       ELSE
  1262:                          call nws10get(wvnx2,wvny2,prn2)
  1263:                       ENDIF
  1264:                    ENDIF
  1265:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1266: +------>           DO I=1,NP
  1267: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1268: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1269: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1270: |       I             WDragCo = WindDrag(WindMag, I)
  1271: |         C     jgf46.00 Add directional wind reduction.
  1272: |                     IF (LoadDirEffRLen) THEN
  1273: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1274: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1275: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1276: |       I                WDragCo = WindDrag(WindMag, I)
  1277: |                     ENDIF
  1278: |                     IF (LoadCanopyCoef)
  1279: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1280: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1281: |                     IF (NCICE.eq.10) then
  1282: |                        Cicenow = 100d0*( CICE1(I) +
  1283: |              &                           WTRatio*( CICE2(I)-CICE1(I) ) )
  1284: |                        WDragCo = WindIceDrag(WDragCo,Cicenow)
  1285: |                     ELSEIF (NCICE.NE.0) THEN
  1286: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1287: |                     ENDIF
  1288: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1289: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1290: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1291: |              &                          -PRBCKGRND_MH2O)
  1292: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1293: |                     WVNXOUT(I)=RampMete*WindX
  1294: |                     WVNYOUT(I)=RampMete*WindY
  1295: +------            END DO
  1296:                 ENDIF
  1297:           C
  1298:           C     Wind velocity (10 m) and atmospheric pressure are read in from a
  1299:           C     sequence of stripped down National Weather Service (NWS) ETA 29km
  1300:           C     model output files. Each ETA file is assumed to contain data on an
  1301:           C     E grid for a single day (8 data sets, one every 3 hours, beginning
  1302:           C     @ 03:00 and continuing through 24:00 of the given day). The wind
  1303:           C     data is converted to an east-west, north-south coordinate system
  1304:           C     inside ADCIRC. Garratt's formula is used to compute wind stress
  1305:           C     from the wind velocity.
  1306:                 IF(NWS.EQ.11) THEN
  1307:                    IF(TimeLoc.GT.WTIME2) THEN
  1308:                       WTIME1=WTIME2
  1309:                       WTIME2=WTIME2+WTIMINC
  1310: V------>              DO I=1,NP
  1311: |                        WVNX1(I)=WVNX2(I)
  1312: |                        WVNY1(I)=WVNY2(I)
  1313: |                        PRN1(I)=PRN2(I)
  1314: V------               END DO
  1315:                       IDSETFLG=IDSETFLG+1
  1316:                       IF(IDSETFLG.GT.8) THEN
  1317:                          NWSEGWI=NWSEGWI+1
  1318:                          IDSETFLG=1
  1319:                       ENDIF
  1320:                       CALL NWS11GET()
  1321:                    ENDIF
  1322:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1323: +------>           DO I=1,NP
  1324: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1325: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1326: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1327: |       I             WDragCo = WindDrag(WindMag, I)
  1328: |         C     jgf46.00 Add directional wind reduction.
  1329: |                     IF (LoadDirEffRLen) THEN
  1330: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1331: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1332: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1333: |       I                WDragCo = WindDrag(WindMag, I)
  1334: |                     ENDIF
  1335: |                     IF (LoadCanopyCoef)
  1336: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1337: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1338: |                     IF(NCICE.NE.0) THEN
  1339: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1340: |                     ENDIF
  1341: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1342: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1343: |         C  tcm v49.16 20100617
  1344: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1345: |              &                          -PRBCKGRND_MH2O)
  1346: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1347: |                     WVNXOUT(I)=RampMete*WindX
  1348: |                     WVNYOUT(I)=RampMete*WindY
  1349: +------            END DO
  1350:                 ENDIF
  1351:           
  1352:           C...  sb46.28sb01 NWS=12 reads in raw OWI files 09/xx/2006
  1353:           C     WJP: Added for NWS = 14 (GRIB2 e.g. CFS)
  1354:                 IF (ABS(NWS).EQ.12.or.ABS(NWS).eq.14) THEN
  1355:                    IF (TimeLoc.GT.WTIME2) THEN
  1356:                       CHANGE_14 = .true.
  1357:                       WTIME1 = WTIME2
  1358:                       WTIME2 = WTIME2 + WTIMINC
  1359: V------>              DO I = 1,NP
  1360: |                       WVNX1(I) = WVNX2(I)
  1361: |                       WVNY1(I) = WVNY2(I)
  1362: |                       PRN1(I)  = PRN2(I)
  1363: V------               END DO
  1364:                       IF (ABS(NWS).eq.12) then
  1365:                          CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND)
  1366:           #ifdef DATETIME
  1367:           #if defined(GRIB2API) || defined(ADCNETCDF)
  1368:                       ELSE
  1369:                          IF ((NCICE.eq.14.or.NCICE.eq.13).and.
  1370:                &             TimeLoc.GT.CICE_TIME2) THEN
  1371:                             CICE_TIME1 = CICE_TIME2
  1372:                             CICE_TIME2 = CICE_TIME2 + CICE_TIMINC
  1373: V======>                    CICE1 = CICE2
  1374:                             CALL NWS14GET(WVNX2,WVNY2,PRN2,CICE2)
  1375:                          ELSE
  1376:                             CALL NWS14GET(WVNX2,WVNY2,PRN2)
  1377:                          ENDIF
  1378:           #endif
  1379:           #endif
  1380:                       ENDIF
  1381:                       if (draglawtype.EQ.draglaw_powell) then
  1382:                          call findStormCenter(eyeLat, eyeLon, foundEye)
  1383:                       endif
  1384:                    ELSE
  1385:                       CHANGE_14 = .false.
  1386:                    ENDIF
  1387:                    WTRATIO = (TimeLoc-WTIME1)/WTIMINC
  1388:                    IF(NCICE.NE.0)THEN
  1389:                        CTRATIO = (TimeLoc-CICE_TIME1)/CICE_TIMINC
  1390:                    ENDIF
  1391:                    IF (NWS.eq.-14) then
  1392:                       IF (TimeLoc.GT.WTIME2_12) THEN
  1393:                          ! Now get OWI file data (will overwrite where data
  1394:                          ! exists)
  1395:                          WTIME1_12 = WTIME2_12
  1396:                          WTIME2_12 = WTIME2_12 + WTIMINC_12
  1397:                          ! Don't do this is we have already for NWS = 14 data
  1398:                          ! on same time snap
  1399:                          IF (.not.CHANGE_14) THEN
  1400: V------>                    DO I = 1,NP
  1401: |                              IF (.not.HasData(I)) cycle
  1402: |                              WVNX1(I) = WVNX2(I)
  1403: |                              WVNY1(I) = WVNY2(I)
  1404: |                              PRN1(I)  = PRN2(I)
  1405: V------                     END DO
  1406:                          ENDIF
  1407:                          CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND,HasData)
  1408:                          if (draglawtype.EQ.draglaw_powell) then
  1409:                             call findStormCenter(eyeLat, eyeLon, foundEye)
  1410:                          endif
  1411:                       ENDIF
  1412:                       WTRATIO_12 = (TimeLoc-WTIME1_12)/WTIMINC_12
  1413:                       WTRATIO_14 = WTRATIO
  1414:                    ENDIF
  1415: +------>           DO I = 1,NP
  1416: |                     IF (NWS.eq.-14) then
  1417: |                        WTRATIO = WTRATIO_14
  1418: |                        IF (HasData(I)) WTRATIO = WTRATIO_12
  1419: |                     ENDIF
  1420: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  1421: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  1422: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  1423: |                     !Casey 110518: Enable Mark Powell's sector-based wind drag.
  1424: |       I             WDragCo = WindDrag(WindMag, I)
  1425: |                     IF (LoadDirEffRLen) THEN
  1426: |       I               CALL ApplyDirectionalWindReduction(I, WDragCo,
  1427: |              &             WindMag, DP(I), ETA2(I), WindX, WindY)
  1428: |                       WindMag = SQRT(WindX*WindX+WindY*WindY)
  1429: |                       !Casey 110518: Enable Mark Powell's sector-based wind drag.
  1430: |       I               WDragCo = WindDrag(WindMag,I)
  1431: |                     ENDIF
  1432: |                     IF (LoadCanopyCoef) then
  1433: |       I                CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1434: |                     ENDIF
  1435: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1436: |                     IF (NCICE.eq.14) then
  1437: |                        Cicenow = 100d0*(CICE1(I) +
  1438: |              &                          CTRATIO*(CICE2(I)-CICE1(I)))
  1439: |                        WDragCo = WindIceDrag(WDragCo,Cicenow)
  1440: |                        ciceout(i) = Cicenow ! GML added 20210727
  1441: |                     elseif (NCICE.ne.0.and.NCICE.ne.13) THEN
  1442: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1443: |                     endif
  1444: |                     ! WJP: added varying sea surface density
  1445: |                     if (abs(IDEN).ge.5) then
  1446: |                        if (SigTS(I) < -1d2) then
  1447: |                           airwaterdensityrat = rhoAir/RhoWat0
  1448: |                        else
  1449: |                           airwaterdensityrat = rhoAir/(SigTS(I) + RhoWat0)
  1450: |                        endif
  1451: |                     endif
  1452: |                     WSX2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  1453: |                     WSY2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  1454: |                     PRDIFF  = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1455: |              &                          -PRBCKGRND_MH2O)
  1456: |         #ifdef NOIVB
  1457: |                     PR2(I)  = PRBCKGRND_MH2O
  1458: |         #else
  1459: |                     PR2(I)  = PRBCKGRND_MH2O + PRDIFF
  1460: |         #endif
  1461: |                     WVNXOUT(I) = RampMete*WINDX
  1462: |                     WVNYOUT(I) = RampMete*WINDY
  1463: |         
  1464: +------             END DO
  1465:                 ENDIF
  1466:           
  1467:           #ifdef ADCNETCDF
  1468:           Casey 180318: Added for NWS=13, ARC modified 190108
  1469:                   IF(ABS(NWS).EQ.13) THEN
  1470:                     IF(TimeLoc.GT.WTIME2I) THEN
  1471:                       WTIME1I=WTIME2I
  1472:                       WTIME2I=WTIME2I+WTIMINC
  1473: V------>              DO I=1,NP
  1474: |                       WVNX1(I)=WVNX2(I)
  1475: |                       WVNY1(I)=WVNY2(I)
  1476: |                       PRN1(I)=PRN2(I)
  1477: V------               END DO
  1478:                       CALL NWS13GET(WTIME2I,WVNX2,WVNY2,PRN2,
  1479:                &          WTIME2,EyeLon,EyeLat,FoundEye,W)
  1480:           !            write(6,*) "timeloc", timeloc, "wtiminc", wtiminc, "inside",
  1481:           !     &        wtime1i, wtime2i, wtime1, wtime2
  1482:                     ENDIF
  1483:                     WTRATIO=(TimeLoc-WTIME1I)/WTIMINC
  1484: +------>            DO I=1,NP
  1485: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  1486: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  1487: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  1488: |       I             WDragCo = WindDrag(WindMag, I)
  1489: |                     IF (LoadDirEffRLen) THEN
  1490: |       I               CALL ApplyDirectionalWindReduction(I, WDragCo,
  1491: |              &             WindMag, DP(I), ETA2(I), WindX, WindY)
  1492: |                       WindMag = SQRT(WindX*WindX+WindY*WindY)
  1493: |       I               WDragCo = WindDrag(WindMag,I)
  1494: |                     ENDIF
  1495: |                     IF (LoadCanopyCoef)
  1496: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1497: |                     IF(NCICE.NE.0) THEN
  1498: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1499: |                     ENDIF
  1500: |                     WSX2(I) = RampMete*0.001293d0*WDRAGCO*WINDX*WINDMAG
  1501: |                     WSY2(I) = RampMete*0.001293d0*WDRAGCO*WINDY*WINDMAG
  1502: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1503: |              &                          -PRBCKGRND_MH2O)
  1504: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1505: |                     WVNXOUT(I)=RampMete*WINDX
  1506: |                     WVNYOUT(I)=RampMete*WINDY
  1507: +------             ENDDO
  1508:                   ENDIF
  1509:           #endif
  1510:           
  1511:           C     RJW ffpl Merged:
  1512:           !     rjw added nws = 19: asymmetric hurricane winds
  1513:                 IF(NWS.EQ.19) THEN
  1514:                    CALL NWS19GET(wvnx2, wvny2, prn2, timeloc)
  1515: +------>           DO I=1,NP
  1516: |                     WindX = WVNX2(I)
  1517: |                     WindY = WVNY2(I)
  1518: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1519: |       I             WDragCo = WindDrag(WindMag, I)
  1520: |                     IF (LoadDirEffRLen) THEN
  1521: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1522: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1523: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1524: |       I                WDragCo = WindDrag(WindMag, I)
  1525: |                     ENDIF
  1526: |                     IF (LoadCanopyCoef)
  1527: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1528: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1529: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1530: |         C  tcm v49.16 20100617C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1531: |                     IF(NCICE.NE.0) THEN
  1532: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1533: |                     ENDIF
  1534: |         !            PR2(I)=RampMete*PRN2(I)
  1535: |                     PRDIFF = RampMete*(PRN2(I)-PRBCKGRND_MH2O)
  1536: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1537: |                     WVNXOUT(I)=RampMete*WindX
  1538: |                     WVNYOUT(I)=RampMete*WindY
  1539: +------            END DO
  1540:                 ENDIF
  1541:           C
  1542:           C     jie added nws = 20: generalized asymmetric vortex model
  1543:                 IF(NWS.EQ.20) THEN
  1544:                    CALL NWS20GET(wvnx2, wvny2, prn2, timeloc)
  1545: +------>           DO I=1,NP
  1546: |                     WindX = WVNX2(I)
  1547: |                     WindY = WVNY2(I)
  1548: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1549: |       I             WDragCo = WindDrag(WindMag, I)
  1550: |                     IF (LoadDirEffRLen) THEN
  1551: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1552: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1553: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1554: |       I                WDragCo = WindDrag(WindMag, I)
  1555: |                     ENDIF
  1556: |                     IF (LoadCanopyCoef)
  1557: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1558: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1559: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1560: |         C  tcm v49.16 20100617C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1561: |                     IF(NCICE.NE.0) THEN
  1562: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1563: |                     ENDIF
  1564: |         !            PR2(I)=RampMete*PRN2(I)
  1565: |                     PRDIFF = RampMete*(PRN2(I)-PRBCKGRND_MH2O)
  1566: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1567: |                     WVNXOUT(I)=RampMete*WindX
  1568: |                     WVNYOUT(I)=RampMete*WindY
  1569: +------            END DO
  1570:                 ENDIF
  1571:           C
  1572:           C     jgf49.1001 Added NWS29 for embedding an asymmetric vortex from
  1573:           C     NWS19 into an OWI basin scale met field from NWS12 (derived from NAM).
  1574:                 IF((ABS(NWS).EQ.29).or.(ABS(NWS).eq.30)) THEN
  1575:                    ! bring in next set of OWI met data
  1576:                    IF(TimeLoc.GT.WTIME2) THEN
  1577:                       WTIME1=WTIME2
  1578:                       WTIME2=WTIME2+WTIMINC
  1579: V------>              DO I=1,NP
  1580: |                        WVNX1(I)=WVNX2(I)
  1581: |                        WVNY1(I)=WVNY2(I)
  1582: |                        PRN1(I)=PRN2(I)
  1583: V------               END DO
  1584:                       CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND)
  1585:                       if(draglawtype.EQ.draglaw_powell)then
  1586:                          call findStormCenter(eyeLat, eyeLon, foundEye)
  1587:                       endif
  1588:                    ENDIF
  1589:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  1590:                    ! bring in next set of asymmetric vortex met data to separate arrays
  1591:                    select case(abs(nws))
  1592:                    case(29)
  1593:                       CALL NWS19GET(vortexWVNX2,vortexWVNY2,vortexPRN2,timeloc)
  1594:                    case(30)
  1595:                       CALL NWS20GET(vortexWVNX2,vortexWVNY2,vortexPRN2,timeloc)
  1596:                    case default
  1597:                       ! should be unreachable
  1598:                       call logMessage(ERROR,'NWS must equal 29 or 30.')
  1599:                    end select
  1600: +------>           DO I=1,NP
  1601: |                     ! compute wind stress due to background met at this node
  1602: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  1603: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  1604: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  1605: |       I             WDragCo = WindDrag(WindMag, I)
  1606: |                     ! jgf49.1001 NAM winds already contain wind reduction
  1607: |                     IF (LoadCanopyCoef)
  1608: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1609: |                     WSX2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  1610: |                     WSY2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  1611: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1612: |              &                          -PRBCKGRND_MH2O)
  1613: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1614: |                     WVNXOUT(I)=RampMete*WINDX
  1615: |                     WVNYOUT(I)=RampMete*WINDY
  1616: |                     ! compute wind stress due to vortex met at this node
  1617: |                     WindX = vortexWVNX2(I)
  1618: |                     WindY = vortexWVNY2(I)
  1619: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1620: |       I             WDragCo = WindDrag(WindMag, I)
  1621: |                     IF (LoadDirEffRLen) THEN
  1622: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1623: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1624: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1625: |       I                WDragCo = WindDrag(WindMag, I)
  1626: |                     ENDIF
  1627: |                     IF (LoadCanopyCoef)
  1628: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1629: |       I             CALL getBlendFactor(I, bf)
  1630: |                     ! blend the wind stresses and barometric pressures
  1631: |                     WSX2(I) = bf*RampMete*airwaterdensityrat*WDragCo*WindX*WindMag
  1632: |              &               +(1.0d0-bf)*WSX2(I)
  1633: |                     WSY2(I) = bf*RampMete*airwaterdensityrat*WDragCo*WindY*WindMag
  1634: |              &               +(1.0d0-bf)*WSY2(I)
  1635: |                     vortexPRDIFF = RampMete*(vortexPRN2(I)-PRBCKGRND_MH2O)
  1636: |                     vortexPRN2(I) = PRBCKGRND_MH2O + vortexPRDIFF
  1637: |                     PR2(I)= bf*vortexPRN2(I)+(1.0d0-bf)*PR2(I)
  1638: |                     WVNXOUT(I)=bf*RampMete*WindX+(1.0d0-bf)*WVNXOUT(I)
  1639: |                     WVNYOUT(I)=bf*RampMete*WindY+(1.0d0-bf)*WVNYOUT(I)
  1640: +------            END DO
  1641:                 ENDIF
  1642:           
  1643:                 !
  1644:                 ! jgf50.38.05: Added NWS=15 for reading HWind data
  1645:                  IF(ABS(NWS).EQ.15) THEN
  1646:                     CALL NWS15GET(WVNX2,WVNY2,PRN2,timeloc)
  1647: +------>            DO I=1,NP
  1648: |                      windx = wvnx2(i)
  1649: |                      windy = wvny2(i)
  1650: |                      windMag = sqrt(windx**2 + windy**2)
  1651: |       I              WDragCo = WindDrag(windMag, i)
  1652: |                      IF (LoadDirEffRLen) THEN
  1653: |       I                 CALL ApplyDirectionalWindReduction(i, WDragCo,
  1654: |              &              windMag, DP(I), ETA2(I),
  1655: |              &              windx, windy)
  1656: |                         WindMag = SQRT(windx**2+windy**2)
  1657: |       I                 WDragCo = WindDrag(WindMag, i)
  1658: |                      ENDIF
  1659: |                     IF (LoadCanopyCoef)
  1660: |       I      &         CALL ApplyCanopyCoefficient(i,windx,windy)
  1661: |                     IF(NCICE.NE.0) THEN
  1662: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1663: |                     ENDIF
  1664: |                      WSX2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  1665: |                      WSY2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  1666: |                      PR2(I) = PRBCKGRND_MH2O + RampMete*(PRN2(I)-PRBCKGRND_MH2O)
  1667: |                      WVNXOUT(I)=RampMete*WINDX
  1668: |                      WVNYOUT(I)=RampMete*WINDY
  1669: +------             END DO
  1670:                  ENDIF
  1671:           C.... tcm v51.06.02 added for GFDL Met Data
  1672:                   IF(ABS(NWS).EQ.16) THEN
  1673:                     IF(TimeLoc.GT.WTIME2) THEN
  1674:                       WTIME1=WTIME2
  1675:                       WTIME2=WTIME2+WTIMINC
  1676: V------>              DO I=1,NP
  1677: |                       WVNX1(I)=WVNX2(I)
  1678: |                       WVNY1(I)=WVNY2(I)
  1679: |                       PRN1(I)=PRN2(I)
  1680: V------               END DO
  1681:                       CALL NWS16GET(timeloc,WVNX2,WVNY2,PRN2)
  1682:                     ENDIF
  1683:                     WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  1684: +------>            DO I=1,NP
  1685: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  1686: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  1687: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  1688: |                     !Casey 110518: Enable Mark Powell's sector-based wind drag.
  1689: |       I             WDragCo = WindDrag(WindMag, I)
  1690: |                     IF (LoadDirEffRLen) THEN
  1691: |       I               CALL ApplyDirectionalWindReduction(I, WDragCo,
  1692: |              &             WindMag, DP(I), ETA2(I), WindX, WindY)
  1693: |                       WindMag = SQRT(WindX*WindX+WindY*WindY)
  1694: |                       !Casey 110518: Enable Mark Powell's sector-based wind drag.
  1695: |       I               WDragCo = WindDrag(WindMag,I)
  1696: |                     ENDIF
  1697: |                     IF (LoadCanopyCoef)
  1698: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1699: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1700: |                     IF(NCICE.NE.0) THEN
  1701: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1702: |                     ENDIF
  1703: |                     WSX2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  1704: |                     WSY2(I) = RampMete*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  1705: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1706: |              &                          -PRBCKGRND_MH2O)
  1707: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1708: |                     WVNXOUT(I)=RampMete*WINDX
  1709: |                     WVNYOUT(I)=RampMete*WINDY
  1710: +------             END DO
  1711:                   ENDIF
  1712:           C
  1713:           C    kmd48.33bc - added in information for the sponge layer
  1714:                  IF (RES_BC_FLAG.GT.0) THEN
  1715: V------>           DO I=1,NP
  1716: |                     WSX2(I)=sponge(I)*WSX2(I)
  1717: |                     WSY2(I)=sponge(I)*WSY2(I)
  1718: V------            END DO
  1719:                  END IF
  1720:            
  1721:           !PV BEG:: NWS=17
  1722:           !... v50.xx sm, v55.xx PV, -- NWS=17 for NUOPC coupling
  1723:                 IF(ABS(NWS).EQ.17) THEN
  1724:                    IF(TimeLoc.GT.WTIME2) THEN
  1725:                       WTIME1=WTIME2
  1726:                       WTIME2=WTIME2+WTIMINC
  1727: V------>              DO I=1,NP
  1728: |                       WVNX1(I)=WVNX2(I)
  1729: |                       WVNY1(I)=WVNY2(I)
  1730: |                       PRN1(I)=PRN2(I)
  1731: V------               END DO
  1732:                    ENDIF
  1733:           C++ GML added 20210727 ncice=17
  1734:                    if ((NCICE.ne. 0).and.
  1735:                &       TimeLoc.GT.CICE_TIME2) THEN
  1736:                        CICE_TIME1 = CICE_TIME2
  1737:                        CICE_TIME2 = CICE_TIME2 + CICE_TIMINC
  1738: V======>               CICE1 = CICE2
  1739:                    endif
  1740:           C++
  1741:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  1742:           C++ GML added 20210727
  1743:                    IF(NCICE.NE.0)THEN
  1744:                        CTRATIO = (TimeLoc-CICE_TIME1)/CICE_TIMINC
  1745:                    ENDIF
  1746:           C++
  1747:                    if (WTRatio .GT. 1.0) then
  1748:                        WTRatio = 1.0
  1749:                        print *, '[Warning:] WTRatio is .GE. 1.0 and Set to 1.0'
  1750:                    endif
  1751:           
  1752: +------>           DO I=1,NP
  1753: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  1754: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  1755: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  1756: |       I             WDragCo = WindDrag(WindMag, I)
  1757: |         C     jgf46.00 Add directional wind reduction.
  1758: |                     IF (LoadDirEffRLen) THEN
  1759: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  1760: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  1761: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  1762: |       I                WDragCo = WindDrag(WindMag, I)
  1763: |                     ENDIF
  1764: |                     IF (LoadCanopyCoef)
  1765: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  1766: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  1767: |                    IF(NCICE.NE.0) THEN
  1768: |                        Cicenow = 100d0*(CICE1(I) + CTRATIO*(CICE2(I)-CICE1(I)))   ! GML added 20210727
  1769: |                        WDragCo = WindIceDrag(WDragCo,Cicenow)                     ! GML added 20210727
  1770: |                        ciceout(i) = Cicenow                                       ! GML added 20210727
  1771: |         C               WDragCo = WindIceDrag(WDragCo,ciceout(i))
  1772: |                     ENDIF
  1773: |                     WSX2(I) = RampMete*airwaterdensityrat*WDragCo*WindX*WindMag   !P.V units: m^2/s^2 aka
  1774: |                     WSY2(I) = RampMete*airwaterdensityrat*WDragCo*WindY*WindMag   !    per water unit mass (1/RhoWat0)
  1775: |         C  tcm v49.16 20100617
  1776: |                     PRDIFF = RampMete*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  1777: |              &                           -PRBCKGRND_MH2O)
  1778: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  1779: |                     !PV Do we need to output the real wind velocities or the ramped ones?
  1780: |                     WVNXOUT(I)=RampMete*WindX
  1781: |                     WVNYOUT(I)=RampMete*WindY
  1782: +------            END DO
  1783:                 ENDIF
  1784:           !PV END:: NWS=17
  1785:           
  1786:           C      DW/WJP: rotate wind stresses if coordinate transform
  1787:                  IF ( IFSPROTS .eq. 1 ) THEN
  1788: V------>            UVECTMP(1:NP) = WSX2(1:NP)
  1789: V------             VVECTMP(1:NP) = WSY2(1:NP)
  1790:                     CALL DRVMAP2DSPVEC( WSX2, WSY2,
  1791:                &              UVECTMP, VVECTMP, NP, FWD = .TRUE. )
  1792:                  ENDIF
  1793:           
  1794:           C--------------------END MET FORCING---------------------------------------
  1795:           
  1796:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  1797:                 call allMessage(DEBUG,"Return.")
  1798:           #endif
  1799:                 call unsetMessageSource()
  1800:           
  1801:           C----------------------------------------------------------------------
  1802:                 end subroutine getMeteorologicalForcing


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETMETEOROLOGICALFORCING
INLINE LIST

  ROOT: WIND::GETMETEOROLOGICALFORCING (wind.F:900)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:934)
     *** Source for routine not found.
  -> NOINLINE: WIND::NWS3GET (wind.F:1007)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1014)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1017)
  -> INLINE: WIND::WINDDRAG (wind.F:1020)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1023)
  -> INLINE: WIND::NWS4GET (wind.F:1049)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:1056)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1059)
  -> INLINE: WIND::WINDDRAG (wind.F:1062)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1065)
  -> INLINE: WIND::WINDDRAG (wind.F:1102)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1105)
  -> INLINE: WIND::WINDDRAG (wind.F:1108)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1111)
  -> NOINLINE: WIND::NWS6GET (wind.F:1145)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1152)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1155)
  -> INLINE: WIND::WINDDRAG (wind.F:1158)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1161)
  -> NOINLINE: WIND::NWS7GET (wind.F:1193)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: WIND::HOLLANDGET (wind.F:1214)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1219)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1221)
  -> INLINE: WIND::WINDDRAG (wind.F:1224)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1227)
  -> NOINLINE: WIND::NWS10GET (wind.F:1260)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1270)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1273)
  -> INLINE: WIND::WINDDRAG (wind.F:1276)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1279)
  -> NOINLINE: WIND::NWS11GET (wind.F:1320)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1327)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1330)
  -> INLINE: WIND::WINDDRAG (wind.F:1333)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1336)
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:1365)
     *** Source for routine not found.
  -> NOINLINE: WIND::NWS14GET (wind.F:1374)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: OWIWIND::FINDSTORMCENTER (wind.F:1382)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:1407)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::FINDSTORMCENTER (wind.F:1409)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:1424)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1426)
  -> INLINE: WIND::WINDDRAG (wind.F:1430)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1433)
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:1478)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:1488)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1490)
  -> INLINE: WIND::WINDDRAG (wind.F:1493)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1496)
  -> NOINLINE: WIND::NWS19GET (wind.F:1514)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1519)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1521)
  -> INLINE: WIND::WINDDRAG (wind.F:1524)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1527)
  -> NOINLINE: WIND::NWS20GET (wind.F:1544)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> INLINE: WIND::WINDDRAG (wind.F:1549)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1551)
  -> INLINE: WIND::WINDDRAG (wind.F:1554)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1557)
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:1584)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::FINDSTORMCENTER (wind.F:1586)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:1598)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:1605)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1608)
  -> INLINE: WIND::WINDDRAG (wind.F:1620)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1622)
  -> INLINE: WIND::WINDDRAG (wind.F:1625)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1628)
  -> INLINE: WIND::GETBLENDFACTOR (wind.F:1629)
   -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:821)
      *** Source for routine not found.
  -> NOINLINE: WIND::NWS15GET (wind.F:1646)
     *** Expansion routine is too big for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:1651)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1653)
  -> INLINE: WIND::WINDDRAG (wind.F:1657)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1660)
  -> NOINLINE: WIND::NWS16GET (wind.F:1681)
     *** Nesting level too deep for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:1689)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1691)
  -> INLINE: WIND::WINDDRAG (wind.F:1695)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1698)
  -> INLINE: WIND::WINDDRAG (wind.F:1756)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:1759)
  -> INLINE: WIND::WINDDRAG (wind.F:1762)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:1765)
  -> NOINLINE: MESH::DRVMAP2DSPVEC (wind.F:1790)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:1799)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETMETEOROLOGICALFORCING
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:951)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:951)
  LOOP END

  LOOP BEGIN: (wind.F:972)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:972)
  LOOP END

  LOOP BEGIN: (wind.F:980)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:980)
    *** The number of VLOAD, VSTORE. :  6,  5. (wind.F:980)
  LOOP END

  LOOP BEGIN: (wind.F:1003)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1003)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:1003)
  LOOP END

  LOOP BEGIN: (wind.F:1010)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1010)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1010)
  LOOP END

  LOOP BEGIN: (wind.F:1044)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1044)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1044)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:1052)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1052)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1052)
  LOOP END

  LOOP BEGIN: (wind.F:1090)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:1090)
  LOOP END

  LOOP BEGIN: (wind.F:1098)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1098)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1098)
  LOOP END

  LOOP BEGIN: (wind.F:1139)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1139)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1139)
  LOOP END

  LOOP BEGIN: (wind.F:1148)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1148)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1148)
  LOOP END

  LOOP BEGIN: (wind.F:1188)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1188)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1188)
  LOOP END

  LOOP BEGIN: (wind.F:1196)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1196)
    *** The number of VLOAD, VSTORE. :  6,  5. (wind.F:1196)
  LOOP END

  LOOP BEGIN: (wind.F:1215)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1215)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1215)
  LOOP END

  LOOP BEGIN: (wind.F:1253)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1253)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1253)
  LOOP END

  LOOP BEGIN: (wind.F:1259)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1259)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1259)
  LOOP END

  LOOP BEGIN: (wind.F:1266)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1266)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1266)
  LOOP END

  LOOP BEGIN: (wind.F:1310)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1310)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1310)
  LOOP END

  LOOP BEGIN: (wind.F:1323)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1323)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1323)
  LOOP END

  LOOP BEGIN: (wind.F:1359)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1359)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1359)
  LOOP END

  LOOP BEGIN: (wind.F:1373)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1373)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1373)
  LOOP END

  LOOP BEGIN: (wind.F:1400)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1400)
    *** The number of VLOAD, VSTORE. :  4,  3. (wind.F:1400)
  LOOP END

  LOOP BEGIN: (wind.F:1415)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1415)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1415)
  LOOP END

  LOOP BEGIN: (wind.F:1473)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1473)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1473)
  LOOP END

  LOOP BEGIN: (wind.F:1484)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1484)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1484)
  LOOP END

  LOOP BEGIN: (wind.F:1515)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1515)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1515)
  LOOP END

  LOOP BEGIN: (wind.F:1545)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1545)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1545)
  LOOP END

  LOOP BEGIN: (wind.F:1579)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1579)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1579)
  LOOP END

  LOOP BEGIN: (wind.F:1600)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1600)
    *** Vectorization obstructive procedure reference. : GLOBAL::SPHERICALDISTANCE (wind.F:1600)
  LOOP END

  LOOP BEGIN: (wind.F:1647)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1647)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1647)
  LOOP END

  LOOP BEGIN: (wind.F:1676)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1676)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1676)
  LOOP END

  LOOP BEGIN: (wind.F:1684)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1684)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1684)
  LOOP END

  LOOP BEGIN: (wind.F:1715)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1715)
    *** The number of VLOAD, VSTORE. :  3,  2. (wind.F:1715)
  LOOP END

  LOOP BEGIN: (wind.F:1727)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1727)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:1727)
  LOOP END

  LOOP BEGIN: (wind.F:1738)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1738)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1738)
  LOOP END

  LOOP BEGIN: (wind.F:1752)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:1752)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:1752)
  LOOP END

  LOOP BEGIN: (wind.F:1788)
    <Vectorized loop.>
    **  Fused loop. (wind.F:1788)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1788)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:1788)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETMETEOROLOGICALFORCING
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 10688 bytes
      Register spill area      :  2984 bytes
      Parameter area           :    72 bytes
      Register save area       :   176 bytes
      User data area           :  7448 bytes
      Others                   :     8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:951)
    *** Estimated execution cycle                       : 136
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Across calls                                : 5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 10
            Across calls                                :  8
            Over basic blocks                           :  2
    *** The number of SCALAR REGISTER TRANSFER          : 13
  LOOP END

  LOOP BEGIN: (wind.F:972)
    *** Estimated execution cycle                       : 110
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 4
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (wind.F:980)
    *** Estimated execution cycle                       : 643
  LOOP END

  LOOP BEGIN: (wind.F:1003)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 693
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 116
            Across calls                                :   7
            Over basic blocks                           : 109
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1044)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 190
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Across calls                                : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 7
            Across calls                                : 5
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1090)
    *** Estimated execution cycle                       : 110
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 4
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1139)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1188)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:1196)
    *** Estimated execution cycle                       : 643
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 638
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 99
            Across calls                                :  4
            Over basic blocks                           : 95
    *** The number of SCALAR REGISTER TRANSFER          : 22
  LOOP END

  LOOP BEGIN: (wind.F:1253)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:1259)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 881
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 37
            Across calls                                :  7
            Over basic blocks                           : 28
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 157
            Across calls                                :   7
            Over basic blocks                           : 150
    *** The number of SCALAR REGISTER TRANSFER          : 54
  LOOP END

  LOOP BEGIN: (wind.F:1310)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1359)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:1373)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1400)
    *** Estimated execution cycle                       : 158
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 1004
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 41
            Across calls                                : 10
            Over basic blocks                           : 29
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 169
            Across calls                                :  10
            Over basic blocks                           : 159
    *** The number of SCALAR REGISTER TRANSFER          : 77
  LOOP END

  LOOP BEGIN: (wind.F:1473)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 724
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 121
            Across calls                                :   7
            Over basic blocks                           : 114
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 645
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 99
            Across calls                                :  4
            Over basic blocks                           : 95
    *** The number of SCALAR REGISTER TRANSFER          : 22
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 645
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 99
            Across calls                                :  4
            Over basic blocks                           : 95
    *** The number of SCALAR REGISTER TRANSFER          : 22
  LOOP END

  LOOP BEGIN: (wind.F:1579)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 1148
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 41
            Across calls                                :  7
            Over basic blocks                           : 31
            Others                                      :  3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 176
            Across calls                                :   7
            Over basic blocks                           : 169
    *** The number of SCALAR REGISTER TRANSFER          : 77
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 638
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 99
            Across calls                                :  4
            Over basic blocks                           : 95
    *** The number of SCALAR REGISTER TRANSFER          : 22
  LOOP END

  LOOP BEGIN: (wind.F:1676)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1715)
    *** Estimated execution cycle                       : 191
  LOOP END

  LOOP BEGIN: (wind.F:1727)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:1738)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 762
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 126
            Across calls                                :   7
            Over basic blocks                           : 119
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:1788)
    *** Estimated execution cycle                       : 96
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::COLDSTARTMETEOROLOGICALFORCING
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  1838: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  1844: vec( 101): Vectorized loop.
  1845: vec( 101): Vectorized loop.
  1846: vec( 101): Vectorized loop.
  1848: vec( 101): Vectorized loop.
  1849: vec( 101): Vectorized loop.
  1853: vec( 101): Vectorized loop.
  1854: vec( 101): Vectorized loop.
  1859: vec( 103): Unvectorized loop.
  1859: vec( 108): Unvectorizable loop structure.
  1863: vec( 103): Unvectorized loop.
  1863: vec( 108): Unvectorizable loop structure.
  1864: opt(1118): This I/O statement inhibits optimization of loop.
  1864: vec( 103): Unvectorized loop.
  1864: vec( 180): I/O statement obstructs vectorization.
  1865: opt(1118): This I/O statement inhibits optimization of loop.
  1865: vec( 103): Unvectorized loop.
  1865: vec( 180): I/O statement obstructs vectorization.
  1874: vec( 103): Unvectorized loop.
  1874: vec( 108): Unvectorizable loop structure.
  1876: vec( 110): Vectorization obstructive procedure reference.: WIND::NWS3GET
  1876: vec( 108): Unvectorizable loop structure.
  1880: vec( 101): Vectorized loop.
  1888: vec( 101): Vectorized loop.
  1897: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  1905: vec( 103): Unvectorized loop.
  1905: vec( 108): Unvectorizable loop structure.
  1908: inl(1222): Inlined: WIND::NWS4GET
  1909: vec( 101): Vectorized loop.
  1910: vec( 101): Vectorized loop.
  1911: inl(1222): Inlined: WIND::NWS4GET
  1915: vec( 103): Unvectorized loop.
  1915: vec( 108): Unvectorizable loop structure.
  1916: opt(1118): This I/O statement inhibits optimization of loop.
  1916: vec( 103): Unvectorized loop.
  1916: vec( 180): I/O statement obstructs vectorization.
  1917: opt(1118): This I/O statement inhibits optimization of loop.
  1917: vec( 103): Unvectorized loop.
  1917: vec( 180): I/O statement obstructs vectorization.
  1926: vec( 103): Unvectorized loop.
  1926: vec( 108): Unvectorizable loop structure.
  1928: vec( 101): Vectorized loop.
  1929: vec( 101): Vectorized loop.
  1943: vec( 103): Unvectorized loop.
  1943: vec( 108): Unvectorizable loop structure.
  1945: vec( 101): Vectorized loop.
  1946: vec( 101): Vectorized loop.
  1961: vec( 103): Unvectorized loop.
  1961: vec( 108): Unvectorizable loop structure.
  1967: vec( 103): Unvectorized loop.
  1967: vec( 108): Unvectorizable loop structure.
  1975: inl(1212): Source for routine not found.: OWIWIND::NWS12INIT
  1976: inl(1212): Source for routine not found.: OWIWIND::NWS12GET
  1978: inl(1212): Source for routine not found.: OWIWIND::FINDSTORMCENTER
  1995: vec( 103): Unvectorized loop.
  1995: vec( 108): Unvectorizable loop structure.
  2000: vec( 103): Unvectorized loop.
  2000: vec( 108): Unvectorizable loop structure.
  2010: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS10INIT
  2011: vec( 101): Vectorized loop.
  2012: vec( 101): Vectorized loop.
  2013: vec( 101): Vectorized loop.
  2017: vec( 101): Vectorized loop.
  2036: vec( 101): Vectorized loop.
  2037: vec( 101): Vectorized loop.
  2048: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS14INIT
  2054: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS14GET
  2086: inl(1212): Source for routine not found.: OWIWIND_NETCDF::NWS13INIT
  2087: inl(1212): Source for routine not found.: OWIWIND_NETCDF::NWS13GET
  2097: inl(1214): Expansion routine is too big for automatic expansion.: WIND::NWS15INIT
  2102: inl(1214): Expansion routine is too big for automatic expansion.: WIND::INIT_GFDL
  2112: vec( 101): Vectorized loop.
  2113: vec( 101): Vectorized loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::COLDSTARTMETEOROLOGICALFORCING
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  1812:                 subroutine coldstartMeteorologicalForcing(nws)
  1813:                 use sizes, only : gblinputdir, inputdir
  1814:                 USE ADC_CONSTANTS, only: g, mb2pa
  1815:                 use global, only : ciceout, h0, eta2, ncice, rampmete,
  1816:                &   sponge, res_bc_flag, statim, wsx1, wsy1, wsx2, wsy2, pr2, pr1,
  1817:                &   cice1, cice2
  1818:                 use owiwind,only : nws12init, nws12get, findStormCenter    ! sb added 09/xx/2006
  1819:                 use nodalAttributes, only : applyDirectionalWindReduction,
  1820:                &   loadCanopyCoef, loadDirEffRLen, applyCanopyCoefficient
  1821:                 use mesh, only : dp, ics, np
  1822:           #ifdef ADCNETCDF
  1823:           Casey 180318: Added for NWS=13
  1824:                 USE OWIWIND_NETCDF, ONLY: NWS13INIT,NWS13GET
  1825:           #endif
  1826:           #ifdef DATETIME
  1827:                 use datetime_module, only: datetime
  1828:           #endif
  1829:                 implicit none
  1830:                 integer, intent(in) :: nws
  1831:                 real(8) :: windx ! wind vel (m/s) in x-dir
  1832:                 real(8) :: windy ! wind vel (m/s) in y-dir
  1833:                 real(8) :: wtratio ! used to time interpolated between met datasets
  1834:                 integer :: nhg ! node number temp
  1835:                 real(8) :: bf ! blend factor for multiple sets of wind data
  1836:                 integer :: i ! node loop counter
  1837:           
  1838:                 call setMessageSource("coldStartMeteorologicalForcing")
  1839:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  1840:                 call allMessage(DEBUG,"Enter.")
  1841:           #endif
  1842:           
  1843:           
  1844: V======>        WSX2(:) = 0.d0
  1845: V======>        WSY2(:) = 0.D0
  1846: V======>        PR2(:) = PRBCKGRND_MH2O
  1847:           
  1848: V======>        WSX1(:) = 0.d0
  1849: V======>        WSY1(:) = 0.d0
  1850:           !      PR1(:) = PRBCKGRND_MH2O ! -- DW for 517
  1851:           !++ GML
  1852:                 if (NCICE.ne. 0) then
  1853: V======>        cice1(:) = 0.d0
  1854: V======>        cice2(:) = 0.D0
  1855:                 endif
  1856:           !++
  1857:           
  1858:                 IF(NWS.EQ.1) THEN
  1859:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1860:                 ENDIF
  1861:           
  1862:                 IF(ABS(NWS).EQ.2) THEN
  1863:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1864: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)
  1865: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  1866:                    WTIME1 = STATIM*86400.D0
  1867:                    WTIME2 = WTIME1 + WTIMINC
  1868:                 ENDIF
  1869:           
  1870:                 IF(NWS.EQ.3) THEN
  1871:           C....    tcm_v49.04 20091124 -- Changed from local inputdir to global inputdir
  1872:           C....                           to correspond with having only a global wind file.
  1873:           !         OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1874:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22')
  1875:           
  1876: +------>           DO WHILE(.TRUE.)
  1877: |                     CALL NWS3GET()
  1878: |                     IF(IWYR.NE.IREFYR) THEN
  1879: |                        IWTIMEP=IWTIME
  1880: |V----->                 DO I=1,NP
  1881: ||                          WVNX1(I)=WVNX2(I)
  1882: ||                          WVNY1(I)=WVNY2(I)
  1883: |V-----                  END DO
  1884: |                        CYCLE
  1885: |                     ENDIF
  1886: |                     IF(WTIMED.LE.WREFTIM) THEN
  1887: |                        IWTIMEP=IWTIME
  1888: |V----->                 DO I=1,NP
  1889: ||                          WVNX1(I)=WVNX2(I)
  1890: ||                          WVNY1(I)=WVNY2(I)
  1891: |V-----                  END DO
  1892: |                        CYCLE
  1893: |                     ENDIF
  1894: |                     EXIT
  1895: +------            ENDDO
  1896:                    write(scratchMessage,'(a,i15)') 'FOUND WIND DATA AT TIME= ',IWTIMEP
  1897:                    call allMessage(INFO,scratchMessage)
  1898:                    write(scratchMessage,'(a,i15)') 'FOUND WIND DATA AT TIME= ',IWTIME
  1899:                    call allMessage(INFO,scratchMessage)
  1900:                    WTIME2=WTIMED-WREFTIM  !CAST INTO MODEL TIME REFERENCE
  1901:                    WTIME1=WTIME2-WTIMINC
  1902:                 ENDIF
  1903:           
  1904:                 IF(ABS(NWS).EQ.4) THEN
  1905:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1906:                    WTIME1 = STATIM*86400.D0
  1907:                    WTIME2=WTIME1+WTIMINC
  1908:         I          CALL NWS4GET()
  1909: V======>           wvnx1 = wvnx2
  1910: V======>           wvny1 = wvny2
  1911:         I          CALL NWS4GET()
  1912:                 ENDIF
  1913:           
  1914:                 IF(ABS(NWS).EQ.5) THEN
  1915:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1916: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)
  1917: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  1918:                    WTIME1 = STATIM*86400.D0
  1919:                    WTIME2 = WTIME1 + WTIMINC
  1920:                 ENDIF
  1921:           
  1922:                 IF(NWS.EQ.6) THEN
  1923:           C....    tcm_v49.04 20091124 -- Changed from local inputdir to global inputdir
  1924:           C....                           to correspond with having only a global wind file.
  1925:           !         OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1926:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22')
  1927:                    CALL NWS6GET()
  1928: V======>           wvnx1 = wvnx2
  1929: V======>           wvny1 = wvny2
  1930:                    CALL NWS6GET()
  1931:                    WTIME1 = STATIM*86400.D0
  1932:                    WTIME2 = WTIME1 + WTIMINC
  1933:                 ENDIF
  1934:           
  1935:           C     jgf46.00 Added option to directly apply surface stress without any
  1936:           C     other correction factors.
  1937:           C     xyc52.30 corrected NWS=7 (wind stress input provided on a
  1938:           C     rectangular grid, same as NWS=6)
  1939:                 IF(ABS(NWS).EQ.7) THEN
  1940:           C         OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  1941:           C         READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)
  1942:           C         READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  1943:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22')
  1944:                    CALL NWS7GET()
  1945: V======>           wvnx1 = wvnx2
  1946: V======>           wvny1 = wvny2
  1947:                    CALL NWS7GET()
  1948:                    WTIME1 = STATIM*86400.D0
  1949:                    WTIME2 = WTIME1 + WTIMINC
  1950:                 ENDIF
  1951:           
  1952:           C     jgf46.02 New option to read in hurricane locations and generate
  1953:           C     generate hurricane winds from the Holland Wind Model.
  1954:                 IF(ABS(NWS).EQ.8) THEN
  1955:                    CALL HollandGet(WVNX2,WVNY2,PRN2,statim*86400.d0)
  1956:                 ENDIF
  1957:           
  1958:           C     RJW Merged:
  1959:           !    rjw added nws = 19: asymmetric hurricane winds v2.0
  1960:                 IF(NWS.EQ.19) THEN
  1961:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22',STATUS='OLD')
  1962:                   CALL NWS19GET(WVNX2,WVNY2,PRN2,STATIM*86400.D0)
  1963:                 ENDIF
  1964:           
  1965:           !    jie added nws = 20: generalized asymmetric vortex model
  1966:                 IF(NWS.EQ.20) THEN
  1967:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22',STATUS='OLD')
  1968:                   CALL NWS20GET(WVNX2,WVNY2,PRN2,STATIM*86400.D0)
  1969:                 ENDIF
  1970:           
  1971:           C.....sb46.28sb01 NWS=-12 and 12 was added to deal with raw OWI files.  09/xx/2006
  1972:                 ! jgf49.1001 Added NWS=29, asymmetric vortex wind (NWS19) embedded in
  1973:                 ! OWI (NWS12) basin scale wind field.
  1974:                 IF ((ABS(NWS).EQ.12).OR.(ABS(NWS).EQ.29).OR.(ABS(NWS).EQ.30)) THEN
  1975:                   CALL NWS12INIT(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)
  1976:                   CALL NWS12GET(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)
  1977:                   if(draglawtype.EQ.draglaw_powell)then
  1978:                       call findStormCenter(eyeLat, eyeLon, foundEye)
  1979:                   endif
  1980:                   CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND)
  1981:                   if(draglawtype.EQ.draglaw_powell)then
  1982:                       call findStormCenter(eyeLat, eyeLon, foundEye)
  1983:                   endif
  1984:                   WTIME1 = STATIM*86400.D0
  1985:                   WTIME2 = WTIME1 + WTIMINC
  1986:                 ENDIF
  1987:                 !
  1988:                 ! jgf49.1001 Added NWS=29, asymmetric vortex wind (NWS19) embedded in
  1989:                 ! OWI (NWS12) basin scale wind field.
  1990:                 ! jgf: Added NWS=30 (GAHM+OWI)
  1991:                 IF ((abs(NWS).EQ.29).or.(abs(NWS).eq.30)) THEN
  1992:                    ! now blend in the vortex met field
  1993:                    ALLOCATE(vortexWVNX2(NP),vortexWVNY2(NP),vortexPRN2(NP))
  1994:                    if (abs(nws).eq.29) then
  1995:                       OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'NWS_19_fort.22',
  1996:                &           STATUS='OLD')
  1997:                       CALL NWS19GET(vortexWVNX2,vortexWVNY2,vortexPRN2,STATIM*86400.D0)
  1998:                    endif
  1999:                    if (abs(nws).eq.30) then
  2000:                       OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'NWS_20_fort.22',
  2001:                &           STATUS='OLD')
  2002:                       CALL NWS20GET(vortexWVNX2,vortexWVNY2,vortexPRN2,STATIM*86400.D0)
  2003:                    endif
  2004:                 ENDIF
  2005:                 !
  2006:                 ! jgf51.52.21: Fixed NWS10 and cleaned up interface.
  2007:                 IF(NWS.EQ.10) THEN
  2008:                    wtime1 = statim*86400.d0
  2009:                    wtime2 = wtime1 + wtiminc
  2010:                    call nws10init()
  2011: V======>           wvnx1 = 0.d0
  2012: V======>           wvny1 = 0.d0
  2013: V======>           prn1  = prbckgrnd * mb2pa / ( rhowat0 * g)
  2014:                    ! read from first available file (not fort.200) and spatially
  2015:                    ! interpolate onto adcirc mesh
  2016:                    IF (NCICE.eq.10) THEN
  2017: V======>              cice1 = 0.d0
  2018:                       call nws10get(wvnx2,wvny2,prn2,cice2)
  2019:                    ELSE
  2020:                       call nws10get(wvnx2,wvny2,prn2)
  2021:                    ENDIF
  2022:                 ENDIF
  2023:           
  2024:                 IF(NWS.EQ.11) THEN
  2025:                    WTIME1=STATIM*86400.D0
  2026:                    WTIME2=WTIME1+WTIMINC
  2027:                    NWSEGWI=0
  2028:                    IDSETFLG=0
  2029:                    call allMessage(INFO,
  2030:                &     'The e29 met grid interpolating factors are being computed.')
  2031:                    CALL NWS11GET()        !JUST COMPUTE INTERPOLATING FACTORS
  2032:                    call allMessage(INFO,
  2033:                &      'Finished computing e29 interpolating factors.')
  2034:                    NWSEGWI=1
  2035:                    IDSETFLG=1
  2036: V======>           wvnx1 = wvnx2
  2037: V======>           wvny1 = wvny2
  2038:                    CALL NWS11GET()        !NOW INTERPOLATE 1st WIND FIELD
  2039:                 ENDIF
  2040:                 !
  2041:                 !
  2042:           #ifdef DATETIME
  2043:           #if defined(GRIB2API) || defined(ADCNETCDF)
  2044:                 IF (ABS(NWS).eq.14) THEN
  2045:                    WTIME1 = STATIM*86400.D0
  2046:                    WTIME2 = WTIME1 + WTIMINC
  2047:                    ! Set datetime and make/check the grib header
  2048:                    CALL NWS14INIT(NWS)
  2049:                    ! Initialising winds (pressure is already initialized)
  2050:                    ! Get the first wind snap
  2051:                    if (NCICE.eq.14) then
  2052:                       CICE_TIME1 = WTIME1
  2053:                       CICE_TIME2 = CICE_TIME1 + CICE_TIMINC
  2054:                       CALL NWS14GET(WVNX1,WVNY1,PRN1,CICE1)
  2055:                    else
  2056:                       CALL NWS14GET(WVNX1,WVNY1,PRN1)
  2057:                    endif
  2058:                    ! Get owi winds (should only overwrite where they exist)
  2059:                    if (NWS.eq.-14) then
  2060:                       CALL NWS12INIT(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)
  2061:                       CALL NWS12GET(WVNX1,WVNY1,PRN1,NP,PRBCKGRND,HasData)
  2062:                       WTIME1_12 = WTIME1
  2063:                       WTIME2_12 = WTIME1_12 + WTIMINC_12
  2064:                    endif
  2065:                    ! Get the second wind snap
  2066:                    if (NCICE.eq.14) then
  2067:                       CALL NWS14GET(WVNX2,WVNY2,PRN2,CICE2)
  2068:                    else
  2069:                       CALL NWS14GET(WVNX2,WVNY2,PRN2)
  2070:                    endif
  2071:                    ! Get owi winds (should only overwrite where they exist)
  2072:                    if (NWS.eq.-14) then
  2073:                       CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND,HasData)
  2074:                    endif
  2075:                 ENDIF
  2076:           #endif
  2077:           #endif
  2078:           
  2079:           #ifdef ADCNETCDF
  2080:           Casey 180318: Added for NWS=13, ARC modified 190108
  2081:                 IF(ABS(NWS).EQ.13)THEN
  2082:                    WTIME1=STATIM*86400.D0
  2083:                    WTIME2=WTIME1+WTIMINC
  2084:                    WTIME2I=WTIME2
  2085:                    WTIME1I=WTIME1
  2086:                   CALL NWS13INIT(0.D0,W)
  2087:                   CALL NWS13GET(WTIME1,WVNX1,WVNY1,PRN1,
  2088:                &      WTIME2,EyeLon,EyeLat,FoundEye,W)
  2089:                   CALL NWS13GET(WTIME2,WVNX2,WVNY2,PRN2,
  2090:                &      WTIME2,EyeLon,EyeLat,FoundEye,W)
  2091:                 ENDIF
  2092:           #endif
  2093:           
  2094:                 !
  2095:                 ! jgf50.38.05: Added NWS=15,-15 for reading HWind data
  2096:                 IF (ABS(NWS).EQ.15) THEN
  2097:                    CALL NWS15INIT(STATIM*86400.0)
  2098:                 ENDIF
  2099:           C
  2100:           C....tcm v51.06.02: Added NWS=16,-16 for reading ASCII GFDL Met data
  2101:                 IF (ABS(NWS).EQ.16) THEN
  2102:                    CALL INIT_GFDL(STATIM*86400.0)
  2103:                 ENDIF
  2104:                 !
  2105:                 ! jgf52.14: Implementing Casey's fix for uninitialized
  2106:                 ! wvnx1 and wvny1 arrays; they are not used/needed/initialized
  2107:                 ! by the parametric vortex meteorological models but are used in
  2108:                 ! the padcswan_init() subroutine to initialize the SWAN wind
  2109:                 ! velocities. Failure to initialize them causes NaNs in the
  2110:                 ! solution.
  2111:                 if ( (abs(nws).eq.8).or.(abs(nws).eq.19).or.(abs(nws).eq.20)) then
  2112: V======>           WVNX1 = WVNX2
  2113: V======>           WVNY1 = WVNY2
  2114:                 endif
  2115:           
  2116:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  2117:                 call allMessage(DEBUG,"Return.")
  2118:           #endif
  2119:                 call unsetMessageSource()
  2120:           C----------------------------------------------------------------------
  2121:                 end subroutine coldstartMeteorologicalForcing


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::COLDSTARTMETEOROLOGICALFORCING
INLINE LIST

  ROOT: WIND::COLDSTARTMETEOROLOGICALFORCING (wind.F:1812)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:1838)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:1897)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:1899)
     *** Source for routine not found.
  -> INLINE: WIND::NWS4GET (wind.F:1908)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::NWS4GET (wind.F:1911)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12INIT (wind.F:1975)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:1976)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::FINDSTORMCENTER (wind.F:1978)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:1980)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::FINDSTORMCENTER (wind.F:1982)
     *** Source for routine not found.
  -> NOINLINE: WIND::NWS10INIT (wind.F:2010)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2029)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2032)
     *** Source for routine not found.
  -> NOINLINE: WIND::NWS14INIT (wind.F:2048)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: WIND::NWS14GET (wind.F:2054)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: OWIWIND::NWS12INIT (wind.F:2060)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:2061)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:2073)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13INIT (wind.F:2086)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:2087)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:2089)
     *** Source for routine not found.
  -> NOINLINE: WIND::NWS15INIT (wind.F:2097)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: WIND::INIT_GFDL (wind.F:2102)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:2119)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::COLDSTARTMETEOROLOGICALFORCING
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:1844)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1844)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1844)
  LOOP END

  LOOP BEGIN: (wind.F:1845)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1845)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1845)
  LOOP END

  LOOP BEGIN: (wind.F:1846)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1846)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1846)
  LOOP END

  LOOP BEGIN: (wind.F:1848)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1848)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1848)
  LOOP END

  LOOP BEGIN: (wind.F:1849)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1849)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1849)
  LOOP END

  LOOP BEGIN: (wind.F:1853)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1853)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1853)
  LOOP END

  LOOP BEGIN: (wind.F:1854)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1854)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:1854)
  LOOP END

  LOOP BEGIN: (wind.F:1859)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1859)
  LOOP END

  LOOP BEGIN: (wind.F:1863)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1863)
  LOOP END

  LOOP BEGIN: (wind.F:1864)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:1864)
  LOOP END

  LOOP BEGIN: (wind.F:1865)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:1865)
  LOOP END

  LOOP BEGIN: (wind.F:1874)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1874)
  LOOP END

  LOOP BEGIN: (wind.F:1876)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : WIND::NWS3GET (wind.F:1876)
    *** Unvectorizable loop structure. (wind.F:1876)

    LOOP BEGIN: (wind.F:1880)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:1880)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:1880)
    LOOP END

    LOOP BEGIN: (wind.F:1888)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:1888)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:1888)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:1905)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1905)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:1909)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1909)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1909)
  LOOP END

  LOOP BEGIN: (wind.F:1910)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1910)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1910)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:1915)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1915)
  LOOP END

  LOOP BEGIN: (wind.F:1916)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:1916)
  LOOP END

  LOOP BEGIN: (wind.F:1917)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:1917)
  LOOP END

  LOOP BEGIN: (wind.F:1926)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1926)
  LOOP END

  LOOP BEGIN: (wind.F:1928)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1928)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1928)
  LOOP END

  LOOP BEGIN: (wind.F:1929)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1929)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1929)
  LOOP END

  LOOP BEGIN: (wind.F:1943)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1943)
  LOOP END

  LOOP BEGIN: (wind.F:1945)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1945)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1945)
  LOOP END

  LOOP BEGIN: (wind.F:1946)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:1946)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:1946)
  LOOP END

  LOOP BEGIN: (wind.F:1961)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1961)
  LOOP END

  LOOP BEGIN: (wind.F:1967)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1967)
  LOOP END

  LOOP BEGIN: (wind.F:1995)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:1995)
  LOOP END

  LOOP BEGIN: (wind.F:2000)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2000)
  LOOP END

  LOOP BEGIN: (wind.F:2011)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2011)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2011)
  LOOP END

  LOOP BEGIN: (wind.F:2012)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2012)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2012)
  LOOP END

  LOOP BEGIN: (wind.F:2013)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2013)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2013)
  LOOP END

  LOOP BEGIN: (wind.F:2017)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2017)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2017)
  LOOP END

  LOOP BEGIN: (wind.F:2036)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2036)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2036)
  LOOP END

  LOOP BEGIN: (wind.F:2037)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2037)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2037)
  LOOP END

  LOOP BEGIN: (wind.F:2112)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2112)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2112)
  LOOP END

  LOOP BEGIN: (wind.F:2113)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2113)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2113)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:06 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::COLDSTARTMETEOROLOGICALFORCING
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 54 [s0-s12 s15-s16 s18-s43 s51-s63]
      Vector registers         : 29 [v35-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 9776 bytes
      Register spill area      :  416 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 9024 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:1844)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1845)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1846)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:1848)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1849)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1853)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1854)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:1859)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1863)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1864)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:1865)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:1874)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1876)
    *** Estimated execution cycle                       : 139
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1

  LOOP BEGIN: (wind.F:1905)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 201
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 3
            Others                                      : 4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 7
            Across calls                                : 5
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END

  LOOP BEGIN: (wind.F:1909)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1910)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 32
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 230
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 19
            Across calls                                : 12
            Over basic blocks                           :  7
    *** The number of SCALAR REGISTER TRANSFER          : 25
  LOOP END

  LOOP BEGIN: (wind.F:1915)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1916)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:1917)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:1926)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1928)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1929)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1943)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1945)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1946)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:1961)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1967)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:1995)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2000)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2011)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2012)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2013)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:2017)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2036)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2037)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2112)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2113)
    *** Estimated execution cycle                       : 64
  LOOP END

    LOOP BEGIN: (wind.F:1888)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (wind.F:1880)
      *** Estimated execution cycle                     : 96
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOTSTARTMETEOROLOGICALFORCING
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  2172: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  2183: vec( 101): Vectorized loop.
  2184: vec( 101): Vectorized loop.
  2185: vec( 101): Vectorized loop.
  2186: vec( 101): Vectorized loop.
  2187: vec( 101): Vectorized loop.
  2188: vec( 101): Vectorized loop.
  2189: vec( 101): Vectorized loop.
  2190: vec( 101): Vectorized loop.
  2191: vec( 101): Vectorized loop.
  2196: vec( 103): Unvectorized loop.
  2196: vec( 108): Unvectorizable loop structure.
  2198: vec( 103): Unvectorized loop.
  2198: vec( 180): I/O statement obstructs vectorization.
  2199: opt(1118): This I/O statement inhibits optimization of loop.
  2202: vec( 101): Vectorized loop.
  2208: vec( 128): Fused multiply-add operation applied.
  2217: vec( 103): Unvectorized loop.
  2217: vec( 108): Unvectorizable loop structure.
  2220: opt(1118): This I/O statement inhibits optimization of loop.
  2220: vec( 103): Unvectorized loop.
  2220: vec( 180): I/O statement obstructs vectorization.
  2221: opt(1118): This I/O statement inhibits optimization of loop.
  2221: vec( 103): Unvectorized loop.
  2221: vec( 180): I/O statement obstructs vectorization.
  2227: vec( 103): Unvectorized loop.
  2227: vec( 180): I/O statement obstructs vectorization.
  2231: opt(1118): This I/O statement inhibits optimization of loop.
  2236: vec( 101): Vectorized loop.
  2237: vec( 128): Fused multiply-add operation applied.
  2238: vec( 128): Fused multiply-add operation applied.
  2243: vec( 128): Fused multiply-add operation applied.
  2245: vec( 128): Fused multiply-add operation applied.
  2250: vec( 103): Unvectorized loop.
  2250: vec( 108): Unvectorizable loop structure.
  2253: opt(1118): This I/O statement inhibits optimization of loop.
  2253: vec( 103): Unvectorized loop.
  2253: vec( 180): I/O statement obstructs vectorization.
  2254: opt(1118): This I/O statement inhibits optimization of loop.
  2254: vec( 103): Unvectorized loop.
  2254: vec( 180): I/O statement obstructs vectorization.
  2255: vec( 101): Vectorized loop.
  2261: vec( 128): Fused multiply-add operation applied.
  2273: vec( 103): Unvectorized loop.
  2273: vec( 108): Unvectorizable loop structure.
  2274: vec( 110): Vectorization obstructive procedure reference.: WIND::NWS3GET
  2274: vec( 108): Unvectorizable loop structure.
  2278: vec( 101): Vectorized loop.
  2286: vec( 101): Vectorized loop.
  2295: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  2300: opt(1135): Outer loop conditionally executes inner loop.
  2300: vec( 110): Vectorization obstructive procedure reference.: WIND::NWS3GET
  2300: vec( 180): I/O statement obstructs vectorization.
  2300: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  2305: vec( 101): Vectorized loop.
  2316: vec( 103): Unvectorized loop.
  2316: vec( 110): Vectorization obstructive procedure reference.:  
  2316: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2320: inl(1222): Inlined: WIND::WINDDRAG
  2323: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2326: inl(1222): Inlined: WIND::WINDDRAG
  2329: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3476: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  2332: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2345: vec( 103): Unvectorized loop.
  2345: vec( 108): Unvectorizable loop structure.
  2348: inl(1222): Inlined: WIND::NWS4GET
  2349: vec( 101): Vectorized loop.
  2350: vec( 101): Vectorized loop.
  2351: inl(1222): Inlined: WIND::NWS4GET
  2357: vec( 101): Vectorized loop.
  2362: inl(1222): Inlined: WIND::NWS4GET
  2366: vec( 103): Unvectorized loop.
  2366: vec( 110): Vectorization obstructive procedure reference.:  
  2366: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2370: inl(1222): Inlined: WIND::WINDDRAG
  2373: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2376: inl(1222): Inlined: WIND::WINDDRAG
  2379: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2382: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2395: vec( 103): Unvectorized loop.
  2395: vec( 108): Unvectorizable loop structure.
  2398: inl(1222): Inlined: WIND::NWS4GET
  2399: vec( 101): Vectorized loop.
  2400: vec( 101): Vectorized loop.
  2401: inl(1222): Inlined: WIND::NWS4GET
  2402: vec( 103): Unvectorized loop.
  2402: vec( 110): Vectorization obstructive procedure reference.:  
  2402: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2406: inl(1222): Inlined: WIND::WINDDRAG
  2409: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2412: inl(1222): Inlined: WIND::WINDDRAG
  2415: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2418: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2434: vec( 103): Unvectorized loop.
  2434: vec( 108): Unvectorizable loop structure.
  2437: opt(1118): This I/O statement inhibits optimization of loop.
  2437: vec( 103): Unvectorized loop.
  2437: vec( 180): I/O statement obstructs vectorization.
  2438: opt(1118): This I/O statement inhibits optimization of loop.
  2438: vec( 103): Unvectorized loop.
  2438: vec( 180): I/O statement obstructs vectorization.
  2444: vec( 103): Unvectorized loop.
  2444: vec( 180): I/O statement obstructs vectorization.
  2448: opt(1118): This I/O statement inhibits optimization of loop.
  2453: vec( 103): Unvectorized loop.
  2453: vec( 110): Vectorization obstructive procedure reference.:  
  2453: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2457: inl(1222): Inlined: WIND::WINDDRAG
  2460: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2463: inl(1222): Inlined: WIND::WINDDRAG
  2466: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2469: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2485: vec( 103): Unvectorized loop.
  2485: vec( 108): Unvectorizable loop structure.
  2488: opt(1118): This I/O statement inhibits optimization of loop.
  2488: vec( 103): Unvectorized loop.
  2488: vec( 180): I/O statement obstructs vectorization.
  2489: opt(1118): This I/O statement inhibits optimization of loop.
  2489: vec( 103): Unvectorized loop.
  2489: vec( 180): I/O statement obstructs vectorization.
  2491: vec( 103): Unvectorized loop.
  2491: vec( 110): Vectorization obstructive procedure reference.:  
  2491: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2495: inl(1222): Inlined: WIND::WINDDRAG
  2498: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2501: inl(1222): Inlined: WIND::WINDDRAG
  2504: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2507: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2531: vec( 103): Unvectorized loop.
  2531: vec( 108): Unvectorizable loop structure.
  2540: vec( 101): Vectorized loop.
  2541: vec( 101): Vectorized loop.
  2546: vec( 103): Unvectorized loop.
  2546: vec( 110): Vectorization obstructive procedure reference.:  
  2546: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2550: inl(1222): Inlined: WIND::WINDDRAG
  2553: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2556: inl(1222): Inlined: WIND::WINDDRAG
  2559: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2562: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2582: vec( 103): Unvectorized loop.
  2582: vec( 108): Unvectorizable loop structure.
  2585: vec( 101): Vectorized loop.
  2586: vec( 101): Vectorized loop.
  2591: vec( 101): Vectorized loop.
  2592: vec( 128): Fused multiply-add operation applied.
  2593: vec( 128): Fused multiply-add operation applied.
  2598: vec( 128): Fused multiply-add operation applied.
  2600: vec( 128): Fused multiply-add operation applied.
  2607: vec( 103): Unvectorized loop.
  2607: vec( 108): Unvectorizable loop structure.
  2610: vec( 101): Vectorized loop.
  2611: vec( 101): Vectorized loop.
  2618: vec( 101): Vectorized loop.
  2619: vec( 128): Fused multiply-add operation applied.
  2620: vec( 128): Fused multiply-add operation applied.
  2625: vec( 128): Fused multiply-add operation applied.
  2627: vec( 128): Fused multiply-add operation applied.
  2637: vec( 103): Unvectorized loop.
  2637: vec( 110): Vectorization obstructive procedure reference.:  
  2637: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2641: inl(1222): Inlined: WIND::WINDDRAG
  2643: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2646: inl(1222): Inlined: WIND::WINDDRAG
  2649: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2652: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2668: vec( 103): Unvectorized loop.
  2668: vec( 108): Unvectorizable loop structure.
  2670: vec( 103): Unvectorized loop.
  2670: vec( 110): Vectorization obstructive procedure reference.:  
  2670: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2674: inl(1222): Inlined: WIND::WINDDRAG
  2676: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2679: inl(1222): Inlined: WIND::WINDDRAG
  2682: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2685: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2701: vec( 103): Unvectorized loop.
  2701: vec( 108): Unvectorizable loop structure.
  2703: vec( 103): Unvectorized loop.
  2703: vec( 110): Vectorization obstructive procedure reference.:  
  2703: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2707: inl(1222): Inlined: WIND::WINDDRAG
  2709: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2712: inl(1222): Inlined: WIND::WINDDRAG
  2715: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2718: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2743: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS10INIT
  2758: vec( 103): Unvectorized loop.
  2758: vec( 110): Vectorization obstructive procedure reference.:  
  2758: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2762: inl(1222): Inlined: WIND::WINDDRAG
  2765: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2768: inl(1222): Inlined: WIND::WINDDRAG
  2771: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2776: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2778: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2811: vec( 101): Vectorized loop.
  2812: vec( 101): Vectorized loop.
  2815: vec( 103): Unvectorized loop.
  2815: vec( 110): Vectorization obstructive procedure reference.:  
  2815: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  2819: inl(1222): Inlined: WIND::WINDDRAG
  2822: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2825: inl(1222): Inlined: WIND::WINDDRAG
  2828: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2831: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  2851: inl(1212): Source for routine not found.: OWIWIND::NWS12INIT
  2852: inl(1212): Source for routine not found.: OWIWIND::NWS12GET
  2856: opt(1135): Outer loop conditionally executes inner loop.
  2856: vec( 110): Vectorization obstructive procedure reference.: OWIWIND::NWS12GET
  2861: vec( 101): Vectorized loop.
  2871: vec( 103): Unvectorized loop.
  2871: vec( 110): Vectorization obstructive procedure reference.:  
  2875: inl(1222): Inlined: WIND::WINDDRAG
  2877: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2880: inl(1222): Inlined: WIND::WINDDRAG
  2883: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2902: inl(1212): Source for routine not found.: OWIWIND_NETCDF::NWS13INIT
  2903: inl(1212): Source for routine not found.: OWIWIND_NETCDF::NWS13GET
  2908: vec( 103): Unvectorized loop.
  2908: vec( 110): Vectorization obstructive procedure reference.:  
  2912: inl(1222): Inlined: WIND::WINDDRAG
  2914: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2917: inl(1222): Inlined: WIND::WINDDRAG
  2920: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2943: vec( 103): Unvectorized loop.
  2943: vec( 108): Unvectorizable loop structure.
  2948: vec( 103): Unvectorized loop.
  2948: vec( 108): Unvectorizable loop structure.
  2952: vec( 103): Unvectorized loop.
  2952: vec( 110): Vectorization obstructive procedure reference.:  
  2952: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SPHERICALDISTANCE
  2956: inl(1222): Inlined: WIND::WINDDRAG
  2958: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  2961: inl(1222): Inlined: WIND::WINDDRAG
   821: inl(1212): Source for routine not found.: GLOBAL::SPHERICALDISTANCE
  2964: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  2965: inl(1222): Inlined: WIND::GETBLENDFACTOR
  2992: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS14INIT
  2998: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS14GET
  3021: vec( 103): Unvectorized loop.
  3021: vec( 110): Vectorization obstructive procedure reference.:  
  3021: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  3030: inl(1222): Inlined: WIND::WINDDRAG
  3032: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3036: inl(1222): Inlined: WIND::WINDDRAG
  3039: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3046: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3048: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3089: vec( 103): Unvectorized loop.
  3089: vec( 110): Vectorization obstructive procedure reference.:  
  3093: inl(1222): Inlined: WIND::WINDDRAG
  3095: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3098: inl(1222): Inlined: WIND::WINDDRAG
  3101: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3117: inl(1214): Expansion routine is too big for automatic expansion.: WIND::NWS15INIT
  3118: inl(1214): Expansion routine is too big for automatic expansion.: WIND::NWS15GET
  3119: vec( 103): Unvectorized loop.
  3119: vec( 110): Vectorization obstructive procedure reference.:  
  3119: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  3120: inl(1222): Inlined: WIND::WINDDRAG
  3124: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3128: inl(1222): Inlined: WIND::WINDDRAG
  3131: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3133: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3147: inl(1214): Expansion routine is too big for automatic expansion.: WIND::INIT_GFDL
  3148: opt(1135): Outer loop conditionally executes inner loop.
  3148: vec( 110): Vectorization obstructive procedure reference.: WIND::NWS16GET
  3153: vec( 101): Vectorized loop.
  3158: inl(1219): Nesting level too deep for automatic expansion.: WIND::NWS16GET
  3162: vec( 103): Unvectorized loop.
  3162: vec( 110): Vectorization obstructive procedure reference.:  
  3162: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  3166: inl(1222): Inlined: WIND::WINDDRAG
  3168: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3171: inl(1222): Inlined: WIND::WINDDRAG
  3174: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3177: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3193: vec( 103): Unvectorized loop.
  3193: vec( 110): Vectorization obstructive procedure reference.:  
  3193: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  3197: inl(1222): Inlined: WIND::WINDDRAG
  3199: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3202: inl(1222): Inlined: WIND::WINDDRAG
  3205: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3208: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3224: opt(1135): Outer loop conditionally executes inner loop.
  3224: vec( 103): Unvectorized loop.
  3224: vec( 113): Overhead of loop division is too large.
  3229: vec( 101): Vectorized loop.
  3244: vec( 103): Unvectorized loop.
  3244: vec( 110): Vectorization obstructive procedure reference.:  
  3244: vec( 110): Vectorization obstructive procedure reference.: WIND::WINDICEDRAG
  3248: inl(1222): Inlined: WIND::WINDDRAG
  3252: inl(1222): Inlined: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION
  3255: inl(1222): Inlined: WIND::WINDDRAG
  3258: inl(1222): Inlined: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT
  3261: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::WINDICEDRAG
  3283: vec( 101): Vectorized loop.
  3284: vec( 101): Vectorized loop.
  3289: vec( 101): Vectorized loop.
  3290: opt(1112): Loop fused with previous loop.
  3291: inl(1212): Source for routine not found.: MESH::DRVMAP2DSPVEC


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOTSTARTMETEOROLOGICALFORCING
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  2132:                 subroutine hotstartMeteorologicalForcing(nws, wsx2, wsy2, pr2,
  2133:                &   wvnxout, wvnyout, timeloc, rampmete2)
  2134:                 use sizes, only : gblinputdir, inputdir
  2135:                 USE ADC_CONSTANTS, only: g
  2136:                 use global, only : ciceout, h0, eta2, ncice, rampmete,
  2137:                &   sponge, res_bc_flag, statim, dtdp, dtdphs, iths,
  2138:                &   IDEN, SigTS, cice1, cice2, IFSPROTS
  2139:                 use owiwind,only : nws12init, nws12get, findStormCenter    ! sb added 09/xx/2006
  2140:                 use nodalAttributes, only : applyDirectionalWindReduction,
  2141:                &   loadCanopyCoef, loadDirEffRLen, applyCanopyCoefficient
  2142:                 use mesh, only : dp, ics, np, uvectmp, vvectmp, DRVMAP2DSPVEC
  2143:           #ifdef ADCNETCDF
  2144:                 USE OWIWIND_NETCDF, ONLY: NWS13INIT,NWS13GET
  2145:           #endif
  2146:                 implicit none
  2147:                 integer, intent(in) :: nws
  2148:                 real(8), intent(out) :: wsx2(:)
  2149:                 real(8), intent(out) :: wsy2(:)
  2150:                 real(8), intent(out) :: pr2(:)
  2151:                 real(8), intent(out) :: wvnxout(:)
  2152:                 real(8), intent(out) :: wvnyout(:)
  2153:                 real(8), intent(in) :: timeloc
  2154:                 real(8), intent(in) :: rampMete2   ! Ramp for wind and atmospheric pressure @ITHS
  2155:                 real(8) :: timeit
  2156:                 real(8) :: windx ! wind vel (m/s) in x-dir
  2157:                 real(8) :: windy ! wind vel (m/s) in y-dir
  2158:                 real(8) :: prdiff
  2159:                 real(8) :: wDragCo
  2160:                 real(8) :: windMag
  2161:                 real(8) :: wtratio ! used to time interpolated between met datasets
  2162:                 real(8) :: cicenow, ctratio
  2163:                 integer :: nhg ! node number temp
  2164:                 real(8) :: bf ! blend factor for multiple sets of wind data
  2165:                 real(8) :: vortexPRDIFF
  2166:                 integer :: it
  2167:                 integer :: i ! node loop counter
  2168:                 integer :: j
  2169:                 real(8) :: wtratio_12, wtratio_14 ! used to time interpolated between met datasets
  2170:                 integer :: TimeLoc_NM ! timeloc to the nearest minute
  2171:           
  2172:                 call setMessageSource("hotStartMeteorologicalForcing")
  2173:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  2174:                 call allMessage(DEBUG,"Enter.")
  2175:           #endif
  2176:           
  2177:           C
  2178:           C......RESTART WIND AND PRESSURE INFORMATION
  2179:           
  2180:                 !c DW, for nonwind and NEM
  2181:                 SELECT CASE(NWS)
  2182:                 CASE (0,17)
  2183: V======>           WVNX1(:) = 0.d0
  2184: V======>           WVNY1(:) = 0.d0
  2185: V======>           WVNX2(:) = 0.d0
  2186: V======>           WVNY2(:) = 0.d0
  2187: V======>           PRN1(:)=PRBCKGRND_MH2O
  2188: V======>           PRN2(:)=PRBCKGRND_MH2O
  2189: V======>           WSX2(:) = 0.d0
  2190: V======>           WSY2(:) = 0.D0
  2191: V======>           PR2(:) = PRBCKGRND_MH2O
  2192:                 END SELECT
  2193:           
  2194:           C     No wind, radiation stress or atmospheric pressure forcings are used.
  2195:                 IF(NWS.EQ.1) THEN
  2196:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2197: +------>           DO J=1,ITHS
  2198: |+----->              DO I=1,NP
  2199: ||                       READ(22,*) NHG,WSX2(I),WSY2(I),PR2(I)
  2200: |+-----               END DO
  2201: +------            END DO
  2202: V------>           DO I=1,NP
  2203: |                     WSX2(I)=RampMete2*WSX2(I)
  2204: |                     WSY2(I)=RampMete2*WSY2(I)
  2205: |         C  tcm v49.16 20100617
  2206: |         !            PR2(I)=RampMete2*PR2(I)
  2207: |                     PRDIFF = RampMete2*(PR2(I)-PRBCKGRND_MH2O)
  2208: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2209: V------            END DO
  2210:                 ENDIF
  2211:           
  2212:           C     Wind stress and atmospheric pressure are read in at all grid nodes
  2213:           C     at a time interval that does not equal the model time
  2214:           C     step. Interpolation in time is used to synchronize the wind and
  2215:           C     pressure information with the model time step.
  2216:                 IF(NWS.EQ.2) THEN
  2217:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2218:                    WTIME1 = STATIM*86400.D0
  2219:                    WTIME2 = WTIME1 + WTIMINC
  2220: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)  !TCM v49.02 Added read for rec. 1
  2221: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  2222: +------>           DO IT=1,ITHS
  2223: |                     TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  2224: |                     IF(TIMEIT.GT.WTIME2) THEN
  2225: |                        WTIME1=WTIME2
  2226: |                        WTIME2=WTIME2+WTIMINC
  2227: |+----->                 DO I=1,NP
  2228: ||                          WVNX1(I)=WVNX2(I)
  2229: ||                          WVNY1(I)=WVNY2(I)
  2230: ||                          PRN1(I)=PRN2(I)
  2231: ||                          READ(22,*) NHG,WVNX2(I),WVNY2(I),PRN2(I)
  2232: |+-----                  END DO
  2233: |                     ENDIF
  2234: +------            END DO
  2235:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2236: V------>           DO I=1,NP
  2237: |       F             WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2238: |       F             WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2239: |                     WSX2(I) = RampMete2*WINDX
  2240: |                     WSY2(I) = RampMete2*WINDY
  2241: |         C  tcm v49.16 20100617
  2242: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2243: |       F             PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2244: |              &                          -PRBCKGRND_MH2O)
  2245: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2246: V------            END DO
  2247:                 ENDIF
  2248:           
  2249:                 IF(NWS.EQ.-2) THEN
  2250:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2251:                    WTIME1 = TimeLoc
  2252:                    WTIME2 = WTIME1 + WTIMINC
  2253: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)
  2254: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  2255: V------>           DO I=1,NP
  2256: |                     WSX2(I) = RampMete2*WVNX1(I)
  2257: |                     WSY2(I) = RampMete2*WVNY1(I)
  2258: |         C  tcm v49.16 20100617
  2259: |         !            PR2(I)=RampMete2*PRN1(I)
  2260: |                     PRDIFF = RampMete2*(PRN1(I)-PRBCKGRND_MH2O)
  2261: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2262: V------            END DO
  2263:                 ENDIF
  2264:           
  2265:           C     Wind velocity in US Navy Fleet Numeric format interpolated in
  2266:           C     space onto the ADCIRC grid and in time to synchronize the wind and
  2267:           C     pressure information with the model time step. Garratt's formula
  2268:           C     is used to compute wind stress from the wind velocity.
  2269:                 IF(NWS.EQ.3) THEN
  2270:           C....    tcm_v49.04 20091124 -- Changed from local inputdir to global inputdir
  2271:           C....                           to correspond with having only a global wind file.
  2272:           !         OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2273:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22')
  2274: +------>           DO WHILE(.TRUE.)
  2275: |                     CALL NWS3GET()
  2276: |                     IF(IWYR.NE.IREFYR) THEN
  2277: |                        IWTIMEP=IWTIME
  2278: |V----->                 DO I=1,NP
  2279: ||                          WVNX1(I)=WVNX2(I)
  2280: ||                          WVNY1(I)=WVNY2(I)
  2281: |V-----                  END DO
  2282: |                        CYCLE
  2283: |                     ENDIF
  2284: |                     IF(WTIMED.LE.WREFTIM) THEN
  2285: |                        IWTIMEP=IWTIME
  2286: |V----->                 DO I=1,NP
  2287: ||                          WVNX1(I)=WVNX2(I)
  2288: ||                          WVNY1(I)=WVNY2(I)
  2289: |V-----                  END DO
  2290: |                        CYCLE
  2291: |                     ENDIF
  2292: |                     EXIT
  2293: +------            ENDDO
  2294:                    write(scratchMessage,'(a,f15.7)') 'FOUND WIND DATA AT TIME= ',IWTIMEP
  2295:                    call allMessage(INFO,scratchMessage)
  2296:                    write(scratchMessage,'(a,f15.7)') 'FOUND WIND DATA AT TIME= ',IWTIME
  2297:                    call allMessage(INFO,scratchMessage)
  2298:                    WTIME2=WTIMED-WREFTIM  !CAST INTO MODEL TIME REFERENCE
  2299:                    WTIME1=WTIME2-WTIMINC
  2300: +------>           DO IT=1,ITHS
  2301: |                     TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  2302: |                     IF(TIMEIT.GT.WTIME2) THEN
  2303: |                        WTIME1=WTIME2
  2304: |                        WTIME2=WTIME2+WTIMINC
  2305: |V----->                 DO I=1,NP
  2306: ||                          WVNX1(I)=WVNX2(I)
  2307: ||                          WVNY1(I)=WVNY2(I)
  2308: |V-----                  END DO
  2309: |                        CALL NWS3GET()
  2310: |                        write(scratchMessage,'(a,f15.7)')
  2311: |              &            'Wind file advanced to time = ',iwtime
  2312: |                        call allMessage(INFO,scratchMessage)
  2313: |                     ENDIF
  2314: +------            END DO
  2315:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2316: +------>           DO I=1,NP              !INTERPOLATE IN TIME
  2317: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2318: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2319: |                     WINDMAG=SQRT(WINDX*WINDX+WINDY*WINDY)
  2320: |       I             WDragCo = WindDrag(WindMag, I)
  2321: |         C     jgf46.01 Add directional wind reduction.
  2322: |                     IF (LoadDirEffRLen) THEN
  2323: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2324: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2325: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2326: |       I                WDragCo = WindDrag(WindMag, I)
  2327: |                     ENDIF
  2328: |                     IF (LoadCanopyCoef)
  2329: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2330: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2331: |                     IF(NCICE.NE.0) THEN
  2332: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2333: |                     ENDIF
  2334: |                     WSX2(I)=RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2335: |                     WSY2(I)=RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2336: +------            END DO
  2337:                 ENDIF
  2338:           
  2339:           C     Wind velocity and atmospheric pressure are read in (PBL/JAG
  2340:           C     format) at selected ADCIRC grid nodes. Interpolation in time is
  2341:           C     used to synchronize the wind and pressure information with the
  2342:           C     model time step. Garratt's formula is used to compute wind stress
  2343:           C     from wind velocity.
  2344:                 IF(NWS.EQ.4) THEN
  2345:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2346:                    WTIME1 = STATIM*86400.D0
  2347:                    WTIME2 = WTIME1 + WTIMINC
  2348:         I          CALL NWS4GET()  !TCM v49.02 Added read for rec. 1
  2349: V======>           wvnx1 = wvnx2
  2350: V======>           wvny1 = wvny2
  2351:         I          CALL NWS4GET()
  2352: +------>           DO IT=1,ITHS
  2353: |                     TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  2354: |                     IF(TIMEIT.GT.WTIME2) THEN
  2355: |                        WTIME1=WTIME2
  2356: |                        WTIME2=WTIME2+WTIMINC
  2357: |V----->                 DO I=1,NP
  2358: ||                          WVNX1(I)=WVNX2(I)
  2359: ||                          WVNY1(I)=WVNY2(I)
  2360: ||                          PRN1(I)=PRN2(I)
  2361: |V-----                  END DO
  2362: |       I                CALL NWS4GET()
  2363: |                     ENDIF
  2364: +------            END DO
  2365:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2366: +------>           DO I=1,NP
  2367: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2368: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2369: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2370: |       I             WDragCo = WindDrag(WindMag, I)
  2371: |         C     jgf46.01 Add directional wind reduction.
  2372: |                     IF (LoadDirEffRLen) THEN
  2373: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2374: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2375: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2376: |       I                WDragCo = WindDrag(WindMag, I)
  2377: |                     ENDIF
  2378: |                     IF (LoadCanopyCoef)
  2379: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2380: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2381: |                     IF(NCICE.NE.0) THEN
  2382: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2383: |                     ENDIF
  2384: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2385: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2386: |         C  tcm v49.16 20100617
  2387: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2388: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2389: |              &                           -PRBCKGRND_MH2O)
  2390: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2391: +------            END DO
  2392:                 ENDIF
  2393:           
  2394:                 IF(NWS.EQ.-4) THEN
  2395:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2396:                    WTIME1 = TimeLoc
  2397:                    WTIME2 = WTIME1 + WTIMINC
  2398:         I          CALL NWS4GET()
  2399: V======>           wvnx1 = wvnx2
  2400: V======>           wvny1 = wvny2
  2401:         I          CALL NWS4GET()
  2402: +------>           DO I=1,NP
  2403: |                     WINDX = WVNX1(I)
  2404: |                     WINDY = WVNY1(I)
  2405: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2406: |       I             WDragCo = WindDrag(WindMag, I)
  2407: |         C     jgf46.01 Add directional wind reduction.
  2408: |                     IF (LoadDirEffRLen) THEN
  2409: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2410: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2411: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2412: |       I                WDragCo = WindDrag(WindMag, I)
  2413: |                     ENDIF
  2414: |                     IF (LoadCanopyCoef)
  2415: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2416: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2417: |                     IF(NCICE.NE.0) THEN
  2418: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2419: |                     ENDIF
  2420: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2421: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2422: |         C  tcm v49.16 20100617
  2423: |         !            PR2(I)=RampMete2*PRN1(I)
  2424: |                     PRDIFF = RampMete2*(PRN1(I)-PRBCKGRND_MH2O)
  2425: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2426: +------            END DO
  2427:                 ENDIF
  2428:           
  2429:           C     Wind velocity and atmospheric pressure are read in at all grid
  2430:           C     nodes. Interpolation in time is used to synchronize the wind and
  2431:           C     pressure information with the model time step. Garratt's formula
  2432:           C     is used to compute wind stress from wind velocity.
  2433:                 IF(NWS.EQ.5) THEN
  2434:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2435:                    WTIME1 = STATIM*86400.D0
  2436:                    WTIME2 = WTIME1 + WTIMINC
  2437: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)  !TCM v49.02 Added read for rec. 1
  2438: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  2439: +------>           DO IT=1,ITHS
  2440: |                     TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  2441: |                     IF(TIMEIT.GT.WTIME2) THEN
  2442: |                        WTIME1=WTIME2
  2443: |                        WTIME2=WTIME2+WTIMINC
  2444: |+----->                 DO I=1,NP
  2445: ||                          WVNX1(I)=WVNX2(I)
  2446: ||                          WVNY1(I)=WVNY2(I)
  2447: ||                          PRN1(I)=PRN2(I)
  2448: ||                          READ(22,*) NHG,WVNX2(I),WVNY2(I),PRN2(I)
  2449: |+-----                  END DO
  2450: |                     ENDIF
  2451: +------            END DO
  2452:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2453: +------>           DO I=1,NP
  2454: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2455: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2456: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2457: |       I             WDragCo = WindDrag(WindMag, I)
  2458: |         C     jgf46.01 Add directional wind reduction.
  2459: |                     IF (LoadDirEffRLen) THEN
  2460: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2461: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2462: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2463: |       I                WDragCo = WindDrag(WindMag, I)
  2464: |                     ENDIF
  2465: |                     IF (LoadCanopyCoef)
  2466: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2467: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2468: |                     IF(NCICE.NE.0) THEN
  2469: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2470: |                     ENDIF
  2471: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2472: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2473: |         C  tcm v49.16 20100617
  2474: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2475: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2476: |              &                           -PRBCKGRND_MH2O)
  2477: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2478: |         C     jjw-42.06j wrote, jgf46.00 added following two lines:
  2479: |                     WVNXOUT(I)=RampMete2*WINDX
  2480: |                     WVNYOUT(I)=RampMete2*WINDY
  2481: +------            END DO
  2482:                 ENDIF
  2483:           
  2484:                 IF(NWS.EQ.-5) THEN
  2485:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2486:                    WTIME1 = TimeLoc
  2487:                    WTIME2 = WTIME1 + WTIMINC
  2488: +------>           READ(22,*) (NHG,WVNX1(I),WVNY1(I),PRN1(I),I=1,NP)
  2489: +------>           READ(22,*) (NHG,WVNX2(I),WVNY2(I),PRN2(I),I=1,NP)
  2490:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC !jgf46.00 added
  2491: +------>           DO I=1,NP
  2492: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2493: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2494: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2495: |       I             WDragCo = WindDrag(WindMag, I)
  2496: |         C     jgf46.01 Add directional wind reduction.
  2497: |                     IF (LoadDirEffRLen) THEN
  2498: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2499: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2500: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2501: |       I                WDragCo = WindDrag(WindMag, I)
  2502: |                     ENDIF
  2503: |                     IF (LoadCanopyCoef)
  2504: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2505: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2506: |                     IF(NCICE.NE.0) THEN
  2507: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2508: |                     ENDIF
  2509: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2510: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2511: |         C  tcm v49.16 20100617
  2512: |         !            PR2(I)=RampMete2*PRN1(I)
  2513: |                     PRDIFF = RampMete2*(PRN1(I)-PRBCKGRND_MH2O)
  2514: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2515: |                     WVNXOUT(I)=RampMete2*WINDX !jgf46.00 added  ! tcm 20100618 v49.16 changed RampMete to RampMete2
  2516: |                     WVNYOUT(I)=RampMete2*WINDY !jgf46.00 added  ! tcm 20100618 v49.16 changed RampMete to RampMete2
  2517: +------            END DO
  2518:                 ENDIF
  2519:           
  2520:           C     Wind velocity and atmospheric pressure are read in for a
  2521:           C     rectangular grid (either in Longitude, Latitude or Cartesian
  2522:           C     coordinates, consistent with the grid coordinates) and
  2523:           C     interpolated in space onto the ADCIRC grid and in time to
  2524:           C     synchronize the wind and pressure information with the model time
  2525:           C     step. Garratt's formula is used to compute wind stress from the
  2526:           C     wind velocity.
  2527:                 IF(NWS.EQ.6) THEN
  2528:           C....    tcm_v49.04 20091124 -- Changed from local inputdir to global inputdir
  2529:           C....                           to correspond with having only a global wind file.
  2530:           !         OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2531:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22')
  2532:           C     The following 3 lines are a hardwire to allow a non standard met
  2533:           C     file to be read in at time zero in a hot start.  They should be
  2534:           C     eliminated or commented out for normal operation
  2535:           c     OPEN(199,FILE=TRIM(INPUTDIR)//'/'//'fort.199')
  2536:           c     READ(199,*) (NHG,PRN1(I),WVNX1(I),WVNY1(I),I=1,NP)
  2537:           c     CLOSE(199)
  2538:           C     The following CALL statement should be uncommented for normal operation
  2539:                    CALL NWS6GET()
  2540: V======>           wvnx1 = wvnx2
  2541: V======>           wvny1 = wvny2
  2542:                    CALL NWS6GET()
  2543:                    WTIME1=TimeLoc
  2544:                    WTIME2=WTIME1+WTIMINC
  2545:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2546: +------>           DO I=1,NP
  2547: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2548: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2549: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2550: |       I             WDragCo = WindDrag(WindMag, I)
  2551: |         C     jgf46.00 Add directional wind reduction.
  2552: |                     IF (LoadDirEffRLen) THEN
  2553: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2554: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2555: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2556: |       I                WDragCo = WindDrag(WindMag, I)
  2557: |                     ENDIF
  2558: |                     IF (LoadCanopyCoef)
  2559: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2560: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2561: |                     IF(NCICE.NE.0) THEN
  2562: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2563: |                     ENDIF
  2564: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2565: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2566: |         C  tcm v49.16 20100617
  2567: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2568: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2569: |              &                           -PRBCKGRND_MH2O)
  2570: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2571: +------            END DO
  2572:                 ENDIF
  2573:           
  2574:           C     jgf46.01 New option to read in surface wind stress and atmospheric
  2575:           C     pressure for a rectangular grid (either in Longitude, Latitude or
  2576:           C     Cartesian coordinates, consistent with the grid coordinates) and
  2577:           C     interpolate in space onto the ADCIRC grid. Interpolation in time
  2578:           C     is used to synchronize the wind and pressure information with the
  2579:           C     model time step.
  2580:           C
  2581:                 IF(NWS.EQ.7) THEN
  2582:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2583:                    WTIME1 = STATIM*86400.D0
  2584:                    CALL NWS7GET()  !TCMv49.02 Changed (WVNX2,WVNY2,PRN2) to (WVNX1,WVNY1,PRN1)
  2585: V======>           wvnx1 = wvnx2
  2586: V======>           wvny1 = wvny2
  2587:                    CALL NWS7GET()
  2588:                    WTIME1=TimeLoc
  2589:                    WTIME2=WTIME1+WTIMINC
  2590:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2591: V------>           DO I=1,NP
  2592: |       F             WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  2593: |       F             WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  2594: |                     WSX2(I) = RampMete2*WindX !apply ramp
  2595: |                     WSY2(I) = RampMete2*WindY
  2596: |         C  tcm v49.16 20100617
  2597: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2598: |       F             PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2599: |              &                           -PRBCKGRND_MH2O)
  2600: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2601: |                     wvnxout(i)=WSX2(i) !for met recording sta. output
  2602: |                     wvnyout(i)=WSY2(i)
  2603: V------            END DO
  2604:                 ENDIF
  2605:           
  2606:                 IF(NWS.EQ.-7) THEN
  2607:                    OPEN(22,FILE=TRIM(INPUTDIR)//'/'//'fort.22')
  2608:                    WTIME1 = STATIM*86400.D0
  2609:                    CALL NWS7GET()
  2610: V======>           wvnx1 = wvnx2
  2611: V======>           wvny1 = wvny2
  2612:                    CALL NWS7GET()
  2613:                    WTIME1=TimeLoc
  2614:                    WTIME2=WTIME1+WTIMINC
  2615:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2616:           C     jgfdebug46.01 How do we convert these marine wind stresses into
  2617:           C     directional land surface stresses?
  2618: V------>           DO I=1,NP
  2619: |       F             WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  2620: |       F             WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  2621: |                     WSX2(I) = RampMete2*WindX !apply ramp
  2622: |                     WSY2(I) = RampMete2*WindY
  2623: |         C  tcm v49.16 20100617
  2624: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2625: |       F             PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2626: |              &                           -PRBCKGRND_MH2O)
  2627: |       F             PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2628: |                     wvnxout(i)=WSX2(i) !for met recording sta. output
  2629: |                     wvnyout(i)=WSY2(i)
  2630: V------            END DO
  2631:                 ENDIF
  2632:           
  2633:           C     jgf46.02 New option to read in hurricane locations and generate
  2634:           C     generate hurricane winds from the Holland Wind Model.
  2635:                 IF(ABS(NWS).EQ.8) THEN
  2636:                    CALL HollandGet(WVNX2,WVNY2,PRN2,timeloc)
  2637: +------>           DO I=1,NP
  2638: |                     WindX = WVNX2(I)
  2639: |                     WindY = WVNY2(I)
  2640: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  2641: |       I             WDragCo = WindDrag(WindMag, I)
  2642: |                     IF (LoadDirEffRLen) THEN
  2643: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2644: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2645: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2646: |       I                WDragCo = WindDrag(WindMag, I)
  2647: |                     ENDIF
  2648: |                     IF (LoadCanopyCoef)
  2649: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2650: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2651: |                     IF(NCICE.NE.0) THEN
  2652: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2653: |                     ENDIF
  2654: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDragCo*WindX*WindMag
  2655: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDragCo*WindY*WindMag
  2656: |         C  tcm v49.16 20100617
  2657: |         !            PR2(I)=RampMete2*PRN2(I)
  2658: |                     PRDIFF = RampMete2*(PRN2(I)-PRBCKGRND_MH2O)
  2659: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2660: |                     WVNXOUT(I)=RampMete2*WindX
  2661: |                     WVNYOUT(I)=RampMete2*WindY
  2662: +------            ENDDO
  2663:                 ENDIF
  2664:           
  2665:           !     rjw added nws = 19: asymmetric hurricane winds v2.0
  2666:           
  2667:                 IF(ABS(NWS).EQ.19) THEN
  2668:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22',STATUS='OLD')
  2669:                    CALL NWS19GET(WVNX2,WVNY2,PRN2,TimeLoc)
  2670: +------>           DO I=1,NP
  2671: |                     WindX = WVNX2(I)
  2672: |                     WindY = WVNY2(I)
  2673: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  2674: |       I             WDragCo = WindDrag(WindMag, I)
  2675: |                     IF (LoadDirEffRLen) THEN
  2676: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2677: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2678: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2679: |       I                WDragCo = WindDrag(WindMag, I)
  2680: |                     ENDIF
  2681: |                     IF (LoadCanopyCoef)
  2682: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2683: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2684: |                     IF(NCICE.NE.0) THEN
  2685: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2686: |                     ENDIF
  2687: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDragCo*WindX*WindMag
  2688: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDragCo*WindY*WindMag
  2689: |         C  tcm v49.16 20100617
  2690: |         !            PR2(I)=RampMete2*PRN2(I)
  2691: |                     PRDIFF = RampMete2*(PRN2(I)-PRBCKGRND_MH2O)
  2692: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2693: |                     WVNXOUT(I)=RampMete2*WindX
  2694: |                     WVNYOUT(I)=RampMete2*WindY
  2695: +------            ENDDO
  2696:                 ENDIF
  2697:           
  2698:           !     jie added nws = 20: generalized asymmetric vortex model
  2699:           
  2700:                 IF(ABS(NWS).EQ.20) THEN
  2701:                    OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'fort.22',STATUS='OLD')
  2702:                    CALL NWS20GET(WVNX2,WVNY2,PRN2,TimeLoc)
  2703: +------>           DO I=1,NP
  2704: |                     WindX = WVNX2(I)
  2705: |                     WindY = WVNY2(I)
  2706: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  2707: |       I             WDragCo = WindDrag(WindMag, I)
  2708: |                     IF (LoadDirEffRLen) THEN
  2709: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2710: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2711: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2712: |       I                WDragCo = WindDrag(WindMag, I)
  2713: |                     ENDIF
  2714: |                     IF (LoadCanopyCoef)
  2715: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2716: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2717: |                     IF(NCICE.NE.0) THEN
  2718: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2719: |                     ENDIF
  2720: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDragCo*WindX*WindMag
  2721: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDragCo*WindY*WindMag
  2722: |         C  tcm v49.16 20100617
  2723: |         !            PR2(I)=RampMete2*PRN2(I)
  2724: |                     PRDIFF = RampMete2*(PRN2(I)-PRBCKGRND_MH2O)
  2725: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2726: |                     WVNXOUT(I)=RampMete2*WindX
  2727: |                     WVNYOUT(I)=RampMete2*WindY
  2728: +------            ENDDO
  2729:                 ENDIF
  2730:           C
  2731:           
  2732:           C     Wind velocity (10 m) and atmospheric pressure are read in from a
  2733:           C     sequence of National Weather Service (NWS) Aviation (AVN) model
  2734:           C     output files. Each AVN file is assumed to contain data on a
  2735:           C     Gaussian longitude, latitude grid at a single time. Consecutive
  2736:           C     files in the sequence are separated by N hours in time. Garratt's
  2737:           C     formula is used to compute wind stress from the wind velocity.
  2738:                 IF(NWS.EQ.10) THEN
  2739:                    WTIME1 = TimeLoc
  2740:                    WTIME2 = WTIME1 + WTIMINC
  2741:                    !
  2742:                    ! jgf51.52.21: Fixed NWS10 and cleaned up interface.
  2743:                    call nws10init()
  2744:                    ! read from fort.200 and spatially interpolate onto adcirc mesh
  2745:                    IF (NCICE.eq.10) THEN
  2746:                       ! read from fort.200 and spatially interpolate onto adcirc mesh
  2747:                       call nws10get(wvnx1,wvny1,prn1,cice1)
  2748:                       ! read from first file after fort.200 and spatially interpolate onto adcirc mesh
  2749:                       call nws10get(wvnx2,wvny2,prn2,cice2)
  2750:                    else
  2751:                       ! read from fort.200 and spatially interpolate onto adcirc mesh
  2752:                       call nws10get(wvnx1,wvny1,prn1)
  2753:                       ! read from first file after fort.200 and spatially interpolate onto adcirc mesh
  2754:                       call nws10get(wvnx2,wvny2,prn2)
  2755:                    endif
  2756:                    !
  2757:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2758: +------>           DO I=1,NP
  2759: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2760: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2761: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2762: |       I             WDragCo = WindDrag(WindMag, I)
  2763: |         C     jgf46.00 Add directional wind reduction.
  2764: |                     IF (LoadDirEffRLen) THEN
  2765: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2766: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2767: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2768: |       I                WDragCo = WindDrag(WindMag, I)
  2769: |                     ENDIF
  2770: |                     IF (LoadCanopyCoef)
  2771: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2772: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2773: |                     IF (NCICE.eq.10) then
  2774: |                        Cicenow = 100d0*( CICE1(I) +
  2775: |              &                           WTRatio*( CICE2(I)-CICE1(I) ) )
  2776: |                        WDragCo = WindIceDrag(WDragCo,Cicenow)
  2777: |                     ELSEIF (NCICE.NE.0) THEN
  2778: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2779: |                     ENDIF
  2780: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2781: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2782: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2783: |              &                           -PRBCKGRND_MH2O)
  2784: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2785: +------            END DO
  2786:                 ENDIF
  2787:           
  2788:           C     Wind velocity (10 m) and atmospheric pressure are read in from a
  2789:           C     sequence of stripped down National Weather Service (NWS) ETA 29km
  2790:           C     model output files. Each ETA file is assumed to contain data on an
  2791:           C     E grid for a single day (8 data sets, one every 3 hours, beginning
  2792:           C     @ 03:00 and continuing through 24:00 of the given day). The wind
  2793:           C     data is converted to an east-west, north-south coordinate system
  2794:           C     inside ADCIRC. Garratt's formula is used to compute wind stress
  2795:           C     from the wind velocity.
  2796:                 IF(NWS.EQ.11) THEN
  2797:                    WTIME1=TimeLoc
  2798:                    WTIME2=WTIME1+WTIMINC
  2799:                    NWSEGWI=0
  2800:                    IDSETFLG=0
  2801:                    call allMessage(INFO,
  2802:                &      'The e29 met grid interpolating factors are being computed.')
  2803:                    CALL NWS11GET()        !JUST COMPUTE INTERPOLATING FACTORS
  2804:                    call allMessage(INFO,
  2805:                &      'Finished computing e29 interpolating factors.')
  2806:                    NWSEGWI=0
  2807:                    IDSETFLG=8
  2808:                    CALL NWS11GET()        !NOW COMPUTE HOTSTART WIND FILED
  2809:                    NWSEGWI=1
  2810:                    IDSETFLG=1
  2811: V======>           wvnx1 = wvnx2
  2812: V======>           wvny1 = wvny2
  2813:                    CALL NWS11GET()        !NOW COMPUTE NEXT WIND FIELD
  2814:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2815: +------>           DO I=1,NP
  2816: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2817: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2818: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2819: |       I             WDragCo = WindDrag(WindMag, I)
  2820: |         C     jgf46.00 Add directional wind reduction.
  2821: |                     IF (LoadDirEffRLen) THEN
  2822: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2823: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2824: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2825: |       I                WDragCo = WindDrag(WindMag, I)
  2826: |                     ENDIF
  2827: |                     IF (LoadCanopyCoef)
  2828: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2829: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2830: |                     IF(NCICE.NE.0) THEN
  2831: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  2832: |                     ENDIF
  2833: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2834: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2835: |         C  tcm v49.16 20100617
  2836: |         !            PR2(I)=RampMete2*(PRN1(I)+WTRATIO*(PRN2(I)-PRN1(I)))
  2837: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2838: |              &                           -PRBCKGRND_MH2O)
  2839: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2840: +------            END DO
  2841:                 ENDIF
  2842:           C
  2843:           C.....sb46.28sb01 NWS=12,-12 were added to deal with raw OWI files.  09/xx/2006
  2844:                 ! jgf: Combined NWS=12 and NWS=-12 and added abs(NWS)=29 and abs(NWS)=30
  2845:                 IF((abs(NWS).eq.12).or.(abs(NWS).eq.29).or.(abs(NWS).eq.30)) THEN
  2846:                    WTIME1 = TimeLoc      ! nws=-12, wind data relative to hot start time
  2847:                    if (nws.gt.0) then
  2848:                       WTIME1 = STATIM*86400.D0 ! wind data relative to cold start time
  2849:                    endif
  2850:                    WTIME2 = WTIME1 + WTIMINC
  2851:                    CALL NWS12INIT(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)  ! This just initializes some variables and might set WVNX1,etc... if skipping ahead.
  2852:                    CALL NWS12GET(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)  !TCM v49.02 Added read for rec. 1
  2853:                    CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND)
  2854:                     ! fast forward if wind data are relative to cold start time
  2855:                    if (nws.gt.0) then
  2856: +------>              DO IT=1,ITHS
  2857: |                        TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  2858: |                        IF(TIMEIT.GT.WTIME2) THEN
  2859: |                           WTIME1=WTIME2
  2860: |                           WTIME2=WTIME2+WTIMINC
  2861: |V----->                    DO I=1,NP
  2862: ||                             WVNX1(I)=WVNX2(I)
  2863: ||                             WVNY1(I)=WVNY2(I)
  2864: ||                             PRN1(I)=PRN2(I)
  2865: |V-----                     END DO
  2866: |                           CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND)
  2867: |                        ENDIF
  2868: +------               END DO
  2869:                    endif
  2870:                    WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2871: +------>           DO I=1,NP
  2872: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2873: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2874: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2875: |       I             WDragCo = WindDrag(WindMag, I)
  2876: |                     IF (LoadDirEffRLen) THEN
  2877: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2878: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2879: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2880: |       I                WDragCo = WindDrag(WindMag, I)
  2881: |                     ENDIF
  2882: |                     IF (LoadCanopyCoef)
  2883: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2884: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2885: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  2886: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  2887: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2888: |              &                          -PRBCKGRND_MH2O)
  2889: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2890: |                     WVNXOUT(I)=RampMete2*WINDX
  2891: |                     WVNYOUT(I)=RampMete2*WINDY
  2892: +------            END DO
  2893:                 ENDIF
  2894:           
  2895:           #ifdef ADCNETCDF
  2896:           Casey 180318: Added for NWS=13, ARC modified 190108
  2897:                 IF(ABS(NWS).EQ.13)THEN
  2898:                    WTIME1 = TimeLoc
  2899:                    WTIME2 = WTIME1 + WTIMINC
  2900:                    WTIME2I = WTIME2
  2901:                    WTIME1I = WTIME1
  2902:                   CALL NWS13INIT(TIMELOC,W)
  2903:                   CALL NWS13GET(WTIME1,WVNX1,WVNY1,PRN1,
  2904:                &      WTIME2,EyeLon,EyeLat,FoundEye,W)
  2905:                   CALL NWS13GET(WTIME2,WVNX2,WVNY2,PRN2,
  2906:                &      WTIME2,EyeLon,EyeLat,FoundEye,W)
  2907:                   WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  2908: +------>          DO I=1,NP
  2909: |                   WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  2910: |                   WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  2911: |                   WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  2912: |       I           WDragCo = WindDrag(WindMag, I)
  2913: |                   IF(LoadDirEffRLen)THEN
  2914: |       I              CALL ApplyDirectionalWindReduction(I, WDragCo,
  2915: |              &         WindMag, DP(I), ETA2(I), WindX, WindY)
  2916: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  2917: |       I             WDragCo = WindDrag(WindMag, I)
  2918: |                   ENDIF
  2919: |                   IF(LoadCanopyCoef)THEN
  2920: |       I             CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2921: |                   ENDIF
  2922: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  2923: |                   WSX2(I) = RampMete2*0.001293d0*WDRAGCO*WINDX*WINDMAG
  2924: |                   WSY2(I) = RampMete2*0.001293d0*WDRAGCO*WINDY*WINDMAG
  2925: |                   PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  2926: |              &        -PRBCKGRND_MH2O)
  2927: |                   PR2(I) = PRBCKGRND_MH2O + PRDIFF
  2928: |                   WVNXOUT(I)=RampMete2*WINDX
  2929: |                   WVNYOUT(I)=RampMete2*WINDY
  2930: +------            ENDDO
  2931:                 ENDIF
  2932:           #endif
  2933:           
  2934:           C
  2935:           C     jgf49.1001 Added NWS29, asymmetric vortex winds (NWS19)
  2936:           C     embedded in an OWI basin scale gridded met field (NWS12)
  2937:           C     from NAM data
  2938:                 ! jgf: Added NWS30 (GAHM+OWI)
  2939:                 IF ((abs(NWS).EQ.29).or.(abs(NWS).eq.30)) THEN
  2940:                    ! Now blend in the vortex winds into the background OWI wind field.
  2941:                    ALLOCATE(vortexWVNX2(NP),vortexWVNY2(NP),vortexPRN2(NP))
  2942:                    if (abs(nws).eq.29) then
  2943:                       OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'NWS_19_fort.22',
  2944:                &           STATUS='OLD')
  2945:                       CALL NWS19GET(vortexWVNX2,vortexWVNY2,vortexPRN2,TimeLoc)
  2946:                    endif
  2947:                    if (abs(nws).eq.30) then
  2948:                       OPEN(22,FILE=TRIM(GBLINPUTDIR)//'/'//'NWS_20_fort.22',
  2949:                &           STATUS='OLD')
  2950:                       CALL NWS20GET(vortexWVNX2,vortexWVNY2,vortexPRN2,TimeLoc)
  2951:                    endif
  2952: +------>           DO I=1,NP
  2953: |                     WindX = vortexWVNX2(I)
  2954: |                     WindY = vortexWVNY2(I)
  2955: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  2956: |       I             WDragCo = WindDrag(WindMag, I)
  2957: |                     IF (LoadDirEffRLen) THEN
  2958: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  2959: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  2960: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  2961: |       I                WDragCo = WindDrag(WindMag, I)
  2962: |                     ENDIF
  2963: |                     IF (LoadCanopyCoef)
  2964: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  2965: |       I             CALL getBlendFactor(I, bf)
  2966: |                     WSX2(I) = bf*RampMete2*airwaterdensityrat*WDragCo*WindX*WindMag
  2967: |              &               +(1.0d0-bf)*WSX2(I)
  2968: |                     WSY2(I) = bf*RampMete2*airwaterdensityrat*WDragCo*WindY*WindMag
  2969: |              &               +(1.0d0-bf)*WSY2(I)
  2970: |                     vortexPRDIFF = RampMete2*(vortexPRN2(I)-PRBCKGRND_MH2O)
  2971: |                     vortexPRN2(I) = PRBCKGRND_MH2O + vortexPRDIFF
  2972: |                     ! blend vortex into background
  2973: |                     PR2(I) = bf*vortexPRN2(I)+(1.0d0-bf)*PR2(I)
  2974: |                     WVNXOUT(I)=bf*RampMete2*WindX+(1.0d0-bf)*WVNXOUT(I)
  2975: |                     WVNYOUT(I)=bf*RampMete2*WindY+(1.0d0-bf)*WVNYOUT(I)
  2976: +------            ENDDO
  2977:                 ENDIF
  2978:                 !
  2979:           #ifdef DATETIME
  2980:           #if defined(GRIB2API) || defined(ADCNETCDF)
  2981:           !     WJP Feb27-2019: Added for NWS=14 for grib2
  2982:                 IF (ABS(NWS).eq.14) THEN
  2983:                    ! TimeLoc should be rounded down to nearest WTIMINC
  2984:                    TimeLoc_NM = nint(TimeLoc/60d0) ! first round to nearest minute
  2985:                    WTIME1 = WTIMINC*floor(TimeLoc_NM*60d0/WTIMINC)
  2986:                    WTIME2 = WTIME1 + WTIMINC
  2987:                    WTRATIO = (TimeLoc-WTIME1)/WTIMINC
  2988:                    IF(NCICE.NE.0)THEN
  2989:                        CTRATIO = (TimeLoc-CICE_TIME1)/CICE_TIMINC
  2990:                    ENDIF
  2991:                    ! Set datetime and make/check the grib header
  2992:                    CALL NWS14INIT(NWS)
  2993:                    ! Initialising winds (pressure is already initialized)
  2994:                    ! Get the first wind snap
  2995:                    if (NCICE.eq.14) then
  2996:                       CICE_TIME1 = CICE_TIMINC*floor(TimeLoc_NM*60d0/CICE_TIMINC)
  2997:                       CICE_TIME2 = CICE_TIME1 + CICE_TIMINC
  2998:                       CALL NWS14GET(WVNX1,WVNY1,PRN1,CICE1)
  2999:                    else
  3000:                       CALL NWS14GET(WVNX1,WVNY1,PRN1)
  3001:                    endif
  3002:                    ! Get owi winds (should only overwrite where they exist)
  3003:                    if (NWS.eq.-14) then
  3004:                       CALL NWS12INIT(WVNX1,WVNY1,PRN1,NP,PRBCKGRND)
  3005:                       CALL NWS12GET(WVNX1,WVNY1,PRN1,NP,PRBCKGRND,HasData)
  3006:                       WTIME1_12 = WTIME1
  3007:                       WTIME2_12 = WTIME1_12 + WTIMINC_12
  3008:                       WTRATIO_12 = (TimeLoc-WTIME1_12)/WTIMINC_12
  3009:                       WTRATIO_14 = WTRATIO
  3010:                    endif
  3011:                    ! Get the second wind snap
  3012:                    if (NCICE.eq.14) then
  3013:                       CALL NWS14GET(WVNX2,WVNY2,PRN2,CICE2)
  3014:                    else
  3015:                       CALL NWS14GET(WVNX2,WVNY2,PRN2)
  3016:                    endif
  3017:                    ! Get owi winds (should only overwrite where they exist)
  3018:                    if (NWS.eq.-14) then
  3019:                       CALL NWS12GET(WVNX2,WVNY2,PRN2,NP,PRBCKGRND,HasData)
  3020:                    endif
  3021: +------>           DO I=1,NP
  3022: |                     IF (NWS.eq.-14) then
  3023: |                        WTRATIO = WTRATIO_14
  3024: |                        IF (HasData(I)) WTRATIO = WTRATIO_12
  3025: |                     ENDIF
  3026: |                     WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  3027: |                     WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  3028: |                     WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  3029: |                     !Casey 110518: Enable Mark Powell's sector-based wind drag.
  3030: |       I             WDragCo = WindDrag(WindMag, I)
  3031: |                     IF (LoadDirEffRLen) THEN
  3032: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  3033: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  3034: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  3035: |                        !Casey 110518: Enable Mark Powell's sector-based wind drag.
  3036: |       I                WDragCo = WindDrag(WindMag,I)
  3037: |                     ENDIF
  3038: |                     IF (LoadCanopyCoef) then
  3039: |       I                CALL ApplyCanopyCoefficient(I,WindX,WindY)
  3040: |                     ENDIF
  3041: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  3042: |                     IF(NCICE.NE.0) THEN
  3043: |                        if (NCICE.eq.14) then
  3044: |                           Cicenow = 100d0*(CICE1(I) +
  3045: |              &                             CTRATIO*(CICE2(I)-CICE1(I)))
  3046: |                           WDragCo = WindIceDrag(WDragCo,Cicenow)
  3047: |                        else
  3048: |                           WDragCo = WindIceDrag(WDragCo,ciceout(i))
  3049: |                        endif
  3050: |                     ENDIF
  3051: |                     ! WJP: added varying sea surface density
  3052: |                     if (abs(IDEN).ge.5) then
  3053: |                        if (SigTS(I) < -1d2) then
  3054: |                           airwaterdensityrat = rhoAir/RhoWat0
  3055: |                        else
  3056: |                           airwaterdensityrat = rhoAir/(SigTS(I) + RhoWat0)
  3057: |                        endif
  3058: |                     endif
  3059: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  3060: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  3061: |                     PRDIFF  = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  3062: |              &                          -PRBCKGRND_MH2O)
  3063: |         #ifdef NOIVB
  3064: |                     PR2(I)  = PRBCKGRND_MH2O
  3065: |         #else
  3066: |                     PR2(I)  = PRBCKGRND_MH2O + PRDIFF
  3067: |         #endif
  3068: |                     WVNXOUT(I) = RampMete2*WINDX
  3069: |                     WVNYOUT(I) = RampMete2*WINDY
  3070: |         
  3071: +------             END DO
  3072:                 ENDIF
  3073:           #endif
  3074:           #endif
  3075:           #ifdef ADCNETCDF
  3076:           Casey 180318: Added for NWS=13
  3077:                 IF(ABS(NWS).EQ.13)THEN
  3078:                   WTIME1 = TIMELOC
  3079:                   WTIME2 = TIMELOC
  3080:                   CALL NWS13INIT(TIMELOC,W)
  3081:                   CALL NWS13GET(TIMELOC,WVNX2,WVNY2,PRN2,
  3082:                &         WTIME2,EyeLon,EyeLat,FoundEye,W)
  3083:           !       IF(TRIM(DragLawString).EQ."Powell".OR.
  3084:           !    &      TRIM(DragLawString).EQ."POWELL".OR.
  3085:           !    &      TRIM(DragLawString).EQ."powell")THEN
  3086:           !         CALL findStormCenter(eyeLatR,eyeLonR,foundEye)
  3087:           !       ENDIF
  3088:                   WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  3089: +------>          DO I=1,NP
  3090: |                   WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  3091: |                   WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  3092: |                   WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  3093: |       I           WDragCo = WindDrag(WindMag, I)
  3094: |                   IF(LoadDirEffRLen)THEN
  3095: |       I             CALL ApplyDirectionalWindReduction(I, WDragCo,
  3096: |              &          WindMag, DP(I), ETA2(I), WindX, WindY)
  3097: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  3098: |       I             WDragCo = WindDrag(WindMag, I)
  3099: |                   ENDIF
  3100: |                   IF(LoadCanopyCoef)THEN
  3101: |       I             CALL ApplyCanopyCoefficient(I,WindX,WindY)
  3102: |                   ENDIF
  3103: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  3104: |                   WSX2(I) = RampMete2*0.001293d0*WDRAGCO*WINDX*WINDMAG
  3105: |                   WSY2(I) = RampMete2*0.001293d0*WDRAGCO*WINDY*WINDMAG
  3106: |                   PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  3107: |              &        -PRBCKGRND_MH2O)
  3108: |                   PR2(I) = PRBCKGRND_MH2O + PRDIFF
  3109: |                   WVNXOUT(I)=RampMete2*WINDX
  3110: |                   WVNYOUT(I)=RampMete2*WINDY
  3111: +------            ENDDO
  3112:                 ENDIF
  3113:           #endif
  3114:                 !
  3115:                 ! jgf50.38.05: Added NWS=15 for reading HWind data
  3116:                  IF(ABS(NWS).EQ.15) THEN
  3117:                     CALL NWS15INIT(timeloc)
  3118:                     CALL NWS15GET(WVNX2,WVNY2,PRN2,timeloc)
  3119: +------>            DO I=1,NP
  3120: |       I              WDragCo = WindDrag(windSpeeds(i), i)
  3121: |                      windx = wvnx2(i)
  3122: |                      windy = wvny2(i)
  3123: |                      IF (LoadDirEffRLen) THEN
  3124: |       I                 CALL ApplyDirectionalWindReduction(i, WDragCo,
  3125: |              &              windSpeeds(i), DP(I), ETA2(I),
  3126: |              &              windx, windy)
  3127: |                         WindMag = SQRT(windx**2+windy**2)
  3128: |       I                 WDragCo = WindDrag(WindMag, i)
  3129: |                      ENDIF
  3130: |                     IF (LoadCanopyCoef)
  3131: |       I      &         CALL ApplyCanopyCoefficient(i,windx,windy)
  3132: |                     IF(NCICE.NE.0) THEN
  3133: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  3134: |                     ENDIF
  3135: |                      WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  3136: |                      WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  3137: |                      PR2(I) = PRBCKGRND_MH2O + RampMete2*(PRN2(I)-PRBCKGRND_MH2O)
  3138: |                      WVNXOUT(I)=RampMete2*WINDX
  3139: |                      WVNYOUT(I)=RampMete2*WINDY
  3140: +------             END DO
  3141:                  ENDIF
  3142:           C
  3143:           C.....tcm v51.06.02 NWS=16,-16 were added to deal with GFDL Met files.
  3144:                 IF(NWS.EQ.16) THEN
  3145:                     WTIME1 = STATIM*86400.D0
  3146:                     WTIME2 = WTIME1 + WTIMINC
  3147:                     CALL INIT_GFDL(wtime1)  !this will read in the two time series
  3148: +------>            DO IT=1,ITHS
  3149: |                      TIMEIT=IT*DTDPHS + STATIM*86400.D0 ! kmd48.33bc - changed the DTDP to DTDPHS
  3150: |                      IF(TIMEIT.GT.WTIME2) THEN
  3151: |                         WTIME1=WTIME2
  3152: |                         WTIME2=WTIME2+WTIMINC
  3153: |V----->                  DO I=1,NP
  3154: ||                           WVNX1(I)=WVNX2(I)
  3155: ||                           WVNY1(I)=WVNY2(I)
  3156: ||                           PRN1(I)=PRN2(I)
  3157: |V-----                    END DO
  3158: |                          CALL NWS16GET(wtime2,WVNX2,WVNY2,PRN2)
  3159: |                       ENDIF
  3160: +------             END DO
  3161:                     WTRATIO=(TimeLoc-WTIME1)/WTIMINC
  3162: +------>            DO I=1,NP
  3163: |                      WINDX = WVNX1(I) + WTRATIO*(WVNX2(I)-WVNX1(I))
  3164: |                      WINDY = WVNY1(I) + WTRATIO*(WVNY2(I)-WVNY1(I))
  3165: |                      WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  3166: |       I              WDragCo = WindDrag(WindMag, I)
  3167: |                      IF (LoadDirEffRLen) THEN
  3168: |       I                 CALL ApplyDirectionalWindReduction(I, WDragCo,
  3169: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  3170: |                         WindMag = SQRT(WindX*WindX+WindY*WindY)
  3171: |       I                 WDragCo = WindDrag(WindMag, I)
  3172: |                      ENDIF
  3173: |                     IF (LoadCanopyCoef)
  3174: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  3175: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  3176: |                     IF(NCICE.NE.0) THEN
  3177: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  3178: |                     ENDIF
  3179: |                      WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  3180: |                      WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  3181: |                      PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  3182: |              &                           -PRBCKGRND_MH2O)
  3183: |                      PR2(I) = PRBCKGRND_MH2O + PRDIFF
  3184: |                      WVNXOUT(I)=RampMete2*WINDX
  3185: |                      WVNYOUT(I)=RampMete2*WINDY
  3186: +------             END DO
  3187:                  ENDIF
  3188:           C
  3189:                  IF(NWS.EQ.-16) THEN
  3190:                     WTIME1 = TimeLoc
  3191:                     WTIME2 = WTIME1 + WTIMINC
  3192:                     call INIT_GFDL(wtime1)  !this reads in the first two time series values
  3193: +------>            DO I=1,NP
  3194: |                      WINDX = WVNX1(I)
  3195: |                      WINDY = WVNY1(I)
  3196: |                      WINDMAG = SQRT(WINDX*WINDX+WINDY*WINDY)
  3197: |       I              WDragCo = WindDrag(WindMag, I)
  3198: |                      IF (LoadDirEffRLen) THEN
  3199: |       I                 CALL ApplyDirectionalWindReduction(I, WDragCo,
  3200: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  3201: |                         WindMag = SQRT(WindX*WindX+WindY*WindY)
  3202: |       I                 WDragCo = WindDrag(WindMag, I)
  3203: |                      ENDIF
  3204: |                     IF (LoadCanopyCoef)
  3205: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  3206: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  3207: |                     IF(NCICE.NE.0) THEN
  3208: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  3209: |                     ENDIF
  3210: |                      WSX2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDX*WINDMAG
  3211: |                      WSY2(I) = RampMete2*airwaterdensityrat*WDRAGCO*WINDY*WINDMAG
  3212: |                      PRDIFF = RampMete2*(PRN1(I)-PRBCKGRND_MH2O)
  3213: |                      PR2(I) = PRBCKGRND_MH2O + PRDIFF
  3214: |                      WVNXOUT(I)=RampMete2*WINDX  ! tcm 20100618 v49.16 changed RampMete to RampMete2
  3215: |                      WVNYOUT(I)=RampMete2*WINDY  ! tcm 20100618 v49.16 changed RampMete to RampMete2
  3216: +------             END DO
  3217:                  ENDIF
  3218:           
  3219:           !PV BEG:: NWS=17, there is no NWS=-17 option
  3220:           !... v55.xx PV -- NWS=17 for NUOPC coupling
  3221:                 IF(ABS(NWS).EQ.17) THEN ! using ABS(NWS) to make sure that this block is always executed for NWS=17/-17
  3222:                    WTIME1 = TimeLoc
  3223:                    WTIME2 = WTIME1 + WTIMINC
  3224: +------>           DO IT=1,ITHS
  3225: |                     TIMEIT=IT*DTDPHS + STATIM*86400.D0
  3226: |                     IF(TIMEIT.GT.WTIME2) THEN
  3227: |                        WTIME1=WTIME2
  3228: |                        WTIME2=WTIME2+WTIMINC
  3229: |V----->                 DO I=1,NP
  3230: ||                          WVNX1(I)=WVNX2(I)
  3231: ||                          WVNY1(I)=WVNY2(I)
  3232: ||                          PRN1(I)=PRN2(I)
  3233: |V-----                   END DO
  3234: |                      ENDIF
  3235: +------            END DO
  3236:           
  3237:                    WTRatio=(TimeLoc-WTIME1)/WTIMINC
  3238:           
  3239:                    if (WTRatio .GT. 1.0) then
  3240:                        WTRatio = 1.0
  3241:                        print *, '[Warning:] WTRatio is .GE. 1.0 and Set to 1.0'
  3242:                    endif
  3243:           
  3244: +------>           DO I=1,NP
  3245: |                     WindX = WVNX1(I) + WTRatio*(WVNX2(I)-WVNX1(I))
  3246: |                     WindY = WVNY1(I) + WTRatio*(WVNY2(I)-WVNY1(I))
  3247: |                     WindMag = SQRT(WindX*WindX+WindY*WindY)
  3248: |       I             WDragCo = WindDrag(WindMag, I)
  3249: |         
  3250: |         C     jgf46.00 Add directional wind reduction.
  3251: |                     IF (LoadDirEffRLen) THEN
  3252: |       I                CALL ApplyDirectionalWindReduction(I, WDragCo,
  3253: |              &              WindMag, DP(I), ETA2(I), WindX, WindY)
  3254: |                        WindMag = SQRT(WindX*WindX+WindY*WindY)
  3255: |       I                WDragCo = WindDrag(WindMag, I)
  3256: |                     ENDIF
  3257: |                     IF (LoadCanopyCoef)
  3258: |       I      &         CALL ApplyCanopyCoefficient(I,WindX,WindY)
  3259: |         C    TCM V49.64.01 ADDED ICE EFFECTS ON WIND DRAG COEFF
  3260: |                    IF(NCICE.NE.0) THEN
  3261: |                        WDragCo = WindIceDrag(WDragCo,ciceout(i))
  3262: |                     ENDIF
  3263: |                     WSX2(I) = RampMete2*airwaterdensityrat*WDragCo*WindX*WindMag
  3264: |                     WSY2(I) = RampMete2*airwaterdensityrat*WDragCo*WindY*WindMag
  3265: |         C  tcm v49.16 20100617
  3266: |                     PRDIFF = RampMete2*((PRN1(I)+WTRatio*(PRN2(I)-PRN1(I)))
  3267: |              &                           -PRBCKGRND_MH2O)
  3268: |                     PR2(I) = PRBCKGRND_MH2O + PRDIFF
  3269: |                     WVNXOUT(I)=RampMete2*WindX
  3270: |                     WVNYOUT(I)=RampMete2*WindY
  3271: +------            END DO
  3272:                 ENDIF
  3273:           !PV END:: NWS=17
  3274:           
  3275:                  !
  3276:                  ! jgf52.14: Implementing Casey's fix for uninitialized
  3277:                  ! wvnx1 and wvny1 arrays; they are not used/needed/initialized
  3278:                  ! by the parametric vortex meteorological models but are used in
  3279:                  ! the padcswan_init() subroutine to initialize the SWAN wind
  3280:                  ! velocities. Failure to initialize them causes NaNs in the
  3281:                  ! solution.
  3282:                  if ( (abs(nws).eq.8).or.(abs(nws).eq.19).or.(abs(nws).eq.20)) then
  3283: V======>            WVNX1 = WVNX2
  3284: V======>            WVNY1 = WVNY2
  3285:                  endif
  3286:           
  3287:           C      DW/WJP: rotate wind stresses if coordinate transform
  3288:                  IF ( IFSPROTS .eq. 1 ) THEN
  3289: V------>            UVECTMP(1:NP) = WSX2(1:NP);
  3290: V------             VVECTMP(1:NP) = WSY2(1:NP);
  3291:                     CALL DRVMAP2DSPVEC( WSX2, WSY2,
  3292:                &              UVECTMP, VVECTMP, NP, FWD = .TRUE. ) ;
  3293:                  ENDIF
  3294:            
  3295:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3296:                  call allMessage(DEBUG,"Return.")
  3297:           #endif
  3298:                  call unsetMessageSource()
  3299:            
  3300:           C--------------------END MET FORCING-----------------------------------
  3301:                 end subroutine hotstartMeteorologicalForcing


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOTSTARTMETEOROLOGICALFORCING
INLINE LIST

  ROOT: WIND::HOTSTARTMETEOROLOGICALFORCING (wind.F:2132)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:2172)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2295)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2297)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2312)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2320)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2323)
  -> INLINE: WIND::WINDDRAG (wind.F:2326)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2329)
  -> INLINE: WIND::NWS4GET (wind.F:2348)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::NWS4GET (wind.F:2351)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::NWS4GET (wind.F:2362)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2370)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2373)
  -> INLINE: WIND::WINDDRAG (wind.F:2376)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2379)
  -> INLINE: WIND::NWS4GET (wind.F:2398)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::NWS4GET (wind.F:2401)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
      *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2406)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2409)
  -> INLINE: WIND::WINDDRAG (wind.F:2412)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2415)
  -> INLINE: WIND::WINDDRAG (wind.F:2457)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2460)
  -> INLINE: WIND::WINDDRAG (wind.F:2463)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2466)
  -> INLINE: WIND::WINDDRAG (wind.F:2495)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2498)
  -> INLINE: WIND::WINDDRAG (wind.F:2501)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2504)
  -> INLINE: WIND::WINDDRAG (wind.F:2550)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2553)
  -> INLINE: WIND::WINDDRAG (wind.F:2556)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2559)
  -> INLINE: WIND::WINDDRAG (wind.F:2641)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2643)
  -> INLINE: WIND::WINDDRAG (wind.F:2646)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2649)
  -> INLINE: WIND::WINDDRAG (wind.F:2674)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2676)
  -> INLINE: WIND::WINDDRAG (wind.F:2679)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2682)
  -> INLINE: WIND::WINDDRAG (wind.F:2707)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2709)
  -> INLINE: WIND::WINDDRAG (wind.F:2712)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2715)
  -> NOINLINE: WIND::NWS10INIT (wind.F:2743)
     *** Nesting level too deep for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:2762)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2765)
  -> INLINE: WIND::WINDDRAG (wind.F:2768)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2771)
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2801)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:2804)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2819)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2822)
  -> INLINE: WIND::WINDDRAG (wind.F:2825)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2828)
  -> NOINLINE: OWIWIND::NWS12INIT (wind.F:2851)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:2852)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:2853)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:2866)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2875)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2877)
  -> INLINE: WIND::WINDDRAG (wind.F:2880)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2883)
  -> NOINLINE: OWIWIND_NETCDF::NWS13INIT (wind.F:2902)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:2903)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:2905)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:2912)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2914)
  -> INLINE: WIND::WINDDRAG (wind.F:2917)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2920)
  -> INLINE: WIND::WINDDRAG (wind.F:2956)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:2958)
  -> INLINE: WIND::WINDDRAG (wind.F:2961)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:2964)
  -> INLINE: WIND::GETBLENDFACTOR (wind.F:2965)
   -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:821)
      *** Source for routine not found.
  -> NOINLINE: WIND::NWS14INIT (wind.F:2992)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: WIND::NWS14GET (wind.F:2998)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: OWIWIND::NWS12INIT (wind.F:3004)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:3005)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND::NWS12GET (wind.F:3019)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:3030)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3032)
  -> INLINE: WIND::WINDDRAG (wind.F:3036)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3039)
  -> NOINLINE: OWIWIND_NETCDF::NWS13INIT (wind.F:3080)
     *** Source for routine not found.
  -> NOINLINE: OWIWIND_NETCDF::NWS13GET (wind.F:3081)
     *** Source for routine not found.
  -> INLINE: WIND::WINDDRAG (wind.F:3093)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3095)
  -> INLINE: WIND::WINDDRAG (wind.F:3098)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3101)
  -> NOINLINE: WIND::NWS15INIT (wind.F:3117)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: WIND::NWS15GET (wind.F:3118)
     *** Expansion routine is too big for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:3120)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3124)
  -> INLINE: WIND::WINDDRAG (wind.F:3128)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3131)
  -> NOINLINE: WIND::INIT_GFDL (wind.F:3147)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: WIND::NWS16GET (wind.F:3158)
     *** Nesting level too deep for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:3166)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3168)
  -> INLINE: WIND::WINDDRAG (wind.F:3171)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3174)
  -> NOINLINE: WIND::INIT_GFDL (wind.F:3192)
     *** Expansion routine is too big for automatic expansion.
  -> INLINE: WIND::WINDDRAG (wind.F:3197)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3199)
  -> INLINE: WIND::WINDDRAG (wind.F:3202)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3205)
  -> INLINE: WIND::WINDDRAG (wind.F:3248)
  -> INLINE: NODALATTRIBUTES::APPLYDIRECTIONALWINDREDUCTION (wind.F:3252)
  -> INLINE: WIND::WINDDRAG (wind.F:3255)
  -> INLINE: NODALATTRIBUTES::APPLYCANOPYCOEFFICIENT (wind.F:3258)
  -> NOINLINE: MESH::DRVMAP2DSPVEC (wind.F:3291)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3298)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOTSTARTMETEOROLOGICALFORCING
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:2183)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2183)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2183)
  LOOP END

  LOOP BEGIN: (wind.F:2184)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2184)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2184)
  LOOP END

  LOOP BEGIN: (wind.F:2185)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2185)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2185)
  LOOP END

  LOOP BEGIN: (wind.F:2186)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2186)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2186)
  LOOP END

  LOOP BEGIN: (wind.F:2187)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2187)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2187)
  LOOP END

  LOOP BEGIN: (wind.F:2188)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2188)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2188)
  LOOP END

  LOOP BEGIN: (wind.F:2189)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2189)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2189)
  LOOP END

  LOOP BEGIN: (wind.F:2190)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2190)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2190)
  LOOP END

  LOOP BEGIN: (wind.F:2191)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2191)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:2191)
  LOOP END

  LOOP BEGIN: (wind.F:2196)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2196)
  LOOP END

  LOOP BEGIN: (wind.F:2197)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:2198)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:2198)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2202)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2202)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:2202)
  LOOP END

  LOOP BEGIN: (wind.F:2217)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2217)
  LOOP END

  LOOP BEGIN: (wind.F:2220)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2220)
  LOOP END

  LOOP BEGIN: (wind.F:2221)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2221)
  LOOP END

  LOOP BEGIN: (wind.F:2222)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:2227)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:2227)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2236)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2236)
    *** The number of VLOAD, VSTORE. :  6,  3. (wind.F:2236)
  LOOP END

  LOOP BEGIN: (wind.F:2250)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2250)
  LOOP END

  LOOP BEGIN: (wind.F:2253)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2253)
  LOOP END

  LOOP BEGIN: (wind.F:2254)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2254)
  LOOP END

  LOOP BEGIN: (wind.F:2255)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2255)
    *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:2255)
  LOOP END

  LOOP BEGIN: (wind.F:2273)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2273)
  LOOP END

  LOOP BEGIN: (wind.F:2274)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : WIND::NWS3GET (wind.F:2274)
    *** Unvectorizable loop structure. (wind.F:2274)

    LOOP BEGIN: (wind.F:2278)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:2278)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:2278)
    LOOP END

    LOOP BEGIN: (wind.F:2286)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:2286)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:2286)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2300)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : WIND::NWS3GET (wind.F:2300)
    *** I/O statement obstructs vectorization. (wind.F:2300)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:2300)

    LOOP BEGIN: (wind.F:2305)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:2305)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:2305)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2316)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2316)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2316)
  LOOP END

  LOOP BEGIN: (wind.F:2345)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2345)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:2349)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2349)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2349)
  LOOP END

  LOOP BEGIN: (wind.F:2350)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2350)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2350)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:2352)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:2357)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:2357)
      *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:2357)
    LOOP END

    LOOP BEGIN: (wind.F:3447)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
      *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
    LOOP END

    LOOP BEGIN: (wind.F:3452)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3452)
    LOOP END

    LOOP BEGIN: (wind.F:3456)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3456)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2366)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2366)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2366)
  LOOP END

  LOOP BEGIN: (wind.F:2395)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2395)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:2399)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2399)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2399)
  LOOP END

  LOOP BEGIN: (wind.F:2400)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2400)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2400)
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END

  LOOP BEGIN: (wind.F:2402)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2402)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2402)
  LOOP END

  LOOP BEGIN: (wind.F:2434)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2434)
  LOOP END

  LOOP BEGIN: (wind.F:2437)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2437)
  LOOP END

  LOOP BEGIN: (wind.F:2438)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2438)
  LOOP END

  LOOP BEGIN: (wind.F:2439)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:2444)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:2444)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2453)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2453)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2453)
  LOOP END

  LOOP BEGIN: (wind.F:2485)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2485)
  LOOP END

  LOOP BEGIN: (wind.F:2488)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2488)
  LOOP END

  LOOP BEGIN: (wind.F:2489)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:2489)
  LOOP END

  LOOP BEGIN: (wind.F:2491)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2491)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2491)
  LOOP END

  LOOP BEGIN: (wind.F:2531)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2531)
  LOOP END

  LOOP BEGIN: (wind.F:2540)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2540)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2540)
  LOOP END

  LOOP BEGIN: (wind.F:2541)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2541)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2541)
  LOOP END

  LOOP BEGIN: (wind.F:2546)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2546)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2546)
  LOOP END

  LOOP BEGIN: (wind.F:2582)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2582)
  LOOP END

  LOOP BEGIN: (wind.F:2585)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2585)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2585)
  LOOP END

  LOOP BEGIN: (wind.F:2586)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2586)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2586)
  LOOP END

  LOOP BEGIN: (wind.F:2591)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2591)
    *** The number of VLOAD, VSTORE. :  6,  5. (wind.F:2591)
  LOOP END

  LOOP BEGIN: (wind.F:2607)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2607)
  LOOP END

  LOOP BEGIN: (wind.F:2610)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2610)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2610)
  LOOP END

  LOOP BEGIN: (wind.F:2611)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2611)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2611)
  LOOP END

  LOOP BEGIN: (wind.F:2618)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2618)
    *** The number of VLOAD, VSTORE. :  6,  5. (wind.F:2618)
  LOOP END

  LOOP BEGIN: (wind.F:2637)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2637)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2637)
  LOOP END

  LOOP BEGIN: (wind.F:2668)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2668)
  LOOP END

  LOOP BEGIN: (wind.F:2670)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2670)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2670)
  LOOP END

  LOOP BEGIN: (wind.F:2701)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2701)
  LOOP END

  LOOP BEGIN: (wind.F:2703)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2703)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2703)
  LOOP END

  LOOP BEGIN: (wind.F:2758)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2758)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2758)
  LOOP END

  LOOP BEGIN: (wind.F:2811)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2811)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2811)
  LOOP END

  LOOP BEGIN: (wind.F:2812)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:2812)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:2812)
  LOOP END

  LOOP BEGIN: (wind.F:2815)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2815)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:2815)
  LOOP END

  LOOP BEGIN: (wind.F:2856)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : OWIWIND::NWS12GET (wind.F:2856)

    LOOP BEGIN: (wind.F:2861)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:2861)
      *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:2861)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2871)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2871)
  LOOP END

  LOOP BEGIN: (wind.F:2908)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2908)
  LOOP END

  LOOP BEGIN: (wind.F:2943)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2943)
  LOOP END

  LOOP BEGIN: (wind.F:2948)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:2948)
  LOOP END

  LOOP BEGIN: (wind.F:2952)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:2952)
    *** Vectorization obstructive procedure reference. : GLOBAL::SPHERICALDISTANCE (wind.F:2952)
  LOOP END

  LOOP BEGIN: (wind.F:3021)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3021)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:3021)
  LOOP END

  LOOP BEGIN: (wind.F:3089)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3089)
  LOOP END

  LOOP BEGIN: (wind.F:3119)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3119)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:3119)
  LOOP END

  LOOP BEGIN: (wind.F:3148)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : WIND::NWS16GET (wind.F:3148)

    LOOP BEGIN: (wind.F:3153)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:3153)
      *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:3153)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3162)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3162)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:3162)
  LOOP END

  LOOP BEGIN: (wind.F:3193)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3193)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:3193)
  LOOP END

  LOOP BEGIN: (wind.F:3224)
    <Unvectorized loop.>
    *** Overhead of loop division is too large. (wind.F:3224)

    LOOP BEGIN: (wind.F:3229)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:3229)
      *** The number of VLOAD, VSTORE. :  3,  3. (wind.F:3229)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3244)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. :   (wind.F:3244)
    *** Vectorization obstructive procedure reference. : WIND::WINDICEDRAG (wind.F:3244)
  LOOP END

  LOOP BEGIN: (wind.F:3283)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3283)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:3283)
  LOOP END

  LOOP BEGIN: (wind.F:3284)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3284)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:3284)
  LOOP END

  LOOP BEGIN: (wind.F:3289)
    <Vectorized loop.>
    **  Fused loop. (wind.F:3289)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3289)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:3289)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOTSTARTMETEOROLOGICALFORCING
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 28352 bytes
      Register spill area      :  5520 bytes
      Parameter area           :   160 bytes
      Register save area       :   176 bytes
      User data area           : 22496 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:2183)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2184)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2185)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2186)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2187)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:2188)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:2189)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2190)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:2191)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:2196)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2197)
    *** Estimated execution cycle                       : 12
    *** The number of SCALAR REGISTER TRANSFER          : 4

    LOOP BEGIN: (wind.F:2198)
      *** Estimated execution cycle                     : 58
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2202)
    *** Estimated execution cycle                       : 287
  LOOP END

  LOOP BEGIN: (wind.F:2217)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2220)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2221)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2222)
    *** Estimated execution cycle                       : 56
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (wind.F:2227)
      *** Estimated execution cycle                     : 125
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  8
              Over basic blocks                         :  2
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:2236)
    *** Estimated execution cycle                       : 579
  LOOP END

  LOOP BEGIN: (wind.F:2250)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2253)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2254)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2255)
    *** Estimated execution cycle                       : 289
  LOOP END

  LOOP BEGIN: (wind.F:2273)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2274)
    *** Estimated execution cycle                       : 142
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 4

  LOOP BEGIN: (wind.F:2300)
    *** Estimated execution cycle                       : 187
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 8
            Across calls                                : 4
            Over basic blocks                           : 4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 15
            Across calls                                :  8
            Over basic blocks                           :  7
    *** The number of SCALAR REGISTER TRANSFER          : 30

    LOOP BEGIN: (wind.F:2305)
      *** Estimated execution cycle                     : 96
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 676
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 110
            Across calls                                :   7
            Over basic blocks                           : 103
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:2345)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 221
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 5
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 13
            Across calls                                :  9
            Over basic blocks                           :  4
    *** The number of SCALAR REGISTER TRANSFER          : 23
  LOOP END

  LOOP BEGIN: (wind.F:2349)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2350)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 32
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 230
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 19
            Across calls                                : 12
            Over basic blocks                           :  7
    *** The number of SCALAR REGISTER TRANSFER          : 25
  LOOP END

  LOOP BEGIN: (wind.F:2352)
    *** Estimated execution cycle                       : 243
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 9
            Across calls                                : 1
            Over basic blocks                           : 8
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 31
            Across calls                                :  1
            Over basic blocks                           : 30
    *** The number of SCALAR REGISTER TRANSFER          : 24

    LOOP BEGIN: (wind.F:2357)
      *** Estimated execution cycle                     : 128
    LOOP END

    LOOP BEGIN: (wind.F:3447)
      *** Estimated execution cycle                     : 128
    LOOP END

    LOOP BEGIN: (wind.F:3452)
      *** Estimated execution cycle                     : 32
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (wind.F:3456)
      *** Estimated execution cycle                     : 243
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 9
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 23
              Across calls                              : 14
              Over basic blocks                         :  9
      *** The number of SCALAR REGISTER TRANSFER        : 26
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 716
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 116
            Across calls                                :   7
            Over basic blocks                           : 109
    *** The number of SCALAR REGISTER TRANSFER          : 74
  LOOP END

  LOOP BEGIN: (wind.F:2395)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 201
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 3
            Others                                      : 4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 7
            Across calls                                : 5
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END

  LOOP BEGIN: (wind.F:2399)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2400)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 32
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 230
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 19
            Across calls                                : 12
            Over basic blocks                           :  7
    *** The number of SCALAR REGISTER TRANSFER          : 25
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 628
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 92
            Across calls                                :  4
            Over basic blocks                           : 88
    *** The number of SCALAR REGISTER TRANSFER          : 67
  LOOP END

  LOOP BEGIN: (wind.F:2434)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2437)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2438)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2439)
    *** Estimated execution cycle                       : 55
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (wind.F:2444)
      *** Estimated execution cycle                     : 125
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  8
              Over basic blocks                         :  2
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:2485)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2488)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:2489)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 716
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 121
            Across calls                                :   7
            Over basic blocks                           : 114
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:2531)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2540)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2541)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 717
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 116
            Across calls                                :   7
            Over basic blocks                           : 109
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:2582)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2585)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2586)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2591)
    *** Estimated execution cycle                       : 643
  LOOP END

  LOOP BEGIN: (wind.F:2607)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2610)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2611)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2618)
    *** Estimated execution cycle                       : 643
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 640
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 98
            Across calls                                :  4
            Over basic blocks                           : 94
    *** The number of SCALAR REGISTER TRANSFER          : 67
  LOOP END

  LOOP BEGIN: (wind.F:2668)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 640
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 98
            Across calls                                :  4
            Over basic blocks                           : 94
    *** The number of SCALAR REGISTER TRANSFER          : 67
  LOOP END

  LOOP BEGIN: (wind.F:2701)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 640
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 98
            Across calls                                :  4
            Over basic blocks                           : 94
    *** The number of SCALAR REGISTER TRANSFER          : 67
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 820
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 30
            Across calls                                :  7
            Over basic blocks                           : 21
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 136
            Across calls                                :   7
            Over basic blocks                           : 129
    *** The number of SCALAR REGISTER TRANSFER          : 98
  LOOP END

  LOOP BEGIN: (wind.F:2811)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:2812)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 717
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 116
            Across calls                                :   7
            Over basic blocks                           : 109
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:2856)
    *** Estimated execution cycle                       : 201
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 7
            Over basic blocks                           : 7
    *** The number of SCALAR REGISTER TRANSFER          : 36

    LOOP BEGIN: (wind.F:2861)
      *** Estimated execution cycle                     : 128
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 786
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 30
            Across calls                                : 10
            Over basic blocks                           : 18
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 159
            Across calls                                :  10
            Over basic blocks                           : 149
    *** The number of SCALAR REGISTER TRANSFER          : 83
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 718
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 24
            Across calls                                :  7
            Over basic blocks                           : 15
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 132
            Across calls                                :   7
            Over basic blocks                           : 125
    *** The number of SCALAR REGISTER TRANSFER          : 76
  LOOP END

  LOOP BEGIN: (wind.F:2943)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:2948)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 913
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 33
            Across calls                                :  4
            Over basic blocks                           : 29
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 133
            Across calls                                :   4
            Over basic blocks                           : 129
    *** The number of SCALAR REGISTER TRANSFER          : 115
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 888
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 27
            Across calls                                :  8
            Over basic blocks                           : 16
            Others                                      :  3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 153
            Across calls                                :   8
            Over basic blocks                           : 145
    *** The number of SCALAR REGISTER TRANSFER          : 77
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 718
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 24
            Across calls                                :  7
            Over basic blocks                           : 15
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 132
            Across calls                                :   7
            Over basic blocks                           : 125
    *** The number of SCALAR REGISTER TRANSFER          : 76
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 704
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 20
            Across calls                                :  5
            Over basic blocks                           : 15
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 124
            Across calls                                :   5
            Over basic blocks                           : 119
    *** The number of SCALAR REGISTER TRANSFER          : 97
  LOOP END

  LOOP BEGIN: (wind.F:3148)
    *** Estimated execution cycle                       : 193
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 6
            Over basic blocks                           : 6
    *** The number of SCALAR REGISTER TRANSFER          : 34

    LOOP BEGIN: (wind.F:3153)
      *** Estimated execution cycle                     : 128
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 640
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 16
            Across calls                                :  4
            Over basic blocks                           : 12
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 98
            Across calls                                :  4
            Over basic blocks                           : 94
    *** The number of SCALAR REGISTER TRANSFER          : 67
  LOOP END

  LOOP BEGIN: (wind.F:3224)
    *** Estimated execution cycle                       : 55
    *** The number of SCALAR REGISTER TRANSFER          : 9

    LOOP BEGIN: (wind.F:3229)
      *** Estimated execution cycle                     : 128
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:471)
    *** Estimated execution cycle                       : 726
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 23
            Across calls                                :  7
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 122
            Across calls                                :   7
            Over basic blocks                           : 115
    *** The number of SCALAR REGISTER TRANSFER          : 75
  LOOP END

  LOOP BEGIN: (wind.F:3283)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:3284)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:3289)
    *** Estimated execution cycle                       : 96
  LOOP END

    LOOP BEGIN: (wind.F:2286)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (wind.F:2278)
      *** Estimated execution cycle                     : 96
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS3GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3340: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3357: inl(1222): Inlined: WIND::TIMECONV
   875: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
   877: inl(1222): Inlined: WIND::WINDTERMINATE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  3360: opt(1118): This I/O statement inhibits optimization of loop.
  3360: vec( 103): Unvectorized loop.
  3360: vec( 180): I/O statement obstructs vectorization.
  3363: opt(1118): This I/O statement inhibits optimization of loop.
  3363: vec( 103): Unvectorized loop.
  3363: vec( 180): I/O statement obstructs vectorization.
  3366: opt(1589): Outer loop moved inside inner loop(s).: I
  3366: vec( 101): Vectorized loop.
  3367: opt(1592): Outer loop unrolled inside inner loop.: J
  3375: vec( 101): Vectorized loop.
  3376: opt(1394): Moved invariant if outside of an inner loop.
  3384: vec( 128): Fused multiply-add operation applied.
  3387: vec( 128): Fused multiply-add operation applied.
  3390: vec( 128): Fused multiply-add operation applied.
  3391: vec( 128): Fused multiply-add operation applied.
  3392: vec( 128): Fused multiply-add operation applied.
  3393: vec( 128): Fused multiply-add operation applied.
  3395: vec( 128): Fused multiply-add operation applied.
  3399: vec( 128): Fused multiply-add operation applied.
  3404: vec( 101): Vectorized loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS3GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3326:                 SUBROUTINE NWS3GET()
  3327:                 USE SIZES
  3328:                 USE MESH, ONLY : X,Y,SLAM,SFEA,NP,ICS
  3329:                 IMPLICIT NONE
  3330:                 INTEGER, SAVE :: FIRSTCALL = 0
  3331:                 INTEGER I,J
  3332:                 INTEGER NScreen,ScreenUnit
  3333:                 REAL*8 XCOOR,YCOOR
  3334:                 INTEGER  LATIND1,LATIND2,LONIND1,LONIND2
  3335:                 REAL(8) WSPEED,WDIR
  3336:                 REAL(8) WLATM,WLONM,XWRATIO,YWRATIO
  3337:                 REAL(8),ALLOCATABLE,SAVE :: WVXFN(:,:),WVYFN(:,:)
  3338:                 INTEGER :: IWYR, IWMO, IWDAY, IWHR
  3339:           
  3340:                 call setMessageSource("nws3get")
  3341:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3342:                 call allMessage(DEBUG,"Enter.")
  3343:           #endif
  3344:           
  3345:           
  3346:           C
  3347:                 IF (FIRSTCALL.EQ.0) THEN
  3348:                    FIRSTCALL = 1
  3349:                    ALLOCATE ( WVXFN(NWLAT,NWLON),WVYFN(NWLAT,NWLON) )
  3350:                 ENDIF
  3351:           C
  3352:                 READ(22,*) IWTIME
  3353:                 IWYR = IWTIME/1000000
  3354:                 IWMO = IWTIME/10000 - IWYR*100
  3355:                 IWDAY = IWTIME/100 - IWYR*10000 - IWMO*100
  3356:                 IWHR = IWTIME - IWYR*1000000 - IWMO*10000 - IWDAY*100
  3357:         I       CALL TIMECONV(IWYR,IWMO,IWDAY,IWHR,0,0.0D0,WTIMED)
  3358:           
  3359: +------>        DO I=1,NWLAT
  3360: |+----->           READ(22,*) (WVXFN(I,J),J=1,NWLON)
  3361: +------         END DO
  3362: +------>        DO I=1,NWLAT
  3363: |+----->           READ(22,*) (WVYFN(I,J),J=1,NWLON)
  3364: +------         END DO
  3365:           C
  3366: X------>        DO I=1,NWLAT              !CONVERT TO X AND Y COMPONENTS
  3367: |U----->           DO J=1,NWLON
  3368: ||                    WSPEED=WVXFN(I,J)
  3369: ||                    WDIR=WVYFN(I,J)*DEG2RAD
  3370: ||                    WVXFN(I,J)=-WSPEED*SIN(WDIR)
  3371: ||                    WVYFN(I,J)=-WSPEED*COS(WDIR)
  3372: |U-----            END DO
  3373: X------         END DO
  3374:           
  3375: V------>        DO I=1,NP                 !INTERPOLATE TO ADCIRC GRID
  3376: |                  IF(ICS.NE.1) THEN
  3377: |                     YCOOR=SFEA(I)*RAD2DEG
  3378: |                     XCOOR=SLAM(I)*RAD2DEG
  3379: |                  ENDIF
  3380: |                  IF(ICS.EQ.1) THEN
  3381: |                     YCOOR=Y(I)
  3382: |                     XCOOR=X(I)
  3383: |                  ENDIF
  3384: |       F          LATIND2=(WLATMAX-YCOOR)/WLATINC + 1
  3385: |                  IF(LATIND2.EQ.NWLAT) LATIND2=LATIND2-1
  3386: |                  LATIND1=LATIND2 + 1
  3387: |       F          LONIND1=(XCOOR-WLONMIN)/WLONINC + 1
  3388: |                  IF(LONIND1.EQ.NWLON) LONIND1=LONIND1-1
  3389: |                  LONIND2=LONIND1+1
  3390: |       F          WLONM = WLONMIN + (LONIND1-1)*WLONINC
  3391: |       F          WLATM = WLATMAX - (LATIND1-1)*WLATINC
  3392: |       F          XWRATIO=(XCOOR-WLONM)/WLONINC
  3393: |       F          YWRATIO=(YCOOR-WLATM)/WLATINC
  3394: |         C
  3395: |       G          WVNX2(I) = WVXFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3396: |              &        + WVXFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3397: |              &        + WVXFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3398: |              &        + WVXFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3399: |       G          WVNY2(I) = WVYFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3400: |              &        + WVYFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3401: |              &        + WVYFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3402: |              &        + WVYFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3403: V------         END DO
  3404: V======>        PRN2 = PRBCKGRND_MH2O
  3405:           
  3406:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3407:                 call allMessage(DEBUG,"Return.")
  3408:           #endif
  3409:                 call unsetMessageSource()
  3410:           C
  3411:                 RETURN
  3412:                 END SUBROUTINE NWS3GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS3GET
INLINE LIST

  ROOT: WIND::NWS3GET (wind.F:3326)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3340)
     *** Source for routine not found.
  -> INLINE: WIND::TIMECONV (wind.F:3357)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:856)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:875)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:877)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:883)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3409)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS3GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:3359)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:3360)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3360)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3362)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:3363)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3363)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3367)
    <Unvectorized loop.>
    **  Copied loop. : FOR UNROLLING (wind.F:3367)

    LOOP BEGIN: (wind.F:3366)
      <Vectorized loop.>
      **  Copied loop. : FOR UNROLLING (wind.F:3366)
      **  Interchanged loop. (wind.F:3366)
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:3366)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:3366)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3367)
    <Unvectorized loop.>
    **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (wind.F:3367)

    LOOP BEGIN: (wind.F:3366)
      <Vectorized loop.>
      **  Interchanged loop. (wind.F:3366)
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:3366)
      *** The number of VLOAD, VSTORE. :  8,  8. (wind.F:3366)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3375)
    <Vectorized loop.>
    **  Copied loop. : FOR REMOVING INVARIANT IF (wind.F:3375)
    *** The number of VGT,   VSC.    :  8,  0. (wind.F:3375)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:3375)
    *** VGT generated (wind.F:3395)
    *** VGT generated (wind.F:3399)
  LOOP END

  LOOP BEGIN: (wind.F:3375)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  8,  0. (wind.F:3375)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:3375)
    *** VGT generated (wind.F:3395)
    *** VGT generated (wind.F:3399)
  LOOP END

  LOOP BEGIN: (wind.F:3404)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3404)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:3404)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS3GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 1584 bytes
      Register spill area      :  128 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1216 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:3359)
    *** Estimated execution cycle                       : 38
    *** The number of SCALAR REGISTER TRANSFER          : 15

    LOOP BEGIN: (wind.F:3360)
      *** Estimated execution cycle                     : 9
      *** The number of SCALAR REGISTER TRANSFER        : 3
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3362)
    *** Estimated execution cycle                       : 38
    *** The number of SCALAR REGISTER TRANSFER          : 15

    LOOP BEGIN: (wind.F:3363)
      *** Estimated execution cycle                     : 9
      *** The number of SCALAR REGISTER TRANSFER        : 3
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3366)
    *** Estimated execution cycle                       : 39
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (wind.F:3366)
      *** Estimated execution cycle                     : 266
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3366)
    *** Estimated execution cycle                       : 53
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (wind.F:3366)
      *** Estimated execution cycle                     : 964
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3375)
    *** Estimated execution cycle                       : 2638
  LOOP END

  LOOP BEGIN: (wind.F:3375)
    *** Estimated execution cycle                       : 2702
  LOOP END

  LOOP BEGIN: (wind.F:3404)
    *** Estimated execution cycle                       : 63
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS4GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3440: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3447: vec( 101): Vectorized loop.
  3452: vec( 103): Unvectorized loop.
  3452: vec( 180): I/O statement obstructs vectorization.
  3456: vec( 103): Unvectorized loop.
  3456: vec( 180): I/O statement obstructs vectorization.
  3476: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS4GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3431:                 SUBROUTINE NWS4GET()
  3432:                 USE SIZES
  3433:                 USE ADC_CONSTANTS, ONLY : RHOWAT0, G
  3434:                 USE MESH, ONLY : NP
  3435:                 IMPLICIT NONE
  3436:                 INTEGER   I,NHG
  3437:                 REAL(8)  RHOWATG
  3438:                 CHARACTER*80 PBLJAGF
  3439:           
  3440:                 call setMessageSource("nws4get")
  3441:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3442:                 call allMessage(DEBUG,"Enter.")
  3443:           #endif
  3444:           
  3445:           C
  3446:                 RHOWATG=RHOWAT0*G
  3447: V------>        DO I=1,NP
  3448: |                 WVNX2(I)=0.d0
  3449: |                 WVNY2(I)=0.d0
  3450: |                 PRN2(I)=101300.d0/RHOWATG
  3451: V------         END DO
  3452: +------>        DO WHILE(.TRUE.)
  3453: |                  READ(22,'(A80)') PBLJAGF
  3454: |                  IF(PBLJAGF(2:2).NE.'#') EXIT
  3455: +------         ENDDO
  3456: +------>        DO WHILE(.TRUE.)
  3457: |          171     READ(PBLJAGF,'(I8,5E13.5)') NHG,WVNX2(NHG),WVNY2(NHG),
  3458: |              &                               PRN2(NHG)
  3459: |         C
  3460: |         C        jgf46.02 From now on, wind files must contain data that are
  3461: |         C        appropriate for the time increment listed within the
  3462: |         C        file. Therefore, the following two lines were commented out.
  3463: |         C        WVNX(NHG)=WVNX(NHG)*1.04d0*0.5144d0 !CONVERT 30-MIN WINDS IN
  3464: |         C        WVNY(NHG)=WVNY(NHG)*1.04d0*0.5144d0 !KNOTS TO 10-MIN WIND IN M/S
  3465: |         C        jgf46.02 Added the following two lines.
  3466: |                  WVNX2(NHG)=WVNX2(NHG)*0.5144d0 !CONVERT KNOTS TO  M/S
  3467: |                  WVNY2(NHG)=WVNY2(NHG)*0.5144d0
  3468: |                  PRN2(NHG)=100.d0*PRN2(NHG)/RHOWATG !CONVERT MILLIBARS TO M OF WATER
  3469: |                  IF(PRN2(NHG).EQ.0.) PRN2(NHG)=101300.d0/RHOWATG                       !RAL0315+ OK
  3470: |                  READ(22,'(A80)') PBLJAGF
  3471: |                  IF(PBLJAGF(2:2).EQ.'#') EXIT
  3472: +------         ENDDO
  3473:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3474:                 call allMessage(DEBUG,"Return.")
  3475:           #endif
  3476:                 call unsetMessageSource()
  3477:                 RETURN
  3478:           
  3479:                 END SUBROUTINE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS4GET
INLINE LIST

  ROOT: WIND::NWS4GET (wind.F:3431)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3440)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3476)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS4GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:3447)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3447)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:3447)
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3452)
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:3456)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:10 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS4GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 45 [s0-s12 s15-s16 s18-s36 s53-s63]
      Vector registers         :  2 [v62-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2432 bytes
      Register spill area      :   24 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 2168 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:3447)
    *** Estimated execution cycle                       : 128
  LOOP END

  LOOP BEGIN: (wind.F:3452)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:3456)
    *** Estimated execution cycle                       : 190
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Across calls                                : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 7
            Across calls                                : 5
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS6GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3571: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3585: vec( 103): Unvectorized loop.
  3585: vec( 180): I/O statement obstructs vectorization.
  3586: opt(1118): This I/O statement inhibits optimization of loop.
  3590: vec( 101): Vectorized loop.
  3591: opt(1394): Moved invariant if outside of an inner loop.
  3599: vec( 128): Fused multiply-add operation applied.
  3602: vec( 128): Fused multiply-add operation applied.
  3605: vec( 128): Fused multiply-add operation applied.
  3606: vec( 128): Fused multiply-add operation applied.
  3607: vec( 128): Fused multiply-add operation applied.
  3608: vec( 128): Fused multiply-add operation applied.
  3613: vec( 128): Fused multiply-add operation applied.
  3617: vec( 128): Fused multiply-add operation applied.
  3621: vec( 128): Fused multiply-add operation applied.
  3632: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS6GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3557:                 SUBROUTINE NWS6GET()
  3558:                 USE SIZES
  3559:                 USE ADC_CONSTANTS, ONLY : RHOWAT0, G
  3560:                 USE MESH, ONLY : X,Y,SLAM,SFEA,NP,ICS
  3561:                 IMPLICIT NONE
  3562:                 INTEGER, SAVE :: FIRSTCALL = 0
  3563:                 INTEGER :: I,J
  3564:                 REAL(8) :: RHOWATG
  3565:                 INTEGER  LATIND1,LATIND2,LONIND1,LONIND2
  3566:                 REAL(8) XWRATIO,YWRATIO
  3567:                 REAL(8) WLATM,WLONM
  3568:                 REAL(8) :: XCOOR,YCOOR
  3569:                 REAL(8),SAVE,ALLOCATABLE :: WVXFN(:,:),WVYFN(:,:),PRN(:,:)
  3570:           
  3571:                 call setMessageSource("nws6get")
  3572:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3573:                 call allMessage(DEBUG,"Enter.")
  3574:           #endif
  3575:           
  3576:           C
  3577:                 IF (FIRSTCALL.EQ.0) THEN
  3578:                    FIRSTCALL = 1
  3579:                    ALLOCATE ( WVXFN(NWLAT,NWLON),WVYFN(NWLAT,NWLON),
  3580:                &        PRN(NWLAT,NWLON) )
  3581:                 ENDIF
  3582:           C
  3583:                 RHOWATG=RHOWAT0*G
  3584: +------>        DO I=1,NWLAT
  3585: |+----->           DO J=1,NWLON
  3586: ||                    READ(22,*) WVXFN(I,J),WVYFN(I,J),PRN(I,J)
  3587: |+-----            END DO
  3588: +------         END DO
  3589:           
  3590: V------>        DO I=1,NP                 !INTERPOLATE TO ADCIRC GRID
  3591: |                  IF(ICS.NE.1) THEN
  3592: |                     YCOOR=SFEA(I)*RAD2DEG
  3593: |                     XCOOR=SLAM(I)*RAD2DEG
  3594: |                  ENDIF
  3595: |                  IF(ICS.EQ.1) THEN
  3596: |                     YCOOR=Y(I)
  3597: |                     XCOOR=X(I)
  3598: |                  ENDIF
  3599: |       F          LATIND2=(WLATMAX-YCOOR)/WLATINC + 1
  3600: |                  IF(LATIND2.EQ.NWLAT) LATIND2=LATIND2-1
  3601: |                  LATIND1=LATIND2 + 1
  3602: |       F          LONIND1=(XCOOR-WLONMIN)/WLONINC + 1
  3603: |                  LONIND2=LONIND1 + 1
  3604: |         C
  3605: |       F          WLONM = WLONMIN + (LONIND1-1)*WLONINC
  3606: |       F          WLATM = WLATMAX - (LATIND1-1)*WLATINC
  3607: |       F          XWRATIO=(XCOOR-WLONM)/WLONINC
  3608: |       F          YWRATIO=(YCOOR-WLATM)/WLATINC
  3609: |         C
  3610: |                  IF(LONIND1.EQ.0) LONIND1=NWLON
  3611: |                  IF(LONIND1.EQ.NWLON) LONIND2=1
  3612: |         C
  3613: |       G          WVNX2(I) = WVXFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3614: |              &        + WVXFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3615: |              &        + WVXFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3616: |              &        + WVXFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3617: |       G          WVNY2(I) = WVYFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3618: |              &        + WVYFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3619: |              &        + WVYFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3620: |              &        + WVYFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3621: |       G          PRN2(I) = PRN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3622: |              &        + PRN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3623: |              &        + PRN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3624: |              &        + PRN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3625: |                  PRN2(I) = PRN2(I)/RHOWATG
  3626: |         
  3627: V------         END DO
  3628:           C
  3629:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3630:                 call allMessage(DEBUG,"Return.")
  3631:           #endif
  3632:                 call unsetMessageSource()
  3633:                 RETURN
  3634:           C     ----------------------------------------------------------------
  3635:                 END SUBROUTINE NWS6GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS6GET
INLINE LIST

  ROOT: WIND::NWS6GET (wind.F:3557)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3571)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3632)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS6GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:3584)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:3585)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3585)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3590)
    <Vectorized loop.>
    **  Copied loop. : FOR REMOVING INVARIANT IF (wind.F:3590)
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:3590)
    *** The number of VLOAD, VSTORE. :  2,  3. (wind.F:3590)
    *** VGT generated (wind.F:3613)
    *** VGT generated (wind.F:3617)
    *** VGT generated (wind.F:3621)
  LOOP END

  LOOP BEGIN: (wind.F:3590)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:3590)
    *** The number of VLOAD, VSTORE. :  2,  3. (wind.F:3590)
    *** VGT generated (wind.F:3613)
    *** VGT generated (wind.F:3617)
    *** VGT generated (wind.F:3621)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS6GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 1376 bytes
      Register spill area      :   56 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1080 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:3584)
    *** Estimated execution cycle                       : 22
    *** The number of SCALAR REGISTER TRANSFER          : 10

    LOOP BEGIN: (wind.F:3585)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3590)
    *** Estimated execution cycle                       : 3476
  LOOP END

  LOOP BEGIN: (wind.F:3590)
    *** Estimated execution cycle                       : 3540
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS7GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3708: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3722: vec( 103): Unvectorized loop.
  3722: vec( 180): I/O statement obstructs vectorization.
  3723: opt(1118): This I/O statement inhibits optimization of loop.
  3727: vec( 101): Vectorized loop.
  3728: opt(1394): Moved invariant if outside of an inner loop.
  3736: vec( 128): Fused multiply-add operation applied.
  3739: vec( 128): Fused multiply-add operation applied.
  3742: vec( 128): Fused multiply-add operation applied.
  3743: vec( 128): Fused multiply-add operation applied.
  3744: vec( 128): Fused multiply-add operation applied.
  3745: vec( 128): Fused multiply-add operation applied.
  3750: vec( 128): Fused multiply-add operation applied.
  3754: vec( 128): Fused multiply-add operation applied.
  3758: vec( 128): Fused multiply-add operation applied.
  3768: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS7GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3694:                 SUBROUTINE NWS7GET()
  3695:                 USE ADC_CONSTANTS, ONLY : RHOWAT0, G
  3696:                 USE MESH, ONLY : X, Y, SLAM, SFEA, NP, ICS
  3697:                 IMPLICIT NONE
  3698:           
  3699:                 INTEGER I                     ! node loop counter
  3700:                 INTEGER K, J                  ! latitude, longitude loop counters
  3701:                 REAL(8) RHOWATG             ! ref. dens. of water * grav. constant
  3702:                 INTEGER  LATIND1,LATIND2,LONIND1,LONIND2
  3703:                 REAL(8) WLATM,WLONM,XWRATIO,YWRATIO
  3704:                 REAL(8) XCOOR,YCOOR
  3705:                 REAL(8), SAVE, ALLOCATABLE :: WVXFN(:,:),WVYFN(:,:),PRN(:,:)
  3706:                 LOGICAL, SAVE :: MemoryAllocated = .False.
  3707:           
  3708:                 call setMessageSource("nws7get")
  3709:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3710:                 call allMessage(DEBUG,"Enter.")
  3711:           #endif
  3712:           
  3713:           C
  3714:                 IF (.not.MemoryAllocated) THEN
  3715:                    ALLOCATE ( WVXFN(NWLAT,NWLON),WVYFN(NWLAT,NWLON),
  3716:                &        PRN(NWLAT,NWLON) )
  3717:                    MemoryAllocated = .True.
  3718:                 ENDIF
  3719:           C
  3720:                 RHOWATG=RHOWAT0*G
  3721: +------>        DO K=1,NWLAT
  3722: |+----->           DO J=1,NWLON
  3723: ||                    READ(22,*) WVXFN(K,J),WVYFN(K,J),PRN(K,J)
  3724: |+-----            END DO
  3725: +------         END DO
  3726:           C
  3727: V------>        DO I=1,NP                 !INTERPOLATE TO ADCIRC GRID
  3728: |                  IF(ICS.NE.1) THEN
  3729: |                     YCOOR=SFEA(I)*RAD2DEG
  3730: |                     XCOOR=SLAM(I)*RAD2DEG
  3731: |                  ENDIF
  3732: |                  IF(ICS.EQ.1) THEN
  3733: |                     YCOOR=Y(I)
  3734: |                     XCOOR=X(I)
  3735: |                  ENDIF
  3736: |       F          LATIND2=(WLATMAX-YCOOR)/WLATINC + 1
  3737: |                  IF(LATIND2.EQ.NWLAT) LATIND2=LATIND2-1
  3738: |                  LATIND1=LATIND2 + 1
  3739: |       F          LONIND1=(XCOOR-WLONMIN)/WLONINC + 1
  3740: |                  LONIND2=LONIND1 + 1
  3741: |         C
  3742: |       F          WLONM = WLONMIN + (LONIND1-1)*WLONINC
  3743: |       F          WLATM = WLATMAX - (LATIND1-1)*WLATINC
  3744: |       F          XWRATIO=(XCOOR-WLONM)/WLONINC
  3745: |       F          YWRATIO=(YCOOR-WLATM)/WLATINC
  3746: |         C
  3747: |                  IF(LONIND1.EQ.0) LONIND1=NWLON
  3748: |                  IF(LONIND1.EQ.NWLON) LONIND2=1
  3749: |         C
  3750: |       G          WVNX2(I) = WVXFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3751: |              &        + WVXFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3752: |              &        + WVXFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3753: |              &        + WVXFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3754: |       G          WVNY2(I) = WVYFN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3755: |              &        + WVYFN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3756: |              &        + WVYFN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3757: |              &        + WVYFN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3758: |       G          PRN2(I) = PRN(LATIND2,LONIND2)*XWRATIO*YWRATIO
  3759: |              &        + PRN(LATIND2,LONIND1)*(1.d0-XWRATIO)*YWRATIO
  3760: |              &        + PRN(LATIND1,LONIND2)*XWRATIO*(1.d0-YWRATIO)
  3761: |              &        + PRN(LATIND1,LONIND1)*(1.d0-XWRATIO)*(1.d0-YWRATIO)
  3762: |                  PRN2(I) = PRN2(I)/RHOWATG
  3763: V------         END DO
  3764:           C
  3765:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3766:                 call allMessage(DEBUG,"Return.")
  3767:           #endif
  3768:                 call unsetMessageSource()
  3769:                 RETURN
  3770:           C     ----------------------------------------------------------------
  3771:                 END SUBROUTINE NWS7GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS7GET
INLINE LIST

  ROOT: WIND::NWS7GET (wind.F:3694)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3708)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3768)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS7GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:3721)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:3722)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:3722)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3727)
    <Vectorized loop.>
    **  Copied loop. : FOR REMOVING INVARIANT IF (wind.F:3727)
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:3727)
    *** The number of VLOAD, VSTORE. :  2,  3. (wind.F:3727)
    *** VGT generated (wind.F:3750)
    *** VGT generated (wind.F:3754)
    *** VGT generated (wind.F:3758)
  LOOP END

  LOOP BEGIN: (wind.F:3727)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:3727)
    *** The number of VLOAD, VSTORE. :  2,  3. (wind.F:3727)
    *** VGT generated (wind.F:3750)
    *** VGT generated (wind.F:3754)
    *** VGT generated (wind.F:3758)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS7GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 1376 bytes
      Register spill area      :   56 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1080 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:3721)
    *** Estimated execution cycle                       : 22
    *** The number of SCALAR REGISTER TRANSFER          : 10

    LOOP BEGIN: (wind.F:3722)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3727)
    *** Estimated execution cycle                       : 3476
  LOOP END

  LOOP BEGIN: (wind.F:3727)
    *** Estimated execution cycle                       : 3540
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10INIT
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3790: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3807: inl(1222): Inlined: WIND::GLATS
  3882: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  3887: inl(1222): Inlined: WIND::WINDTERMINATE
  3902: inl(1222): Inlined: WIND::WINDTERMINATE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  3808: vec( 101): Vectorized loop.
  3814: vec( 101): Vectorized loop.
  3817: inl(1222): Inlined: WIND::G2RINI


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10INIT
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3782:                 subroutine nws10Init()
  3783:                 use global, only : ihot, ncice
  3784:                 use mesh, only : np, slam, sfea
  3785:                 use adc_constants, only: twopi
  3786:                 implicit none
  3787:                 real(8) :: gdlon
  3788:                 integer :: j, jj ! loop counters
  3789:           
  3790:                 call setMessageSource("nws10init")
  3791:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3792:                 call allMessage(DEBUG,"Enter.")
  3793:           #endif
  3794:                 !
  3795:                 ! gaussian met values
  3796:                 allocate ( ug(latb*lonb),vg(latb*lonb),pg(latb*lonb) )
  3797:                 if (ncice.eq.10) allocate ( ig(latb*lonb) )
  3798:                 ! four corner met values in grid cell associated with each adcirc mesh vertex
  3799:                 allocate ( n00(np),n10(np),n11(np),n01(np) )
  3800:                 ! four interpolating factors associated with each adcirc mesh vertex
  3801:                 allocate ( d00(np),d10(np),d11(np),d01(np) )
  3802:                 !
  3803:                 allocate ( colrab(latb),dummy(latb),gclat(latb),gclon(lonb) )
  3804:           C
  3805:           C...  Set up the Gaussian grid and determine the interpolating factors
  3806:           C     for the ADCIRC grid.
  3807:         I       call glats(latb/2,colrab,dummy,dummy,dummy)
  3808: V------>        do j=1,latb/2
  3809: |                  gclat(j)=colrab(j)
  3810: |                  jj=latb-j+1
  3811: |                  gclat(jj)=pi-colrab(j)
  3812: V------         enddo
  3813:                 gdlon=twopi/lonb
  3814: V------>        do j=1,lonb
  3815: |                  gclon(j)=gdlon*(j-1)
  3816: V------         end do
  3817:         I       call g2rini()
  3818:                 !
  3819:                 ! Set the counter value. According to the ADCIRC documentation,
  3820:                 ! fort.200 is read upon hotstart, but not at coldstart.
  3821:                 if (ihot.eq.0) then
  3822:                    nws10DatasetCounter = 1
  3823:                 else
  3824:                    nws10DatasetCounter = 0
  3825:                 endif
  3826:           
  3827:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3828:                 call allMessage(DEBUG,"Return.")
  3829:           #endif
  3830:                 call unsetMessageSource()
  3831:           
  3832:                 !----------------------------------------------------------------
  3833:                 end subroutine nws10Init


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10INIT
INLINE LIST

  ROOT: WIND::NWS10INIT (wind.F:3782)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3790)
     *** Source for routine not found.
  -> INLINE: WIND::GLATS (wind.F:3807)
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:4178)
      *** Source for routine not found.
  -> INLINE: WIND::G2RINI (wind.F:3817)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3859)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3882)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3886)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:3887)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3897)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3901)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:3902)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3954)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3830)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10INIT
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:4141)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:4144)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:4144)

      LOOP BEGIN: (wind.F:4197)
        <Unvectorized loop.>
        *** Unvectorizable dependency. (wind.F:4200)
        *** Unvectorizable dependency. (wind.F:4199)
      LOOP END

      LOOP BEGIN: (wind.F:4146)
        <Unvectorized loop.>

        LOOP BEGIN: (wind.F:4197)
          <Unvectorized loop.>
          *** Unvectorizable dependency. (wind.F:4200)
          *** Unvectorizable dependency. (wind.F:4199)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      <Unvectorized loop.>
      *** Unvectorizable dependency. (wind.F:4200)
      *** Unvectorizable dependency. (wind.F:4199)
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:4197)
      *** The number of VLOAD, VSTORE. :  0,  0. (wind.F:4197)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3808)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3808)
    *** The number of VLOAD, VSTORE. :  1,  2. (wind.F:3808)
  LOOP END

  LOOP BEGIN: (wind.F:3814)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:3814)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:3814)
  LOOP END

  LOOP BEGIN: (wind.F:3873)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:3873)
    *** Deallocation obstructs vectorization. (wind.F:3873)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:3873)
    *** Vectorization obstructive statement. (wind.F:3873)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:3873)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:3873)
    *** I/O statement obstructs vectorization. (wind.F:3873)

    LOOP BEGIN: (wind.F:3905)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:3905)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10INIT
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  6 [v58-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 4112 bytes
      Register spill area      :  344 bytes
      Parameter area           :   40 bytes
      Register save area       :  176 bytes
      User data area           : 3544 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:4141)
    *** Estimated execution cycle                       : 62
    *** The number of SCALAR REGISTER TRANSFER          : 10

    LOOP BEGIN: (wind.F:4144)
      *** Estimated execution cycle                     : 18
      *** The number of SCALAR REGISTER TRANSFER        : 3

      LOOP BEGIN: (wind.F:4197)
        *** Estimated execution cycle                   : 30
        *** The number of SCALAR REGISTER TRANSFER      : 2
      LOOP END

      LOOP BEGIN: (wind.F:4146)
        *** Estimated execution cycle                   : 21
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER TRANSFER      : 3

        LOOP BEGIN: (wind.F:4197)
          *** Estimated execution cycle                 : 30
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      *** Estimated execution cycle                     : 4
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:3808)
    *** Estimated execution cycle                       : 99
  LOOP END

  LOOP BEGIN: (wind.F:3814)
    *** Estimated execution cycle                       : 129
  LOOP END

  LOOP BEGIN: (wind.F:3873)
    *** Estimated execution cycle                       : 738
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 38
            Across calls                                : 38
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 58
            Across calls                                : 42
            Over basic blocks                           : 14
            Others                                      :  2
    *** The number of SCALAR REGISTER TRANSFER          : 102

    LOOP BEGIN: (wind.F:3905)
      *** Estimated execution cycle                     : 43
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::G2RINI
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3859: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  3873: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  3873: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  3873: vec( 182): Deallocation obstructs vectorization.
  3873: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  3873: vec( 109): Vectorization obstructive statement.
  3873: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  3873: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  3873: vec( 180): I/O statement obstructs vectorization.
  3882: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  3882: opt(1025): Reference to this procedure inhibits optimization.: GLOBAL::ALLMESSAGE
  3887: inl(1222): Inlined: WIND::WINDTERMINATE
  3902: inl(1222): Inlined: WIND::WINDTERMINATE
  3905: opt(1082): Backward transfers inhibit loop optimization.
  3905: vec( 103): Unvectorized loop.
  3905: vec( 108): Unvectorizable loop structure.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::G2RINI
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3851:                 subroutine g2rini()
  3852:                 use mesh, only : np, slam, sfea
  3853:                 use adc_constants, only: twopi, hfpi
  3854:                 implicit none
  3855:                 integer :: N,I,LON,LONP1,LAT,LATP1
  3856:                 real(8) :: DLAT,DLON,FLONWORK,COLAT,DDLAT,XLAT,DFLAT,DFLAT1,
  3857:                &     DDLON,XLON,DFLON,DFLON1
  3858:           
  3859:                 call setMessageSource("g2rini")
  3860:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3861:                 call allMessage(DEBUG,"Enter.")
  3862:           #endif
  3863:           
  3864:           C
  3865:           C...Compute estimated DLAT, true DLON for Gaussian grid
  3866:                 DLAT=PI/REAL(LATB-1,KIND=8)
  3867:                 DLON=TWOPI/REAL(LONB,KIND=8)
  3868:                 N=0
  3869:           
  3870:           C...Loop through all the nodes in the grid to be interpolated onto and
  3871:           C.....compute the interpolating factors.
  3872:           
  3873: +------>        DO I=1,NP
  3874: |         C.....   Compute initial guess of which lon value FLON(I) is in the Gaussian file
  3875: |         C......  Check that this value is reasonable.
  3876: |                  flonwork=slam(i)
  3877: |                  if(flonwork.lt.0.) flonwork=flonwork+twopi
  3878: |                  lon=flonwork/dlon + 1
  3879: |                  lonp1=lon+1
  3880: |                  if(lon.eq.lonb) lonp1=1 !circle condition
  3881: |                  if((lon.lt.1).or.(lon.gt.lonb)) then
  3882: |                     call allMessage(ERROR,'Mesh node outside gaussian grid.')
  3883: |                     write(scratchMessage,
  3884: |              &       '("i=",i0," lon=",f15.8," dlon=",f15.8," flon(i)=",f15.8)')
  3885: |              &       i, lon, dlon, slam(i)
  3886: |                     call allMessage(ERROR, scratchMessage)
  3887: |       I             call windTerminate()
  3888: |                  endif
  3889: |         
  3890: |         C.....   Compute initial guess of which lat value FLAT(I) is in the Gaussian file
  3891: |         C....... Check that this value is reasonable.
  3892: |                  colat=hfpi-sfea(i)
  3893: |                  lat=colat/dlat + 1
  3894: |                  if(lat.eq.latb) lat=lat-1
  3895: |                  latp1=lat+1
  3896: |                  if((lat.lt.1).or.(lat.gt.latb)) then
  3897: |                     call allMessage(ERROR,'Mesh node outside gaussian grid.')
  3898: |                     write(scratchMessage,
  3899: |              &       '("i=",i0," lat=",f15.8," dlat=",f15.8," flat(i)=",f15.8)')
  3900: |              &       i, lat, dlat, sfea(i)
  3901: |                     call allMessage(ERROR, scratchMessage)
  3902: |       I             call windTerminate()
  3903: |                  endif
  3904: |         
  3905: |+----->           DO WHILE(.TRUE.)
  3906: ||                    IF((COLAT.GE.GCLAT(LAT)).AND.(COLAT.LE.GCLAT(LATP1))) EXIT
  3907: ||                    IF(COLAT.LT.GCLAT(LAT)) THEN
  3908: ||                       LATP1=LAT
  3909: ||                       LAT=LAT-1
  3910: ||                       IF(LAT.LE.0) THEN
  3911: ||                          LAT=1
  3912: ||                          LATP1=2
  3913: ||                          EXIT
  3914: ||                       ENDIF
  3915: ||                       CYCLE
  3916: ||                    ENDIF
  3917: ||                    IF(COLAT.GT.GCLAT(LATP1)) THEN
  3918: ||                       LAT=LAT+1
  3919: ||                       LATP1=LAT+1
  3920: ||                       IF(LAT.GE.LATB ) THEN
  3921: ||                          LAT=LATB-1
  3922: ||                          LATP1=LATB
  3923: ||                          EXIT
  3924: ||                       ENDIF
  3925: ||                       CYCLE
  3926: ||                    ENDIF
  3927: ||                    EXIT
  3928: |+-----            ENDDO
  3929: |                  DDLAT=GCLAT(LATP1)-GCLAT(LAT)
  3930: |                  XLAT=GCLAT(LAT)
  3931: |                  DFLAT1=(COLAT-XLAT)/DDLAT
  3932: |                  IF(LAT.EQ.1) DFLAT1=MAX(0.d0,DFLAT1) !MODIFY THIS FOR POLAR POINTS
  3933: |                  IF(LATP1.EQ.LATB) DFLAT1=MIN(1.d0,DFLAT1) !MODIFY THIS FOR POLAR POINTS
  3934: |                  DFLAT=1.d0-DFLAT1
  3935: |                  DDLON=DLON
  3936: |                  XLON=GCLON(LON)
  3937: |                  DFLON1=(FLONWORK-XLON)/DDLON
  3938: |                  DFLON=1.d0-DFLON1
  3939: |                  N=N+1
  3940: |                  D00(N)=DFLON*DFLAT
  3941: |                  D10(N)=DFLON1*DFLAT
  3942: |                  D11(N)=DFLON1*DFLAT1
  3943: |                  D01(N)=DFLON*DFLAT1
  3944: |                  N00(N)=LON+(LAT-1)*LONB
  3945: |                  N10(N)=LONP1+(LAT-1)*LONB
  3946: |                  N11(N)=LONP1+(LATP1-1)*LONB
  3947: |                  N01(N)=LON+(LATP1-1)*LONB
  3948: |         
  3949: +------         END DO
  3950:           
  3951:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  3952:                 call allMessage(DEBUG,"Return.")
  3953:           #endif
  3954:                 call unsetMessageSource()
  3955:                 !----------------------------------------------------------------
  3956:                 end subroutine g2rini


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::G2RINI
INLINE LIST

  ROOT: WIND::G2RINI (wind.F:3851)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:3859)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3882)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3886)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:3887)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3897)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:3901)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:3902)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:3954)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::G2RINI
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:3873)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:3873)
    *** Deallocation obstructs vectorization. (wind.F:3873)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:3873)
    *** Vectorization obstructive statement. (wind.F:3873)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:3873)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:3873)
    *** I/O statement obstructs vectorization. (wind.F:3873)

    LOOP BEGIN: (wind.F:3905)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:3905)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::G2RINI
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3920 bytes
      Register spill area      :  248 bytes
      Parameter area           :   40 bytes
      Register save area       :  176 bytes
      User data area           : 3448 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:3873)
    *** Estimated execution cycle                       : 733
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 40
            Across calls                                : 40
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 58
            Across calls                                : 45
            Over basic blocks                           : 11
            Others                                      :  2
    *** The number of SCALAR REGISTER TRANSFER          : 98

    LOOP BEGIN: (wind.F:3905)
      *** Estimated execution cycle                     : 43
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4008: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  4018: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  4020: inl(1222): Inlined: WIND::WINDTERMINATE
  4029: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  4029: vec( 103): Unvectorized loop.
  4029: vec( 108): Unvectorizable loop structure.
  4031: inl(1222): Inlined: WIND::WINDTERMINATE
  4037: vec( 103): Unvectorized loop.
  4037: vec( 180): I/O statement obstructs vectorization.
  4038: opt(1118): This I/O statement inhibits optimization of loop.
  4042: vec( 103): Unvectorized loop.
  4042: vec( 180): I/O statement obstructs vectorization.
  4043: opt(1118): This I/O statement inhibits optimization of loop.
  4050: vec( 101): Vectorized loop.
  4066: vec( 128): Fused multiply-add operation applied.
  4067: vec( 128): Fused multiply-add operation applied.
  4068: vec( 128): Fused multiply-add operation applied.
  4074: vec( 101): Vectorized loop.
  4082: vec( 128): Fused multiply-add operation applied.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3990:                 subroutine nws10get(ull,vll,pll,ill)
  3991:                 USE ADC_CONSTANTS, only : mb2pa
  3992:                 use sizes, only : gblinputdir
  3993:                 use mesh, only : np, slam, sfea
  3994:                 implicit none
  3995:                 real(8), intent(out) :: ull(:),vll(:),pll(:) ! mesh met values
  3996:                 real(8), intent(out), optional :: ill(:) ! mesh ice values
  3997:                 !
  3998:                 real(8) :: rhowatg ! density of water * gravitational acceleration
  3999:                 real(8) :: p1,p2,p3,p4 ! pressure at 4 corners of gaussian grid cell
  4000:                 real(8) :: u1,u2,u3,u4 ! east velocity at 4 corners of gaussian grid cell
  4001:                 real(8) :: v1,v2,v3,v4 ! north velocity at 4 corners of gaussian grid cell
  4002:                 real(8) :: i1,i2,i3,i4 ! ice concentration at 4 corners of gaussian grid cell
  4003:                 character(len=8) :: fname1 ! name of GFS file to read
  4004:                 integer :: iext        ! numerical extension to file name
  4005:                 integer :: ios = 0     ! i/o status for opening the fort.xxx files
  4006:                 integer :: i, n        ! loop counters
  4007:           
  4008:                 call setMessageSource("nws10get")
  4009:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4010:                 call allMessage(DEBUG,"Enter.")
  4011:           #endif
  4012:           
  4013:           C
  4014:                 rhowatg=rhowat0*g
  4015:                 !
  4016:                 ! Check to be sure that wtiminc is evenly divisible.
  4017:                 if (modulo(int(wtiminc),3600).ne.0) then
  4018:                    call allMessage(ERROR,
  4019:                &      'For NWS=10, WTIMINC must be evenly divisible by 3600.')
  4020:         I          call windTerminate()
  4021:                 endif
  4022:                 !
  4023:                 ! Form the data file name.
  4024:                 iext = 200 + nws10DatasetCounter * int(wtiminc/3600.d0)
  4025:                 write(fname1,'("fort.",i3)') iext
  4026:                 !
  4027:                 ! jgf51.52.21: Fixed name of met file with full path for use in
  4028:                 ! parallel operation.
  4029:                 call openFileForRead(iext,trim(gblinputdir)//'/'//trim(fname1),ios)
  4030:                 if (ios.ne.0) then
  4031:         I          call windTerminate()
  4032:                 endif
  4033:           C
  4034:           C...  Read the ASCII data file
  4035:           !     WJP: With ice
  4036:                 if (present(ill)) then
  4037: +------>           do i=1,lonb*latb
  4038: |                     read(iext,*) pg(i),ug(i),vg(i),ig(i)
  4039: +------            enddo
  4040:                 else
  4041:           !     WJP: Without ice
  4042: +------>           do i=1,lonb*latb
  4043: |                     read(iext,*) pg(i),ug(i),vg(i)
  4044: +------            enddo
  4045:                 endif
  4046:                 close(iext)
  4047:           C
  4048:           C.....Go from the Gaussian grid to the ADCIRC grid
  4049:           C.....Convert pressure from N/M^2 to M of H20
  4050: V------>        do n=1,np
  4051: |                  ! grab the numerical values at the 4 corners of the grid
  4052: |                  ! cell containing this mesh node
  4053: |       G          p1=pg(n00(n))
  4054: |       G          p2=pg(n10(n))
  4055: |       G          p3=pg(n11(n))
  4056: |       G          p4=pg(n01(n))
  4057: |       G          u1=ug(n00(n))
  4058: |       G          u2=ug(n10(n))
  4059: |       G          u3=ug(n11(n))
  4060: |       G          u4=ug(n01(n))
  4061: |       G          v1=vg(n00(n))
  4062: |       G          v2=vg(n10(n))
  4063: |       G          v3=vg(n11(n))
  4064: |       G          v4=vg(n01(n))
  4065: |                  ! spatially interpolate from the 4 values to the mesh vertex
  4066: |       F          pll(n)=p1*d00(n)+p2*d10(n)+p3*d11(n)+p4*d01(n)
  4067: |       F          ull(n)=u1*d00(n)+u2*d10(n)+u3*d11(n)+u4*d01(n)
  4068: |       F          vll(n)=v1*d00(n)+v2*d10(n)+v3*d11(n)+v4*d01(n)
  4069: |                  pll(n)=pll(n)/rhowatg
  4070: V------         end do
  4071:           
  4072:           !     WJP: Interpolate ice concentration if present
  4073:                 if (present(ill)) then
  4074: V------>           do n=1,np
  4075: |                     ! grab the numerical values at the 4 corners of the grid
  4076: |                     ! cell containing this mesh node
  4077: |       G             i1=ig(n00(n))
  4078: |       G             i2=ig(n10(n))
  4079: |       G             i3=ig(n11(n))
  4080: |       G             i4=ig(n01(n))
  4081: |                     ! spatially interpolate from the 4 values to the mesh vertex
  4082: |       F             ill(n)=i1*d00(n)+i2*d10(n)+i3*d11(n)+i4*d01(n)
  4083: V------            enddo
  4084:                 endif
  4085:           C
  4086:                 nws10DatasetCounter = nws10DatasetCounter + 1
  4087:           
  4088:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4089:                 call allMessage(DEBUG,"Return.")
  4090:           #endif
  4091:                 call unsetMessageSource()
  4092:           !----------------------------------------------------------------
  4093:                 end subroutine nws10get


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10GET
INLINE LIST

  ROOT: WIND::NWS10GET (wind.F:3990)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:4008)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:4018)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:4020)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:4029)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:4031)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:4091)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:4029)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:4029)
  LOOP END

  LOOP BEGIN: (wind.F:4029)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:4029)
  LOOP END

  LOOP BEGIN: (wind.F:4042)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:4042)
  LOOP END

  LOOP BEGIN: (wind.F:4037)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:4037)
  LOOP END

  LOOP BEGIN: (wind.F:4050)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:4050)
    *** The number of VLOAD, VSTORE. :  8,  3. (wind.F:4050)
    *** VGT generated (wind.F:4053)
    *** VGT generated (wind.F:4057)
    *** VGT generated (wind.F:4061)
    *** VGT generated (wind.F:4054)
    *** VGT generated (wind.F:4058)
    *** VGT generated (wind.F:4062)
    *** VGT generated (wind.F:4055)
    *** VGT generated (wind.F:4059)
    *** VGT generated (wind.F:4063)
    *** VGT generated (wind.F:4056)
    *** VGT generated (wind.F:4060)
    *** VGT generated (wind.F:4064)
  LOOP END

  LOOP BEGIN: (wind.F:4074)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  4,  0. (wind.F:4074)
    *** The number of VLOAD, VSTORE. :  8,  1. (wind.F:4074)
    *** VGT generated (wind.F:4077)
    *** VGT generated (wind.F:4078)
    *** VGT generated (wind.F:4079)
    *** VGT generated (wind.F:4080)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS10GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2688 bytes
      Register spill area      :   56 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 2392 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:4029)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:4029)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:4042)
    *** Estimated execution cycle                       : 59
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END

  LOOP BEGIN: (wind.F:4037)
    *** Estimated execution cycle                       : 71
    *** The number of SCALAR REGISTER TRANSFER          : 9
  LOOP END

  LOOP BEGIN: (wind.F:4050)
    *** Estimated execution cycle                       : 2223
  LOOP END

  LOOP BEGIN: (wind.F:4074)
    *** Estimated execution cycle                       : 997
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GLATS
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4114: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  4144: opt(1097): This statement prevents loop optimization.
  4144: vec( 108): Unvectorizable loop structure.
  4145: inl(1222): Inlined: WIND::POLY
  4150: inl(1222): Inlined: WIND::POLY
  4160: inl(1222): Inlined: WIND::POLY
  4169: inl(1222): Inlined: WIND::POLY
  4178: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GLATS
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4105:                 SUBROUTINE GLATS(LGGHAF,COLRAD,WGT,WGTCS,RCS2)
  4106:                 USE SIZES
  4107:                 IMPLICIT NONE
  4108:                 REAL(8) COLRAD(*),WGT(*),WGTCS(*),RCS2(*)
  4109:                 INTEGER LGGHAF,L2,K,K1,ITER
  4110:                 REAL(8) SI,SCALEVAL,RL2,DRAD,RAD,P1,P2,EPS,PHI,X,W,SN,RC
  4111:                 real(8) :: dradz ! initial guess that represents a distance between gridpoints (radian)
  4112:                 integer :: multiple ! yf51.52.25: reduce initial guess for DRAD for T1534 grid
  4113:           
  4114:                 call setMessageSource("glats")
  4115:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4116:                 call allMessage(DEBUG,"Enter.")
  4117:           #endif
  4118:           
  4119:           C
  4120:                 EPS=1.d-6
  4121:           C     EPS=1.d-12
  4122:           C     PRINT 101
  4123:           C     101  FORMAT ('0 I   COLAT   COLRAD     WGT', 12X, 'WGTCS',
  4124:           CCCC  1 10X, 'ITER  RES')
  4125:           C
  4126:                 SI = 1.0d0
  4127:                 L2=2*LGGHAF
  4128:                 RL2=L2
  4129:                 SCALEVAL = 2.0d0/(RL2*RL2)
  4130:                 K1=L2-1
  4131:                 !yf51.52.25 DRADZ = PI / 360.d0
  4132:                 !yf51.52.25: In equation L2/(190+2), L2 (1536) is a number of
  4133:                 ! latitude from T1534 grid and 190 is ones from the original
  4134:                 ! T126 grid. +2 is polar points which didn't include in T126 grid.
  4135:                 ! The reason why I used the equation and the integer "multiple"
  4136:                 ! are I want to use the original T126 latitudinal number (as the
  4137:                 ! base number) for the future update of GFS.
  4138:                 multiple = L2/(190+2)
  4139:                 dradz = pi/(multiple*360.d0)
  4140:                 RAD = 0.0
  4141: +------>        DO 1000 K=1,LGGHAF
  4142: |                  ITER=0
  4143: |                  DRAD=DRADZ
  4144: |+----->           DO WHILE(.TRUE.)
  4145: ||      I             CALL POLY(L2,RAD,P2)
  4146: ||+---->              DO WHILE(.TRUE.)
  4147: |||                      P1 =P2
  4148: |||                      ITER=ITER+1
  4149: |||                      RAD=RAD+DRAD
  4150: |||     I                CALL POLY(L2,RAD,P2)
  4151: |||                      IF(SIGN(SI,P1).EQ.SIGN(SI,P2)) CYCLE
  4152: |||                      EXIT
  4153: ||+----               ENDDO
  4154: ||                    IF(DRAD.LT.EPS) EXIT
  4155: ||                    RAD=RAD-DRAD
  4156: ||                    DRAD = DRAD * 0.25d0
  4157: |+-----            ENDDO
  4158: |                  COLRAD(K)=RAD
  4159: |                  PHI = RAD * 180.d0 / PI
  4160: |       I          CALL POLY(K1,RAD,P1)
  4161: |                  X = COS(RAD)
  4162: |                  W = SCALEVAL * (1.0d0 - X*X)/ (P1*P1)
  4163: |                  WGT(K) = W
  4164: |                  SN = SIN(RAD)
  4165: |                  W=W/(SN*SN)
  4166: |                  WGTCS(K) = W
  4167: |                  RC=1.d0/(SN*SN)
  4168: |                  RCS2(K) = RC
  4169: |       I          CALL POLY(L2,RAD,P1)
  4170: |         C     PRINT 102,K,PHI,COLRAD(K),WGT(K),WGTCS(K),ITER,P1
  4171: |         C     102  FORMAT(1H ,I2,2X,F6.2,2X,F10.7,2X,E13.7,2X,E13.7,2X,I4,2X,D13.7)
  4172: +------    1000 CONTINUE
  4173:           c     PRINT 100,LGGHAF
  4174:           c     100  FORMAT(1H ,'SHALOM FROM 0.0 GLATS FOR ',I3)
  4175:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4176:                 call allMessage(DEBUG,"Return.")
  4177:           #endif
  4178:                 call unsetMessageSource()
  4179:                 RETURN
  4180:                 END SUBROUTINE GLATS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GLATS
INLINE LIST

  ROOT: WIND::GLATS (wind.F:4105)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:4114)
     *** Source for routine not found.
  -> INLINE: WIND::POLY (wind.F:4145)
  -> INLINE: WIND::POLY (wind.F:4150)
  -> INLINE: WIND::POLY (wind.F:4160)
  -> INLINE: WIND::POLY (wind.F:4169)
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:4178)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GLATS
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:4141)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:4144)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:4144)

      LOOP BEGIN: (wind.F:4197)
        <Unvectorized loop.>
        *** Unvectorizable dependency. (wind.F:4200)
        *** Unvectorizable dependency. (wind.F:4199)
      LOOP END

      LOOP BEGIN: (wind.F:4146)
        <Unvectorized loop.>

        LOOP BEGIN: (wind.F:4197)
          <Unvectorized loop.>
          *** Unvectorizable dependency. (wind.F:4200)
          *** Unvectorizable dependency. (wind.F:4199)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      <Unvectorized loop.>
      *** Unvectorizable dependency. (wind.F:4200)
      *** Unvectorizable dependency. (wind.F:4199)
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:4197)
      *** The number of VLOAD, VSTORE. :  0,  0. (wind.F:4197)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GLATS
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 37 [s0-s4 s8-s12 s15-s16 s18-s33 s55-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 256 bytes
      Register spill area      :  32 bytes
      Parameter area           :  16 bytes
      Register save area       : 176 bytes
      User data area           :  32 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:4141)
    *** Estimated execution cycle                       : 73
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 6
            Over basic blocks                           : 6
    *** The number of SCALAR REGISTER TRANSFER          : 4

    LOOP BEGIN: (wind.F:4144)
      *** Estimated execution cycle                     : 25
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (wind.F:4197)
        *** Estimated execution cycle                   : 31
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END

      LOOP BEGIN: (wind.F:4146)
        *** Estimated execution cycle                   : 23
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 1
                Others                                  : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 1
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER TRANSFER      : 2

        LOOP BEGIN: (wind.F:4197)
          *** Estimated execution cycle                 : 30
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END

    LOOP BEGIN: (wind.F:4197)
      *** Estimated execution cycle                     : 4
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POLY
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4197: vec( 103): Unvectorized loop.
  4198: opt(1019): Feedback of scalar value from one loop pass to another.: Y2
  4199: opt(1019): Feedback of scalar value from one loop pass to another.: Y1
  4199: vec( 121): Unvectorizable dependency.
  4200: vec( 121): Unvectorizable dependency.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POLY
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4188:                 SUBROUTINE POLY(N,RAD,P)
  4189:                 USE SIZES
  4190:                 IMPLICIT NONE
  4191:                 INTEGER N,I
  4192:                 REAL(8) RAD,P,X,Y1,Y2,Y3,G
  4193:           C
  4194:                 X = COS(RAD)
  4195:                 Y1 = 1.0d0
  4196:                 Y2=X
  4197: +------>        DO 1 I=2,N
  4198: |                  G=X*Y2
  4199: |                  Y3=G-Y1+G-(G-Y1)/REAL(I,KIND=8)
  4200: |                  Y1=Y2
  4201: |                  Y2=Y3
  4202: +------    1    CONTINUE
  4203:                 P=Y3
  4204:                 RETURN
  4205:                 END SUBROUTINE POLY


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POLY
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POLY
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:4197)
    <Unvectorized loop.>
    *** Unvectorizable dependency. (wind.F:4200)
    *** Unvectorizable dependency. (wind.F:4199)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::POLY
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 20 [s0-s2 s8-s12 s15-s16 s23-s24 s33 s57-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 192 bytes
      Register spill area      :   0 bytes
      Parameter area           :   8 bytes
      Register save area       : 176 bytes
      User data area           :   0 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:4197)
    *** Estimated execution cycle                       : 30
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS11GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4257: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  4276: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  4277: vec( 103): Unvectorized loop.
  4277: vec( 110): Vectorization obstructive procedure reference.: WIND::E29SEARCH
  4280: inl(1214): Expansion routine is too big for automatic expansion.: WIND::E29SEARCH
  4286: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  4302: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  4304: inl(1222): Inlined: WIND::WINDTERMINATE
  4313: vec( 103): Unvectorized loop.
  4313: vec( 180): I/O statement obstructs vectorization.
  4313: vec( 108): Unvectorizable loop structure.
  4314: opt(1118): This I/O statement inhibits optimization of loop.
  4325: vec( 101): Vectorized loop.
  4335: vec( 128): Fused multiply-add operation applied.
  4336: vec( 128): Fused multiply-add operation applied.
  4339: vec( 128): Fused multiply-add operation applied.
  4340: vec( 128): Fused multiply-add operation applied.
  4341: vec( 128): Fused multiply-add operation applied.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS11GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4237:                 SUBROUTINE NWS11GET()
  4238:                 USE SIZES
  4239:                 USE ADC_CONSTANTS, ONLY : RHOWAT0, G
  4240:                 USE MESH, ONLY : NP, SLAM, SFEA
  4241:                 IMPLICIT NONE
  4242:                 INTEGER,SAVE  ::  ICALL = 0
  4243:                 INTEGER I,IEXT,IDIG1,IDIG2,IDIG3,KERR,N
  4244:                 INTEGER IYEAR,IMONTH,IDAY,IHOUR
  4245:                 REAL*8 RHOWATG100,FLONDEG,FLATDEG
  4246:                 REAL(8) P1,P2,P3,U1,U2,U3,V1,V2,V3,UE29,VE29,CBETAU,SBETAU
  4247:           C
  4248:                 INTEGER,SAVE,ALLOCATABLE ::  N1(:),N2(:),N3(:)
  4249:                 REAL(8),SAVE,ALLOCATABLE :: D1(:),D2(:),D3(:),BETAU(:)
  4250:                 REAL(8),SAVE,ALLOCATABLE :: UE(:),VE(:),PE(:)
  4251:           C
  4252:                 CHARACTER*1 FNAME2(8)
  4253:                 CHARACTER*8 FNAME1
  4254:                 EQUIVALENCE (FNAME1,FNAME2)
  4255:                 integer :: errorio
  4256:           
  4257:                 call setMessageSource("nws11get")
  4258:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4259:                 call allMessage(DEBUG,"Enter.")
  4260:           #endif
  4261:           
  4262:           C
  4263:                 IF (ICALL.EQ.0) THEN
  4264:                    ICALL = 1
  4265:                    ALLOCATE ( N1(MNP),N2(MNP),N3(MNP) )
  4266:                    ALLOCATE ( D1(MNP),D2(MNP),D3(MNP),BETAU(MNP) )
  4267:                    ALLOCATE ( UE(181*271),VE(181*271),PE(181*271) )
  4268:                 ENDIF
  4269:           C
  4270:                 RHOWATG100=RHOWAT0*G*100.d0
  4271:           
  4272:           C...  The first time the subroutine is called, setup the interpolating factors
  4273:           C...  between the Eta-29 grid and the ADCIRC grid.
  4274:           
  4275:                 IF((NWSEGWI.EQ.0).AND.(IDSETFLG.EQ.0)) THEN
  4276:                    call allMessage(INFO,'Computing ETA29 met field interp factors.')
  4277: +------>           DO I=1,NP
  4278: |                     flondeg=rad2deg*slam(i)
  4279: |                     flatdeg=rad2deg*sfea(i)
  4280: |                     CALL E29SEARCH(I,FLONDEG,FLATDEG,N1(I),N2(I),N3(I),
  4281: |              &           D1(I),D2(I),D3(I),betau(i))
  4282: +------            END DO
  4283:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4284:                    call allMessage(DEBUG,"Return.")
  4285:           #endif
  4286:                    call unsetMessageSource()
  4287:                    RETURN
  4288:                 ENDIF
  4289:           
  4290:           C...  Figure out the met data file name
  4291:           
  4292:                 FNAME1='fort.   '
  4293:                 IEXT=200 + NWSEGWI
  4294:                 IDIG1=IEXT/100
  4295:                 IDIG2=(IEXT-100*IDIG1)/10
  4296:                 IDIG3=(IEXT-100*IDIG1-10*IDIG2)
  4297:                 FNAME2(6)=CHAR(IDIG1+48)
  4298:                 FNAME2(7)=CHAR(IDIG2+48)
  4299:                 FNAME2(8)=CHAR(IDIG3+48)
  4300:           
  4301:           C...  If appropriate, enter, locate and open the met data file
  4302:                 call openFileForRead(IEXT,FNAME1,errorIO)
  4303:                 if (errorIO.ne.0) then
  4304:         I          call windTerminate()
  4305:                 endif
  4306:           
  4307:           C...  Read the met data file
  4308:           
  4309:                 READ(IEXT,END=1100) IYEAR,IMONTH,IDAY,IHOUR
  4310:                 READ(IEXT,END=1100) UE,VE,PE
  4311:           
  4312:                 IF(NWSEGWI.EQ.0) THEN     !If the first file, read until the end
  4313: +------>           DO I=2,IDSETFLG
  4314: |                     READ(IEXT,END=1100) IYEAR,IMONTH,IDAY,IHOUR
  4315: |                     READ(IEXT,END=1100) UE,VE,PE
  4316: +------            ENDDO
  4317:                 ENDIF
  4318:           
  4319:            1100 IF(IDSETFLG.EQ.8) CLOSE(IEXT)
  4320:           
  4321:           C.....Interpolate onto ADCIRC grid
  4322:           C.....Convert velocity from the E grid reference to a lat/lon reference
  4323:           C.....Convert pressure from millibars to N/M^2 to M of H20
  4324:           
  4325: V------>        DO N=1,NP
  4326: |       G          P1=PE(N1(N))
  4327: |       G          P2=PE(N2(N))
  4328: |       G          P3=PE(N3(N))
  4329: |       G          U1=UE(N1(N))
  4330: |       G          U2=UE(N2(N))
  4331: |       G          U3=UE(N3(N))
  4332: |       G          V1=VE(N1(N))
  4333: |       G          V2=VE(N2(N))
  4334: |       G          V3=VE(N3(N))
  4335: |       F          UE29=U1*D1(N)+U2*D2(N)+U3*D3(N)
  4336: |       F          VE29=V1*D1(N)+V2*D2(N)+V3*D3(N)
  4337: |                  CBETAU=COS(BETAU(N))
  4338: |                  SBETAU=SIN(BETAU(N))
  4339: |       F          WVNX2(N)=UE29*CBETAU - VE29*SBETAU
  4340: |       F          WVNY2(N)=UE29*SBETAU + VE29*CBETAU
  4341: |       F          PRN2(N)=P1*D1(N)+P2*D2(N)+P3*D3(N)
  4342: |                  PRN2(N)=PRN2(N)/RHOWATG100
  4343: V------         END DO
  4344:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  4345:                 call allMessage(DEBUG,"Return.")
  4346:           #endif
  4347:                 call unsetMessageSource()
  4348:                 RETURN
  4349:           C-----------------------------------------------------------------------
  4350:                 END SUBROUTINE NWS11GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS11GET
INLINE LIST

  ROOT: WIND::NWS11GET (wind.F:4237)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:4257)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:4276)
     *** Source for routine not found.
  -> NOINLINE: WIND::E29SEARCH (wind.F:4280)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:4286)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:4302)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:4304)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:4347)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS11GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:4313)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:4313)
    *** Unvectorizable loop structure. (wind.F:4313)
  LOOP END

  LOOP BEGIN: (wind.F:4325)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  9,  0. (wind.F:4325)
    *** The number of VLOAD, VSTORE. :  7,  3. (wind.F:4325)
    *** VGT generated (wind.F:4326)
    *** VGT generated (wind.F:4329)
    *** VGT generated (wind.F:4332)
    *** VGT generated (wind.F:4327)
    *** VGT generated (wind.F:4330)
    *** VGT generated (wind.F:4333)
    *** VGT generated (wind.F:4328)
    *** VGT generated (wind.F:4331)
    *** VGT generated (wind.F:4334)
  LOOP END

  LOOP BEGIN: (wind.F:4277)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : WIND::E29SEARCH (wind.F:4277)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS11GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 49 [s0-s12 s15-s16 s18-s41 s54-s63]
      Vector registers         : 40 [v0-v1 v26-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2192 bytes
      Register spill area      :  280 bytes
      Parameter area           :   80 bytes
      Register save area       :  176 bytes
      User data area           : 1656 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:4313)
    *** Estimated execution cycle                       : 182
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 4
            Over basic blocks                           : 2
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 18
            Over basic blocks                           : 18
    *** The number of SCALAR REGISTER TRANSFER          : 19
  LOOP END

  LOOP BEGIN: (wind.F:4325)
    *** Estimated execution cycle                       : 1518
  LOOP END

  LOOP BEGIN: (wind.F:4277)
    *** Estimated execution cycle                       : 55
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 4
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29SEARCH
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4468: inl(1222): Inlined: WIND::E29CALC
  4910: inl(1222): Inlined: WIND::E29CALC
  4911: inl(1222): Inlined: WIND::E29CALC
  4912: inl(1222): Inlined: WIND::E29CALC
  4933: inl(1222): Inlined: WIND::E29CALC
  4934: inl(1222): Inlined: WIND::E29CALC
  4935: inl(1222): Inlined: WIND::E29CALC
  4956: inl(1222): Inlined: WIND::E29CALC
  4957: inl(1222): Inlined: WIND::E29CALC
  4958: inl(1222): Inlined: WIND::E29CALC
  4484: inl(1222): Inlined: WIND::E29CALC
  4910: inl(1222): Inlined: WIND::E29CALC
  4911: inl(1222): Inlined: WIND::E29CALC
  4912: inl(1222): Inlined: WIND::E29CALC
  4933: inl(1222): Inlined: WIND::E29CALC
  4934: inl(1222): Inlined: WIND::E29CALC
  4935: inl(1222): Inlined: WIND::E29CALC
  4956: inl(1222): Inlined: WIND::E29CALC
  4957: inl(1222): Inlined: WIND::E29CALC
  4958: inl(1222): Inlined: WIND::E29CALC
  4494: inl(1222): Inlined: WIND::E29CALC
  4910: inl(1222): Inlined: WIND::E29CALC
  4911: inl(1222): Inlined: WIND::E29CALC
  4912: inl(1222): Inlined: WIND::E29CALC
  4933: inl(1222): Inlined: WIND::E29CALC
  4934: inl(1222): Inlined: WIND::E29CALC
  4935: inl(1222): Inlined: WIND::E29CALC
  4956: inl(1222): Inlined: WIND::E29CALC
  4957: inl(1222): Inlined: WIND::E29CALC
  4958: inl(1222): Inlined: WIND::E29CALC
  4510: inl(1222): Inlined: WIND::E29CALC
  4526: inl(1222): Inlined: WIND::E29CALC
  4536: inl(1222): Inlined: WIND::E29CALC
  4552: inl(1222): Inlined: WIND::E29CALC
  4606: inl(1222): Inlined: WIND::BETAUCALC
  4634: inl(1222): Inlined: WIND::BETAUCALC
  4662: inl(1222): Inlined: WIND::BETAUCALC
  4689: inl(1222): Inlined: WIND::BETAUCALC
  4717: inl(1235): Inline halted: code size exceeds limit.: WIND::E29SEARCH


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29SEARCH
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4364:                 subroutine e29search(node,FLON,FLAT,NN1,NN2,NN3,DD1,DD2,DD3,betau)
  4365:                 implicit none
  4366:                 integer nn1,nn2,nn3,node,icode,nwlon,nwlat,ifflag
  4367:                 integer i,j,im2,jm2,n,ia,ja,na,ib,jb,nb,ic,jc,nc,id,jd,nd,
  4368:                &  ie,je,ne,ig,jg,ng,if
  4369:                 real(8) dd1,dd2,dd3,betau,ri,x1,x2,x3,x4,y1,y2,y3,y4
  4370:                 real(8) aemin,areas,a1,a2,a3,aa,ae,lambda
  4371:                 real(8) lamda0,phi0,rphi0,cphi0,sphi0,tphi0,dlamda,dphi,rdlamda,
  4372:                &       rdphi,rflat,tflat,sflat,cflat,a,rlamar,cphiicrlamda,phiarg,
  4373:                &       rphii,rlamda,ri1,ri2,rj,dgtora,flon,flat
  4374:                 real(8) lamda,lamdaa,lamdab,lamdac,lamdad,lamdae,lamdag
  4375:                 real(8) phi,phia,phib,phic,phid,phie,phig
  4376:           c
  4377:                 icode=0
  4378:                 nwlon=181
  4379:                 nwlat=271
  4380:                 dgtora=deg2rad
  4381:                 lamda0=-97.0d0
  4382:                 phi0=41.0d0
  4383:                 rphi0=dgtora*phi0
  4384:                 cphi0=cos(rphi0)
  4385:                 sphi0=sin(rphi0)
  4386:                 tphi0=tan(rphi0)
  4387:                 dlamda=7.d0/36.d0
  4388:                 dphi=5.d0/27.d0
  4389:                 rdlamda=dgtora*dlamda
  4390:                 rdphi=dgtora*dphi
  4391:           c
  4392:                 rflat=flat*dgtora
  4393:                   tflat=tan(rflat)
  4394:                 sflat=sin(rflat)
  4395:                 cflat=cos(rflat)
  4396:           
  4397:           c     compute the position of the closest node in the E29 grid
  4398:           
  4399:                 a=flon-lamda0
  4400:                 rlamar=cos(a*dgtora)
  4401:                 cphiicrlamda=(rlamar+tflat*tphi0)*cflat*cphi0
  4402:                 phiarg=sflat
  4403:                 rphii=asin((phiarg-sphi0*cphiicrlamda)/cphi0)
  4404:                 rlamda=acos(cphiicrlamda/cos(rphii))
  4405:                 if(flon.lt.lamda0) rlamda=-rlamda
  4406:           c
  4407:                 ri2=(rlamda/rdlamda+nwlon+1)/2.
  4408:                 ri1=(rlamda/rdlamda+nwlon)/2.
  4409:                 rj=rphii/rdphi+(nwlat+1)/2
  4410:                 j=(rj+0.5d0)
  4411:                 ri=ri1
  4412:                 if(mod(j,2).eq.0) ri=ri2
  4413:                 i=(ri+0.5d0)
  4414:           
  4415:           c     if (myproc == 0) then
  4416:           c       write(screenunit,*) "lamda, phi = ",flon,flat
  4417:           c       write(screenunit,*) "ri1, ri2, ri, rj = ",ri1,ri2,ri,rj
  4418:           c       write(screenunit,*) "i, j = ",i,j
  4419:           c     endif
  4420:           
  4421:                 if ((rj.lt.1).or.(rj.gt.nwlat)) then
  4422:           c        write(333,*) 'ADCIRC grid node ',node,
  4423:           c     &             ' falls outside of the ETA 29 grid'
  4424:                   icode=1
  4425:                   NN1=1
  4426:                   NN2=1
  4427:                   NN3=1
  4428:                   DD1=0
  4429:                   DD2=0
  4430:                   DD3=0
  4431:                   return
  4432:                 endif
  4433:           
  4434:                 if (mod(j,2).eq.0) then
  4435:                    if ((ri.lt.1).or.(ri.gt.(nwlon+0.5d0))) then
  4436:           c          write(333,*) 'ADCIRC grid node ',node,
  4437:           c     &                 ' falls outside of the ETA 29 grid'
  4438:                       icode=1
  4439:                       NN1=1
  4440:                       NN2=1
  4441:                       NN3=1
  4442:                       DD1=0
  4443:                       DD2=0
  4444:                       DD3=0
  4445:                       return
  4446:                    endif
  4447:                 endif
  4448:           
  4449:                 if (mod(j,2).ne.0) then
  4450:                    if ((ri.lt.0.5).or.(ri.gt.nwlon)) then
  4451:           c           write(333,*) 'ADCIRC grid node ',node,
  4452:           c     &                 ' falls outside of the ETA 29 grid'
  4453:                       icode=1
  4454:                       NN1=1
  4455:                       NN2=1
  4456:                       NN3=1
  4457:                       DD1=0
  4458:                       DD2=0
  4459:                       DD3=0
  4460:                       return
  4461:                    endif
  4462:                 endif
  4463:           
  4464:           c     compute the coordinates of the closest Eta29 grid node
  4465:           
  4466:                 jm2=(nwlat+1)/2
  4467:                 im2=nwlon*2
  4468:         I       call e29calc(i,j,lamda,phi,n)
  4469:           
  4470:           c     compute the coordinates of neighbor node "a" (located SW of closest node)
  4471:           
  4472:                 if ((i.eq.1).and.(mod(j,2).eq.0)) then
  4473:                    ia=i
  4474:                    ja=j-2
  4475:                 else
  4476:                    ia=i
  4477:                    if(mod(j,2).eq.0) ia=i-1
  4478:                    ja=j-1
  4479:                 endif
  4480:           c                                 this neighbor lies outside of Eta29 grid
  4481:                 if ((ia.lt.1).or.(ja.lt.1)) then
  4482:                    na=0
  4483:                 else
  4484:         I          call e29calc(ia,ja,lamdaa,phia,na)
  4485:                 endif
  4486:           
  4487:           c     compute the coordinates of neighbor node "b" (located W of closest node)
  4488:           
  4489:                 ib=i-1
  4490:                 jb=j
  4491:                 if (ib.lt.1) then         !this neighbor lies outside of Eta29 grid
  4492:                    nb=0
  4493:                 else
  4494:         I          call e29calc(ib,jb,lamdab,phib,nb)
  4495:                 endif
  4496:           
  4497:           c     compute the coordinates of neighbor node "c" (located NW of closest node)
  4498:           
  4499:                 if ((i.eq.1).and.(mod(j,2).eq.0)) then
  4500:                    ic=i
  4501:                    jc=j+2
  4502:                 else
  4503:                    ic=ia
  4504:                    jc=j+1
  4505:                 endif
  4506:           c                                    this neighbor lies outside of Eta29 grid
  4507:                 if ((ic.lt.1).or.(jc.gt.nwlat)) then
  4508:                    nc=0
  4509:                 else
  4510:         I          call e29calc(ic,jc,lamdac,phic,nc)
  4511:                 endif
  4512:           
  4513:           c     compute the coordinates of neighbor node "d" (located NE of closest node)
  4514:           
  4515:                 if ((i.eq.181).and.(mod(j,2).ne.0)) then
  4516:                    id=i
  4517:                    jd=j+2
  4518:                 else
  4519:                    id=ic+1
  4520:                    jd=j+1
  4521:                 endif
  4522:           c                                    this neighbor lies outside of Eta29 grid
  4523:                 if ((id.gt.nwlon).or.(jd.gt.nwlat)) then
  4524:                    nd=0
  4525:                 else
  4526:         I          call e29calc(id,jd,lamdad,phid,nd)
  4527:                 endif
  4528:           
  4529:           c     compute the coordinates of neighbor node "e" (located E of closest node)
  4530:           
  4531:                 ie=i+1
  4532:                 je=j
  4533:                 if (ie.gt.nwlon) then     !this neighbor lies outside of Eta29 grid
  4534:                    ne=0
  4535:                 else
  4536:         I          call e29calc(ie,je,lamdae,phie,ne)
  4537:                 endif
  4538:           
  4539:           c     compute the coordinates of neighbor node "g" (located SE of closest node)
  4540:           
  4541:                 if ((i.eq.181).and.(mod(j,2).ne.0)) then
  4542:                    ig=i
  4543:                    jg=j-2
  4544:                 else
  4545:                    ig=id
  4546:                    jg=j-1
  4547:                 endif
  4548:           c                                    this neighbor lies outside of Eta29 grid
  4549:                 if ((ig.gt.nwlon).or.(jg.lt.1)) then
  4550:                    ng=0
  4551:                 else
  4552:         I          call e29calc(ig,jg,lamdag,phig,ng)
  4553:                 endif
  4554:           
  4555:           c     if (myproc == 0) then
  4556:           c      write(screenunit,*) 'closest E29 node i,j = ',n,i,j,lamda,phi
  4557:           c      if(na.eq.0) write(screenunit,*) 'point a falls outside of Eta29 grid'
  4558:           c      if(na.ne.0) write(screenunit,*) 'point a   = ',na,ia,ja,lamdaa,phia
  4559:           c      if(nb.eq.0) write(screenunit,*) 'point b falls outside of Eta29 grid'
  4560:           c      if(nb.ne.0) write(screenunit,*) 'point b   = ',nb,ib,jb,lamdab,phib
  4561:           c      if(nc.eq.0) write(screenunit,*) 'point c falls outside of Eta29 grid'
  4562:           c      if(nc.ne.0) write(screenunit,*) "point c   = ",nc,ic,jc,lamdac,phic
  4563:           c      if(nd.eq.0) write(screenunit,*) 'point d falls outside of Eta29 grid'
  4564:           c      if(nd.ne.0) write(screenunit,*) "point d   = ",nd,id,jd,lamdad,phid
  4565:           c      if(ne.eq.0) write(screenunit,*) 'point e falls outside of Eta29 grid'
  4566:           c      if(ne.ne.0) write(screenunit,*) "point e   = ",ne,ie,je,lamdae,phie
  4567:           c      if(ng.eq.0) write(screenunit,*) 'point g falls outside of Eta29 grid'
  4568:           c      if(ng.ne.0) write(screenunit,*) "point g   = ",ng,ig,jg,lamdag,phig
  4569:           c     endif
  4570:           
  4571:                 NN1=1
  4572:                 NN2=1
  4573:                 NN3=1
  4574:                 DD1=0
  4575:                 DD2=0
  4576:                 DD3=0
  4577:                 X1=lamda
  4578:                 X4=flon
  4579:                 Y1=phi
  4580:                 Y4=flat
  4581:                 ifflag=0
  4582:                 AEMIN=99999.d0
  4583:           
  4584:           c     test if the point is in triangle ij - b - a
  4585:           
  4586:                 if ((na.ne.0).and.(nb.ne.0)) then
  4587:                    X2=lamdab
  4588:                    X3=lamdaa
  4589:                    Y2=phib
  4590:                    Y3=phia
  4591:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4592:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4593:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4594:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4595:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4596:                    AE=ABS(AA-AREAS)/AREAS
  4597:           c     write(333,*) "AE = ",AE
  4598:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4599:                       AEMIN=AE
  4600:                       NN1=n
  4601:                       NN2=nb
  4602:                       NN3=na
  4603:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4604:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4605:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4606:         I             call betaucalc(i,j,DD1,ib,jb,DD2,ia,ja,DD3,betau)
  4607:                       ifflag=ifflag+1
  4608:           c     write(333,*) 'position found in triangle ij - b - a'
  4609:                    ENDIF
  4610:                 endif
  4611:           
  4612:           c     if along the west boundary, test if the point is in triangle ij - c - a
  4613:           
  4614:                 if((i.eq.1).and.(mod(j,2).ne.0)) then
  4615:                    if((na.ne.0).and.(nc.ne.0)) then
  4616:                       X2=lamdac
  4617:                       X3=lamdaa
  4618:                       Y2=phic
  4619:                       Y3=phia
  4620:                       AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4621:                       A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4622:                       A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4623:                       A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4624:                       AA=ABS(A1)+ABS(A2)+ABS(A3)
  4625:                       AE=ABS(AA-AREAS)/AREAS
  4626:           c     write(333,*) "AE = ",AE
  4627:                       IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4628:                          NN1=n
  4629:                          NN2=nc
  4630:                          NN3=na
  4631:                          DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4632:                          DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4633:                          DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4634:         I                call betaucalc(i,j,DD1,ic,jc,DD2,ia,ja,DD3,betau)
  4635:                          ifflag=ifflag+1
  4636:           c     write(333,*) 'position found in triangle ij - c - a'
  4637:                       ENDIF
  4638:                    endif
  4639:                 endif
  4640:           
  4641:           c     test if the point is in triangle ij - c - b
  4642:           
  4643:                 if((nb.ne.0).and.(nc.ne.0)) then
  4644:                    X2=lamdac
  4645:                    X3=lamdab
  4646:                    Y2=phic
  4647:                    Y3=phib
  4648:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4649:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4650:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4651:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4652:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4653:                    AE=ABS(AA-AREAS)/AREAS
  4654:           c     write(333,*) "AE = ",AE
  4655:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4656:                       NN1=n
  4657:                       NN2=nc
  4658:                       NN3=nb
  4659:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4660:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4661:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4662:         I             call betaucalc(i,j,DD1,ic,jc,DD2,ib,jb,DD3,betau)
  4663:                       ifflag=ifflag+1
  4664:           c     write(333,*) 'position found in triangle ij - c - b'
  4665:                    ENDIF
  4666:                 endif
  4667:           
  4668:           c     test if the point is in triangle ij - d - c
  4669:           
  4670:                 if((nc.ne.0).and.(nd.ne.0)) then
  4671:                    X2=lamdad
  4672:                    X3=lamdac
  4673:                    Y2=phid
  4674:                    Y3=phic
  4675:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4676:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4677:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4678:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4679:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4680:                    AE=ABS(AA-AREAS)/AREAS
  4681:           c     write(333,*) "AE = ",AE
  4682:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4683:                       NN1=n
  4684:                       NN2=nd
  4685:                       NN3=nc
  4686:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4687:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4688:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4689:         I             call betaucalc(i,j,DD1,id,jd,DD2,ic,jc,DD3,betau)
  4690:                       ifflag=ifflag+1
  4691:           c     write(333,*) 'position found in triangle ij - d - c'
  4692:                    ENDIF
  4693:                 endif
  4694:           
  4695:           c     if along the east boundary, test if the point is in triangle ij - g - d
  4696:           
  4697:                 if((i.eq.181).and.(mod(j,2).eq.0)) then
  4698:                    if((nd.ne.0).and.(ng.ne.0)) then
  4699:                       X2=lamdag
  4700:                       X3=lamdad
  4701:                       Y2=phig
  4702:                       Y3=phid
  4703:                       AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4704:                       A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4705:                       A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4706:                       A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4707:                       AA=ABS(A1)+ABS(A2)+ABS(A3)
  4708:                       AE=ABS(AA-AREAS)/AREAS
  4709:           c     write(333,*) "AE = ",AE
  4710:                       IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4711:                          NN1=n
  4712:                          NN2=ng
  4713:                          NN3=nd
  4714:                          DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4715:                          DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4716:                          DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4717:                          call betaucalc(i,j,DD1,ig,jg,DD2,id,jd,DD3,betau)
  4718:                          ifflag=ifflag+1
  4719:           c     write(333,*) 'position found in triangle ij - g - d'
  4720:                       ENDIF
  4721:                    endif
  4722:                 endif
  4723:           
  4724:           c     test if the point is in triangle ij - e - d
  4725:           
  4726:                 if((nd.ne.0).and.(ne.ne.0)) then
  4727:                    X2=lamdae
  4728:                    X3=lamdad
  4729:                    Y2=phie
  4730:                    Y3=phid
  4731:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4732:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4733:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4734:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4735:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4736:                    AE=ABS(AA-AREAS)/AREAS
  4737:           c     write(333,*) "AE = ",AE
  4738:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4739:                       NN1=n
  4740:                       NN2=ne
  4741:                       NN3=nd
  4742:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4743:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4744:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4745:                       call betaucalc(i,j,DD1,ie,je,DD2,id,jd,DD3,betau)
  4746:                       ifflag=ifflag+1
  4747:           c     write(333,*) 'position found in triangle ij - e - d'
  4748:                    ENDIF
  4749:                 endif
  4750:           
  4751:           c     test if the point is in triangle ij - g - e
  4752:           
  4753:                 if((ne.ne.0).and.(ng.ne.0)) then
  4754:                    X2=lamdag
  4755:                    X3=lamdae
  4756:                    Y2=phig
  4757:                    Y3=phie
  4758:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4759:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4760:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4761:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4762:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4763:                    AE=ABS(AA-AREAS)/AREAS
  4764:           c     write(333,*) "AE = ",AE
  4765:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4766:                       NN1=n
  4767:                       NN2=ng
  4768:                       NN3=ne
  4769:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4770:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4771:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4772:                       call betaucalc(i,j,DD1,ig,jg,DD2,ie,je,DD3,betau)
  4773:                       ifflag=ifflag+1
  4774:           c     write(333,*) 'position found in triangle ij - g - e'
  4775:                    ENDIF
  4776:                 endif
  4777:           
  4778:           c     test if the point is in triangle ij - a - g
  4779:           
  4780:                 if((na.ne.0).and.(ng.ne.0)) then
  4781:                    X2=lamdaa
  4782:                    X3=lamdag
  4783:                    Y2=phia
  4784:                    Y3=phig
  4785:                    AREAS=ABS((X1-X3)*(Y2-Y3)+(X3-X2)*(Y1-Y3))
  4786:                    A1=(X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4)
  4787:                    A2=(X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1)
  4788:                    A3=(Y4-Y1)*(X2-X1)-(X4-X1)*(Y2-Y1)
  4789:                    AA=ABS(A1)+ABS(A2)+ABS(A3)
  4790:                    AE=ABS(AA-AREAS)/AREAS
  4791:           c     write(333,*) "AE = ",AE
  4792:                    IF((AE.LT.1.0d-5).AND.(AE.LT.AEMIN)) THEN
  4793:                       NN1=n
  4794:                       NN2=na
  4795:                       NN3=ng
  4796:                       DD1=((X4-X3)*(Y2-Y3)+(X2-X3)*(Y3-Y4))/AREAS
  4797:                       DD2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREAS
  4798:                       DD3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREAS
  4799:                       call betaucalc(i,j,DD1,ia,ja,DD2,ig,jg,DD3,betau)
  4800:                       ifflag=ifflag+1
  4801:           c     write(333,*) 'position found in triangle ij - a - g'
  4802:                    ENDIF
  4803:                 endif
  4804:           
  4805:           c      if(ifflag.eq.0) then
  4806:           c         write(333,*) 'position not found'
  4807:           c        if (myproc == 0) then
  4808:           c         write(screenunit,*) 'position not found in subroutine E29SEARCH'
  4809:           c        endif
  4810:           c        icode=3
  4811:           c      else
  4812:           c        if (myproc == 0) then
  4813:           c         write(screenunit,*) 'i,j,NN1,NN2,NN3,DD1,DD2,DD3'
  4814:           c        endif
  4815:           c         write(333,999) i,j,NN1,NN2,NN3,DD1,DD2,DD3,betau/dgtora
  4816:           c 999     format(5I8,1x,3E13.6)
  4817:           c      endif
  4818:           
  4819:                 return
  4820:                 end subroutine


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29SEARCH
INLINE LIST

  ROOT: WIND::E29SEARCH (wind.F:4364)
  -> INLINE: WIND::E29CALC (wind.F:4468)
  -> INLINE: WIND::E29CALC (wind.F:4484)
  -> INLINE: WIND::E29CALC (wind.F:4494)
  -> INLINE: WIND::E29CALC (wind.F:4510)
  -> INLINE: WIND::E29CALC (wind.F:4526)
  -> INLINE: WIND::E29CALC (wind.F:4536)
  -> INLINE: WIND::E29CALC (wind.F:4552)
  -> INLINE: WIND::BETAUCALC (wind.F:4606)
   -> INLINE: WIND::E29CALC (wind.F:4958)
  -> INLINE: WIND::BETAUCALC (wind.F:4634)
   -> INLINE: WIND::E29CALC (wind.F:4958)
  -> INLINE: WIND::BETAUCALC (wind.F:4662)
   -> INLINE: WIND::E29CALC (wind.F:4958)
  -> INLINE: WIND::BETAUCALC (wind.F:4689)
   -> INLINE: WIND::E29CALC (wind.F:4958)
  -> NOINLINE: WIND::BETAUCALC (wind.F:4717)
     *** Inline halted: code size exceeds limit.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29SEARCH
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29SEARCH
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2848 bytes
      Register spill area      : 1272 bytes
      Parameter area           :   80 bytes
      Register save area       :  176 bytes
      User data area           : 1320 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29CALC
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  No diagnostic message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29CALC
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4831:                 subroutine e29calc(i,j,lamda,phi,n)
  4832:                 implicit none
  4833:                 integer i,j,n,nwlon,nwlat,im2,jm2,i1,i2,i1p1,i1m1,i2p1,i2m1,
  4834:                &     i3p1,i3m1
  4835:                 real(8) lamda,phi,phii,dlon,dlat,dlnt,arg,betau1,betau2,betau3
  4836:                 real(8) lamda0,phi0,rphi0,cphi0,sphi0,tphi0,dlamda,dphi,rdlamda,
  4837:                &     rdphi,a,rlamar,phiarg,rlamda,dgtora
  4838:           c
  4839:                 nwlon=181
  4840:                 nwlat=271
  4841:                 dgtora=deg2rad
  4842:                 lamda0=-97.0d0
  4843:                 phi0=41.0d0
  4844:                 rphi0=dgtora*phi0
  4845:                 cphi0=cos(rphi0)
  4846:                 sphi0=sin(rphi0)
  4847:                 tphi0=tan(rphi0)
  4848:                 dlamda=7.d0/36.d0
  4849:                 dphi=5.d0/27.d0
  4850:                 rdlamda=dgtora*dlamda
  4851:                 rdphi=dgtora*dphi
  4852:           c
  4853:                 jm2=(nwlat+1)/2
  4854:                 im2=nwlon*2
  4855:           c
  4856:                 phii=rdphi*real(j-jm2,kind=8)
  4857:                 i1=2*i-1
  4858:                 i2=2*i
  4859:                 if(mod(j,2).ne.0) then
  4860:                    rlamda=rdlamda*real(i2-nwlon,kind=8)
  4861:                 else
  4862:                    rlamda=rdlamda*real(i1-nwlon,kind=8)
  4863:                 endif
  4864:                 phiarg= sin(phii)*cphi0+cos(phii)*sphi0*cos(rlamda)
  4865:                 if(phiarg.gt.1.0d0) phiarg=1.0d0
  4866:                 if(phiarg.lt.-1.0d0) phiarg=-1.0d0
  4867:                 phi=asin(phiarg)
  4868:                 rlamar= cos(phii)*cos(rlamda)/(cos(phi)*cphi0)-tan(phi)*tphi0
  4869:                 if(rlamar.gt.1.0d0) rlamar=1.0d0
  4870:                 if(rlamar.lt.-1.d0) rlamar=-1.d0
  4871:                 a=acos(rlamar)/dgtora
  4872:                 if(rlamda.le.0.) then
  4873:                    lamda=lamda0-a
  4874:                 else
  4875:                    lamda=lamda0+a
  4876:                 endif
  4877:                 phi=phi/dgtora
  4878:                 n=nwlon*(j-1)+i
  4879:           C
  4880:                 return
  4881:                 end subroutine


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29CALC
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29CALC
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::E29CALC
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 30 [s0-s4 s8-s12 s15-s16 s18-s20 s23-s34 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 208 bytes
      Register spill area      :   8 bytes
      Parameter area           :   8 bytes
      Register save area       : 176 bytes
      User data area           :   8 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::BETAUCALC
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4910: inl(1222): Inlined: WIND::E29CALC
  4911: inl(1222): Inlined: WIND::E29CALC
  4912: inl(1222): Inlined: WIND::E29CALC
  4933: inl(1222): Inlined: WIND::E29CALC
  4934: inl(1222): Inlined: WIND::E29CALC
  4935: inl(1222): Inlined: WIND::E29CALC
  4956: inl(1222): Inlined: WIND::E29CALC
  4957: inl(1222): Inlined: WIND::E29CALC
  4958: inl(1222): Inlined: WIND::E29CALC


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::BETAUCALC
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4891:                 subroutine betaucalc(i1,j1,dd1,i2,j2,dd2,i3,j3,dd3,betau)
  4892:                 implicit none
  4893:                 integer i1,j1,i2,j2,i3,j3,n,i1p1,i1m1,i2p1,i2m1,i3p1,i3m1
  4894:                 real(8) dd1,dd2,dd3,betau
  4895:                 real(8) lamda,lamdap1,lamdam1,phi,phip1,phim1,dlon,dlat,
  4896:                &     dlnt,arg,betau1,betau2,betau3,dgtora
  4897:           c
  4898:                 dgtora=deg2rad
  4899:           c
  4900:                 if(i1.ne.181) then
  4901:                    i1p1=i1+1
  4902:                 else
  4903:                    i1p1=i1
  4904:                 endif
  4905:                 if(i1.ne.1) then
  4906:                    i1m1=i1-1
  4907:                 else
  4908:                    i1m1=i1
  4909:                 endif
  4910:         I       call e29calc(i1,j1,lamda,phi,n)
  4911:         I       call e29calc(i1p1,j1,lamdap1,phip1,n)
  4912:         I       call e29calc(i1m1,j1,lamdam1,phim1,n)
  4913:                 dlon=(lamdap1-lamdam1)*cos(phi*dgtora)
  4914:                 dlat=phip1-phim1
  4915:                 dlnt=sqrt(dlon*dlon+dlat*dlat)
  4916:                 arg=dlat/dlnt
  4917:                 if(arg.gt.1.d0) arg=1.d0
  4918:                 if(arg.lt.-1.d0) arg=-1.d0
  4919:                 betau1=asin(arg)
  4920:           c
  4921:                 if(i2.ne.181) then
  4922:                    i2p1=i2+1
  4923:                 else
  4924:                    i2p1=i2
  4925:                 endif
  4926:           c
  4927:                 if(i2.ne.1) then
  4928:                    i2m1=i2-1
  4929:                 else
  4930:                    i2m1=i2
  4931:                 endif
  4932:           c
  4933:         I       call e29calc(i2,j2,lamda,phi,n)
  4934:         I       call e29calc(i2p1,j2,lamdap1,phip1,n)
  4935:         I       call e29calc(i2m1,j2,lamdam1,phim1,n)
  4936:                 dlon=(lamdap1-lamdam1)*cos(phi*dgtora)
  4937:                 dlat=phip1-phim1
  4938:                 dlnt=sqrt(dlon*dlon+dlat*dlat)
  4939:                 arg=dlat/dlnt
  4940:                 if(arg.gt.1.d0) arg=1.d0
  4941:                 if(arg.lt.-1.d0) arg=-1.d0
  4942:                 betau2=asin(arg)
  4943:           c
  4944:                 if(i3.ne.181) then
  4945:                    i3p1=i3+1
  4946:                 else
  4947:                    i3p1=i3
  4948:                 endif
  4949:           c
  4950:                 if(i3.ne.1) then
  4951:                    i3m1=i3-1
  4952:                 else
  4953:                    i3m1=i3
  4954:                 endif
  4955:           c
  4956:         I       call e29calc(i3,j3,lamda,phi,n)
  4957:         I       call e29calc(i3p1,j3,lamdap1,phip1,n)
  4958:         I       call e29calc(i3m1,j3,lamdam1,phim1,n)
  4959:                 dlon=(lamdap1-lamdam1)*cos(phi*dgtora)
  4960:                 dlat=phip1-phim1
  4961:                 dlnt=sqrt(dlon*dlon+dlat*dlat)
  4962:                 arg=dlat/dlnt
  4963:                 if(arg.gt.1.d0) arg=1.d0
  4964:                 if(arg.lt.-1.d0) arg=-1.d0
  4965:                 betau3=asin(arg)
  4966:                 betau=dd1*betau1+dd2*betau2+dd3*betau3
  4967:           C
  4968:                 return
  4969:                 end subroutine


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::BETAUCALC
INLINE LIST

  ROOT: WIND::BETAUCALC (wind.F:4891)
  -> INLINE: WIND::E29CALC (wind.F:4910)
  -> INLINE: WIND::E29CALC (wind.F:4911)
  -> INLINE: WIND::E29CALC (wind.F:4912)
  -> INLINE: WIND::E29CALC (wind.F:4933)
  -> INLINE: WIND::E29CALC (wind.F:4934)
  -> INLINE: WIND::E29CALC (wind.F:4935)
  -> INLINE: WIND::E29CALC (wind.F:4956)
  -> INLINE: WIND::E29CALC (wind.F:4957)
  -> INLINE: WIND::E29CALC (wind.F:4958)


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::BETAUCALC
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::BETAUCALC
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 39 [s0-s12 s15-s16 s18-s35 s58-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 608 bytes
      Register spill area      : 208 bytes
      Parameter area           :   8 bytes
      Register save area       : 176 bytes
      User data area           : 208 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOLLANDGET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5015: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  5028: vec( 101): Vectorized loop.
  5035: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::GETHOLLANDSTORMDATA
  5041: vec( 101): Vectorized loop.
  5042: opt(1112): Loop fused with previous loop.
  5043: opt(1112): Loop fused with previous loop.
  5054: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  5115: vec( 103): Unvectorized loop.
  5115: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SPHERICALDISTANCE
  5121: inl(1212): Source for routine not found.: GLOBAL::SPHERICALDISTANCE
  5121: opt(1025): Reference to this procedure inhibits optimization.: GLOBAL::SPHERICALDISTANCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOLLANDGET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4991:                 SUBROUTINE HollandGet(WVNX,WVNY,PRESS,TIMELOC)
  4992:                 USE SIZES, ONLY : MyProc, LOCALDIR
  4993:                 USE MESH, ONLY : X, Y, SLAM, SFEA, NP, ICS
  4994:                 USE ADC_CONSTANTS, ONLY : RHOWAT0, G, mb2pa, omega
  4995:                 IMPLICIT NONE
  4996:                 REAL(8), intent(in) :: TIMELOC
  4997:                 REAL(8), intent(out), dimension(NP) :: WVNX,WVNY
  4998:                 REAL(8), intent(out), dimension(NP) :: PRESS
  4999:                 INTEGER I, J
  5000:                 REAL(8),SAVE,ALLOCATABLE :: RAD(:),DX(:),DY(:)
  5001:                 REAL(8),SAVE,ALLOCATABLE :: XCOOR(:),YCOOR(:) !lat and lon of nodes
  5002:                 REAL(8),SAVE,ALLOCATABLE :: V_r(:)            !wind sp. as fn. of dist
  5003:                 REAL(8),SAVE,ALLOCATABLE :: THETA(:)
  5004:                 REAL(8) :: TVX,TVY,RRP,RMW,A,B,WTRATIO
  5005:                 REAL(8) :: TransSpdX, TransSpdY
  5006:                 REAL(8) :: TM, cpress, lon, lat, spd
  5007:                 REAL(8) :: ts        ! storm translation speed, m/s
  5008:                 REAL(8) :: WindMultiplier         ! for storm 2 in LPFS ensemble
  5009:                 REAL(8) :: centralPressureDeficit ! difference btw ambient and cpress
  5010:           C
  5011:                 REAL(8) :: coriolis
  5012:           
  5013:                 LOGICAL, SAVE :: FIRSTCALL = .True.
  5014:           
  5015:                 call setMessageSource("hollandget")
  5016:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5017:                 call allMessage(DEBUG,"Enter.")
  5018:           #endif
  5019:           
  5020:           C
  5021:           C
  5022:                 IF (FIRSTCALL) THEN
  5023:                    FIRSTCALL = .False.
  5024:                    ALLOCATE (RAD(NP),DX(NP),DY(NP),XCOOR(NP),YCOOR(NP))
  5025:                    ALLOCATE (V_r(NP),THETA(NP))
  5026:           C
  5027:           C     The subroutine only works for ICS=2 (spherical coordinates)
  5028: V------>           DO I=1,NP
  5029: |                     XCOOR(I)=SLAM(I)*RAD2DEG
  5030: |                     YCOOR(I)=SFEA(I)*RAD2DEG
  5031: V------            END DO
  5032:                 ENDIF
  5033:           C
  5034:           C     Get data for this time step.
  5035:                 CALL GetHollandStormData(lat,lon,cpress,spd,rrp,rmw,
  5036:                &                         tvx,tvy,TIMELOC)
  5037:                 !
  5038:                 ! @jasonfleming: If this is a "CALM" period, set winds to zero
  5039:                 ! velocity and pressure equal to the background pressure and return.
  5040:                 if ( cpress.lt.0.d0 ) then
  5041: V------>           press(:) = PRBCKGRND * mb2pa / rhoWat0g ! convert mb to mH2O
  5042: |                  wvnx(:)=0.d0
  5043: V------            wvny(:)=0.d0
  5044:                    EyeLat(1) = EyeLat(2)
  5045:                    EyeLon(1) = EyeLon(2)
  5046:                    EyeLat(2) = EyeLat(3)
  5047:                    EyeLon(2) = EyeLon(3)
  5048:                    EyeLat(3) = lat
  5049:                    EyeLon(3) = lon
  5050:                    FoundEye = .true.
  5051:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5052:                    call allMessage(DEBUG,"Return.")
  5053:           #endif
  5054:                    call unsetMessageSource()
  5055:                    return
  5056:                 endif
  5057:           C
  5058:           C     jgf50.32: If we are using sector-based wind drag, record the location
  5059:           C     of the center of the storm.
  5060:                 IF ((lat.ne.EyeLat(3)).or.(lon.ne.EyeLon(3))) THEN
  5061:                    EyeLat(1) = EyeLat(2)
  5062:                    EyeLon(1) = EyeLon(2)
  5063:                    EyeLat(2) = EyeLat(3)
  5064:                    EyeLon(2) = EyeLon(3)
  5065:                    EyeLat(3) = lat
  5066:                    EyeLon(3) = lon
  5067:                    FoundEye = .true.
  5068:                 ENDIF
  5069:           C
  5070:           C     Calculate and limit central pressure deficit; some track files
  5071:           C     (e.g., Charley 2004) may have a central pressure greater than the
  5072:           C     ambient pressure that this subroutine assumes
  5073:           
  5074:           C     jgf51.14: Apply a factor of 100.0 to convert PRBCKGRND from
  5075:           C     mb to pa for use in this subroutine.
  5076:                 centralPressureDeficit = PRBCKGRND * 100.d0 - cpress
  5077:                 IF ( centralPressureDeficit .lt. 100.d0 ) THEN
  5078:                    centralPressureDeficit = 100.d0
  5079:                 ENDIF
  5080:           C
  5081:           C     jgf46.29 Subtract the translational speed of the storm from the
  5082:           C     observed max wind speed to avoid distortion in the Holland curve
  5083:           C     fit. The translational speed will be added back later.
  5084:                 ts=sqrt(tvx*tvx+tvy*tvy)
  5085:                 spd=spd-ts
  5086:           C
  5087:           C     Convert wind speed from 10 meter altitude (which is what the
  5088:           C     NHC forecast contains) to wind speed at the top of the atmospheric
  5089:           C     boundary layer (which is what the Holland curve fit requires).
  5090:                 spd=spd/BLAdj
  5091:           C
  5092:           C     Calculate Holland parameters and limit the result to its appropriate
  5093:           C     range.
  5094:                 B = rhoAir*e*(spd**2.d0)/(centralPressureDeficit)
  5095:                 IF (B.lt.1.0d0) B=1.0d0
  5096:                 IF (B.gt.2.5d0) B=2.5d0
  5097:           C
  5098:           C     Calculate Holland A parameter. (jgf46.32jgf4 commented out)
  5099:           C      A = (RMW*1000.d0)**B
  5100:           C
  5101:           #ifdef DEBUG_HOLLAND
  5102:                 WRITE(16,4321) B
  5103:            4321 FORMAT(/,2x,'Holland B parameter is ',e16.8)
  5104:           #endif
  5105:           C     jgf46.28 If we are running storm 2 in the Lake Pontchartrain
  5106:           C     Forecast System ensemble, the final wind speeds should be
  5107:           C     multiplied by 1.2.
  5108:                 IF (StormNumber.eq.2) THEN
  5109:                    WindMultiplier=1.2d0
  5110:                 ELSE
  5111:                    WindMultiplier=1.0d0
  5112:                 ENDIF
  5113:           C
  5114:           C     Calculate wind velocity and pressure at each node.
  5115: +------>        DO I=1,NP
  5116: |                  DX(I)=(XCOOR(I)-lon)*DEG2RAD
  5117: |                  DY(I)=(YCOOR(I)-lat)*DEG2RAD
  5118: |                  THETA(I)=ATAN2(DY(I),DX(I))
  5119: |         C     RJW v48.45
  5120: |         C     Compute the distances based on haversine formula for distance along a sphere
  5121: |                  rad(i) = sphericalDistance(DX(I),DY(I),lat, ycoor(i))
  5122: |         C     Compute coriolis
  5123: |                  coriolis = 2.0d0 * omega * sin(YCOOR(I)*DEG2RAD)
  5124: |         C     Compute pressure field
  5125: |         !P.V 11/04/2022 to account for Southern Hemisphere
  5126: |         !         PRESS(I)=(cpress+(centralPressureDeficit)*
  5127: |         !     &        EXP(-(RMW*1000.d0/RAD(I))**B)) / (RHOWAT0*G)
  5128: |                  PRESS(I)=cpress+(centralPressureDeficit)*
  5129: |              &        EXP(-(RMW*1000.d0/RAD(I))**B)
  5130: |         C     Compute velocity field with absolute around
  5131: |         C     CORIOLIS for the Southern Hempisphere
  5132: |                  V_r(I) = sqrt(
  5133: |              &        (RMW*1000.d0/RAD(I))**B *
  5134: |              &        EXP(1.d0-(RMW*1000.d0/RAD(I))**B)*spd**2.d0
  5135: |              &        + (RAD(I)**2.d0)*(CORIOLIS**2.d0)/4.d0
  5136: |              &        )
  5137: |              &        - RAD(I)*ABS(CORIOLIS)/2.d0
  5138: |         C
  5139: |         C     jgf46.31 Determine translation speed that should be added to final
  5140: |         C     storm wind speed. This is tapered to zero as the storm wind tapers
  5141: |         C     to zero toward the eye of the storm and at long distances from the
  5142: |         C     storm.
  5143: |                  TransSpdX = (abs(V_r(I))/spd)*TVX
  5144: |                  TransSpdY = (abs(V_r(I))/spd)*TVY
  5145: |         C     Apply mutliplier for Storm2 in LPFS ensemble.
  5146: |                  V_r(I) = V_r(I) * WindMultiplier
  5147: |         C
  5148: |         C     Find the velocity components.
  5149: |         !P.V 11/04/2022 to account for Southern Hemisphere
  5150: |                 !WVNX(I)=-V_r(I)*SIN(THETA(I))
  5151: |                 !WVNY(I)= V_r(I)*COS(THETA(I))
  5152: |                 ! Find the wind velocity components (caution to SH/NH)
  5153: |                 if(lat.lt.0.d0) then ! SH
  5154: |                  WVNX(I)= V_r(I)*SIN(THETA(I))
  5155: |                  WVNY(I)=-V_r(I)*COS(THETA(I))
  5156: |                 else ! NH
  5157: |                  WVNX(I)=-V_r(I)*SIN(THETA(I))
  5158: |                  WVNY(I)= V_r(I)*COS(THETA(I))
  5159: |                 endif
  5160: |          
  5161: |         C
  5162: |         C     jgf46.19 Convert wind velocity from top of atmospheric boundary
  5163: |         C     layer (which is what the Holland curve fit produces) to wind
  5164: |         C     velocity at 10m above the earth's surface (factor of
  5165: |         C     0.7).
  5166: |                  WVNX(I)=WVNX(I)*BLAdj
  5167: |                  WVNY(I)=WVNY(I)*BLAdj
  5168: |         C
  5169: |         C     jgf46.21 Also convert from 1 minute averaged winds to 10
  5170: |         C     minute averaged winds (0.88 factor).
  5171: |                  WVNX(I)=WVNX(I)*one2ten
  5172: |                  WVNY(I)=WVNY(I)*one2ten
  5173: |         C
  5174: |         C     jgf46.31 Add the storm translation speed.
  5175: |                  WVNX(I)=WVNX(I)+TransSpdX
  5176: |                  WVNY(I)=WVNY(I)+TransSpdY
  5177: |         C
  5178: |         C     jgf46.31 Set the wind velocities to zero outside the last closed
  5179: |         C     isobar.
  5180: |         C         IF (RAD(I).gt.rrp) THEN
  5181: |         C            WVNX(I)=0.0d0
  5182: |         C            WVNY(I)=0.0d0
  5183: |         C         ENDIF
  5184: |         C
  5185: |         !P.V 11/04/2022
  5186: |                 PRESS(I) = max(0.85d5,min(1.1e5,PRESS(I))) !Typhoon Tip 870 hPa ... 12-oct-1979
  5187: |                 WVNX(I)  = max(-200.d0,min(200.d0,WVNX(I)))
  5188: |                 WVNY(I)  = max(-200.d0,min(200.d0,WVNY(I)))
  5189: |                 !-------------------------------------------
  5190: |                 ! Convert atmospheric pressure (Pascals) to
  5191: |                 ! atmospheric pressure-induced water surface
  5192: |                 ! elevation (meters).
  5193: |                 !-------------------------------------------
  5194: |                 PRESS(I) = PRESS(I) / (RHOWAT0*G)
  5195: |         
  5196: +------         END DO
  5197:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5198:                 call allMessage(DEBUG,"Return.")
  5199:           #endif
  5200:                 call unsetMessageSource()
  5201:           C     ----------------------------------------------------------------
  5202:                 END SUBROUTINE HollandGet


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOLLANDGET
INLINE LIST

  ROOT: WIND::HOLLANDGET (wind.F:4991)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:5015)
     *** Source for routine not found.
  -> NOINLINE: WIND::GETHOLLANDSTORMDATA (wind.F:5035)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:5054)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:5121)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:5200)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOLLANDGET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:5028)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5028)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:5028)
  LOOP END

  LOOP BEGIN: (wind.F:5115)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : GLOBAL::SPHERICALDISTANCE (wind.F:5115)
  LOOP END

  LOOP BEGIN: (wind.F:5041)
    <Vectorized loop.>
    **  Fused loop. (wind.F:5041)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5041)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:5041)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:11 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HOLLANDGET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 56 [s0-s12 s15-s16 s18-s44 s50-s63]
      Vector registers         :  6 [v58-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 800 bytes
      Register spill area      : 240 bytes
      Parameter area           :  72 bytes
      Register save area       : 176 bytes
      User data area           : 304 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:5028)
    *** Estimated execution cycle                       : 164
  LOOP END

  LOOP BEGIN: (wind.F:5115)
    *** Estimated execution cycle                       : 358
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 24
            Across calls                                : 22
            Over basic blocks                           :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 48
            Across calls                                : 23
            Over basic blocks                           : 25
    *** The number of SCALAR REGISTER TRANSFER          : 44
  LOOP END

  LOOP BEGIN: (wind.F:5041)
    *** Estimated execution cycle                       : 130
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETHOLLANDSTORMDATA
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5247: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  5259: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  5259: vec( 103): Unvectorized loop.
  5259: vec( 108): Unvectorizable loop structure.
  5261: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  5264: inl(1222): Inlined: WIND::WINDTERMINATE
  5267: vec( 103): Unvectorized loop.
  5267: vec( 180): I/O statement obstructs vectorization.
  5267: vec( 108): Unvectorizable loop structure.
  5288: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  5288: vec( 180): I/O statement obstructs vectorization.
  5288: vec( 181): Allocation obstructs vectorization.
  5288: vec( 182): Deallocation obstructs vectorization.
  5288: vec( 118): Unvectorizable data type.
  5288: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  5288: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  5288: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  5288: vec( 109): Vectorization obstructive statement.
  5288: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  5288: vec( 108): Unvectorizable loop structure.
  5297: opt(3014): Moved reference within a conditional branch.
  5309: vec( 103): Unvectorized loop.
  5309: vec( 108): Unvectorizable loop structure.
  5330: inl(1222): Inlined: WIND::TIMECONV
   877: inl(1222): Inlined: WIND::WINDTERMINATE
  5358: inl(1222): Inlined: WIND::TIMECONV
  5374: inl(1222): Inlined: WIND::WINDTERMINATE
  5397: inl(1222): Inlined: WIND::TIMECONV
  5410: inl(1222): Inlined: WIND::WINDTERMINATE
  5462: vec( 101): Vectorized loop.
  5463: vec( 101): Vectorized loop.
  5464: vec( 103): Unvectorized loop.
  5464: vec( 110): Vectorization obstructive procedure reference.: VORTEX::UVTRANS
  5467: inl(1212): Source for routine not found.: VORTEX::UVTRANS
  5467: opt(1025): Reference to this procedure inhibits optimization.: VORTEX::UVTRANS
  5483: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  5483: vec( 103): Unvectorized loop.
  5483: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  5483: vec( 182): Deallocation obstructs vectorization.
  5483: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  5483: vec( 109): Vectorization obstructive statement.
  5483: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  5483: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  5483: vec( 108): Unvectorizable loop structure.
  5495: inl(1222): Inlined: WIND::WINDTERMINATE
  5506: inl(1222): Inlined: WIND::WINDTERMINATE
  5527: inl(1222): Inlined: WIND::WINDTERMINATE
  5535: vec( 103): Unvectorized loop.
  5535: vec( 108): Unvectorizable loop structure.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETHOLLANDSTORMDATA
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  5218:                 SUBROUTINE GetHollandStormData(LatOut,LonOut,CPressOut,SpdOut,
  5219:                &     RRPOut,RMWOut,TVXOut,TVYOut,TIMELOC)
  5220:                 USE SIZES, ONLY : MyProc, GBLINPUTDIR
  5221:                 USE GLOBAL, ONLY : RNDAY
  5222:                 USE VORTEX, ONLY : uvtrans
  5223:                 IMPLICIT NONE
  5224:                 REAL(8),intent(in) :: TIMELOC
  5225:                 REAL(8),intent(out) :: LatOut, LonOut, CPressOut
  5226:                 REAL(8),intent(out) :: SpdOut, RRPOut, RMWOut, TVXOut, TVYOut
  5227:           C
  5228:                 INTEGER, ALLOCATABLE, SAVE :: iYear(:),iMth(:),iDay(:),iHr(:)
  5229:                 INTEGER, ALLOCATABLE, SAVE :: iLat(:),iLon(:)
  5230:                 CHARACTER(1), ALLOCATABLE, SAVE :: ns(:), ew(:)
  5231:                 INTEGER, ALLOCATABLE, SAVE :: iSpd(:),iCPress(:),iRRP(:),iRMW(:)
  5232:                 REAL(8), ALLOCATABLE, SAVE :: Lat(:),Lon(:),Spd(:)
  5233:                 REAL(8), ALLOCATABLE, SAVE :: CPress(:),RRP(:),RMW(:)
  5234:                 REAL(8), ALLOCATABLE, SAVE :: TVX(:), TVY(:)      ! jgf46.32jgf9
  5235:                 CHARACTER(len=4), ALLOCATABLE, SAVE :: CastType(:) !hindcast,forecast
  5236:                 INTEGER, ALLOCATABLE, SAVE :: iFcstInc(:) ! hours
  5237:                 REAL(8), ALLOCATABLE, SAVE :: FcstInc(:) ! seconds
  5238:                 REAL(8),SAVE :: WTRATIO          !time ratio used for interpolation
  5239:                 REAL(8), ALLOCATABLE, SAVE :: CastTime(:) ! seconds since start of year
  5240:                 INTEGER,SAVE :: iNowcastCPress, iNowcastRRP, iNowcastRMW
  5241:                 LOGICAL,SAVE :: FIRSTCALL = .True.
  5242:                 INTEGER,SAVE :: i  ! Current array counter for fort.22 file
  5243:                 INTEGER,SAVE :: nl ! Number of lines in the fort.22 file
  5244:                 INTEGER,SAVE :: pl ! populated length of Holland Data array
  5245:                 INTEGER :: j ! loop counter
  5246:                 INTEGER :: ios ! return code for an i/o operation
  5247:                 call setMessageSource("getHollandStormData")
  5248:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5249:                 call allMessage(DEBUG,"Enter.")
  5250:           #endif
  5251:           
  5252:           C     ------------------------------------------------------
  5253:           C     BEGIN Code executed upon first call to this subroutine
  5254:           C     ------------------------------------------------------
  5255:                 IF (FIRSTCALL) THEN
  5256:           C
  5257:           C     Determine the number of lines in the file.
  5258:                    nl=0
  5259:                    call openFileForRead(22,TRIM(GBLINPUTDIR)//'/'//'fort.22',ios)
  5260:                    if ( ios.gt.0 ) then
  5261:                       call allMessage(ERROR,
  5262:                &       "The symmetric vortex parameter file was not found. "
  5263:                &       //"ADCIRC terminating.")
  5264:         I             call windTerminate()
  5265:                    endif
  5266:           
  5267: +------>           DO
  5268: |                     READ(UNIT=22,FMT='(A170)',END=8888)
  5269: |                     nl=nl+1
  5270: +------            ENDDO
  5271:            8888    REWIND(22)
  5272:           C
  5273:           C     Dimension the arrays according to the number of lines in the file,
  5274:           C     this will be greater than or equal to the size of the array we need
  5275:           C     (probably greater because of the repeated lines that we throw away)
  5276:                    ALLOCATE(iYear(nl),iMth(nl),iDay(nl),iHr(nl),iLat(nl),iLon(nl),
  5277:                &        iSpd(nl),iCpress(nl),iRRP(nl),iRMW(nl),iFcstInc(nl))
  5278:                    ALLOCATE(ns(nl),ew(nl))
  5279:                    ALLOCATE(Lat(nl),Lon(nl),Spd(nl),CPress(nl),RRP(nl),RMW(nl),
  5280:                &        FcstInc(nl),TVX(nl),TVY(nl))
  5281:                    ALLOCATE(CastType(nl))
  5282:                    ALLOCATE(CastTime(nl))
  5283:           C
  5284:           C     Now read the data into the arrays. The first
  5285:           C     line must be a hindcast/nowcast.
  5286:                    i=1
  5287:           C
  5288: +------>           DO
  5289: |         C     Get another line of data from the file and check to see if the
  5290: |         C     line represents a new point in time, or is a repeated time
  5291: |         C     point. Repeated time points occur in hindcasts for the purpose of
  5292: |         C     describing winds in the quadrants of the storm. We don't use the
  5293: |         C     quadrant-by-quadrant wind data. Repeated time data occur in the
  5294: |         C     forecast because the time data is just the time that the forecast
  5295: |         C     was made. The important parameter in the forecast file is the
  5296: |         C     forecast increment.
  5297: |                     READ(UNIT=22,FMT=228,END=9999)
  5298: |              &           iYear(i),iMth(i),iDay(i),iHr(i),
  5299: |              &           CastType(i),iFcstInc(i),iLat(i),ns(i),iLon(i),ew(i),
  5300: |              &           iSpd(i),iCPress(i),iRRP(i),iRMW(i)
  5301: |         
  5302: |         C                yr,mo,dy,hr, ,type, inc,  lat,NS,  lon,EW,  spd,   pc,
  5303: |          228        format(8x,i4,i2,i2,i2,6x,a4,2x,i3,1x,i4,a1,2x,i4,a1,2x,i3,2x,i4,
  5304: |              &     47x,i3,2x,i3)
  5305: |         C              RRP,  RMW
  5306: |         
  5307: |         C
  5308: |         C
  5309: |                     SELECT CASE(trim(CastType(i)))
  5310: |         C           ------------
  5311: |                     CASE("BEST")     ! nowcast/hindcast
  5312: |         C           ------------
  5313: |         C     Check to see if this is a repeated line. If so, go directly to the
  5314: |         C     next line without any processing.
  5315: |                        IF (i.gt.1) THEN
  5316: |                        IF ( iYear(i).eq.iYear(i-1).and.iMth(i).eq.iMth(i-1).and.
  5317: |              &              iDay(i).eq.iDay(i-1).and.iHr(i).eq.iHr(i-1)) THEN
  5318: |                           CYCLE
  5319: |                        ENDIF
  5320: |                        ENDIF
  5321: |         C
  5322: |         C     Save the central pressure, radius of last closed isobar, and
  5323: |         C     radius to max wind for use in forecasts
  5324: |                        iNowcastCPress=iCPress(i)
  5325: |                        iNowcastRMW=iRMW(i)
  5326: |                        iNowcastRRP=iRRP(i)
  5327: |         C
  5328: |         C     Determine the time of this hindcast in seconds since the beginning
  5329: |         C     of the year.
  5330: |                        CALL TimeConv(iYear(i),iMth(i),iDay(i),iHr(i),0,0.d0,
  5331: |              &              CastTime(i))
  5332: |         C
  5333: |         C     Determine the CastTime in seconds since the beginning of the simulation.
  5334: |                        CastTime(i)=CastTime(i)-WindRefTime
  5335: |                        FcstInc(i)=iFcstInc(i)
  5336: |         C
  5337: |         C           ------------
  5338: |                     CASE("OFCL")        ! forecast
  5339: |         C           ------------
  5340: |         C     Check to see if this is a repeated line (i.e., a forecast that
  5341: |         C     coincides with the nowcast, or a repeated forecast). If so, go
  5342: |         C     directly to the next line without any processing.
  5343: |                        IF (i.gt.1 ) THEN
  5344: |                        IF ((iFcstInc(i).eq.0.and.
  5345: |              &              (iYear(i).eq.iYear(i-1).and.iMth(i).eq.iMth(i-1)
  5346: |              &              .and.iDay(i).eq.iDay(i-1).and.iHr(i).eq.iHr(i-1)))
  5347: |              &              .or.
  5348: |              &             (iFcstInc(i).ne.0.and.iFcstInc(i).eq.iFcstInc(i-1)))
  5349: |              &              THEN
  5350: |                           CYCLE
  5351: |                        ENDIF
  5352: |                        ENDIF
  5353: |                        FcstInc(i) = iFcstInc(i)
  5354: |         C
  5355: |         C     Determine the time of this forecast in seconds since the beginning
  5356: |         C     of the year.
  5357: |                        IF ( iFcstInc(i).eq.0 ) THEN
  5358: |                           CALL TimeConv(iYear(i),iMth(i),iDay(i),iHr(i),0,0.d0,
  5359: |              &                 CastTime(i))
  5360: |                           CastTime(i)=CastTime(i)-WindRefTime
  5361: |                        ELSE
  5362: |                           FcstInc(i) = FcstInc(i) * 3600.d0 ! convert hours to seconds
  5363: |                           CastTime(i) = CastTime(i-1) +
  5364: |              &                 ( FcstInc(i) - FcstInc(i-1) )
  5365: |                        ENDIF
  5366: |         C
  5367: |         C     jgf48.4637 If the forecast values of central pressure or RMW are
  5368: |         C     zero (and they will be if unless the user has filled them in, because
  5369: |         C     the NHC does not forecast these parameters), exit with a fatal error.
  5370: |                        IF ( (iCPress(i).eq.0).or.(iRMW(i).eq.0) ) THEN
  5371: |                           call allMessage(ERROR,
  5372: |              &            'The storm hindcast/forecast input file (unit 22) '//
  5373: |              &            'contains invalid data for central pressure or Rmax.')
  5374: |                           call windTerminate()
  5375: |                        endif
  5376: |         C
  5377: |               ! @jasonfleming: Adding a new type to allow the analyst to add lines
  5378: |               ! that do nothing but produce zero winds and background barometric
  5379: |               ! pressure. These lines can have a date/time like a BEST line or
  5380: |               ! a date/time and forecast period like an OFCL line.
  5381: |                     CASE("CALM")
  5382: |                        call allMessage(ECHO,
  5383: |              &            'The fort.22 file contains at least one "CALM" line.')
  5384: |                        IF (i.gt.1 ) THEN
  5385: |                        IF ((iFcstInc(i).eq.0.and.
  5386: |              &              (iYear(i).eq.iYear(i-1).and.iMth(i).eq.iMth(i-1)
  5387: |              &              .and.iDay(i).eq.iDay(i-1).and.iHr(i).eq.iHr(i-1)))
  5388: |              &              .or.
  5389: |              &             (iFcstInc(i).ne.0.and.iFcstInc(i).eq.iFcstInc(i-1)))
  5390: |              &              THEN
  5391: |                           CYCLE
  5392: |                        ENDIF
  5393: |                        ENDIF
  5394: |                        FcstInc(i) = iFcstInc(i)
  5395: |         
  5396: |                        IF ( iFcstInc(i).eq.0 ) THEN
  5397: |                           CALL TimeConv(iYear(i),iMth(i),iDay(i),iHr(i),0,0.d0,
  5398: |              &                 CastTime(i))
  5399: |                           CastTime(i)=CastTime(i)-WindRefTime
  5400: |                        ELSE
  5401: |                           FcstInc(i) = FcstInc(i) * 3600.d0 ! convert hours to seconds
  5402: |                           CastTime(i) = CastTime(i-1) +
  5403: |              &                 ( FcstInc(i) - FcstInc(i-1) )
  5404: |                        ENDIF
  5405: |         
  5406: |                     CASE DEFAULT        ! unrecognized
  5407: |                        call allMessage(ERROR,
  5408: |              &          'Only "BEST", "OFCL", or "CALM" are allowed '//
  5409: |              &          'in the 5th column of fort.22.')
  5410: |                        call windTerminate()
  5411: |                     END SELECT
  5412: |         C
  5413: |         C     Convert integers to reals.
  5414: |                     Lat(i) = iLat(i)
  5415: |                     Lon(i) = iLon(i)
  5416: |                     Spd(i) = iSpd(i)
  5417: |       I             CPress(i) = iCPress(i)
  5418: |                     RRP(i) = iRRP(i)
  5419: |                     RMW(i) = iRMW(i)
  5420: |         C
  5421: |         C     Convert units.
  5422: |                     Lat(i) = Lat(i) / 10.d0 ! convert 10ths of degs to degs
  5423: |                     Lon(i) = Lon(i) / 10.d0 ! convert 10ths of degs to degs
  5424: |                     if ( ew(i).eq.'W' ) then
  5425: |                        Lon(i) = -1.d0 * Lon(i) ! negative b/c WEST longitude
  5426: |                     endif
  5427: |                     if ( ns(i).eq.'S' ) then
  5428: |       I                Lat(i) = -1.d0 * Lat(i) ! negative b/c SOUTH latitude
  5429: |                     endif
  5430: |                     CPress(i) = CPress(i) * 100.d0 ! convert mbar to Pa
  5431: |                     RRP(i) = RRP(i) * 1.852000003180799d0 * 1000.0d0 ! convert nm to m
  5432: |                     RMW(i) = RMW(i) * 1.852000003180799d0 ! convert nm to km
  5433: |                     Spd(i) = Spd(i) * 0.51444444d0 ! convert kts to m/s
  5434: |         C
  5435: |         #ifdef DEBUG_HOLLAND
  5436: |       I             WRITE(16,1244) CastTime(i),Lat(i),Lon(i),
  5437: |              &           Spd(i),CPress(i),RRP(i),RMW(i),WindRefTime
  5438: |                     if ( i.gt.1 ) then
  5439: |                        write(scratchMessage,2355) FcstInc(i-1)
  5440: |                        call logMessage(DEBUG, scratchMessage)
  5441: |                     endif
  5442: |          1244       FORMAT('DEBUG HOLLAND: CastTime ',
  5443: |              &           e16.8,' Lat ',f6.2,' Lon ',f6.2,
  5444: |              &           /,'Spd ',f8.2,' CPress ',f10.2,' RRP ',f12.2,
  5445: |              &           ' RMW ',f8.2, ' WindRefTime ',e16.8)
  5446: |          2355       format('FcstInc(i-1) ',e16.8)
  5447: |       I #endif
  5448: |         C
  5449: |         C     Save the number of non-repeated lines from the fort.22 file, this
  5450: |         C     is the populated length of the array.
  5451: |                     pl=i
  5452: |         C
  5453: |         C     Increment array counter
  5454: |                     i=i+1
  5455: |       I C
  5456: |                  ENDDO
  5457: |          9999    CLOSE(22)
  5458: |         C
  5459: |         C     Calculate storm translation velocities based on change in position, then
  5460: |         C     convert degrees/time to m/s
  5461: |                  ! initialize storm translation speeds
  5462: |                  TVX = 0.0
  5463: |                  TVY = 0.0
  5464: |                  DO i=2, pl
  5465: |         C     Calculate storm translation velocities based on change in position,
  5466: |                     ! approximate u and v translation velocities
  5467: |                     call uvTrans(lat(i-1),lon(i-1),
  5468: |              &                    lat(i),lon(i),
  5469: |              &                    CastTime(i-1),CastTime(i),
  5470: |              &                    tvx(i),tvy(i))
  5471: |         
  5472: |                  ENDDO
  5473: |                  ! extrapolate later storm translation speeds back to the
  5474: |                  ! first storm position
  5475: |                  IF ( pl.ge.2 ) THEN
  5476: |                     TVX(1) = TVX(2)
  5477: +------               TVY(1) = TVY(2)
  5478:                    ENDIF
  5479: V======>  C
  5480: V======>  C     Determine the correspondence between the current simulation time and
  5481: +------>  C     the fort.22 file.
  5482: |                  i=2
  5483: +------            DO
  5484:                       IF (ceiling(TIMELOC).ge.CastTime(i-1).and.
  5485:                &          floor(TIMELOC).lt.CastTime(i)) THEN
  5486:                          EXIT
  5487:                       ELSE
  5488:                          i=i+1
  5489: +------>                 IF (i.gt.pl) THEN
  5490: |                           call allMessage(ERROR,
  5491: |              &             "The Storm Hindcast/Forecast Input File (unit 22) "
  5492: |              &             //"does not contain times/dates that correspond "
  5493: |              &             //"to the ADCIRC current model time. "
  5494: |              &             //" ADCIRC terminating.")
  5495: |                           call windTerminate()
  5496: |       I                ENDIF
  5497: |                     ENDIF
  5498: |                  ENDDO
  5499: +------            FIRSTCALL = .False.
  5500:                 ENDIF
  5501:                 !
  5502:                 ! @jasonfleming: Check to see if there is enough data to cover
  5503:                 ! the whole run and bomb out immediately if there isn't.
  5504:                 if (castTime(pl).lt.RNDAY*86400.d0) then
  5505:                    call allMessage(ERROR,'The fort.22 file ends before RNDAY.')
  5506:         I          call windTerminate()
  5507:                 endif
  5508:           
  5509:           C     ----------------------------------------------------------
  5510:           C     END Code executed only upon first call to this subroutine
  5511:           C     ----------------------------------------------------------
  5512:           C
  5513:           C
  5514:           C     ----------------------------------------------------------
  5515:           C     BEGIN Code executed on every call to this subroutine
  5516:           C     ----------------------------------------------------------
  5517:           C
  5518:           C     If time exceeds the next hindcast/nowcast/forecast time, increment the
  5519:           C     array counter.
  5520:                 IF (TIMELOC.gt.CastTime(i)) THEN
  5521:                    i=i+1
  5522:           C        jgf51.14: Check to see that we haven't gone off the end of
  5523:           C        meteorological data.
  5524:                     IF (i.gt.pl) THEN
  5525:                        call allMessage(ERROR,'The simulation time has extended '//
  5526:                &          'beyond the end of the meteorological dataset.')
  5527:         I              call windTerminate()
  5528:                     ENDIF
  5529:                 ENDIF
  5530:           C
  5531:           C     Interpolate w.r.t. time
  5532:                 ! @jasonfleming: Add CALM handling.
  5533:                 LonOut = Lon(i-1) + WTRATIO*(Lon(i)-lon(i-1))
  5534:                 LatOut = Lat(i-1) + WTRATIO*(Lat(i)-lat(i-1))
  5535:                 if ( (trim(castType(i)).ne.'CALM').and.
  5536:                &      trim(castType(i-1)).ne.'CALM' ) then
  5537:                    WTRATIO=(TIMELOC-CastTime(i-1))/(CastTime(i)-CastTime(i-1))
  5538:                    CPressOut = CPress(i-1) + WTRATIO*(CPress(i)-CPress(i-1))
  5539:                    SpdOut = Spd(i-1) + WTRATIO*(Spd(i)-Spd(i-1))
  5540:                    RRPOut = RRP(i-1) + WTRATIO*(RRP(i)-RRP(i-1))
  5541:                    RMWOut = RMW(i-1) + WTRATIO*(RMW(i)-RMW(i-1))
  5542:                    TVXOut = TVX(i-1) + WTRATIO*(TVX(i)-TVX(i-1))
  5543:                    TVYOut = TVY(i-1) + WTRATIO*(TVY(i)-TVY(i-1))
  5544:                 else
  5545:                    CPressOut = -99999.d0
  5546:                    SpdOut = -99999.d0
  5547:                    RRPOut = -99999.d0
  5548:                    RMWOut = -99999.d0
  5549:                    TVXOut = -99999.d0
  5550:                    TVYOut = -99999.d0
  5551:                 endif
  5552:           C
  5553:           C     ----------------------------------------------------------
  5554:           C     END Code executed on every call to this subroutine
  5555:           C     ----------------------------------------------------------
  5556:            10   format(8x,i4,i2,i2,i2,6x,a4,7x,i3,4x,i3,3x,i3,2x,i4,52x,i3)
  5557:            12   format(8x,i4,i2,i2,i2,6x,a4,2x,i3,2x,i3,4x,i3,3x,i3,2x,i4,52x,i3)
  5558:            14   format(8x,i4,i2,i2,i2,6x,a4,2x,i3,1x,i4,3x,i4,3x,i3,2x,i4,47x,i3,
  5559:                &     2x,i3)
  5560:           
  5561:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5562:                 call allMessage(DEBUG,"Return.")
  5563:           #endif
  5564:                 call unsetMessageSource()
  5565:           
  5566:                 RETURN
  5567:           C     ----------------------------------------------------------------
  5568:                 END SUBROUTINE GetHollandStormData


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETHOLLANDSTORMDATA
INLINE LIST

  ROOT: WIND::GETHOLLANDSTORMDATA (wind.F:5218)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:5247)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:5259)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5261)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5264)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> INLINE: WIND::TIMECONV (wind.F:5330)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:856)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:875)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:877)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:883)
      *** Source for routine not found.
  -> INLINE: WIND::TIMECONV (wind.F:5358)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:856)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:875)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:877)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:883)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5371)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5374)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5382)
     *** Source for routine not found.
  -> INLINE: WIND::TIMECONV (wind.F:5397)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:856)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:875)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:877)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:883)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5407)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5410)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: VORTEX::UVTRANS (wind.F:5467)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5490)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5495)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5505)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5506)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:5525)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:5527)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:5564)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETHOLLANDSTORMDATA
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:5259)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:5259)
  LOOP END

  LOOP BEGIN: (wind.F:5267)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:5267)
    *** Unvectorizable loop structure. (wind.F:5267)
  LOOP END

  LOOP BEGIN: (wind.F:5288)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:5288)
    *** Allocation obstructs vectorization. (wind.F:5288)
    *** Deallocation obstructs vectorization. (wind.F:5288)
    *** Unvectorizable data type. (wind.F:5288)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:5288)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:5288)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:5288)
    *** Vectorization obstructive statement. (wind.F:5288)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:5288)
    *** Unvectorizable loop structure. (wind.F:5288)

    LOOP BEGIN: (wind.F:5309)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:5309)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:5462)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5462)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:5462)
  LOOP END

  LOOP BEGIN: (wind.F:5463)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5463)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:5463)
  LOOP END

  LOOP BEGIN: (wind.F:5464)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : VORTEX::UVTRANS (wind.F:5464)
  LOOP END

  LOOP BEGIN: (wind.F:5483)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:5483)
    *** Deallocation obstructs vectorization. (wind.F:5483)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:5483)
    *** Vectorization obstructive statement. (wind.F:5483)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:5483)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:5483)
    *** Unvectorizable loop structure. (wind.F:5483)
  LOOP END

  LOOP BEGIN: (wind.F:5535)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:5535)
  LOOP END

  LOOP BEGIN: (wind.F:5535)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:5535)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETHOLLANDSTORMDATA
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 59 [s0-s12 s15-s16 s18-s39 s42-s63]
      Vector registers         :  2 [v62-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3488 bytes
      Register spill area      :  872 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 2376 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:5259)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:5267)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:856)
    *** Estimated execution cycle                       : 2482
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 44
            Across calls                                : 11
            Over basic blocks                           : 32
            Others                                      :  1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 279
            Across calls                                :  11
            Over basic blocks                           : 268
    *** The number of SCALAR REGISTER TRANSFER          : 109

    LOOP BEGIN: (wind.F:5309)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:5462)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:5463)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:5464)
    *** Estimated execution cycle                       : 25
  LOOP END

  LOOP BEGIN: (wind.F:5483)
    *** Estimated execution cycle                       : 98
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER TRANSFER          : 13
  LOOP END

  LOOP BEGIN: (wind.F:5535)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:5535)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS67GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5632: vec( 101): Vectorized loop.
  5670: vec( 101): Vectorized loop.
  5671: vec( 101): Vectorized loop.
  5672: vec( 101): Vectorized loop.
  5673: vec( 101): Vectorized loop.
  5673: vec( 128): Fused multiply-add operation applied.
  5674: vec( 101): Vectorized loop.
  5677: vec( 101): Vectorized loop.
  5684: vec( 128): Fused multiply-add operation applied.
  5685: vec( 128): Fused multiply-add operation applied.
  5693: vec( 128): Fused multiply-add operation applied.
  5694: vec( 128): Fused multiply-add operation applied.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS67GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  5605:                 SUBROUTINE NWS67GET  (X,Y,SLAM,SFEA,WVNX,WVNY,PRESS,NP,ICS,
  5606:                &     RHOWAT0,G,TIMELOC,WTIMINC,WTIME1,WTIME2)
  5607:                 USE SIZES
  5608:                 IMPLICIT NONE
  5609:                 REAL(8), PARAMETER :: Ambient_Pressure=101300.d0      !   Pascals!!
  5610:                 REAL(8), PARAMETER :: Coriolis=7.287588493541447D-05  ! 1/sec
  5611:                 REAL(8), PARAMETER :: Rho_Air = 1.15d0                ! kg/ m/m/m
  5612:                 INTEGER, SAVE :: FIRSTCALL = 0
  5613:                 INTEGER NP,I,J,ICS
  5614:                 REAL(8) RHOWAT0,G,WTIME1,WTIME2,TIMELOC,WTIMINC
  5615:                 REAL(8) X(*),Y(*),SLAM(*),SFEA(*)
  5616:                 REAL(8) WVNX(*),WVNY(*),PRESS(*)
  5617:           ! LOCAL VARIABLES
  5618:                 REAL(8),SAVE,ALLOCATABLE :: RAD(:),DX(:),DY(:),XCOOR (:),YCOOR(:)
  5619:                 REAL(8),SAVE,ALLOCATABLE :: EARG(:)
  5620:                 REAL(8),SAVE,ALLOCATABLE :: VG(:),THETA(:)
  5621:                 REAL(8),SAVE :: XC1,YC1,DP1,TVX1,TVY1,RMW1,A1,B1
  5622:                 REAL(8),SAVE :: XC2,YC2,DP2,TVX2,TVY2,RMW2,A2,B2
  5623:                 REAL(8) :: XC,YC,DP,TVX,TVY,RMW,A,B,WTRATIO
  5624:                 REAL(8) :: Central_Pressure,T1,T2,T3,D,N,TT,TM
  5625:                 REAL(8),SAVE :: RHOWATG
  5626:                 IF (FIRSTCALL.EQ.0) THEN
  5627:                    FIRSTCALL = 1
  5628:                    RHOWATG=RHOWAT0*G
  5629:                    ALLOCATE (RAD(NP),DX(NP),DY(NP),XCOOR(NP),YCOOR(NP),EARG (NP))
  5630:                    ALLOCATE (VG(NP),THETA(NP))
  5631:           !         IF(ICS.NE.1) THEN
  5632: V------>              DO I=1,NP
  5633: |                     XCOOR(I)=SLAM(I)*RAD2DEG
  5634: |                     YCOOR(I)=SFEA(I)*RAD2DEG
  5635: V------               END DO
  5636:           !         ENDIF
  5637:           !         IF(ICS.EQ.1) THEN
  5638:           !            DO I=1,NP
  5639:           !               XCOOR(i)=X(i)
  5640:           !                  YCOOR(i)=Y(i)
  5641:           !            END DO
  5642:           !         ENDIF
  5643:                    READ(22,*) TT,XC1,YC1,DP1,TVX1,TVY1,RMW1,B1
  5644:                    READ(22,*) TT,XC2,YC2,DP2,TVX2,TVY2,RMW2,B2
  5645:                    OPEN(667,file='fort.22.adc')
  5646:                 ENDIF
  5647:                 IF(TIMELOC.GT.WTIME2) THEN
  5648:                    WTIME1=WTIME2
  5649:                    WTIME2=WTIME2+WTIMINC
  5650:                    XC1=XC2
  5651:                    YC1=YC2
  5652:                    DP1=DP2
  5653:                    TVX1=TVX2
  5654:                    TVY1=TVY2
  5655:                    RMW1=RMW2
  5656:                    B1=B2
  5657:                    READ(22,*) TT,XC2,YC2,DP2,TVX2,TVY2,RMW2,B2
  5658:                 END IF
  5659:                 WTRATIO=(TIMELOC-WTIME1)/WTIMINC
  5660:                 DP  = DP1  + WTRATIO*(DP2-DP1)
  5661:                 XC  = XC1  + WTRATIO*(XC2-XC1)
  5662:                 YC  = YC1  + WTRATIO*(YC2-YC1)
  5663:                 TVX = TVX1 + WTRATIO*(TVX2-TVX1)
  5664:                 TVY = TVY1 + WTRATIO*(TVY2-TVY1)
  5665:                 RMW = RMW1 + WTRATIO*(RMW2-RMW1)
  5666:                 B   = B1   + WTRATIO*(B2-B1)
  5667:           
  5668:                 Central_Pressure=Ambient_Pressure-DP
  5669:                 A=(RMW*1000)**B
  5670: V======>        DX=XCOOR-XC
  5671: V======>        DY=YCOOR-YC
  5672: V======>        THETA=ATAN2(DY,DX)
  5673: V======>F       RAD=SQRT(DX*DX+DY*DY)*100.d0*1000.d0  ! into meters!!
  5674: V======>        EARG=EXP(-A/RAD**B)
  5675:           
  5676:                 ! WVNX,WVNY,PRESS are returned!!
  5677: V------>        DO I=1,NP
  5678: |                  PRESS(I)=(Central_Pressure + (DP)*EARG(I))/RHOWATG
  5679: |                  D=Rho_Air*RAD(I)**B
  5680: |                  N=A*B*DP*EARG(I)
  5681: |                  T1=N/D
  5682: |                  T2=((CORIOLIS**2.d0)/4.d0)*RAD(I)**2.d0
  5683: |                  T3=RAD(I)*CORIOLIS/2.d0
  5684: |       F          VG(I)=sqrt(T1+T2)-T3
  5685: |       F          TM=(RAD(I)/(RMW*1000))-5.
  5686: |                  IF (TM.LT.0.)THEN
  5687: |                     TM=0.
  5688: |                  ELSEIF (TM.GT.1.)THEN
  5689: |                     TM=1.
  5690: |                  END IF
  5691: |                  TM=-TM/2
  5692: |                  TM=COS(TM*PI)
  5693: |       F          WVNX(I)=-VG(I)*SIN(THETA(I))+TVX*TM
  5694: |       F          WVNY(I)= VG(I)*COS(THETA(I))+TVY*TM
  5695: V------         END DO
  5696:           
  5697:           C      write(667,'(12(f12.4,1x))')TIMELOC,XC,YC,TVX,TVY,DP,RMW,B
  5698:           C     ----------------------------------------------------------------
  5699:                 END SUBROUTINE NWS67GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS67GET
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS67GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:5632)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5632)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:5632)
  LOOP END

  LOOP BEGIN: (wind.F:5670)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5670)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5670)
  LOOP END

  LOOP BEGIN: (wind.F:5670)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5670)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5670)
  LOOP END

  LOOP BEGIN: (wind.F:5671)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5671)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5671)
  LOOP END

  LOOP BEGIN: (wind.F:5671)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5671)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5671)
  LOOP END

  LOOP BEGIN: (wind.F:5672)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5672)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:5672)
  LOOP END

  LOOP BEGIN: (wind.F:5672)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5672)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5672)
  LOOP END

  LOOP BEGIN: (wind.F:5673)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5673)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:5673)
  LOOP END

  LOOP BEGIN: (wind.F:5673)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5673)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5673)
  LOOP END

  LOOP BEGIN: (wind.F:5674)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5674)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5674)
  LOOP END

  LOOP BEGIN: (wind.F:5674)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5674)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5674)
  LOOP END

  LOOP BEGIN: (wind.F:5677)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5677)
    *** The number of VLOAD, VSTORE. :  3,  4. (wind.F:5677)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS67GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 58 [s0-s12 s15-s16 s18-s44 s48-s63]
      Vector registers         : 52 [v0-v1 v9-v11 v17-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 6032 bytes
      Register spill area      : 2328 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 3368 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:5632)
    *** Estimated execution cycle                       : 164
  LOOP END

  LOOP BEGIN: (wind.F:5670)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:5670)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:5671)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:5671)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:5672)
    *** Estimated execution cycle                       : 133
  LOOP END

  LOOP BEGIN: (wind.F:5672)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:5673)
    *** Estimated execution cycle                       : 486
  LOOP END

  LOOP BEGIN: (wind.F:5673)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:5674)
    *** Estimated execution cycle                       : 493
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END

  LOOP BEGIN: (wind.F:5674)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:5677)
    *** Estimated execution cycle                       : 1442
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS19GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5864: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  5878: vec( 101): Vectorized loop.
  5890: vec( 101): Vectorized loop.
  5891: vec( 101): Vectorized loop.
  5908: vec( 103): Unvectorized loop.
  5908: vec( 180): I/O statement obstructs vectorization.
  5908: vec( 108): Unvectorizable loop structure.
  5943: opt(1418): Constant-length loop is expanded.
  5992: opt(1418): Constant-length loop is expanded.
  5999: vec( 180): I/O statement obstructs vectorization.
  6001: opt(1418): Constant-length loop is expanded.
  6001: opt(1118): This I/O statement inhibits optimization of loop.
  6061: opt(1418): Constant-length loop is expanded.
  6071: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  6079: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  6081: inl(1222): Inlined: WIND::WINDTERMINATE
  6110: vec( 103): Unvectorized loop.
  6110: vec( 108): Unvectorizable loop structure.
  6111: vec( 101): Vectorized loop.
  6112: opt(1112): Loop fused with previous loop.
  6113: opt(1112): Loop fused with previous loop.
  6156: opt(1418): Constant-length loop is expanded.
  6183: opt(1418): Constant-length loop is expanded.
  6196: inl(1212): Source for routine not found.: VORTEX::NEWVORTEX
  6197: inl(1212): Source for routine not found.: VORTEX::SETRMAXES
  6198: inl(1212): Source for routine not found.: VORTEX::FITRMAXES
  6210: vec( 103): Unvectorized loop.
  6210: vec( 110): Vectorization obstructive procedure reference.: VORTEX::UVP
  6210: vec( 180): I/O statement obstructs vectorization.
  6210: vec( 110): Vectorization obstructive procedure reference.: VORTEX::GETLATESTANGLE
  6210: vec( 110): Vectorization obstructive procedure reference.: VORTEX::GETLATESTRMAX
  6211: inl(1212): Source for routine not found.: VORTEX::UVP
  6211: opt(1025): Reference to this procedure inhibits optimization.: VORTEX::UVP
  6221: inl(1212): Source for routine not found.: VORTEX::GETLATESTRMAX
  6221: inl(1212): Source for routine not found.: VORTEX::GETLATESTANGLE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS19GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  5793:                 SUBROUTINE NWS19GET(wvnx,wvny,press,timeloc)
  5794:                 USE ADC_CONSTANTS, ONLY: rhowat0, g, mb2pa
  5795:                 USE GLOBAL,ONLY: rnday
  5796:                 USE MESH, ONLY : np, ics, slam, sfea
  5797:                 USE VORTEX, ONLY : newVortex, setRmaxes, fitRmaxes, uvp,
  5798:                &                   getLatestRmax, getLatestAngle
  5799:                 IMPLICIT NONE
  5800:                 INTEGER  :: ient,itpc
  5801:                 INTEGER  :: i, nwi
  5802:                 INTEGER  :: num_entry
  5803:                 REAL(8) :: TIMELOC, time1, wtratio
  5804:                 REAL( 8), SAVE, ALLOCATABLE :: xcoor(:),ycoor(:)
  5805:                 REAL( 8) :: wvnx(np),wvny(np), press(np)
  5806:                 REAL(8) :: RhoWatG
  5807:           
  5808:                 REAL,DIMENSION(:),ALLOCATABLE,SAVE::lat,lon
  5809:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE::ilat,ilon,atcfRMW
  5810:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ilat1,ilon1,atcfRMW1
  5811:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ispd,icpress
  5812:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ispd1,icpress1
  5813:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: iyear,imth,iday,ihr
  5814:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE ::iyear1,imth1,iday1,ihr1
  5815:                 REAL(8), SAVE ::  lat1, lon1,  spd1,  cpress1,  rmw1
  5816:                 REAL(8), SAVE ::  dt, told, cLat1, cLon1
  5817:                 CHARACTER(LEN=4),DIMENSION(:),ALLOCATABLE, SAVE:: type! hindcast/nowcast or forecast?
  5818:                 CHARACTER(LEN=4),DIMENSION(:),ALLOCATABLE, SAVE:: type1 !hindcast/nowcast or forecast?
  5819:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE::iFcstInc1, iFcstInc ! hours between forecasts
  5820:                 INTEGER , SAVE :: firstCall = 0
  5821:                 LOGICAL , SAVE :: firstTime = .TRUE.
  5822:                 REAL(8),DIMENSION(:),ALLOCATABLE,SAVE :: HollB,HollB1
  5823:                 INTEGER ,DIMENSION(:),ALLOCATABLE,SAVE :: advr,advr1
  5824:                 REAL(8), SAVE :: Vmax
  5825:                 REAL(8), SAVE :: Vr
  5826:                 REAL(8), SAVE, DIMENSION(4) :: r
  5827:                 REAL(8), SAVE :: Pn
  5828:                 REAL(8), SAVE :: Pc
  5829:                 REAL(8), SAVE :: cLat
  5830:                 REAL(8), SAVE :: cLon
  5831:                 REAL(8), SAVE :: cHollB
  5832:                 REAL(8) , DIMENSION(4), SAVE :: crmaxw
  5833:                 REAL(8), SAVE :: timeOffset
  5834:           !-------------------------------
  5835:                 INTEGER,SAVE :: icyc
  5836:           !------------------------------
  5837:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: cycle_num
  5838:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: isotachs_per_cycle
  5839:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: isotachs_per_cycle1
  5840:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: ipn,ipn1,cycle_num1
  5841:           
  5842:                 REAL(8) , DIMENSION(:,:), ALLOCATABLE,SAVE :: rmaxw,rmaxw1
  5843:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::CycleTime,CycleTime1
  5844:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::uTrans1,uTrans
  5845:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::vTrans1,vTrans
  5846:                 REAL(8), DIMENSION(:), ALLOCATABLE, SAVE :: h_speed
  5847:                 INTEGER , DIMENSION(:,:), ALLOCATABLE,SAVE::quadflag,quadflag1
  5848:                 INTEGER ,DIMENSION(:),ALLOCATABLE,SAVE :: ivr, dir,speed
  5849:                 REAL(8), SAVE :: dx,dy
  5850:                 REAL(8) :: VmaxBL
  5851:                 REAL(8) :: stormMotionU
  5852:                 REAL(8) :: stormMotionV
  5853:                 REAL(8) :: stormMotion
  5854:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ivr1, dir1, speed1
  5855:                 INTEGER , DIMENSION(:,:),ALLOCATABLE, SAVE :: ir,ir1
  5856:                 CHARACTER(LEN = 10),DIMENSION(:),ALLOCATABLE,SAVE::name,name1
  5857:                 REAL(8),SAVE :: timeOld,timeNew
  5858:                 REAL(8) :: uTransNow, vTransNow ! time-interpolated overland speed, kts
  5859:                 CHARACTER(1) ew,ns
  5860:                 INTEGER, SAVE :: num_cycles ! num unique date/times in the fort.22
  5861:                 REAL(8) :: rndaySeconds ! end time of the run in seconds
  5862:           
  5863:           C
  5864:                 call setMessageSource("nws19get")
  5865:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  5866:                 call allMessage(DEBUG,"Enter.")
  5867:           #endif
  5868:                 timeNew = TIMELOC
  5869:                 rhoWatG = rhoWat0 * g
  5870:                 !----------------------------------------
  5871:                 ! Read (lon,lat) at nodal points and
  5872:                 ! transform them from radians --> degrees
  5873:                 !----------------------------------------
  5874:                 IF (firstTime) THEN
  5875:                    firstTime = .FALSE.
  5876:                    ALLOCATE (xcoor(np), ycoor(np))
  5877:           
  5878: V------>           DO i=1,np
  5879: |                     xcoor(i) = slam(i) * rad2deg
  5880: |                     ycoor(i) = sfea(i) * rad2deg
  5881: V------            END DO
  5882:                    timeOffset = nint(TIMELOC/60d0)*60d0 ! round to nearest minute
  5883:                 END IF   ! end of first Time data allocations and such
  5884:                 !
  5885:                 ! the mesh changes at each time step if we are writing out
  5886:                 ! the full circle Rmaxes
  5887:                 if ((writeFullCircleRmaxes.eqv..true.).or.
  5888:                &           (writeRadialVandP.eqv..true.).or.
  5889:                &           (writeSpatialVandP.eqv..true.)) then
  5890: V======>           xcoor(:) = slam(:) * rad2deg
  5891: V======>           ycoor(:) = sfea(:) * rad2deg
  5892:                 endif
  5893:                 !---------------
  5894:                 ! Initialization
  5895:                 ! it's the first time the routine is called so read
  5896:                 ! in all variables and set the desired radii and
  5897:                 ! such
  5898:                 ! jgf49.10: Replaced opening and closing of fort.22 file with
  5899:                 ! rewind, since opening is already done in the calling routine;
  5900:                 ! this also makes it easier to vary the file name (needed
  5901:                 ! for NWS29).
  5902:                 !---------------
  5903:                 IF (firstCall .EQ. 0) THEN  ! first time the routine is called
  5904:                    ! @jasonfleming: compute run end time in seconds to make sure
  5905:                    ! there are enough data in the file to cover the whole run.
  5906:                    rndaySeconds = RNDAY * 86400.d0
  5907:                    i=0
  5908: +------>           DO      ! determine the number of entries in the file
  5909: |                     READ(22,*,END=991)
  5910: |                     i=i+1
  5911: +------            ENDDO
  5912:           991      continue
  5913:                    num_entry=i
  5914:                    rewind(22)
  5915:                    i=num_entry
  5916:           
  5917:                    allocate(advr1(i),iyear1(i),imth1(i),iday1(i),ihr1(i),type1(i))
  5918:                    allocate(advr(i),iyear(i),imth(i),iday(i),ihr(i),type(i))
  5919:                    allocate(iFcstInc1(i),ilat1(i),ilon1(i), ispd1(i))
  5920:                    allocate(iFcstInc(i) ,ilat(i) ,ilon(i) , ispd(i))
  5921:                    allocate(lat(i),lon(i))
  5922:                    allocate(icpress1(i), ivr1(i),ir1(i,4), rmaxw1(i,4), ipn1(i))
  5923:                    allocate(icpress(i) , ivr(i) ,ir(i,4) , rmaxw(i,4) , ipn(i))
  5924:                    allocate(dir1(i),speed1(i),cycle_num1(i))
  5925:                    allocate(dir(i) ,speed(i) ,cycle_num(i))
  5926:                    allocate(isotachs_per_cycle1(i),CycleTime1(i))
  5927:                    allocate(isotachs_per_cycle(i) ,CycleTime(i))
  5928:                    allocate(quadflag1(i,4),name1(i))
  5929:                    allocate(quadflag(i,4) ,name(i))
  5930:                    allocate(uTrans1(i), vTrans1(i),HollB1(i),atcfRMW1(i) )
  5931:                    allocate(uTrans(i) , vTrans(i) ,HollB(i) ,atcfRMW(i) )
  5932:                    allocate(h_speed(i))
  5933:           
  5934:                    ! Read parsed NHC advisory in modified best-track format
  5935:           
  5936:           26       FORMAT(3x, i3, 2x, i4, 3i2, 6x, a4, 2(2x,i3),a1, 2x, i4,a1, 2x,
  5937:                &         i3,2x, i4, 6x, i3, 7x, 4(i4,2x), i4, 8x, i3,
  5938:                &          27x, 2(i3,2x), a10, 2x, i4, 2x, i4,
  5939:                &         2x, 4(i1,2x),2x, 4(f6.1,2x), 2x, f8.4) !,2(2x,f10.4))
  5940:           
  5941:                    ient=1
  5942:           
  5943: *------>           READ(22,26) advr1(ient), iyear1(ient),imth1(ient),iday1(ient),
  5944:                &    ihr1(ient), type1(ient),iFcstInc1(ient), ilat1(ient),ns,
  5945:                &    ilon1(ient),ew, ispd1(ient), icpress1(ient), ivr1(ient),
  5946:                &    (ir1(ient,i),i=1,4), ipn1(ient), atcfRMW1(ient),
  5947:                &    dir1(ient),speed1(ient), name1(ient),
  5948:                &    cycle_num1(ient),isotachs_per_cycle1(ient),
  5949:                &    (quadflag1(ient,i),i=1,4),(rmaxw1(ient,i),i=1,4),HollB1(ient)
  5950:           
  5951:                    icyc=1
  5952:           
  5953:                    isotachs_per_cycle(icyc) = isotachs_per_cycle1(ient)
  5954:                    advr(icyc)  =  advr1(ient)
  5955:                    iyear(icyc) =  iyear1(ient)
  5956:                    imth(icyc)  =  imth1(ient)
  5957:                    iday(icyc)  =  iday1(ient)
  5958:                    ihr(icyc)   =  ihr1(ient)
  5959:                    type(icyc)  =  type1(ient)
  5960:                    iFcstInc(icyc)= iFcstInc1(ient)
  5961:                    ilat(icyc)  =  ilat1(ient)
  5962:                    ilon(icyc)  =  ilon1(ient)
  5963:                    ispd(icyc)  =  ispd1(ient)
  5964:                    icpress(icyc) =  icpress1(ient)
  5965:                    ivr(icyc)   =  ivr1(ient)
  5966:                    ipn(icyc)   =  ipn1(ient)
  5967:                    atcfRMW(icyc) = atcfRMW1(ient)
  5968:                    !    dir(icyc)   =  dir1(ient)
  5969:                    h_speed(icyc) =  real(speed1(ient))
  5970: +======>           name(icyc)  =  name1(ient)
  5971:                    cycle_num(icyc) = cycle_num1(ient)
  5972:                    HollB(icyc) = HollB1(ient)
  5973:           
  5974:                    ! switch sin and cos b/c these are compass directions
  5975:                    uTrans(icyc) = sin(dir1(ient)*deg2rad)*speed1(ient)
  5976:                    vTrans(icyc) = cos(dir1(ient)*deg2rad)*speed1(ient)
  5977:           
  5978:                    CycleTime(icyc) =  iFcstInc1(ient) * 3600.d0 + timeOffset
  5979:           !         The logic for the code is set for W and N so if E or S
  5980:           !         multiply lats and lons by -1
  5981:           !
  5982:                    IF(ew.EQ.'E')THEN
  5983:                       ilon(icyc)=(-1)*ilon(icyc)
  5984:                    ENDIF
  5985:                    IF(ns.EQ.'S')THEN
  5986:                       ilat(icyc)=(-1)*ilat(icyc)
  5987:                    ENDIF
  5988:                    lon(icyc) = (-1.0d0) * ilon(icyc) * 0.1d0
  5989:                    lat(icyc)=ilat(icyc) * 0.1d0
  5990:           
  5991:                    ! PICK OUT THE CYCLE DATA THAT THE USER WANTS TO USE
  5992: *------>           do i=1,4  ! loop quads
  5993: |                    if (quadflag1(ient,i)==1) then
  5994: |                       rmaxw(icyc,i) = rmaxw1(ient,i)
  5995: |                       quadflag(icyc,i) = quadflag1(ient,i)
  5996: |                    endif
  5997: *------            enddo
  5998:           ! ---------------------------------------------------------------------------
  5999: +------>           DO ient=2,num_entry  ! LOOP through entris (lines) in input file
  6000: |         
  6001: |*----->              READ(22,26) advr1(ient), iyear1(ient),imth1(ient),
  6002: |              &        iday1(ient),
  6003: |              &        ihr1(ient), type1(ient),iFcstInc1(ient), ilat1(ient),ns,
  6004: |              &        ilon1(ient),ew, ispd1(ient), icpress1(ient), ivr1(ient),
  6005: |              &        (ir1(ient,i),i=1,4), ipn1(ient), atcfRMW1(ient),
  6006: |              &        dir1(ient),speed1(ient), name1(ient),
  6007: |              &        cycle_num1(ient),isotachs_per_cycle1(ient),
  6008: |              &        (quadflag1(ient,i),i=1,4),(rmaxw1(ient,i),i=1,4),
  6009: |              &        HollB1(ient)
  6010: |         
  6011: |                     if ( cycle_num1(ient) == cycle_num1(ient-1)) then
  6012: |                        ! do nothing
  6013: |                     else
  6014: |                        IF ( iFcstInc1(ient) == 0 .AND. iFcstInc(icyc) == 0) then
  6015: |                           icyc = icyc
  6016: |                        ELSE
  6017: |                           icyc=icyc+1
  6018: |                        ENDIF
  6019: |                        isotachs_per_cycle(icyc) = isotachs_per_cycle1(ient)
  6020: |         
  6021: |                        advr(icyc)  =  advr1(ient)
  6022: |                        iyear(icyc) =  iyear1(ient)
  6023: |                        imth(icyc)  =  imth1(ient)
  6024: |                        iday(icyc)  =  iday1(ient)
  6025: |                        ihr(icyc)   =  ihr1(ient)
  6026: |                        type(icyc)  =  type1(ient)
  6027: |                        iFcstInc(icyc)= iFcstInc1(ient)
  6028: |                        ilat(icyc)  =  ilat1(ient)
  6029: |                        ilon(icyc)  =  ilon1(ient)
  6030: |                        ispd(icyc)  =  ispd1(ient)
  6031: |                        icpress(icyc) =  icpress1(ient)
  6032: |                        ivr(icyc)   =  ivr1(ient)
  6033: |                        ipn(icyc)   =  ipn1(ient)
  6034: |                        atcfRMW(icyc) = atcfRMW1(ient)
  6035: |                        dir(icyc)   =  dir1(ient)
  6036: |                        h_speed(icyc) =  speed1(ient)
  6037: |+=====>                 name(icyc)  =  name1(ient)
  6038: |                        cycle_num(icyc) = cycle_num1(ient)
  6039: |                        HollB(icyc) = HollB1(ient)
  6040: |         
  6041: |                        ! switch sin and cos b/c these are compass directions
  6042: |                        uTrans(icyc)=sin(dir1(ient)*deg2rad)*speed1(ient)
  6043: |                        vTrans(icyc)=cos(dir1(ient)*deg2rad)*speed1(ient)
  6044: |         
  6045: |                        CycleTime(icyc) =  iFcstInc(icyc) * 3600.d0 + timeOffset
  6046: |         
  6047: |         !              The logic for the code is set for W and N so if E or S
  6048: |         !              multiply lats and lons by -1
  6049: |                        IF(ew.EQ.'E')THEN
  6050: |                           ilon(icyc)=(-1)*ilon(icyc)
  6051: |                        ENDIF
  6052: |                        IF(ns.EQ.'S')THEN
  6053: |                           ilat(icyc)=(-1)*ilat(icyc)
  6054: |                        ENDIF
  6055: |                        lon(icyc) = (-1.0d0) * ilon(icyc) * 0.1d0
  6056: |                        lat(icyc) = ilat(icyc) * 0.1d0
  6057: |         
  6058: |                     endif
  6059: |         
  6060: |                     ! PICK OUT THE CYCLE DATA THAT THE USER WANTS TO USE
  6061: |*----->              do i=1,4 ! loop through quads
  6062: ||                      if (quadflag1(ient,i)==1) then
  6063: ||                        rmaxw(icyc,i) = rmaxw1(ient,i)
  6064: ||                        quadflag(icyc,i) = quadflag1(ient,i)
  6065: ||                      endif
  6066: |*-----               enddo ! loop through quads
  6067: |         
  6068: +------            ENDDO ! loop through entries (lines ) in input file
  6069:                    write(scratchMessage,12) icyc
  6070:            12      format('There are ',i2,' cycles in the fort.22 input file')
  6071:                    CALL logMessage(INFO,scratchMessage)
  6072:                    num_cycles = icyc
  6073:                    icyc=2
  6074:           
  6075:                    !
  6076:                    ! @jasonfleming: If there isn't enough data in the fort.22 to
  6077:                    ! cover the whole run, bomb out immediately.
  6078:                    if (cycleTime(num_cycles).lt.rndaySeconds) then
  6079:                       call allMessage(ERROR,"There aren't enough data in the "//
  6080:                &      'fort.22 file to cover the entire run time.')
  6081:         I             call windTerminate()
  6082:                    endif
  6083:           
  6084:                 END IF   ! (firstCall .EQ. 0)
  6085:           
  6086:                 !--------------------------------------
  6087:                 !
  6088:                 ! This part of code executes each time step
  6089:                 !
  6090:                 !--------------------------------------
  6091:           
  6092:           C     If time exceeds the next hindcast/nowcast/forecast time, increment the
  6093:           C     array counter.
  6094:           C     jgf50.30 Changed .ge. to .gt. so that we wouldn't start looking at the
  6095:           C     next cycle until we are in it ... this should prevent problems when
  6096:           C     the ADCIRC run ends right at the end of the fort.22 ... otherwise,
  6097:           C     we are running off the end of the data.
  6098:                 IF (TIMELOC.gt.CycleTime(icyc)) THEN
  6099:                    IF (icyc.gt.num_cycles) THEN
  6100:                       CALL allMessage(WARNING,
  6101:                & "ADCIRC simulation time is later than the last data in fort.22.")
  6102:                       CALL allMessage(WARNING,
  6103:                &      "The simulation has run out of meteorological data.")
  6104:                    ELSE
  6105:                       icyc=icyc+1
  6106:                    ENDIF
  6107:                 ENDIF
  6108:                 !
  6109:                 ! @jasonfleming: Add handling of "CALM"
  6110:                 if ((trim(type(icyc)).eq.'CALM').or.trim(type(icyc-1)).eq.'CALM') then
  6111: V------>           wvnx(:)=0.d0
  6112: |                  wvny(:)=0.d0
  6113: V------            press(:)=PRBCKGRND*mb2pa/(rhowat0*g)
  6114:                    wtratio=(TIMELOC-CycleTime(icyc-1))/
  6115:                &                  (CycleTime(icyc)-CycleTime(icyc-1))
  6116:                    cLat   = lat(icyc-1)  +
  6117:                &                         wtratio * (lat(icyc)-lat(icyc-1))
  6118:                    cLon  =  lon(icyc-1)  +
  6119:                &                         wtratio * (lon(icyc)-lon(icyc-1))
  6120:                    vortexLat = cLat
  6121:                    vortexLon = cLon
  6122:                    vortexRMW = 0.0d0
  6123:                    EyeLat(1) = EyeLat(2)
  6124:                    EyeLon(1) = EyeLon(2)
  6125:                    EyeLat(2) = EyeLat(3)
  6126:                    EyeLon(2) = EyeLon(3)
  6127:                    EyeLat(3) = cLat
  6128:                    EyeLon(3) = cLon
  6129:                    FoundEye = .true.
  6130:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6131:                    call allMessage(DEBUG,"Return.")
  6132:           #endif
  6133:                    call unsetMessageSource()
  6134:                    return
  6135:                 endif
  6136:                 !
  6137:                 ! Interpolate NHC forecast interval in
  6138:                 ! time to obtain values at model time.
  6139:                 wtratio=(TIMELOC-CycleTime(icyc-1))/
  6140:                &                  (CycleTime(icyc)-CycleTime(icyc-1))
  6141:                 !
  6142:                 ! Perform time interpolation, transform variables from integers
  6143:                 ! to real numbers for hurricane vortex calcualtions.
  6144:                 cLat   =  lat(icyc-1)  +
  6145:                &                         wtratio * (lat(icyc)-lat(icyc-1))
  6146:                 cLon  =  lon(icyc-1)  +
  6147:                &                         wtratio * (lon(icyc)-lon(icyc-1))
  6148:                 Vmax  =  1.d0*(ispd(icyc-1) +
  6149:                &                         wtratio * (ispd(icyc)-ispd(icyc-1)))
  6150:                 Pn    =  1.d0*(ipn(icyc-1)  +
  6151:                &                         wtratio * (ipn(icyc)-ipn(icyc-1)))
  6152:                 Pc    =  1.d0*(icpress(icyc-1) +
  6153:                &                         wtratio*(icpress(icyc)-icpress(icyc-1)))
  6154:                 cHollB   =  HollB(icyc-1) +
  6155:                &                         wtratio * (HollB(icyc)-HollB(icyc-1))
  6156: *------>        do i=1,4
  6157: |                  crmaxw(i)=rmaxw(icyc-1,i) +
  6158: |              &                          wtratio*(rmaxw(icyc,i)-rmaxw(icyc-1,i))
  6159: *------         enddo
  6160:                 uTransNow = uTrans(icyc-1) + wtratio
  6161:                &                  * (uTrans(icyc)-utrans(icyc-1))
  6162:                 vTransNow = vTrans(icyc-1) + wtratio
  6163:                &                  * (vTrans(icyc)-vTrans(icyc-1))
  6164:           
  6165:                 ! jgf49.0803 Make the current Rmax and center location
  6166:                 ! available at the module level for use in NWS29
  6167:                 vortexLat = cLat
  6168:                 vortexLon = cLon
  6169:                 vortexRMW = 0.0d0
  6170:                 !jgf50.32: For sector-based wind drag, record the center
  6171:                 !of the storm.
  6172:                 IF ((cLat.ne.EyeLat(3)).or.(cLon.ne.EyeLon(3))) THEN
  6173:                    EyeLat(1) = EyeLat(2)
  6174:                    EyeLon(1) = EyeLon(2)
  6175:                    EyeLat(2) = EyeLat(3)
  6176:                    EyeLon(2) = EyeLon(3)
  6177:                    EyeLat(3) = cLat
  6178:                    EyeLon(3) = cLon
  6179:                    FoundEye = .true.
  6180:                 ENDIF
  6181:                 !
  6182:                 ! arithmetic mean of the Rmax in the 4 storm quadrants
  6183: *------>        do i=1,4
  6184: |                  vortexRMW = vortexRMW + 0.25d0*crmaxw(i)
  6185: *------         end do
  6186:           
  6187:                 !-------------------------------
  6188:                 ! Create a new asymmetric hurricane vortex.
  6189:                 !
  6190:                 ! Note: Subtract translational speed from Vmax, then
  6191:                 ! scale (Vmax - Vt) and Vr up to the top of the surface,
  6192:                 ! where the cylcostrophic wind balance is valid.
  6193:                 !-------------------------------------------------------
  6194:                 stormMotion = 1.5d0*(SQRT(uTransNow**2.d0+vTransNow**2.d0))**0.63d0
  6195:                 VmaxBL = (Vmax-stormMotion)/windReduction
  6196:                 call newVortex(Pn,Pc,cLat,cLon,VmaxBL)
  6197:                 call setRmaxes(crmaxw)
  6198:                 call fitRmaxes()
  6199:           
  6200:                 !-------------------------------------------------------------
  6201:                 ! Calculate wind and pressure fields at model nodal points.
  6202:                 !
  6203:                 ! Note: the asymmetric vortex wind speed is reduced from the
  6204:                 ! top of the surface layer to the surface, then converted from
  6205:                 ! a 1-minute (max sustained) to a 10-minute average prior to
  6206:                 ! adding the translational velocity in subroutine uvp.
  6207:                 !-------------------------------------------------------------
  6208:                 stormMotionU=sin(dir(icyc)/rad2deg)*stormMotion
  6209:                 stormMotionV=cos(dir(icyc)/rad2deg)*stormMotion
  6210: +------>        DO i=1,np
  6211: |                  CALL uvp(ycoor(i),xcoor(i),stormMotionU,stormMotionV,
  6212: |              &        wvnx(i),wvny(i), press(i)) !
  6213: |                  !-------------------------------------------
  6214: |                  ! Convert atmospheric pressure (Pascals) to
  6215: |                  ! atmospheric pressure-induced water surface
  6216: |                  ! elevation (meters).
  6217: |                  !-------------------------------------------
  6218: |                  press(i) = press(i) / RhoWatG
  6219: |         
  6220: |                  if (writeFullCircleRmaxes.eqv..true.) then
  6221: |                     write(444,*) getLatestRmax(), getLatestAngle()
  6222: |                  endif
  6223: |         
  6224: +------         END DO
  6225:                 !-----------------------------------
  6226:                 ! NHC advisory best-track i/o format
  6227:                 !-----------------------------------
  6228:                 firstCall = 1
  6229:                 told=TIMELOC
  6230:           
  6231:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6232:                 call allMessage(DEBUG,"Return.")
  6233:           #endif
  6234:                 call unsetMessageSource()
  6235:           999   RETURN
  6236:           C***********************************************************************
  6237:                 END SUBROUTINE NWS19GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS19GET
INLINE LIST

  ROOT: WIND::NWS19GET (wind.F:5793)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:5864)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:6071)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6079)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:6081)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6100)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6102)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:6133)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::NEWVORTEX (wind.F:6196)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SETRMAXES (wind.F:6197)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::FITRMAXES (wind.F:6198)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::UVP (wind.F:6211)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::GETLATESTRMAX (wind.F:6221)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::GETLATESTANGLE (wind.F:6221)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:6234)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS19GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:5878)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5878)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:5878)
  LOOP END

  LOOP BEGIN: (wind.F:5890)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5890)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5890)
  LOOP END

  LOOP BEGIN: (wind.F:5891)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:5891)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:5891)
  LOOP END

  LOOP BEGIN: (wind.F:5908)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:5908)
    *** Unvectorizable loop structure. (wind.F:5908)
  LOOP END

  LOOP BEGIN: (wind.F:5970)
    <Unvectorized loop.>
    *** Unvectorizable data type. : NAME1 (wind.F:5970)
    *** Unvectorizable data type. : NAME (wind.F:5970)
  LOOP END

  LOOP BEGIN: (wind.F:5999)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:5999)

    LOOP BEGIN: (wind.F:6037)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NAME1 (wind.F:6037)
      *** Unvectorizable data type. : NAME (wind.F:6037)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:6110)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:6110)
  LOOP END

  LOOP BEGIN: (wind.F:6110)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:6110)
  LOOP END

  LOOP BEGIN: (wind.F:6210)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : VORTEX::UVP (wind.F:6210)
    *** I/O statement obstructs vectorization. (wind.F:6210)
    *** Vectorization obstructive procedure reference. : VORTEX::GETLATESTANGLE (wind.F:6210)
    *** Vectorization obstructive procedure reference. : VORTEX::GETLATESTRMAX (wind.F:6210)
  LOOP END

  LOOP BEGIN: (wind.F:6111)
    <Vectorized loop.>
    **  Fused loop. (wind.F:6111)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6111)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:6111)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:12 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS19GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 10 [v54-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 5888 bytes
      Register spill area      : 1744 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 3904 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:5878)
    *** Estimated execution cycle                       : 164
  LOOP END

  LOOP BEGIN: (wind.F:5890)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:5891)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:5908)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (wind.F:5970)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:5999)
    *** Estimated execution cycle                       : 1159
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 103
            Across calls                                :   3
            Not enough registers                        :  16
            Over basic blocks                           :  83
            Others                                      :   1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 216
            Across calls                                :  40
            Not enough registers                        :  16
            Over basic blocks                           : 160
    *** The number of SCALAR REGISTER TRANSFER          : 87

    LOOP BEGIN: (wind.F:6037)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:6110)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:6110)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:6210)
    *** Estimated execution cycle                       : 67
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER TRANSFER          : 17
  LOOP END

  LOOP BEGIN: (wind.F:6111)
    *** Estimated execution cycle                       : 128
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:13 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS20GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6433: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  6458: vec( 101): Vectorized loop.
  6474: vec( 101): Vectorized loop.
  6475: vec( 101): Vectorized loop.
  6489: vec( 103): Unvectorized loop.
  6489: vec( 180): I/O statement obstructs vectorization.
  6489: vec( 108): Unvectorizable loop structure.
  6519: vec( 101): Vectorized loop.
  6520: vec( 101): Vectorized loop.
  6521: vec( 101): Vectorized loop.
  6522: vec( 101): Vectorized loop.
  6523: vec( 101): Vectorized loop.
  6534: opt(1418): Constant-length loop is expanded.
  6584: opt(1418): Constant-length loop is expanded.
  6595: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  6595: vec( 180): I/O statement obstructs vectorization.
  6595: vec( 182): Deallocation obstructs vectorization.
  6595: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  6595: vec( 109): Vectorization obstructive statement.
  6595: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  6595: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  6595: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  6597: opt(1418): Constant-length loop is expanded.
  6597: opt(1118): This I/O statement inhibits optimization of loop.
  6612: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  6613: inl(1222): Inlined: WIND::WINDTERMINATE
  6664: opt(1418): Constant-length loop is expanded.
  6677: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  6689: inl(1222): Inlined: WIND::WINDTERMINATE
  6719: vec( 103): Unvectorized loop.
  6719: vec( 108): Unvectorizable loop structure.
  6720: vec( 101): Vectorized loop.
  6721: opt(1112): Loop fused with previous loop.
  6722: opt(1112): Loop fused with previous loop.
  6756: vec( 101): Vectorized loop.
  6759: vec( 128): Fused multiply-add operation applied.
  6760: vec( 128): Fused multiply-add operation applied.
  6771: opt(1418): Constant-length loop is expanded.
  6772: opt(1418): Constant-length loop is expanded.
  6773: opt(1418): Constant-length loop is expanded.
  6774: opt(1418): Constant-length loop is expanded.
  6775: opt(1418): Constant-length loop is expanded.
  6777: inl(1212): Source for routine not found.: VORTEX::FITRMAXES4
  6784: vec( 103): Unvectorized loop.
  6784: vec( 110): Vectorization obstructive procedure reference.: VORTEX::SPINTERP
  6785: inl(1212): Source for routine not found.: VORTEX::SPINTERP
  6785: opt(1025): Reference to this procedure inhibits optimization.: VORTEX::SPINTERP
  6806: opt(1418): Constant-length loop is expanded.
  6807: opt(1418): Constant-length loop is expanded.
  6808: opt(1418): Constant-length loop is expanded.
  6809: opt(1418): Constant-length loop is expanded.
  6810: opt(1418): Constant-length loop is expanded.
  6816: vec( 103): Unvectorized loop.
  6816: vec( 110): Vectorization obstructive procedure reference.: VORTEX::SPINTERP
  6817: opt(1025): Reference to this procedure inhibits optimization.: VORTEX::SPINTERP
  6834: vec( 101): Vectorized loop.
  6834: vec( 128): Fused multiply-add operation applied.
  6836: vec( 101): Vectorized loop.
  6836: vec( 128): Fused multiply-add operation applied.
  6838: vec( 101): Vectorized loop.
  6838: vec( 128): Fused multiply-add operation applied.
  6840: vec( 101): Vectorized loop.
  6840: vec( 128): Fused multiply-add operation applied.
  6850: vec( 101): Vectorized loop.
  6851: vec( 128): Fused multiply-add operation applied.
  6866: vec( 103): Unvectorized loop.
  6866: vec( 180): I/O statement obstructs vectorization.
  6867: opt(1118): This I/O statement inhibits optimization of loop.
  6890: opt(1418): Constant-length loop is expanded.
  6891: opt(1418): Constant-length loop is expanded.
  6900: opt(1418): Constant-length loop is expanded.
  6901: opt(1418): Constant-length loop is expanded.
  6931: inl(1212): Source for routine not found.: VORTEX::SETVORTEX
  6933: vec( 103): Unvectorized loop.
  6933: vec( 110): Vectorization obstructive procedure reference.: VORTEX::UVPR
  6934: inl(1212): Source for routine not found.: VORTEX::UVPR
  6934: opt(1025): Reference to this procedure inhibits optimization.: VORTEX::UVPR


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS20GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6339:                 SUBROUTINE NWS20GET(wvnx, wvny, press, timeloc)
  6340:                 USE VORTEX, ONLY : setVortex, fitRmaxes4,  uvpr, spInterp,
  6341:                &                   Rmaxes4, QuadFlag4, QuadIr4, Bs4, VmBL4  ! jgfdebug
  6342:                 USE ADC_CONSTANTS, ONLY: kt2ms, nm2m, deg2rad, omega, Rearth, m2nm, mb2pa
  6343:                 USE GLOBAL, ONLY: rnday
  6344:                 USE MESH, ONLY : slam, sfea, np, ics
  6345:                 IMPLICIT NONE
  6346:           
  6347:                 INTEGER  :: ient
  6348:                 INTEGER  :: i, j
  6349:                 INTEGER  :: num_entry
  6350:                 REAL(8) :: TIMELOC, wtratio
  6351:                 REAL( 8), SAVE, ALLOCATABLE :: xcoor(:),ycoor(:)
  6352:                 REAL( 8) :: wvnx(np),wvny(np), press(np)
  6353:                 REAL(8) :: RhoWatG
  6354:                 REAL(8) :: corio                       ! Coriolis force (1/s)
  6355:           
  6356:                 !REAL(8),DIMENSION(:),ALLOCATABLE,SAVE::lat,lon
  6357:                 ! jgf53.dev: FIXME this should be REAL(8) as above
  6358:                 REAL(8),DIMENSION(:),ALLOCATABLE,SAVE::lat,lon
  6359:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE::ilat,ilon,atcfRMW
  6360:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ilat1,ilon1,atcfRMW1
  6361:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ispd,icpress
  6362:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ispd1,icpress1
  6363:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: iyear,imth,iday,ihr
  6364:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE ::iyear1,imth1,iday1,ihr1
  6365:                 CHARACTER(LEN=4),DIMENSION(:),ALLOCATABLE, SAVE:: type! hindcast/nowcast or forecast?
  6366:                 CHARACTER(LEN=4),DIMENSION(:),ALLOCATABLE, SAVE:: type1 !hindcast/nowcast or forecast?
  6367:                 INTEGER,DIMENSION(:),ALLOCATABLE,SAVE::iFcstInc1, iFcstInc ! hours between forecasts
  6368:                 INTEGER , SAVE :: firstCall = 0
  6369:                 LOGICAL , SAVE :: firstTime = .TRUE.
  6370:                 REAL(8),DIMENSION(:),ALLOCATABLE,SAVE :: HollB,HollB1
  6371:                 REAL(8),DIMENSION(:,:),ALLOCATABLE,SAVE :: VmaxesBL1,HollBs1
  6372:                 REAL(8),DIMENSION(:,:,:),ALLOCATABLE,SAVE :: HollBs,VmaxesBL
  6373:                 INTEGER ,DIMENSION(:),ALLOCATABLE,SAVE :: advr,advr1
  6374:                 REAL(8), SAVE :: Vr
  6375:                 REAL(8), SAVE, DIMENSION(4) :: r
  6376:                 REAL(8), SAVE :: Pn
  6377:                 REAL(8), SAVE :: Pc
  6378:                 REAL(8), SAVE :: cLat
  6379:                 REAL(8), SAVE :: cLon
  6380:                 REAL(8), SAVE :: told
  6381:                 ! save parameters for each node
  6382:                 ! change them to allocatable, save Aug. 2013, Jie
  6383:                 REAL(8), ALLOCATABLE, SAVE :: cHollBs1(:), cHollBs2(:)
  6384:                 REAL(8), ALLOCATABLE, SAVE :: cPhiFactor1(:), cPhiFactor2(:)
  6385:                 REAL(8), ALLOCATABLE, SAVE :: cVmwBL1(:), cVmwBL2(:)
  6386:                 REAL(8), ALLOCATABLE, SAVE :: crmaxw1(:), crmaxw2(:)
  6387:                 REAL(8), ALLOCATABLE, SAVE :: crmaxwTrue1(:), crmaxwTrue2(:)
  6388:                 REAL(8), ALLOCATABLE, SAVE :: cHollBs(:)
  6389:                 REAL(8), ALLOCATABLE, SAVE :: cPhiFactor(:)
  6390:                 REAL(8), ALLOCATABLE, SAVE :: cVmwBL(:)
  6391:                 REAL(8), ALLOCATABLE, SAVE :: crmaxw(:)
  6392:                 REAL(8), ALLOCATABLE, SAVE :: crmaxwTrue(:)
  6393:                 REAL(8), ALLOCATABLE, SAVE :: aziangle(:), dist(:)
  6394:                 REAL(8), SAVE :: timeOffset
  6395:           !-------------------------------
  6396:                 INTEGER,SAVE :: icyc
  6397:                 INTEGER,SAVE :: isot
  6398:           !------------------------------
  6399:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: cycle_num
  6400:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: isotachs_per_cycle
  6401:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: isotachs_per_cycle1
  6402:                 INTEGER ,DIMENSION(:),ALLOCATABLE, SAVE :: ipn,ipn1,cycle_num1
  6403:           
  6404:                 REAL(8) , DIMENSION(:,:), ALLOCATABLE,SAVE :: rmaxw1
  6405:                 REAL(8) , DIMENSION(:,:,:), ALLOCATABLE,SAVE :: rmaxw
  6406:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::CycleTime,CycleTime1
  6407:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::uTrans1,uTrans
  6408:                 REAL(8) , DIMENSION(:), ALLOCATABLE,SAVE::vTrans1,vTrans
  6409:                 REAL(8), DIMENSION(:), ALLOCATABLE, SAVE :: h_speed
  6410:                 INTEGER , DIMENSION(:,:), ALLOCATABLE,SAVE::quadflag1
  6411:                 INTEGER , DIMENSION(:,:,:), ALLOCATABLE,SAVE::quadflag
  6412:                 INTEGER ,DIMENSION(:),ALLOCATABLE,SAVE :: ivr, dir,speed
  6413:                 REAL(8), SAVE :: dx,dy
  6414:                 REAL(8) :: VmaxBL
  6415:                 REAL(8) :: stormMotionU
  6416:                 REAL(8) :: stormMotionV
  6417:                 REAL(8) :: stormMotion
  6418:                 INTEGER,DIMENSION(:),ALLOCATABLE, SAVE :: ivr1, dir1, speed1
  6419:                 INTEGER , DIMENSION(:,:),ALLOCATABLE, SAVE :: ir1
  6420:                 INTEGER , DIMENSION(:,:,:),ALLOCATABLE, SAVE :: ir
  6421:                 CHARACTER(LEN = 10),DIMENSION(:),ALLOCATABLE,SAVE::name,name1
  6422:                 REAL(8),SAVE :: timeNew
  6423:                 REAL(8) :: uTransNow, vTransNow ! time-interpolated overland speed, kts
  6424:                 REAL(8) :: dirNow ! Jie
  6425:                 REAL(8) :: numRmaxes ! number of Rmax values selected by user
  6426:                 CHARACTER(1) ew,ns
  6427:                 INTEGER, SAVE :: num_cycles ! num unique date/times in the fort.22
  6428:           
  6429:                 REAL(8) :: rndaySeconds ! end time of the run in seconds
  6430:                 real(8) :: newVortexRMW ! average Rmax at icyc   (next fort.22 time value)
  6431:                 real(8) :: oldVortexRMW ! average Rmax at icyc-1 (previous fort.22 time value)
  6432:           
  6433:                 call setMessageSource("nws20get")
  6434:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6435:                 call allMessage(DEBUG,"Enter.")
  6436:           #endif
  6437:                 timeNew = TIMELOC
  6438:                 rhoWatG = rhoWat0 * g
  6439:                 !----------------------------------------
  6440:                 ! Read (lon,lat) at nodal points and
  6441:                 ! transform them from radians --> degrees
  6442:                 !----------------------------------------
  6443:                 IF (firstTime) THEN
  6444:                    firstTime = .FALSE.
  6445:                    ALLOCATE (xcoor(np), ycoor(np))
  6446:                    ALLOCATE (cHollBs1(np), cHollBs2(np))
  6447:                    ALLOCATE (cPhiFactor1(np), cPhiFactor2(np))
  6448:                    ALLOCATE (cVmwBL1(np), cVmwBL2(np))
  6449:                    ALLOCATE (crmaxw1(np), crmaxw2(np))
  6450:                    ALLOCATE (crmaxwTrue1(np), crmaxwTrue2(np))
  6451:                    ALLOCATE (cHollBs(np))
  6452:                    ALLOCATE (cPhiFactor(np))
  6453:                    ALLOCATE (cVmwBL(np))
  6454:                    ALLOCATE (crmaxw(np))
  6455:                    ALLOCATE (crmaxwTrue(np))
  6456:                    ALLOCATE (aziangle(np), dist(np))
  6457:           
  6458: V------>           DO i=1,np
  6459: |                     xcoor(i) = slam(i) * rad2deg
  6460: |                     ycoor(i) = sfea(i) * rad2deg
  6461: V------            END DO
  6462:            
  6463:                    timeOffset = nint(TIMELOC/60d0)*60d0 ! round initial time to nearest minute
  6464:                    rndaySeconds = RNDAY * 86400.d0
  6465:           
  6466:                 END IF   ! end of first Time data allocations and such
  6467:                 !
  6468:                 ! the mesh changes at each time step if we are writing out
  6469:                 ! the full circle Rmaxes
  6470:                 if ((writeFullCircleRmaxes.eqv..true.).or.
  6471:                &           (writeRadialVandP.eqv..true.).or.
  6472:                &           (writeSpatialVandP.eqv..true.).or.
  6473:                &           (writeSpatialuvp.eqv..true.)) then
  6474: V======>           xcoor(:) = slam(:) * rad2deg
  6475: V======>           ycoor(:) = sfea(:) * rad2deg
  6476:                 endif
  6477:                 !---------------
  6478:                 ! Initialization
  6479:                 ! it's the first time the routine is called so read
  6480:                 ! in all variables and set the desired radii and
  6481:                 ! such
  6482:                 ! jgf49.10: Replaced opening and closing of fort.22 file with
  6483:                 ! rewind, since opening is already done in the calling routine;
  6484:                 ! this also makes it easier to vary the file name (needed
  6485:                 ! for NWS29).
  6486:                 !---------------
  6487:                 IF (firstCall .EQ. 0) THEN  ! first time the routine is called
  6488:                    i=0
  6489: +------>           DO      ! determine the number of entries in the file
  6490: |                     READ(22,*,END=992)
  6491: |                     i=i+1
  6492: +------            ENDDO
  6493:           992      continue
  6494:                    num_entry=i
  6495:                    rewind(22)
  6496:                    i=num_entry
  6497:           
  6498:                    allocate(advr1(i),iyear1(i),imth1(i),iday1(i),ihr1(i),type1(i))
  6499:                    allocate(advr(i),iyear(i),imth(i),iday(i),ihr(i),type(i))
  6500:                    allocate(iFcstInc1(i),ilat1(i),ilon1(i), ispd1(i))
  6501:                    allocate(iFcstInc(i) ,ilat(i) ,ilon(i) , ispd(i))
  6502:                    allocate(lat(i),lon(i))
  6503:                    allocate(icpress1(i), ivr1(i),ir1(i,4), rmaxw1(i,4), ipn1(i))
  6504:                    allocate(icpress(i), ivr(i) ,ir(i,4,4) , rmaxw(i,4,4) , ipn(i))
  6505:                    allocate(dir1(i),speed1(i),cycle_num1(i))
  6506:                    allocate(dir(i) ,speed(i) ,cycle_num(i))
  6507:                    allocate(isotachs_per_cycle1(i),CycleTime1(i))
  6508:                    allocate(isotachs_per_cycle(i) ,CycleTime(i))
  6509:                    allocate(quadflag1(i,4),name1(i))
  6510:                    allocate(quadflag(i,4,4),name(i))
  6511:                    allocate(uTrans1(i), vTrans1(i),HollB1(i),atcfRMW1(i) )
  6512:                    allocate(uTrans(i) , vTrans(i) ,HollB(i) ,atcfRMW(i) )
  6513:                    allocate(HollBs1(i,4))
  6514:                    allocate(HollBs(i,4,4))
  6515:                    allocate(h_speed(i))
  6516:                    allocate(VmaxesBL1(i,4), VmaxesBL(i,4,4))
  6517:           
  6518:                    ! jgf: initialize arrays to zero
  6519: V======>           ir = 0
  6520: V======>           rmaxw = 0.0d0
  6521: V======>           quadflag = 0
  6522: V======>           HollBs = 0.0d0
  6523: V======>           VmaxesBL = 0.0d0
  6524:           
  6525:                    ! Read parsed NHC advisory in modified best-track format
  6526:           
  6527:           27       FORMAT(3x, i3, 2x, i4, 3i2, 6x, a4, 2(2x,i3),a1, 2x, i4,a1, 2x,
  6528:                &         i3,2x, i4, 6x, i3, 7x, 4(i4,2x), i4, 8x, i3,
  6529:                &          27x, 2(i3,2x), a10, 2x, i4, 2x, i4,
  6530:                &         2x, 4(i1,2x),2x, 4(f6.1,2x),1x, 8(f8.4,2x), f8.4)
  6531:           
  6532:                    ient = 1
  6533:           
  6534: *------>           READ(22,27) advr1(ient), iyear1(ient),imth1(ient),iday1(ient),
  6535:                &    ihr1(ient), type1(ient),iFcstInc1(ient), ilat1(ient),ns,
  6536:                &    ilon1(ient),ew, ispd1(ient), icpress1(ient), ivr1(ient),
  6537:                &    (ir1(ient,i),i=1,4), ipn1(ient), atcfRMW1(ient),
  6538:                &    dir1(ient),speed1(ient), name1(ient),
  6539:                &    cycle_num1(ient),isotachs_per_cycle1(ient),
  6540:                &    (quadflag1(ient,i),i=1,4),(rmaxw1(ient,i),i=1,4),HollB1(ient),
  6541:                &    (HollBs1(ient,i),i=1,4),(VmaxesBL1(ient,i),i=1,4)
  6542:           
  6543:                    icyc=1
  6544:                    isot=1
  6545:                    isotachs_per_cycle(icyc) = isotachs_per_cycle1(ient)
  6546:                    advr(icyc)  =  advr1(ient)
  6547:                    iyear(icyc) =  iyear1(ient)
  6548:                    imth(icyc)  =  imth1(ient)
  6549:                    iday(icyc)  =  iday1(ient)
  6550:                    ihr(icyc)   =  ihr1(ient)
  6551:                    type(icyc)  =  type1(ient)
  6552:                    iFcstInc(icyc)= iFcstInc1(ient)
  6553:                    ilat(icyc)  =  ilat1(ient)
  6554:                    ilon(icyc)  =  ilon1(ient)
  6555:                    ispd(icyc)  =  ispd1(ient)
  6556:                    icpress(icyc) =  icpress1(ient)
  6557:                    ivr(icyc)   =  ivr1(ient)
  6558:                    ipn(icyc)   =  ipn1(ient)
  6559:                    atcfRMW(icyc) = atcfRMW1(ient)
  6560:                    !    dir(icyc)   =  dir1(ient)
  6561:                    h_speed(icyc) =  real(speed1(ient))
  6562: +======>           name(icyc)  =  name1(ient)
  6563:                    cycle_num(icyc) = cycle_num1(ient)
  6564:                    HollB(icyc) = HollB1(ient)
  6565:           
  6566:                    ! switch sin and cos b/c these are compass directions
  6567:                    uTrans(icyc) = sin(dir1(ient)*deg2rad)*speed1(ient)
  6568:                    vTrans(icyc) = cos(dir1(ient)*deg2rad)*speed1(ient)
  6569:           
  6570:                    CycleTime(icyc) =  iFcstInc1(ient) * 3600.d0 + timeOffset
  6571:           !         The logic for the code is set for W and N so if E or S
  6572:           !         multiply lats and lons by -1
  6573:           !
  6574:                    IF(ew.EQ.'E')THEN
  6575:                       ilon(icyc)=(-1)*ilon(icyc)
  6576:                    ENDIF
  6577:                    IF(ns.EQ.'S')THEN
  6578:                       ilat(icyc)=(-1)*ilat(icyc)
  6579:                    ENDIF
  6580:                    lon(icyc) = (-1.0d0) * ilon(icyc) * 0.1d0
  6581:                    lat(icyc)=ilat(icyc) * 0.1d0
  6582:           
  6583:                    ! PICK OUT THE CYCLE DATA THAT THE USER WANTS TO USE
  6584: *------>           do i=1,4  ! loop quads
  6585: |                    if (quadflag1(ient,i)==1) then
  6586: |                       ir(icyc,i, isot) = ir1(ient,i)
  6587: |                       rmaxw(icyc,i,isot) = rmaxw1(ient,i)
  6588: |                       quadflag(icyc,i,isot) = quadflag1(ient,i)
  6589: |                       HollBs(icyc,i,isot) = HollBs1(ient,i)
  6590: |                       VmaxesBL(icyc,i,isot) = VmaxesBL1(ient,i)
  6591: |                    endif
  6592: *------            enddo
  6593:           
  6594:           ! ---------------------------------------------------------------------------
  6595: +------>           DO ient=2,num_entry  ! LOOP through entris (lines) in input file
  6596: |         
  6597: |*----->           READ(22,27) advr1(ient), iyear1(ient),imth1(ient),iday1(ient),
  6598: |              &    ihr1(ient), type1(ient),iFcstInc1(ient), ilat1(ient),ns,
  6599: |              &    ilon1(ient),ew, ispd1(ient), icpress1(ient), ivr1(ient),
  6600: |              &    (ir1(ient,i),i=1,4), ipn1(ient), atcfRMW1(ient),
  6601: |              &    dir1(ient),speed1(ient), name1(ient),
  6602: |              &    cycle_num1(ient),isotachs_per_cycle1(ient),
  6603: |              &    (quadflag1(ient,i),i=1,4),(rmaxw1(ient,i),i=1,4),HollB1(ient),
  6604: |              &    (HollBs1(ient,i),i=1,4),(VmaxesBL1(ient,i),i=1,4)
  6605: |         
  6606: |                     if ( cycle_num1(ient) == cycle_num1(ient-1)) then
  6607: |                        isot=isot+1 ! same icyc, next isotach
  6608: |                        if (isot.gt.4) then
  6609: |                           write(scratchMessage,'(a,a,i0,a)')
  6610: |              &             'The GAHM fort.22 input file has more than 4 ',
  6611: |              &             'isotachs in cycle ',cycle_num1(ient),'.'
  6612: |                           call allMessage(ERROR,scratchMessage)
  6613: |       I                   call windTerminate()
  6614: |                        endif
  6615: |                     else
  6616: |                        isot=1 ! initialize isotach #
  6617: |                        IF ( iFcstInc1(ient) == 0 .AND. iFcstInc(icyc) == 0) then
  6618: |                           icyc = icyc
  6619: |                        ELSE
  6620: |                           icyc = icyc+1
  6621: |                        ENDIF
  6622: |                        isotachs_per_cycle(icyc) = isotachs_per_cycle1(ient)
  6623: |         
  6624: |                        advr(icyc)  =  advr1(ient)
  6625: |                        iyear(icyc) =  iyear1(ient)
  6626: |                        imth(icyc)  =  imth1(ient)
  6627: |                        iday(icyc)  =  iday1(ient)
  6628: |                        ihr(icyc)   =  ihr1(ient)
  6629: |                        type(icyc)  =  type1(ient)
  6630: |                        iFcstInc(icyc)= iFcstInc1(ient)
  6631: |                        ilat(icyc)  =  ilat1(ient)
  6632: |                        ilon(icyc)  =  ilon1(ient)
  6633: |                        ispd(icyc)  =  ispd1(ient)
  6634: |                        icpress(icyc) =  icpress1(ient)
  6635: |                        ivr(icyc)   =  ivr1(ient)
  6636: |                        ipn(icyc)   =  ipn1(ient)
  6637: |                        atcfRMW(icyc) = atcfRMW1(ient)
  6638: |                        dir(icyc)   =  dir1(ient)
  6639: |                        h_speed(icyc) =  speed1(ient)
  6640: |+=====>                 name(icyc)  =  name1(ient)
  6641: |                        cycle_num(icyc) = cycle_num1(ient)
  6642: |                        HollB(icyc) = HollB1(ient)
  6643: |         
  6644: |                        ! switch sin and cos b/c these are compass directions
  6645: |                        uTrans(icyc)=sin(dir1(ient)*deg2rad)*speed1(ient)
  6646: |                        vTrans(icyc)=cos(dir1(ient)*deg2rad)*speed1(ient)
  6647: |         
  6648: |                        CycleTime(icyc) =  iFcstInc(icyc) * 3600.d0 + timeOffset
  6649: |         
  6650: |         !              The logic for the code is set for W and N so if E or S
  6651: |         !              multiply lats and lons by -1
  6652: |                        IF(ew.EQ.'E')THEN
  6653: |                           ilon(icyc)=(-1)*ilon(icyc)
  6654: |                        ENDIF
  6655: |                        IF(ns.EQ.'S')THEN
  6656: |                           ilat(icyc)=(-1)*ilat(icyc)
  6657: |                        ENDIF
  6658: |                        lon(icyc) = (-1.0d0) * ilon(icyc) * 0.1d0
  6659: |                        lat(icyc) = ilat(icyc) * 0.1d0
  6660: |         
  6661: |                     endif
  6662: |         
  6663: |                     ! PICK OUT THE CYCLE DATA THAT THE USER WANTS TO USE
  6664: |*----->              do i=1,4 ! loop through quads
  6665: ||                      if (quadflag1(ient,i)==1) then
  6666: ||                        ir(icyc,i, isot) = ir1(ient,i)
  6667: ||                        rmaxw(icyc,i,isot) = rmaxw1(ient,i)
  6668: ||                        quadflag(icyc,i,isot) = quadflag1(ient,i)
  6669: ||                        HollBs(icyc,i,isot) = HollBs1(ient,i)
  6670: ||                        VmaxesBL(icyc,i,isot) = VmaxesBL1(ient,i)
  6671: ||                      endif
  6672: |*-----               enddo ! loop through quads
  6673: |         
  6674: +------            ENDDO ! loop through entries (lines ) in input file
  6675:                    write(scratchMessage,13) icyc
  6676:            13      format('There are ',i2,' cycles in the fort.22 input file')
  6677:                    CALL logMessage(INFO,scratchMessage)
  6678:                    num_cycles = icyc
  6679:                    icyc=2
  6680:                    !
  6681:                    ! @jasonfleming: If there isn't enough data in the fort.22 to
  6682:                    ! cover the whole run, bomb out immediately.
  6683:                    write(scratchMessage,*) 'The last cycle in the fort.22 '//
  6684:                &      'file is at ', cycleTime(num_cycles), ' [sec]'
  6685:                    CALL logMessage(INFO,scratchMessage)
  6686:                    if (cycleTime(num_cycles).lt.rndaySeconds) then
  6687:                       call allMessage(ERROR,"There aren't enough data in the "//
  6688:                &      'fort.22 file to cover the entire run time.')
  6689:         I             call windTerminate()
  6690:                    endif
  6691:           
  6692:                 END IF   ! (firstCall .EQ. 0)
  6693:           
  6694:                 !--------------------------------------
  6695:                 !
  6696:                 ! This part of code executes each time step
  6697:                 !
  6698:                 !--------------------------------------
  6699:           
  6700:           C     If time exceeds the next hindcast/nowcast/forecast time, increment the
  6701:           C     array counter.
  6702:           C     jgf50.30 Changed .ge. to .gt. so that we wouldn't start looking at the
  6703:           C     next cycle until we are in it ... this should prevent problems when
  6704:           C     the ADCIRC run ends right at the end of the fort.22 ... otherwise,
  6705:           C     we are running off the end of the data.
  6706:           
  6707:                 IF (TIMELOC.gt.CycleTime(icyc)) THEN
  6708:                    IF (icyc.gt.num_cycles) THEN
  6709:                       CALL allMessage(WARNING,
  6710:                & "ADCIRC simulation time is later than the last data in fort.22.")
  6711:                       CALL allMessage(WARNING,
  6712:                &      "The simulation has run out of meteorological data.")
  6713:                    ELSE
  6714:                    icyc=icyc+1
  6715:                    ENDIF
  6716:                 ENDIF
  6717:                 !
  6718:                 ! @jasonfleming: Add handling of "CALM"
  6719:                 if ((trim(type(icyc)).eq.'CALM').or.trim(type(icyc-1)).eq.'CALM') then
  6720: V------>           wvnx(:)=0.d0
  6721: |                  wvny(:)=0.d0
  6722: V------            press(:)=PRBCKGRND*mb2pa/(rhowat0*g)
  6723:                    wtratio=(TIMELOC-CycleTime(icyc-1))/
  6724:                &                  (CycleTime(icyc)-CycleTime(icyc-1))
  6725:                    cLat   = lat(icyc-1)  +
  6726:                &                         wtratio * (lat(icyc)-lat(icyc-1))
  6727:                    cLon  =  lon(icyc-1)  +
  6728:                &                         wtratio * (lon(icyc)-lon(icyc-1))
  6729:                    vortexLat = cLat
  6730:                    vortexLon = cLon
  6731:                    vortexRMW = 0.0d0
  6732:                    EyeLat(1) = EyeLat(2)
  6733:                    EyeLon(1) = EyeLon(2)
  6734:                    EyeLat(2) = EyeLat(3)
  6735:                    EyeLon(2) = EyeLon(3)
  6736:                    EyeLat(3) = cLat
  6737:                    EyeLon(3) = cLon
  6738:                    FoundEye = .true.
  6739:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6740:                    call allMessage(DEBUG,"Return.")
  6741:           #endif
  6742:                    call unsetMessageSource()
  6743:                    return
  6744:                 endif
  6745:           
  6746:                 ! Interpolate NHC forecast interval in
  6747:                 ! time to obtain values at model time.
  6748:                 ! obtain the latest hurricane center location
  6749:                 wtratio=(TIMELOC-CycleTime(icyc-1))/
  6750:                &                  (CycleTime(icyc)-CycleTime(icyc-1))
  6751:                 cLat   = lat(icyc-1)  +
  6752:                &                         wtratio * (lat(icyc)-lat(icyc-1))
  6753:                 cLon  =  lon(icyc-1)  +
  6754:                &                         wtratio * (lon(icyc)-lon(icyc-1))
  6755:                 ! locate each node based on the latest hurricane center location
  6756: V------>        do i=1,np
  6757: |                  dx = deg2rad * Rearth * (xcoor(i) - cLon)*COS(deg2rad*cLat)
  6758: |                  dy = deg2rad * Rearth * (ycoor(i) - cLat)
  6759: |       F          dist(i) = SQRT(dx*dx + dy*dy)* m2nm
  6760: |       F          aziangle(i) = 360.0d0 + rad2deg * ATAN2(dx,dy)
  6761: |                  IF (aziangle(i) > 360.d0) aziangle(i) = aziangle(i) - 360.d0
  6762: V------         enddo
  6763:           
  6764:            ! set parameters at icyc-1
  6765:            !        call setQuadFlag4(reshape(quadflag(icyc-1,:,:),(/4,4/)))
  6766:            !        call setQuadIr4(reshape(ir(icyc-1,:,:),(/4,4/)))
  6767:            !        call setRmaxes4(reshape(rmaxw(icyc-1,:,:),(/4,4/)))
  6768:            !        call setShapeParameters4(reshape(HollBs(icyc-1,:,:),(/4,4/)))
  6769:            !        call setVmaxesBL4(reshape(VmaxesBL(icyc-1,:,:),(/4,4/)))
  6770:           
  6771: *======>        QuadFlag4(2:5,1:4) = quadflag(icyc-1,1:4,1:4)
  6772: *======>        QuadIr4(2:5,1:4) = real(ir(icyc-1,1:4,1:4))
  6773: *======>        Rmaxes4(2:5,1:4) = rmaxw(icyc-1,1:4,1:4)
  6774: *======>        Bs4(2:5,1:4) = HollBs(icyc-1,1:4,1:4)
  6775: *======>        VmBL4(2:5,1:4) = VmaxesBL(icyc-1,1:4,1:4)
  6776:           
  6777:                 call fitRmaxes4()
  6778:           !699      FORMAT(5(f8.4,2x))
  6779:           !700      FORMAT(a25, 2x, 3(f12.2,2x))
  6780:            !Jie debug GAHM
  6781:            !        WRITE(16,*) 'Previous: Spatially-interpolated storm parameters',
  6782:            !    &                   ' at icyc-1= ', icyc-1,
  6783:            !    &                   ' CycleTime=', CycleTime(icyc-1)
  6784: +------>        do i=1,np
  6785: |                  crmaxw1(i) = spInterp(aziangle(i),dist(i),1)
  6786: |                  crmaxwTrue1(i) = spInterp(aziangle(i),1.d0,1)
  6787: |                  !an artificial number 1.0 is chosen to ensure only
  6788: |                  !rmax from the highest isotach is picked
  6789: |                  cHollBs1(i)= spInterp(aziangle(i),dist(i),2)
  6790: |                  cVmwBL1(i) = spInterp(aziangle(i),dist(i),3)
  6791: |          !Jie debug GAHM
  6792: |          !            WRITE(16,699) crmaxw1(i),  crmaxwTrue1(i),
  6793: |          !    &                   cHollBs1(i) ,cVmwBL1(i)
  6794: +------         end do
  6795:           
  6796:           
  6797:                    ! set parameters at icyc
  6798:           !         call setVortex(ipn(icyc),icpress(icyc),cLat,cLon
  6799:           !     $                  ,isotachs_per_cycle(icyc))
  6800:           !         call setQuadFlag4(reshape(quadflag(icyc,:,:),(/4,4/)))
  6801:           !         call setQuadIr4(reshape(ir(icyc,:,:),(/4,4/)))
  6802:           !         call setRmaxes4(reshape(rmaxw(icyc,:,:),(/4,4/)))
  6803:           !         call setShapeParameters4(reshape(HollBs(icyc,:,:),(/4,4/)))
  6804:           !         call setVmaxesBL4(reshape(VmaxesBL(icyc,:,:),(/4,4/)))
  6805:           
  6806: *======>        QuadFlag4(2:5,1:4) = quadflag(icyc,1:4,1:4)
  6807: *======>        QuadIr4(2:5,1:4) = real(ir(icyc,1:4,1:4))
  6808: *======>        Rmaxes4(2:5,1:4) = rmaxw(icyc,1:4,1:4)
  6809: *======>        Bs4(2:5,1:4) = HollBs(icyc,1:4,1:4)
  6810: *======>        VmBL4(2:5,1:4) = VmaxesBL(icyc,1:4,1:4)
  6811:                 call fitRmaxes4()
  6812:            !Jie debug GAHM
  6813:            !        WRITE(16,*) 'After: Spatially-interpolated storm parameters',
  6814:            !    &                   ' at icyc= ', icyc,
  6815:            !    &                   ' CycleTime=', CycleTime(icyc)
  6816: +------>        do i=1,np
  6817: |                  crmaxw2(i) = spInterp(aziangle(i),dist(i),1)
  6818: |                  crmaxwTrue2(i) = spInterp(aziangle(i),1.d0,1)
  6819: |                  !an artificial number 1.0 is chosen to ensure only
  6820: |                  !rmax from the highest isotach is picked
  6821: |                  cHollBs2(i)= spInterp(aziangle(i),dist(i),2)
  6822: |                  cVmwBL2(i) = spInterp(aziangle(i),dist(i),3)
  6823: |                       !Jie debug GAHM
  6824: |           !           WRITE(16,699) crmaxw2(i),  crmaxwTrue2(i),
  6825: |           !   &                   cHollBs2(i) ,cVmwBL2(i)
  6826: +------         end do
  6827:                 ! Perform time interpolation, transform variables from integers
  6828:                 ! to real numbers for hurricane vortex calcualtions.
  6829:           
  6830:                 Pn    =  1.d0*(ipn(icyc-1)  +
  6831:                &                         wtratio*(ipn(icyc)-ipn(icyc-1)))
  6832:                 Pc    =  1.d0*(icpress(icyc-1) +
  6833:                &                         wtratio*(icpress(icyc)-icpress(icyc-1)))
  6834: V======>F       crmaxw   =  crmaxw1(:) +
  6835:                &                         wtratio*(crmaxw2(:)-crmaxw1(:))
  6836: V======>F       crmaxwTrue   =  crmaxwTrue1(:) +
  6837:                &                         wtratio*(crmaxwTrue2(:)-crmaxwTrue1(:))
  6838: V======>F       cHollBs  =  cHollBs1(:) +
  6839:                &                         wtratio*(cHollBs2(:)-cHollBs1(:))
  6840: V======>F       cVmwBL   =  cVmwBL1(:) +
  6841:                &                         wtratio*(cVmwBL2(:)-cVmwBL1(:))
  6842:                 !P.V 11/04/2022
  6843:                 !Using absolute value for coriolis for Southern Hemisphere
  6844:                 corio = ABS(2.0d0 * omega * SIN(deg2rad*cLat))
  6845:           
  6846:           !Jie debug GAHM
  6847:           !         WRITE(16,700) 'Temporal interpolation:',
  6848:           !     &           CycleTime(icyc-1), TIMELOC, CycleTime(icyc)
  6849:           
  6850: V------>        do i=1,np
  6851: |       F          cPhiFactor(i) =  1 +
  6852: |              &                       cVmwBL(i)*kt2ms*crmaxw(i)*nm2m*corio/
  6853: |              &                       (cHollBs(i)*((cVmwBL(i)*kt2ms)**2+
  6854: |              &                       cVmwBL(i)*kt2ms*crmaxw(i)*nm2m*corio))
  6855: |         !Jie debug GAHM
  6856: |         !             WRITE(16,699) crmaxw(i),  crmaxwTrue(i),
  6857: |         !     &                   cHollBs(i) ,cVmwBL(i), cPhiFactor(i)
  6858: V------         enddo
  6859:           
  6860:                 uTransNow = uTrans(icyc-1) + wtratio
  6861:                &                  * (uTrans(icyc)-utrans(icyc-1))
  6862:                 vTransNow = vTrans(icyc-1) + wtratio
  6863:                &                  * (vTrans(icyc)-vTrans(icyc-1))
  6864:           
  6865:                 if (writeFullCircleRmaxes.eqv..true.) then
  6866: +------>           do i=1,np
  6867: |                     write(444,*)  crmaxw(i), aziangle(i),dist(i)
  6868: +------            end do
  6869:                 endif
  6870:                 ! jgf49.0803 Make the current Rmax and center location
  6871:                 ! available at the module level for use in NWS29
  6872:                 vortexLat = cLat
  6873:                 vortexLon = cLon
  6874:                 vortexRMW = 0.0d0
  6875:                 !jgf50.32: For sector-based wind drag, record the center
  6876:                 !of the storm.
  6877:                 IF ((cLat.ne.EyeLat(3)).or.(cLon.ne.EyeLon(3))) THEN
  6878:                    EyeLat(1) = EyeLat(2)
  6879:                    EyeLon(1) = EyeLon(2)
  6880:                    EyeLat(2) = EyeLat(3)
  6881:                    EyeLon(2) = EyeLon(3)
  6882:                    EyeLat(3) = cLat
  6883:                    EyeLon(3) = cLon
  6884:                    FoundEye = .true.
  6885:                 ENDIF
  6886:           
  6887:                 ! jgf: arithmetic mean of the Rmax in the selected storm quadrants from
  6888:                 ! the selected isotachs
  6889:                 numRmaxes = 0.d0 ! count how many Rmax values we have to work with
  6890: *------>        do i=1,4  ! loop quads
  6891: |*----->           do j=1,3 ! loop isotachs
  6892: ||                    if (quadflag(icyc-1,i,j)==1) then
  6893: ||                       oldVortexRMW = oldVortexRMW + rmaxw(icyc-1,i,j)
  6894: ||                       numRmaxes = numRmaxes + 1.d0
  6895: ||                    endif
  6896: |*-----            end do
  6897: *------         enddo
  6898:                 oldVortexRMW = oldVortexRMW / numRmaxes
  6899:                 numRmaxes = 0.d0 ! count how many Rmax values we have to work with
  6900: *------>        do i=1,4  ! loop quads
  6901: |*----->           do j=1,3 ! loop isotachs
  6902: ||                    if (quadflag(icyc,i,j)==1) then
  6903: ||                       newVortexRMW = newVortexRMW + rmaxw(icyc,i,j)
  6904: ||                       numRmaxes = numRmaxes + 1.d0
  6905: ||                    endif
  6906: |*-----            end do
  6907: *------         enddo
  6908:                 newVortexRMW = newVortexRMW / numRmaxes
  6909:                 vortexRMW = oldVortexRMW + wtratio * ( newVortexRMW - oldVortexRMW )
  6910:           
  6911:                 !-------------------------------
  6912:                 ! Create a new asymmetric hurricane vortex.
  6913:                 !
  6914:                 ! Note: Subtract translational speed from Vmax, then
  6915:                 ! scale (Vmax - Vt) and Vr up to the top of the surface,
  6916:                 ! where the cylcostrophic wind balance is valid.
  6917:                 !-------------------------------------------------------
  6918:                 !-------------------------------------------------------------
  6919:                 ! Calculate wind and pressure fields at model nodal points.
  6920:                 !
  6921:                 ! Note: the asymmetric vortex wind speed is reduced from the
  6922:                 ! top of the surface layer to the surface, then converted from
  6923:                 ! a 1-minute (max sustained) to a 10-minute average prior to
  6924:                 ! adding the translational velocity in subroutine uvp.
  6925:                 !-------------------------------------------------------------
  6926:                 stormMotion = 1.5d0*(SQRT(uTransNow**2.d0+vTransNow**2.d0))**0.63d0
  6927:                 dirNow = rad2deg * ATAN2(uTransNow, vTransNow)
  6928:                 if (dirNow .lt. 0.d0) dirNow = dirNow + 360.d0
  6929:                 stormMotionU = sin(dirNow/rad2deg)*stormMotion
  6930:                 stormMotionV = cos(dirNow/rad2deg)*stormMotion
  6931:                 call setVortex(Pn,Pc,cLat,cLon)
  6932:           
  6933: +------>        DO i=1,np
  6934: |                  CALL uvpr(dist(i),aziangle(i),crmaxw(i),crmaxwTrue(i),
  6935: |              &        cHollBs(i),cVmwBL(i),cPhiFactor(i),stormMotionU,
  6936: |              &        stormMotionV,geofactor,wvnx(i),wvny(i),press(i))
  6937: |         
  6938: |         
  6939: |                  !P.V 11/04/2022
  6940: |                  press(i) = max(0.85d5,min(1.1e5,press(i)))  ! Typhoon Tip 870 hPa ... 12-oct-1979
  6941: |                  wvnx(i)  = max(-200.d0,min(200.d0,wvnx(i)))
  6942: |                  wvny(i)  = max(-200.d0,min(200.d0,wvny(i)))
  6943: |         
  6944: |                  !-------------------------------------------
  6945: |                  ! Convert atmospheric pressure (Pascals) to
  6946: |                  ! atmospheric pressure-induced water surface
  6947: |                  ! elevation (meters).
  6948: |                  !-------------------------------------------
  6949: |                  press(i) = press(i) / RhoWatG
  6950: |         
  6951: +------         END DO
  6952:           
  6953:                 !-----------------------------------
  6954:                 ! NHC advisory best-track i/o format
  6955:                 !-----------------------------------
  6956:                 firstCall = 1
  6957:                 told=TIMELOC
  6958:           
  6959:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6960:                 call allMessage(DEBUG,"Return.")
  6961:           #endif
  6962:                 call unsetMessageSource()
  6963:           C***********************************************************************
  6964:                 END SUBROUTINE NWS20GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:13 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS20GET
INLINE LIST

  ROOT: WIND::NWS20GET (wind.F:6339)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:6433)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6612)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:6613)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:6677)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:6685)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6687)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:6689)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6709)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:6711)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:6742)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::FITRMAXES4 (wind.F:6777)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6785)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6786)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6789)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6790)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::FITRMAXES4 (wind.F:6811)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6817)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6818)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6821)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SPINTERP (wind.F:6822)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::SETVORTEX (wind.F:6931)
     *** Source for routine not found.
  -> NOINLINE: VORTEX::UVPR (wind.F:6934)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:6962)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:13 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS20GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:6458)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6458)
    *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:6458)
  LOOP END

  LOOP BEGIN: (wind.F:6474)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6474)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6474)
  LOOP END

  LOOP BEGIN: (wind.F:6475)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6475)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6475)
  LOOP END

  LOOP BEGIN: (wind.F:6489)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:6489)
    *** Unvectorizable loop structure. (wind.F:6489)
  LOOP END

  LOOP BEGIN: (wind.F:6519)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6519)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:6519)
  LOOP END

  LOOP BEGIN: (wind.F:6520)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6520)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:6520)
  LOOP END

  LOOP BEGIN: (wind.F:6521)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6521)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:6521)
  LOOP END

  LOOP BEGIN: (wind.F:6522)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6522)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:6522)
  LOOP END

  LOOP BEGIN: (wind.F:6523)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6523)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:6523)
  LOOP END

  LOOP BEGIN: (wind.F:6562)
    <Unvectorized loop.>
    *** Unvectorizable data type. : NAME1 (wind.F:6562)
    *** Unvectorizable data type. : NAME (wind.F:6562)
  LOOP END

  LOOP BEGIN: (wind.F:6595)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:6595)
    *** Deallocation obstructs vectorization. (wind.F:6595)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:6595)
    *** Vectorization obstructive statement. (wind.F:6595)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:6595)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:6595)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:6595)

    LOOP BEGIN: (wind.F:6640)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NAME1 (wind.F:6640)
      *** Unvectorizable data type. : NAME (wind.F:6640)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:6719)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:6719)
  LOOP END

  LOOP BEGIN: (wind.F:6719)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:6719)
  LOOP END

  LOOP BEGIN: (wind.F:6756)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6756)
    *** The number of VLOAD, VSTORE. :  2,  3. (wind.F:6756)
  LOOP END

  LOOP BEGIN: (wind.F:6784)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : VORTEX::SPINTERP (wind.F:6784)
  LOOP END

  LOOP BEGIN: (wind.F:6816)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : VORTEX::SPINTERP (wind.F:6816)
  LOOP END

  LOOP BEGIN: (wind.F:6834)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6834)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:6834)
  LOOP END

  LOOP BEGIN: (wind.F:6834)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6834)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6834)
  LOOP END

  LOOP BEGIN: (wind.F:6836)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6836)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:6836)
  LOOP END

  LOOP BEGIN: (wind.F:6836)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6836)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6836)
  LOOP END

  LOOP BEGIN: (wind.F:6838)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6838)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:6838)
  LOOP END

  LOOP BEGIN: (wind.F:6838)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6838)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6838)
  LOOP END

  LOOP BEGIN: (wind.F:6840)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6840)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:6840)
  LOOP END

  LOOP BEGIN: (wind.F:6840)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6840)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:6840)
  LOOP END

  LOOP BEGIN: (wind.F:6850)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6850)
    *** The number of VLOAD, VSTORE. :  3,  1. (wind.F:6850)
  LOOP END

  LOOP BEGIN: (wind.F:6866)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:6866)
  LOOP END

  LOOP BEGIN: (wind.F:6933)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : VORTEX::UVPR (wind.F:6933)
  LOOP END

  LOOP BEGIN: (wind.F:6720)
    <Vectorized loop.>
    **  Fused loop. (wind.F:6720)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:6720)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:6720)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:13 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS20GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 23328 bytes
      Register spill area      :  9232 bytes
      Parameter area           :   104 bytes
      Register save area       :   176 bytes
      User data area           : 13808 bytes
      Others                   :     8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:6458)
    *** Estimated execution cycle                       : 164
  LOOP END

  LOOP BEGIN: (wind.F:6474)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:6475)
    *** Estimated execution cycle                       : 100
  LOOP END

  LOOP BEGIN: (wind.F:6489)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (wind.F:6519)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:6520)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:6521)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:6522)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:6523)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:6562)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:6595)
    *** Estimated execution cycle                       : 1867
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 128
            Across calls                                :   7
            Not enough registers                        :  24
            Over basic blocks                           :  96
            Others                                      :   1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 434
            Across calls                                :  84
            Not enough registers                        :  24
            Over basic blocks                           : 326
    *** The number of SCALAR REGISTER TRANSFER          : 111

    LOOP BEGIN: (wind.F:6640)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:6719)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:6719)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:6756)
    *** Estimated execution cycle                       : 786
    *** The number of VECTOR REGISTER SPILL
          Total                                         : 2
            Others                                      : 2
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:6784)
    *** Estimated execution cycle                       : 84
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Across calls                                : 5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 10
            Across calls                                :  7
            Over basic blocks                           :  3
    *** The number of SCALAR REGISTER TRANSFER          : 17
  LOOP END

  LOOP BEGIN: (wind.F:6816)
    *** Estimated execution cycle                       : 96
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 14
            Across calls                                :  9
            Over basic blocks                           :  5
    *** The number of SCALAR REGISTER TRANSFER          : 18
  LOOP END

  LOOP BEGIN: (wind.F:6834)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:6834)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:6836)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:6836)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:6838)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:6838)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:6840)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:6840)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:6850)
    *** Estimated execution cycle                       : 710
  LOOP END

  LOOP BEGIN: (wind.F:6866)
    *** Estimated execution cycle                       : 47
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (wind.F:6933)
    *** Estimated execution cycle                       : 94
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Across calls                                : 4
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 6
            Across calls                                : 4
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END

  LOOP BEGIN: (wind.F:6720)
    *** Estimated execution cycle                       : 128
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15INIT
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6989: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  6994: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  6994: vec( 103): Unvectorized loop.
  6994: vec( 108): Unvectorizable loop structure.
  6995: inl(1222): Inlined: WIND::WINDTERMINATE
  8778: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  6999: opt(1418): Constant-length loop is expanded.
  7005: vec( 103): Unvectorized loop.
  7005: vec( 180): I/O statement obstructs vectorization.
  7005: vec( 108): Unvectorizable loop structure.
  7011: vec( 101): Vectorized loop.
  7017: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  7017: vec( 103): Unvectorized loop.
  7017: vec( 108): Unvectorizable loop structure.
  7025: vec( 103): Unvectorized loop.
  7025: vec( 108): Unvectorizable loop structure.
  7025: vec( 118): Unvectorizable data type.: SCRATCHMESSAGE
  7025: vec( 118): Unvectorizable data type.: PRESSUREWINDRELATIONSHIP
  7027: vec( 103): Unvectorized loop.
  7027: vec( 108): Unvectorizable loop structure.
  7029: vec( 180): I/O statement obstructs vectorization.
  7029: vec( 181): Allocation obstructs vectorization.
  7029: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::LOGMESSAGE
  7029: vec( 182): Deallocation obstructs vectorization.
  7029: vec( 108): Unvectorizable loop structure.
  7030: opt(1118): This I/O statement inhibits optimization of loop.
  7035: opt(1082): Backward transfers inhibit loop optimization.
  7035: vec( 103): Unvectorized loop.
  7035: vec( 108): Unvectorizable loop structure.
  7055: inl(1222): Inlined: WIND::WINDTERMINATE
  7060: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7060: vec( 103): Unvectorized loop.
  7060: vec( 180): I/O statement obstructs vectorization.
  7060: vec( 182): Deallocation obstructs vectorization.
  7060: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  7060: vec( 109): Vectorization obstructive statement.
  7060: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  7060: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  7060: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  7062: opt(1118): This I/O statement inhibits optimization of loop.
  7065: inl(1222): Inlined: WIND::WINDTERMINATE
  7071: vec( 103): Unvectorized loop.
  7071: vec( 108): Unvectorizable loop structure.
  7073: vec( 103): Unvectorized loop.
  7073: vec( 108): Unvectorizable loop structure.
  7076: vec( 103): Unvectorized loop.
  7076: vec( 108): Unvectorizable loop structure.
  7078: inl(1222): Inlined: WIND::WINDTERMINATE
  7085: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7085: vec( 180): I/O statement obstructs vectorization.
  7085: vec( 181): Allocation obstructs vectorization.
  7085: vec( 182): Deallocation obstructs vectorization.
  7085: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  7085: vec( 109): Vectorization obstructive statement.
  7085: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  7085: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  7085: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  7087: opt(1118): This I/O statement inhibits optimization of loop.
  7089: opt(1082): Backward transfers inhibit loop optimization.
  7089: vec( 103): Unvectorized loop.
  7089: vec( 108): Unvectorizable loop structure.
  7091: inl(1222): Inlined: WIND::WINDTERMINATE
  7095: vec( 101): Vectorized loop.
  7112: vec( 101): Vectorized loop.
  7117: vec( 101): Vectorized loop.
  7122: vec( 101): Vectorized loop.
  7123: vec( 126): Idiom detected.: SEARCH
  7139: inl(1222): Inlined: WIND::WINDTERMINATE
  7144: inl(1214): Expansion routine is too big for automatic expansion.: WIND::LOADHWINDFILE
  7148: opt(1418): Constant-length loop is expanded.
  7149: opt(1418): Constant-length loop is expanded.
  7174: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15INIT
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6975:                 subroutine NWS15INIT(timeloc)
  6976:                 use sizes, only : globaldir, mnp
  6977:                 use global, only : ihot, nws, openFileForRead, nabout
  6978:                 implicit none
  6979:           C
  6980:                 real(8), intent(in) :: timeloc ! adcirc time in seconds since coldstart
  6981:           C
  6982:                 logical :: fileFound   ! true if the file could be found
  6983:                 integer :: errorio     ! .gt. 1 if there was an i/o error
  6984:                 integer :: currentLine ! line from fort.22 being processed, used in error msgs
  6985:                 logical :: cycleTimeFound ! true if the adcirc time falls into one
  6986:                                           ! of the hwind time intervals
  6987:                 integer :: i           ! loop counter
  6988:           C
  6989:                 call setMessageSource("nws15init")
  6990:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  6991:                 call allMessage(DEBUG,"Enter.")
  6992:           #endif
  6993:                 errorio = 0
  6994:                 call openFileForRead(22,trim(globaldir)//"/fort.22",errorio)
  6995:         I       if (errorio.gt.0) call windTerminate()
  6996:                 !
  6997:                 ! read fort.22 to determine how many HWind files there are
  6998:                 currentLine = 1
  6999: *------>        do i=1,3
  7000: |                  ! throw header away this time
  7001: |                  read(22,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7002: |                  currentLine = currentLine + 1
  7003: *------         end do
  7004:                 numFiles = 0
  7005: +------>        do   ! loop until we run out of data, just counting the files this time
  7006: |                  read(22,'(A)',end=123,err=248,iostat=errorio) scratchMessage
  7007: |                  currentLine = currentLine + 1
  7008: |                  numFiles = numFiles + 1
  7009: +------         end do
  7010:            123  continue ! jump to here when we've run out of lines in the fort.22
  7011: V======>        allocate(hWindFiles(numFiles))
  7012:                 !
  7013:                 ! now go back to the beginning of the file and read in the data
  7014:                 rewind(22)
  7015:                 currentLine = 1
  7016:                 read(22,'(A)',end=246,err=248,iostat=errorio) metComment
  7017:                 call logMessage(ECHO,"metComment: "//trim(metComment))
  7018:                 currentLine = currentLine + 1
  7019:                 read(22,*,end=246,err=248,iostat=errorio) hWindMultiplier
  7020:                 currentLine = currentLine + 1
  7021:                 write(scratchMessage,'("hWindMultiplier=",E15.8)') hWindMultiplier
  7022:                 call logMessage(ECHO,scratchMessage)
  7023:                 read(22,'(A)',end=248,err=248,iostat=errorio) scratchMessage
  7024:                 currentLine = currentLine + 1
  7025: +======>        pressureWindRelationship
  7026:                &      = scratchMessage(1:index(adjustl(scratchMessage)," "))
  7027:                 call logMessage(ECHO,"pressureWindRelationship: "
  7028:                &     //trim(pressureWindRelationship))
  7029: +------>        do i=1,numFiles
  7030: |                  read(22,*,end=246,err=248,iostat=errorio)
  7031: |              &     hWindFiles(i)%cycleTime,
  7032: |              &     hWindFiles(i)%Pc,
  7033: |              &     hWindFiles(i)%rampVal,
  7034: |              &     hwindFiles(i)%file_name
  7035: |                  write(scratchMessage,
  7036: |              &   '("time=",E15.8," Pc=",E15.8," ramp=",E15.8," file_name=",A)')
  7037: |              &       hWindFiles(i)%cycleTime, hWindFiles(i)%Pc,
  7038: |              &       hWindFiles(i)%rampVal, trim(hwindFiles(i)%file_name)
  7039: |                  call logMessage(ECHO,scratchMessage)
  7040: |                  currentLine = currentLine + 1
  7041: +------         end do
  7042:                 close(22)
  7043:                 !
  7044:                 ! log the number of HWind files that were specified
  7045:                 write(scratchMessage,
  7046:                &    '("There were ",i0," HWind files specified.")') numFiles
  7047:                 call logMessage(INFO,scratchMessage)
  7048:                 !
  7049:                 ! need at least 2 files so we have something to interpolate between
  7050:                 ! in time
  7051:                 if (numFiles.lt.2) then
  7052:                    call allMessage(ERROR,"Only one HWind file was specified.")
  7053:                    call allMessage(ERROR,
  7054:                &    "ADCIRC requires at least two HWind files for interpolation.")
  7055:         I          call windTerminate()
  7056:                 endif
  7057:                 !
  7058:                 ! check to make sure that the cycleTimes are
  7059:                 ! monotonically increasing
  7060: +------>        do i=1,numFiles-1
  7061: |                  if (hWindFiles(i)%cycleTime.ge.hWindFiles(i+1)%cycleTime) then
  7062: |                     write(scratchMessage,
  7063: |              &    '("Cycle time ",i0," must be less cycle time ",i0,".")')i,i+1
  7064: |                     call allMessage(ERROR,scratchMessage)
  7065: |       I             call windTerminate()
  7066: |                  endif
  7067: +------         end do
  7068:                 !
  7069:                 ! check to make sure the specified pressure-wind relationship
  7070:                 ! is supported by ADCIRC
  7071:                 select case(trim(pressureWindRelationship))
  7072:                 case("dvorak","knaffzehr","specifiedPc","background")
  7073:                    call logMessage(INFO,"ADCIRC will use the "//
  7074:                &   trim(pressureWindRelationship)//" pressure-wind relationship.")
  7075:                 case default
  7076:                    call allMessage(ERROR,"The "//trim(pressureWindRelationship)//
  7077:                &      " pressure-wind relationship is not supported by ADCIRC.")
  7078:                    call windTerminate()
  7079:                 end select
  7080:                 !
  7081:         I       ! check to make sure that all the HWind files are actually there;
  7082:                 ! we assume that the file names contain the full path to the file;
  7083:                 ! if the file name contains forward slashes, it must be surrounded
  7084:                 ! by quotation marks
  7085: +------>        do i=1,numFiles-1
  7086: |                  fileFound = .false.
  7087: |                  inquire(file=hWindFiles(i)%file_name,exist=fileFound)
  7088: |                  if (fileFound.eqv..false.) then
  7089: |                     call allMessage(ERROR,"The HWind file "//
  7090: |              &          trim(hWindFiles(i)%file_name)//" was not found.")
  7091: |       I             call windTerminate()
  7092: |                  endif
  7093: +------         end do
  7094:                 call logMessage(INFO,"All specified HWind files were found.")
  7095: V======>        hWindFiles(:)%loaded = .false.
  7096:                 !
  7097:                 ! allocate memory for mesh coordinates in mercator projection
  7098:                 allocate(x_mercator(mnp),y_mercator(mnp))
  7099:                 ! allocate memory for lower left HWind grid indices assigned to each mesh node
  7100:                 allocate(x_indices(mnp),y_indices(mnp))
  7101:                 ! allocate memory for the interpolation weights
  7102:                 allocate(w1(mnp),w2(mnp),w3(mnp),w4(mnp))
  7103:                 ! allocate memory for wind u,v velocity work arrays
  7104:                 allocate(wvnx_work(mnp),wvny_work(mnp))
  7105:                 ! allocate memory for wind speed; this is used to find Vmax and Rmax
  7106:                 allocate(windSpeeds(mnp))
  7107:                 ! allocate memory to keep track of which mesh nodes are inside
  7108:                 ! the hwind bounding box
  7109:                 allocate(inside(mnp))
  7110:                 !
  7111:                 ! relate timing in the files to current ADCIRC time
  7112: V======>        hWindFiles(:)%cycleTime = hWindFiles(:)%cycleTime * 3600.d0 ! convert hours to seconds
  7113:                 if  ((nws.lt.0).and.(ihot.ne.0)) then
  7114:                    ! if times are relative to hotstart time, add the hotstart time
  7115:                    ! so that we can consider the times relative to the coldstart
  7116:                    ! time from here on
  7117: V======>           hWindFiles(:)%cycleTime = hWindFiles(:)%cycleTime + timeloc
  7118:                 endif
  7119:                 !
  7120:                 ! locate the cycle that is relevant to current ADCIRC time
  7121:                 cycleTimeFound = .false.
  7122: V------>        do i=1,numFiles-1
  7123: |                  if ( (hWindFiles(i)%cycleTime.le.timeloc).and.
  7124: |              &        (hWindFiles(i+1)%cycleTime.gt.timeloc) ) then
  7125: |                     cycleTimeFound = .true.
  7126: |                     exit
  7127: |                  endif
  7128: V------         end do
  7129:                 ! if we couldn't find a relevant time interval, game over
  7130:                 if ( cycleTimeFound.eqv..false. ) then
  7131:                    if ( timeloc.lt.hWindFiles(1)%cycleTime ) then
  7132:                       call allMessage(ERROR,
  7133:                & "The current ADCIRC time is earlier than the first HWind file.")
  7134:                    endif
  7135:                 if ( timeloc.gt.hWindFiles(numFiles)%cycleTime ) then
  7136:                       call allMessage(ERROR,
  7137:                &    "The current ADCIRC time is later than the last HWind file.")
  7138:                    endif
  7139:         I          call windTerminate()
  7140:                 endif
  7141:                 currentCycle = i
  7142:                 !
  7143:                 ! load up the data for this time interval
  7144:                 call loadHWindFile(currentCycle)
  7145:                 call loadHWindFile(currentCycle+1)
  7146:                 !
  7147:                 ! initialize eye locations for sector based wind drag (Powell)
  7148: *======>        EyeLat = 0.d0
  7149: *======>        EyeLon = 0.d0
  7150:           
  7151:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7152:                 call allMessage(DEBUG,"Return.")
  7153:           #endif
  7154:                 call unsetMessageSource()
  7155:                 return
  7156:           C
  7157:           C     We jump to this section if there was an error reading a file.
  7158:           246   call allMessage(ERROR,"Unexpectedly reached end-of-file.") ! END jumps here
  7159:           248   call allMessage(ERROR,"I/O error during file access.") !  ERR jumps here
  7160:                 call allMessage(INFO,
  7161:                &   "Check the fort.16 file for more information.")
  7162:                 if (nabout.gt.0) then
  7163:                    call allMessage(INFO,
  7164:                &  "Reducing the value of NABOUT to 0"
  7165:                &  //" will maximize the information written to the fort.16 file,"
  7166:                &  //" which may aid in troubleshooting this issue.")
  7167:                 endif
  7168:                 write(scratchMessage,'("Could not read line ",I2," of fort.22.")')
  7169:                &  currentLine
  7170:                 call allMessage(ERROR,scratchMessage)
  7171:                 write(scratchMessage,'(A,I3,A)')
  7172:                &       'The value of the i/o error flag was ',errorio,'.'
  7173:                 call allMessage(ERROR,scratchMessage)
  7174:         I       CALL windTerminate()
  7175:           C     ----------------------------------------------------------------
  7176:                 END SUBROUTINE NWS15INIT


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15INIT
INLINE LIST

  ROOT: WIND::NWS15INIT (wind.F:6975)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:6989)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:6994)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:6995)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7017)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7022)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7027)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7039)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7047)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7052)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7053)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7055)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7064)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7065)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7073)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7076)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7078)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7089)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7091)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7094)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7132)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7136)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7139)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: WIND::LOADHWINDFILE (wind.F:7144)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: WIND::LOADHWINDFILE (wind.F:7145)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7154)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7158)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7159)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7160)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7163)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7170)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7173)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7174)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15INIT
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:6994)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:6994)
  LOOP END

  LOOP BEGIN: (wind.F:7005)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7005)
    *** Unvectorizable loop structure. (wind.F:7005)
  LOOP END

  LOOP BEGIN: (wind.F:7011)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7011)
    *** The number of VLOAD, VSTORE. :  0,  2. (wind.F:7011)
  LOOP END

  LOOP BEGIN: (wind.F:7017)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7017)
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7025)
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SCRATCHMESSAGE (wind.F:7025)
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:7025)
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:7025)
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRESSUREWINDRELATIONSHIP (wind.F:7025)
  LOOP END

  LOOP BEGIN: (wind.F:7027)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7027)
  LOOP END

  LOOP BEGIN: (wind.F:7029)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7029)
    *** Allocation obstructs vectorization. (wind.F:7029)
    *** Vectorization obstructive procedure reference. : GLOBAL::LOGMESSAGE (wind.F:7029)
    *** Deallocation obstructs vectorization. (wind.F:7029)
    *** Unvectorizable loop structure. (wind.F:7029)

    LOOP BEGIN: (wind.F:7035)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:7035)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7060)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7060)
    *** Deallocation obstructs vectorization. (wind.F:7060)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:7060)
    *** Vectorization obstructive statement. (wind.F:7060)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:7060)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:7060)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:7060)
  LOOP END

  LOOP BEGIN: (wind.F:7071)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7071)
  LOOP END

  LOOP BEGIN: (wind.F:7076)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7076)
  LOOP END

  LOOP BEGIN: (wind.F:7073)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7073)
  LOOP END

  LOOP BEGIN: (wind.F:7085)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7085)
    *** Allocation obstructs vectorization. (wind.F:7085)
    *** Deallocation obstructs vectorization. (wind.F:7085)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:7085)
    *** Vectorization obstructive statement. (wind.F:7085)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:7085)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:7085)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:7085)

    LOOP BEGIN: (wind.F:7089)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:7089)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7095)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7095)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7095)
  LOOP END

  LOOP BEGIN: (wind.F:7112)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7112)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7112)
  LOOP END

  LOOP BEGIN: (wind.F:7117)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7117)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7117)
  LOOP END

  LOOP BEGIN: (wind.F:7122)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7122)
    *** The number of VLOAD, VSTORE. :  2,  0. (wind.F:7122)
    *** Idiom detected. : SEARCH (wind.F:7123)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15INIT
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 45 [s0-s12 s15-s16 s18-s39 s56-s63]
      Vector registers         : 14 [v50-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 9472 bytes
      Register spill area      :  544 bytes
      Parameter area           :  104 bytes
      Register save area       :  176 bytes
      User data area           : 8640 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:6994)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7005)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 9
  LOOP END

  LOOP BEGIN: (wind.F:7011)
    *** Estimated execution cycle                       : 101
  LOOP END

  LOOP BEGIN: (wind.F:7017)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    *** Estimated execution cycle                       : 8
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:7025)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:7027)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7029)
    *** Estimated execution cycle                       : 265
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 9
            Across calls                                : 4
            Over basic blocks                           : 3
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 20
            Across calls                                :  7
            Over basic blocks                           : 12
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 30

    LOOP BEGIN: (wind.F:7035)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7060)
    *** Estimated execution cycle                       : 143
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 11
            Across calls                                : 11
    *** The number of SCALAR REGISTER TRANSFER          : 19
  LOOP END

  LOOP BEGIN: (wind.F:7071)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7076)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7073)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7085)
    *** Estimated execution cycle                       : 263
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 10
            Across calls                                :  8
            Over basic blocks                           :  1
            Others                                      :  1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 20
            Across calls                                : 12
            Over basic blocks                           :  7
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 17

    LOOP BEGIN: (wind.F:7089)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7095)
    *** Estimated execution cycle                       : 67
  LOOP END

  LOOP BEGIN: (wind.F:7112)
    *** Estimated execution cycle                       : 97
  LOOP END

  LOOP BEGIN: (wind.F:7117)
    *** Estimated execution cycle                       : 97
  LOOP END

  LOOP BEGIN: (wind.F:7122)
    *** Estimated execution cycle                       : 341
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7238: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  7255: inl(1214): Expansion routine is too big for automatic expansion.: WIND::LOADHWINDFILE
  7257: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  7262: inl(1222): Inlined: WIND::WINDTERMINATE
  7316: vec( 101): Vectorized loop.
  7319: vec( 101): Vectorized loop.
  7319: vec( 128): Fused multiply-add operation applied.
  7323: vec( 101): Vectorized loop.
  7324: vec( 101): Vectorized loop.
  7328: inl(1222): Inlined: WIND::HWINDINTERPOLATEVELOCITY
  7333: inl(1222): Inlined: WIND::HWINDINTERPOLATEVELOCITY
  7338: vec( 101): Vectorized loop.
  7338: vec( 128): Fused multiply-add operation applied.
  7343: vec( 101): Vectorized loop.
  7344: opt(1059): Unable to determine last value of scalar temporary.
  7344: vec( 101): Vectorized loop.
  7344: vec( 126): Idiom detected.: MAX/MIN
  7345: inl(1212): Source for routine not found.: GLOBAL::SPHERICALDISTANCE
  7357: vec( 103): Unvectorized loop.
  7357: vec( 108): Unvectorizable loop structure.
  7371: vec( 103): Unvectorized loop.
  7371: vec( 108): Unvectorizable loop structure.
  7374: inl(1222): Inlined: WIND::WINDTERMINATE
  7385: vec( 103): Unvectorized loop.
  7385: vec( 108): Unvectorizable loop structure.
  7387: vec( 103): Unvectorized loop.
  7387: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SPHERICALDISTANCE
  7388: opt(1025): Reference to this procedure inhibits optimization.: GLOBAL::SPHERICALDISTANCE
  7396: vec( 101): Vectorized loop.
  7402: vec( 101): Vectorized loop.
  7402: vec( 128): Fused multiply-add operation applied.
  7405: opt(1112): Loop fused with previous loop.
  7408: vec( 101): Vectorized loop.
  7409: opt(1112): Loop fused with previous loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7209:                 subroutine NWS15GET(wvnx, wvny, press, timeloc)
  7210:                 use sizes, only : mnp
  7211:                 USE ADC_CONSTANTS, only : mb2pa, m2nm, nm2m
  7212:                 use mesh, only : slam, sfea, np, dp
  7213:                 implicit none
  7214:                 real(8), intent(out) :: wvnx(:)  ! wind u-velocity (m/s)
  7215:                 real(8), intent(out) :: wvny(:)  ! wind v-velocity (m/s)
  7216:                 real(8), intent(out) :: press(:) ! barometric pressure (mH2O)
  7217:                 real(8), intent(in) :: timeloc    ! adcirc time, seconds since coldstart
  7218:           C
  7219:                 real(8) :: wtratio  ! time weighting factor for time interpolation
  7220:                 real(8) :: cLonNow  ! time interpolated longitude at center of storm
  7221:                 real(8) :: cLatNow  ! time interpolated latitude at center of storm
  7222:                 real(8) :: rampValNow  ! time interpolated met ramp value
  7223:                 real(8) :: k_0      ! constant used in mercator projection
  7224:                 real(8) :: y_mercator_0 ! mercator y coord at center of storm
  7225:                 real(8) :: rmaxNow  ! (nm) used in estimating central pressure
  7226:                 real(8) :: pc       ! (mbar) used to find pressure field
  7227:                 real(8) :: B        ! Holland cyclone shape parameter
  7228:                 real(8) :: dist     ! (m) distance from storm center to mesh node
  7229:                 real(8) :: dxNow,dyNow ! (nm) x and y distance from storm center rmaxNow
  7230:                 real(8) :: vmaxNow  ! (m/s) time interpolated fulldomain vmax
  7231:                 real(8) :: oldDX, oldDY ! (nm) distances to rmax in last hwind cycle
  7232:                 real(8) :: newDX, newDY ! (nm) distances to rmax in next hwind cycle
  7233:                 real(8) :: angle    ! (nm) angle to location of mesh vmax (on subdomain in parallel)
  7234:                 real(8) :: maxSpeed ! (m/s) max wind speed on mesh (subdomain in parallel)
  7235:                 integer  :: maxNode  ! mesh node on which maxSpeed occurs
  7236:                 integer  :: i        ! loop counter
  7237:           C
  7238:                 call setMessageSource("nws15get")
  7239:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7240:                 call allMessage(DEBUG,"Enter.")
  7241:           #endif
  7242:                 !
  7243:                 ! check to see if the current ADCIRC time is still in the interval of
  7244:                 ! the HWind cycles we are currently accessing ... if the ADCIRC
  7245:                 ! time has gone beyond this interval, load up the next file
  7246:                 if ( timeloc.gt.hWindFiles(currentCycle+1)%cycleTime) then
  7247:                    ! "unload" the stale hwind data
  7248:                    deallocate(hWindFiles(currentCycle)%u)
  7249:                    deallocate(hWindFiles(currentCycle)%v)
  7250:                    hWindFiles(currentCycle)%loaded = .false.
  7251:                    ! update cycle number
  7252:                    currentCycle = currentCycle + 1
  7253:                    ! load up the new data, unless we've gone past the last file
  7254:                    if ((currentCycle+1).le.numFiles) then
  7255:                       call loadHWindFile(currentCycle+1)
  7256:                    else
  7257:                       call allMessage(ERROR,
  7258:                &  "The ADCIRC time has exceeded the time of the last HWind file.")
  7259:                       write(scratchMessage,
  7260:                &    '("ADCIRC time=",E15.3," (sec), last HWind time=",E15.3,".")')
  7261:                &      timeloc, hWindFiles(numFiles)%cycleTime
  7262:         I             call windTerminate()
  7263:                    endif
  7264:                 endif
  7265:                 !
  7266:                 ! compute the time weighting factor for time interpolation
  7267:                 wtratio = (timeloc - hWindFiles(currentCycle)%cycleTime) /
  7268:                &          ( hWindFiles(currentCycle+1)%cycleTime -
  7269:                &            hWindFiles(currentCycle)%cycleTime )
  7270:                 !
  7271:                 ! time-interpolate the location of the storm center
  7272:                 cLonNow = hWindFiles(currentCycle)%cLon +
  7273:                &     wtratio * (hWindFiles(currentCycle+1)%cLon -
  7274:                &                 hWindFiles(currentCycle)%cLon )
  7275:                 cLatNow = hWindFiles(currentCycle)%cLat +
  7276:                &     wtratio * (hWindFiles(currentCycle+1)%cLat -
  7277:                &                 hWindFiles(currentCycle)%cLat )
  7278:                 !
  7279:                 ! set eye location for sector based wind drag
  7280:                 if ( (cLatNow.ne.EyeLat(3)).or.(cLonNow.ne.EyeLon(3))) then
  7281:                    EyeLat(1) = EyeLat(2)
  7282:                    EyeLon(1) = EyeLon(2)
  7283:                    EyeLat(2) = EyeLat(3)
  7284:                    EyeLon(2) = EyeLon(3)
  7285:                    EyeLat(3) = cLatNow
  7286:                    EyeLon(3) = cLonNow
  7287:                    FoundEye = .TRUE.
  7288:                 endif
  7289:                 !
  7290:                 ! time-interpolate the vmax, rmax, and angle to rmax
  7291:                 ! vmaxNow represents the current vmax on the whole domain
  7292:                 ! ... not just  on this particular subdomain (in parallel)
  7293:                 vmaxNow = hWindFiles(currentCycle)%vmax +
  7294:                &     wtratio * (hWindFiles(currentCycle+1)%vmax -
  7295:                &                 hWindFiles(currentCycle)%vmax )
  7296:                 rmaxNow = hWindFiles(currentCycle)%rmax +
  7297:                &     wtratio * (hWindFiles(currentCycle+1)%rmax -
  7298:                &                 hWindFiles(currentCycle)%rmax )
  7299:                 oldDX = cos(hWindFiles(currentCycle)%rmaxAngle*deg2rad)
  7300:                 oldDY = sin(hWindFiles(currentCycle)%rmaxAngle*deg2rad)
  7301:                 newDX = cos(hWindFiles(currentCycle+1)%rmaxAngle*deg2rad)
  7302:                 newDY = sin(hWindFiles(currentCycle+1)%rmaxAngle*deg2rad)
  7303:                 dxNow = oldDX + wtratio * (newDX - oldDX)
  7304:                 dyNow = oldDY + wtratio * (newDY - oldDY)
  7305:                 angleNow = 360.0d0 + rad2deg * ATAN2(dxNow,dyNow)
  7306:                 if ( angleNow > 360.d0) angleNow = angleNow - 360.d0
  7307:                 !
  7308:                 ! time-interpolate the ramp value
  7309:                 rampValNow = hWindFiles(currentCycle)%rampval +
  7310:                &     wtratio * (hWindFiles(currentCycle+1)%rampval -
  7311:                &                 hWindFiles(currentCycle)%rampval )
  7312:                 !
  7313:                 ! transform the ADCIRC mesh into mercator with origin at the
  7314:                 ! actual current storm center
  7315:                 k_0 = cos(deg2rad*cLatNow)
  7316: V======>        x_mercator = k_0 * Rearth * (slam - deg2rad*cLonNow)
  7317:                 y_mercator_0 = k_0 *
  7318:                &    Rearth * log(tan(0.25d0*pi+0.5d0*deg2rad*cLatNow))
  7319: V======>F       y_mercator = k_0 * Rearth * log(tan(0.25d0*pi+0.5d0*sfea))
  7320:                &    - y_mercator_0
  7321:                 !
  7322:                 ! initialize arrays
  7323: V======>        wvnx = 0.d0
  7324: V======>        wvny = 0.d0
  7325:                 !------------------------------------------------------------
  7326:                 ! interpolate from most recent HWind dataset onto ADCIRC mesh
  7327:                 !------------------------------------------------------------
  7328:         I       call hWindInterpolateVelocity(wvnx, wvny, currentCycle,
  7329:                &    rampValNow, (1.d0-wtratio) )
  7330:                 !------------------------------------------------------------
  7331:                 ! interpolate from next (future) HWind dataset onto ADCIRC mesh
  7332:                 !------------------------------------------------------------
  7333:         I       call hWindInterpolateVelocity(wvnx, wvny, currentCycle+1,
  7334:                &    rampValNow, wtratio)
  7335:                 !
  7336:                 ! determine maximum interpolated wind speeds on adcirc mesh
  7337:                 ! (or on this subdomain mesh if we are running in parallel)
  7338: V======>F       windSpeeds(:) = sqrt(wvnx(:)**2+wvny(:)**2)
  7339:                 !
  7340:                 ! if this run is for wind analysis
  7341:                 ! write out Rmax (nautical miles) and azimuthal angle (degrees),
  7342:                 if (writeFullCircleRmaxes.eqv..true.) then
  7343: V======>           maxSpeed = maxval(windSpeeds)
  7344: V======>           maxNode = maxloc(windSpeeds,1)
  7345:                    dist = m2nm * sphericalDistance(slam(maxNode)-deg2rad*cLonNow,
  7346:                &      sfea(maxNode)-deg2rad*cLatNow,
  7347:                &      cLatNow, rad2deg*sfea(maxNode))
  7348:                    angle = 360.0d0 + rad2deg
  7349:                &       * ATAN2((slam(maxNode)-deg2rad*cLonNow),
  7350:                &                (sfea(maxNode)-deg2rad*cLatNow))
  7351:                    if ( angle > 360.d0) angle = angle - 360.d0
  7352:                    write(444,*) dist, angle
  7353:                 endif
  7354:                 !
  7355:                 ! use max wind speed to estimate minimum central pressure
  7356:                 ! using the specified pressure-wind relationship
  7357:                 select case(trim(pressureWindRelationship))
  7358:                    case("dvorak")
  7359:                       pc = 1015.d0 - (vmaxNow/3.92d0)**(1.0d0/0.644d0);
  7360:                    case("knaffzehr")
  7361:                       pc = 1010.d0 - (vmaxNow/2.3d0)**(1.0d0/0.76d0);
  7362:                    case("specifiedPc")
  7363:                       ! time-interpolate the specified central pressure value
  7364:                       pc = hWindFiles(currentCycle)%Pc +
  7365:                &           wtratio * (hWindFiles(currentCycle+1)%Pc -
  7366:                &                      hWindFiles(currentCycle)%Pc )
  7367:                    case("background")
  7368:                       pc = 1013.d0
  7369:                    case default
  7370:                       ! should be unreachable; already quality checked in nws15init
  7371:                       call allMessage(ERROR,"The "
  7372:                &          //trim(pressureWindRelationship)//
  7373:                &        " pressure-wind relationship is not supported by ADCIRC.")
  7374:                       call windTerminate()
  7375:                 end select
  7376:                 !
  7377:                 ! use central pressure and max wind speed to estimate the Holland B value
  7378:                 B = vmaxNow**2*RhoAir*EXP(1.d0)/((1013.d0 - Pc)*mb2pa)
  7379:                 B = MAX( MIN(B,2.5d0), 1.0d0) ! limit B to range 1.0->2.5
  7380:                 !
  7381:         I       ! using Vmax, Rmax, Pc, and B ... estimate the pressure
  7382:                 ! field using Holland's curve fit ... even compute pressure outside
  7383:                 ! the bounding box of the hwind data, just so we don't get a
  7384:                 ! destabilizing step change in the barometric pressure
  7385:                 select case(trim(pressureWindRelationship))
  7386:                    case("dvorak","knaffzehr","specifiedPc")
  7387:                       do i=1,np
  7388:                          dist = sphericalDistance(slam(i)-deg2rad*cLonNow,
  7389:                &               sfea(i)-deg2rad*cLatNow, cLatNow, rad2deg*sfea(i))
  7390:                          ! the following assumes the rmax is uniform all the way
  7391:                          ! around the storm
  7392:                          press(i) = (Pc + (1013.d0 - Pc)
  7393:                &               * EXP(-(rmaxNow*nm2m/dist)**B))
  7394:                       end do
  7395:                    case("background")
  7396:                       press = 1013.d0
  7397:                    case default
  7398:                       ! should be unreachable
  7399:                 end select
  7400: +------>        !
  7401: |               ! apply ramp value from fort.22 to pressure field
  7402: |               press = ( press - 1013.d0 ) * rampValNow + 1013.d0
  7403: +------         !
  7404:                 ! convert pressure from mb to mH2O
  7405: V======>        press = mb2pa * press / ( RhoWat0 * g )
  7406:                 ! convert from 1 minute avg winds to 10 minute averaged winds
  7407:                 ! TODO: confirm that HWind data are 1 minute averaged winds
  7408: V------>F       wvnx = wvnx * one2ten
  7409: V======         wvnx = wvnx * one2ten
  7410: V------>  C
  7411: V======   #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7412:                 call allMessage(DEBUG,"Return.")
  7413:           #endif
  7414:                 call unsetMessageSource()
  7415:           C     ----------------------------------------------------------------
  7416:                 END SUBROUTINE NWS15GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15GET
INLINE LIST

  ROOT: WIND::NWS15GET (wind.F:7209)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7238)
     *** Source for routine not found.
  -> NOINLINE: WIND::LOADHWINDFILE (wind.F:7255)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7257)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7262)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> INLINE: WIND::HWINDINTERPOLATEVELOCITY (wind.F:7328)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7622)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7684)
      *** Source for routine not found.
  -> INLINE: WIND::HWINDINTERPOLATEVELOCITY (wind.F:7333)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7622)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7684)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:7345)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7371)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7374)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::SPHERICALDISTANCE (wind.F:7388)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7414)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:7316)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7316)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7316)
  LOOP END

  LOOP BEGIN: (wind.F:7316)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7316)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7316)
  LOOP END

  LOOP BEGIN: (wind.F:7319)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7319)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7319)
  LOOP END

  LOOP BEGIN: (wind.F:7319)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7319)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7319)
  LOOP END

  LOOP BEGIN: (wind.F:7323)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7323)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7323)
  LOOP END

  LOOP BEGIN: (wind.F:7324)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7324)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7324)
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7640)
    *** The number of VLOAD, VSTORE. : 20,  6. (wind.F:7640)
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  8,  0. (wind.F:7659)
    *** The number of VLOAD, VSTORE. :  7,  2. (wind.F:7659)
    *** VGT generated (wind.F:7663)
    *** VGT generated (wind.F:7667)
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7676)
    *** The number of VLOAD, VSTORE. :  5,  2. (wind.F:7676)
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7640)
    *** The number of VLOAD, VSTORE. : 20,  6. (wind.F:7640)
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  8,  0. (wind.F:7659)
    *** The number of VLOAD, VSTORE. :  7,  2. (wind.F:7659)
    *** VGT generated (wind.F:7663)
    *** VGT generated (wind.F:7667)
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7676)
    *** The number of VLOAD, VSTORE. :  5,  2. (wind.F:7676)
  LOOP END

  LOOP BEGIN: (wind.F:7338)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7338)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:7338)
  LOOP END

  LOOP BEGIN: (wind.F:7343)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7343)
    *** The number of VLOAD, VSTORE. :  0,  0. (wind.F:7343)
  LOOP END

  LOOP BEGIN: (wind.F:7344)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7344)
    *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:7344)
    *** Idiom detected. : MAX/MIN (wind.F:7344)
  LOOP END

  LOOP BEGIN: (wind.F:7357)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7357)
  LOOP END

  LOOP BEGIN: (wind.F:7371)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7371)
  LOOP END

  LOOP BEGIN: (wind.F:7385)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7385)
  LOOP END

  LOOP BEGIN: (wind.F:7396)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7396)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7396)
  LOOP END

  LOOP BEGIN: (wind.F:7387)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : GLOBAL::SPHERICALDISTANCE (wind.F:7387)
  LOOP END

  LOOP BEGIN: (wind.F:7402)
    <Vectorized loop.>
    **  Fused loop. (wind.F:7402)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7402)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7402)
  LOOP END

  LOOP BEGIN: (wind.F:7408)
    <Vectorized loop.>
    **  Fused loop. (wind.F:7408)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7408)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7408)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS15GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 29088 bytes
      Register spill area      : 12912 bytes
      Parameter area           :    64 bytes
      Register save area       :   176 bytes
      User data area           : 15936 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:7316)
    *** Estimated execution cycle                       : 132
  LOOP END

  LOOP BEGIN: (wind.F:7316)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7319)
    *** Estimated execution cycle                       : 204
  LOOP END

  LOOP BEGIN: (wind.F:7319)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7323)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:7324)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    *** Estimated execution cycle                       : 1741
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    *** Estimated execution cycle                       : 1843
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    *** Estimated execution cycle                       : 326
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    *** Estimated execution cycle                       : 1741
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    *** Estimated execution cycle                       : 1843
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    *** Estimated execution cycle                       : 326
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7338)
    *** Estimated execution cycle                       : 451
  LOOP END

  LOOP BEGIN: (wind.F:7343)
    *** Estimated execution cycle                       : 4
  LOOP END

  LOOP BEGIN: (wind.F:7344)
    *** Estimated execution cycle                       : 159
  LOOP END

  LOOP BEGIN: (wind.F:7357)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7371)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7385)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7396)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:7387)
    *** Estimated execution cycle                       : 92
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 4
            Across calls                                : 4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 6
            Across calls                                : 4
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 13
  LOOP END

  LOOP BEGIN: (wind.F:7402)
    *** Estimated execution cycle                       : 195
  LOOP END

  LOOP BEGIN: (wind.F:7408)
    *** Estimated execution cycle                       : 127
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::LOADHWINDFILE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7449: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  7454: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  7454: vec( 103): Unvectorized loop.
  7454: vec( 108): Unvectorizable loop structure.
  7456: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  7456: vec( 103): Unvectorized loop.
  7456: vec( 108): Unvectorizable loop structure.
  7458: inl(1222): Inlined: WIND::WINDTERMINATE
  7465: vec( 103): Unvectorized loop.
  7465: vec( 108): Unvectorizable loop structure.
  7483: vec( 108): Unvectorizable loop structure.
  7486: vec( 103): Unvectorized loop.
  7486: vec( 108): Unvectorizable loop structure.
  7494: opt(1118): This I/O statement inhibits optimization of loop.
  7494: vec( 103): Unvectorized loop.
  7494: vec( 180): I/O statement obstructs vectorization.
  7504: vec( 103): Unvectorized loop.
  7504: vec( 108): Unvectorizable loop structure.
  7509: vec( 103): Unvectorized loop.
  7509: vec( 108): Unvectorizable loop structure.
  7520: vec( 108): Unvectorizable loop structure.
  7522: opt(1118): This I/O statement inhibits optimization of loop.
  7522: vec( 103): Unvectorized loop.
  7522: vec( 180): I/O statement obstructs vectorization.
  7522: vec( 108): Unvectorizable loop structure.
  7529: vec( 103): Unvectorized loop.
  7529: vec( 108): Unvectorizable loop structure.
  7539: opt(1592): Outer loop unrolled inside inner loop.
  7539: vec( 101): Vectorized loop.
  7539: vec( 128): Fused multiply-add operation applied.
  7541: opt(1592): Outer loop unrolled inside inner loop.
  7541: vec( 101): Vectorized loop.
  7541: vec( 126): Idiom detected.: MAX/MIN
  7542: vec( 101): Vectorized loop.
  7542: vec( 126): Idiom detected.: MAX/MIN
  7577: vec( 103): Unvectorized loop.
  7577: vec( 108): Unvectorizable loop structure.
  7582: vec( 103): Unvectorized loop.
  7582: vec( 108): Unvectorizable loop structure.
  7590: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::LOADHWINDFILE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7429:                 subroutine loadHWindFile(cn)
  7430:                 use global, only : openFileForRead, nabout
  7431:                 USE ADC_CONSTANTS, only: m2nm
  7432:                 implicit none
  7433:                 integer, intent(in) :: cn ! cycle number of file to load
  7434:           C
  7435:                 real(8), allocatable    :: windMag(:,:) ! hwind speeds, used to find hwind vmax
  7436:                 real(8)                 :: dx, dy ! distances (m) to location of vmax
  7437:                 integer                  :: maxIndices(2) !i,j indices of hwind vmax
  7438:                 real(8)                 :: throwAwayCoordinate ! dummy variable
  7439:                 integer                  :: numValues ! total number of u,v velocity pairs
  7440:                 integer                  :: indexLimit ! abs(array bounds)
  7441:                 integer                  :: errorio ! nonzero if there was an i/o error
  7442:                 integer                  :: currentLine ! used in error messages
  7443:                 integer                  :: dataset ! used in error messages
  7444:                 integer                  :: counter ! used to count uvWind array values
  7445:                 integer                  :: i, j    ! loop counters
  7446:                 character(1)             :: paren
  7447:                 character(1)             :: comma
  7448:           C
  7449:                 call setMessageSource("loadHWindFile")
  7450:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7451:                 call allMessage(DEBUG,"Enter.")
  7452:           #endif
  7453:           C
  7454:                 call logMessage(INFO,"Loading the HWind file '"
  7455:                &                     //trim(hWindFiles(cn)%file_name)//"'.")
  7456:                 call openFileForRead(220,trim(hWindFiles(cn)%file_name), errorio)
  7457:                 if (errorio.gt.0) then
  7458:         I          call windTerminate()
  7459:                 endif
  7460:                 currentLine = 1
  7461:                 dataset = 0
  7462:                 !
  7463:                 ! SURFACE WIND COMPONENTS FOR HURRICANE  name_0825_22_30
  7464:                 read(220,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7465:                 call logMessage(ECHO,"HWind comment line: "//trim(scratchMessage))
  7466:                 !
  7467:                 ! DX=DY= 6.02280 KILOMETERS.
  7468:                 currentLine = currentLine + 1
  7469:                 read(220,'(7X,F8.5,A)',end=246,err=248,iostat=errorio)
  7470:                &   hWindFiles(cn)%dh
  7471:                 write(scratchMessage,'("Mercator grid spacing is ",F8.5," km.")')
  7472:                &    hWindFiles(cn)%dh
  7473:                 call logMessage(ECHO,scratchMessage)
  7474:                 !
  7475:                 ! STORM CENTER LOCALE IS -77.2730 EAST LONGITUDE and  27.2950 NORTH LATITUDE ... STORM CENTER IS AT (X,Y)=(0,0)
  7476:                 currentLine = currentLine + 1
  7477:                 read(220,'(23X,F9.4,18X,F9.4,A)',end=246,err=248,iostat=errorio)
  7478:                &   hWindFiles(cn)%cLon, hWindFiles(cn)%cLat ! degrees
  7479:                 write(scratchMessage,'("center lon=",E15.8," center lat=",E15.8)')
  7480:                &   hWindFiles(cn)%cLon, hWindFiles(cn)%cLat
  7481:                 call logMessage(ECHO,scratchMessage)
  7482:                 ! dimensions
  7483: +------>        do i=1,4
  7484: |                  currentLine = currentLine + 1
  7485: |                  read(220,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7486: |                  call logMessage(ECHO,"Coordinate: "//trim(scratchMessage))
  7487: |                  currentLine = currentLine + 1
  7488: |                  read(220,*,end=246,err=248,iostat=errorio) hWindFiles(cn)%nh
  7489: |                  write(scratchMessage,'("HWind dimension read: ",i3,".")')
  7490: |              &      hWindFiles(cn)%nh
  7491: |                  call logMessage(ECHO,scratchMessage)
  7492: |                  ! we won't need the actual coordinates
  7493: |                  currentLine = currentLine + 1
  7494: |+----->           read(220,'(6F13.4)',end=246,err=248,iostat=errorio)
  7495: |              &      (throwAwayCoordinate,j=1,hWindFiles(cn)%nh)
  7496: +------         end do
  7497:                 !
  7498:                 ! read the actual vector data
  7499:                 !
  7500:                 ! SURFACE WIND COMPONENTS ... M/S ... COMPLEX ARRAY W=(U,V)
  7501:                 currentLine = currentLine + 1
  7502:                 read(220,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7503:                 currentLine = currentLine + 1
  7504:                 call logMessage(ECHO,"HWind sfc wind line: "
  7505:                &      //trim(scratchMessage))
  7506:                 currentLine = currentLine + 1
  7507:                 read(220,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7508:                 currentLine = currentLine + 1
  7509:                 call logMessage(ECHO,"HWind sfc wind dimensions line: "
  7510:                &       //trim(scratchMessage))
  7511:                 indexLimit = (hWindFiles(cn)%nh - 1) / 2
  7512:                 allocate(hWindFiles(cn)
  7513:                &    %u(-indexLimit:indexLimit,-indexLimit:indexLimit))
  7514:                 allocate(hWindFiles(cn)
  7515:                &    %v(-indexLimit:indexLimit,-indexLimit:indexLimit))
  7516:                 allocate(windMag(-indexLimit:indexLimit,-indexLimit:indexLimit))
  7517:                 ! read all the wind vector values
  7518:                 currentLine = currentLine + 1
  7519:                 dataset = 1
  7520: +------>        do j=-indexLimit,indexLimit
  7521: |                     ! ref bottom of http://www.aoml.noaa.gov/hrd/Storm_pages/grid.html
  7522: |+----->           read(220,'(2(A1,F13.5,A1,F13.5,A1))',end=246,err=248,iostat=errorio)
  7523: |              &       (paren, hWindFiles(cn)%u(i,j), comma,
  7524: |              &        hWindFiles(cn)%v(i,j), paren,
  7525: |              &        i=-indexLimit, indexLimit)
  7526: |                  dataset = dataset + 1
  7527: +------         end do
  7528:                 close(220)
  7529:                 call logMessage(INFO,"Finished loading the HWind file '"
  7530:                &                     //trim(hWindFiles(cn)%file_name)//"'.")
  7531:                 !
  7532:                 ! convert mercator mesh spacing dh from km to m
  7533:                 hWindFiles(cn)%dh = hWindFiles(cn)%dh * 1000.d0
  7534:                 !
  7535:                 ! set index limit according to values found in the file
  7536:                 hWindFiles(cn)%indexLimit = indexLimit
  7537:                 !
  7538:                 ! find the maximum wind speed in this dataset
  7539: U======>F       windMag(:,:) = sqrt(hWindFiles(cn)%u(:,:)**2
  7540:                &    + hWindFiles(cn)%v(:,:)**2)
  7541: U======>        hWindFiles(cn)%vmax = maxval(windMag)
  7542: V======>        maxIndices = maxloc(windMag) ! returns indices as if array is 1-indexed
  7543:                 !
  7544:                 ! now calculate rmax in nautical miles
  7545:                 dx = (real(maxindices(1)-(indexLimit+1)))*hWindFiles(cn)%dh
  7546:                 dy = (real(maxindices(2)-(indexLimit+1)))*hWindFiles(cn)%dh
  7547:                 hWindFiles(cn)%rmax = m2nm * sqrt(dx**2 + dy**2)
  7548:                 !
  7549:                 ! calculate angle at which rmax occurs
  7550:                 hWindFiles(cn)%rmaxAngle = 360.0d0 + rad2deg * ATAN2(dx,dy)
  7551:                 if (hWindFiles(cn)%rmaxAngle > 360.d0) then
  7552:                    hWindFiles(cn)%rmaxAngle = hwindFiles(cn)%rmaxAngle - 360.d0
  7553:                 endif
  7554:                 deallocate(windMag)
  7555:                 !
  7556:                 ! set the state variable
  7557:                 hWindFiles(cn)%loaded = .true.
  7558:           C
  7559:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7560:                 call allMessage(DEBUG,"Return.")
  7561:           #endif
  7562:                 call unsetMessageSource()
  7563:                 return
  7564:           C
  7565:           C     We jump to this section if there was an error reading a file.
  7566:           246   call allMessage(ERROR,"Unexpectedly reached end-of-file.") ! END jumps here
  7567:           248   call allMessage(ERROR,"I/O error during file access.") !  ERR jumps here
  7568:                 call allMessage(ERROR,
  7569:                &   "Check the fort.16 file for more information.")
  7570:                      if (nabout.gt.0) then
  7571:                    call allMessage(INFO,
  7572:                &  "Reducing the value of NABOUT to 0"
  7573:                &  //" will maximize the information written to the fort.16 file,"
  7574:                &  //" which may aid in troubleshooting this issue.")
  7575:                 endif
  7576:                 if ( dataset.eq.0 ) then
  7577:                    write(scratchMessage,
  7578:                &    '("Could not read line ",i0," from the file ",A,".")')
  7579:                &    currentLine, trim(hWindFiles(cn)%file_name)
  7580:                    call allMessage(ERROR,scratchMessage)
  7581:                 else
  7582:                    write(scratchMessage,
  7583:                &     '("Could not read dataset ",i0," from the file ",A,".")')
  7584:                &    dataset, trim(hWindFiles(cn)%file_name)
  7585:                    call allMessage(ERROR,scratchMessage)
  7586:                 endif
  7587:                 write(scratchMessage,'(A,i0,A)')
  7588:                &       'The value of the i/o error flag was ',errorio,'.'
  7589:                 call allMessage(ERROR,scratchMessage)
  7590:         I       CALL windTerminate()
  7591:           C
  7592:           C     ----------------------------------------------------------------
  7593:                 end subroutine loadHWindFile


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::LOADHWINDFILE
INLINE LIST

  ROOT: WIND::LOADHWINDFILE (wind.F:7429)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7449)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7454)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:7456)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7458)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7465)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7473)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7481)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7486)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7491)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7504)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7509)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7529)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7562)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7566)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7567)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7568)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7571)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7580)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7585)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7589)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7590)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::LOADHWINDFILE
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:7454)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7454)
  LOOP END

  LOOP BEGIN: (wind.F:7456)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7456)
  LOOP END

  LOOP BEGIN: (wind.F:7465)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7465)
  LOOP END

  LOOP BEGIN: (wind.F:7483)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7483)

    LOOP BEGIN: (wind.F:7486)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:7486)
    LOOP END

    LOOP BEGIN: (wind.F:7494)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:7494)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7504)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7504)
  LOOP END

  LOOP BEGIN: (wind.F:7509)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7509)
  LOOP END

  LOOP BEGIN: (wind.F:7520)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7520)

    LOOP BEGIN: (wind.F:7522)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:7522)
      *** Unvectorizable loop structure. (wind.F:7522)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7529)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7529)
  LOOP END

  LOOP BEGIN: (wind.F:7539)
    <Unvectorized loop.>
    **  Copied loop. : FOR UNROLLING (wind.F:7539)

    LOOP BEGIN: (wind.F:7539)
      <Vectorized loop.>
      **  Copied loop. : FOR UNROLLING (wind.F:7539)
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:7539)
      *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:7539)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7539)
    <Unvectorized loop.>
    **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (wind.F:7539)

    LOOP BEGIN: (wind.F:7539)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:7539)
      *** The number of VLOAD, VSTORE. :  8,  4. (wind.F:7539)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7541)
    <Unvectorized loop.>
    **  Copied loop. : FOR UNROLLING (wind.F:7541)

    LOOP BEGIN: (wind.F:7541)
      <Vectorized loop.>
      **  Copied loop. : FOR UNROLLING (wind.F:7541)
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:7541)
      *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:7541)
      *** Idiom detected. : MAX/MIN (wind.F:7541)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7541)
    <Unvectorized loop.>
    **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (wind.F:7541)

    LOOP BEGIN: (wind.F:7541)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:7541)
      *** The number of VLOAD, VSTORE. :  4,  0. (wind.F:7541)
      *** Idiom detected. : MAX/MIN (wind.F:7541)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7542)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:7542)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:7542)
      *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:7542)
      *** Idiom detected. : MAX/MIN (wind.F:7542)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7582)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7582)
  LOOP END

  LOOP BEGIN: (wind.F:7577)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7577)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::LOADHWINDFILE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 8960 bytes
      Register spill area      :  632 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 8088 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:7454)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7456)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7465)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7483)
    *** Estimated execution cycle                       : 336
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 11
            Across calls                                :  5
            Over basic blocks                           :  6
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 27
            Across calls                                :  8
            Over basic blocks                           : 19
    *** The number of SCALAR REGISTER TRANSFER          : 48

    LOOP BEGIN: (wind.F:7486)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (wind.F:7494)
      *** Estimated execution cycle                     : 11
      *** The number of SCALAR REGISTER TRANSFER        : 4
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7504)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7509)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7520)
    *** Estimated execution cycle                       : 118
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 13
            Over basic blocks                           : 13
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 9
            Over basic blocks                           : 9
    *** The number of SCALAR REGISTER TRANSFER          : 45

    LOOP BEGIN: (wind.F:7522)
      *** Estimated execution cycle                     : 103
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Over basic blocks                         : 1
              Others                                    : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 8
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7529)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7539)
    *** Estimated execution cycle                       : 45
    *** The number of SCALAR REGISTER TRANSFER          : 9

    LOOP BEGIN: (wind.F:7539)
      *** Estimated execution cycle                     : 454
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7539)
    *** Estimated execution cycle                       : 61
    *** The number of SCALAR REGISTER TRANSFER          : 18

    LOOP BEGIN: (wind.F:7539)
      *** Estimated execution cycle                     : 1714
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7541)
    *** Estimated execution cycle                       : 100
    *** The number of SCALAR REGISTER TRANSFER          : 9

    LOOP BEGIN: (wind.F:7541)
      *** Estimated execution cycle                     : 96
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7541)
    *** Estimated execution cycle                       : 101
    *** The number of SCALAR REGISTER TRANSFER          : 18

    LOOP BEGIN: (wind.F:7541)
      *** Estimated execution cycle                     : 290
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7542)
    *** Estimated execution cycle                       : 255
    *** The number of SCALAR REGISTER TRANSFER          : 12

    LOOP BEGIN: (wind.F:7542)
      *** Estimated execution cycle                     : 159
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7582)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7577)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HWINDINTERPOLATEVELOCITY
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7622: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  7635: vec( 101): Vectorized loop.
  7636: vec( 101): Vectorized loop.
  7640: vec( 101): Vectorized loop.
  7640: vec( 128): Fused multiply-add operation applied.
  7659: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7659: vec( 101): Vectorized loop.
  7663: opt(3014): Moved reference within a conditional branch.
  7663: vec( 128): Fused multiply-add operation applied.
  7667: opt(3014): Moved reference within a conditional branch.
  7667: vec( 128): Fused multiply-add operation applied.
  7676: opt(3014): Moved reference within a conditional branch.
  7676: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7676: vec( 101): Vectorized loop.
  7676: vec( 128): Fused multiply-add operation applied.
  7684: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HWINDINTERPOLATEVELOCITY
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7606:                 subroutine hWindInterpolateVelocity(wvnx, wvny, cn, rv, tw)
  7607:                 use mesh, only : np
  7608:                 implicit none
  7609:                 real(8), intent(out) :: wvnx(:) ! wind u-velocity
  7610:                 real(8), intent(out) :: wvny(:) ! wind v-velocity
  7611:                 integer, intent(in)   :: cn      ! cycle number, or hwind file number
  7612:                 real(8), intent(in)  :: rv      ! ramp value from hwind file
  7613:                 real(8), intent(in)  :: tw      ! time weighting for time interpolation
  7614:           C
  7615:                 real(8)              :: dh      ! readability shorthand for hwind dh
  7616:                 integer               :: il      ! readability shorthand for hwind integerLimit
  7617:                 real(8), pointer     :: hwu(:,:)! readability shorthand for hwind u
  7618:                 real(8), pointer     :: hwv(:,:)! readability shorthand for hwind v
  7619:                 real(8)              :: oneOverW2 ! 1/w**2 ; const in interp weights
  7620:                 integer               :: i       ! loop counter
  7621:           C
  7622:                 call setMessageSource("hwindinterpolatevelocity")
  7623:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7624:                 call allMessage(DEBUG,"Enter.")
  7625:           #endif
  7626:           C
  7627:                 dh = hWindFiles(cn)%dh
  7628:                 hwu => hWindFiles(cn)%u
  7629:                 hwv => hWindFiles(cn)%v
  7630:                 il = hWindFiles(cn)%indexLimit
  7631:                 !
  7632:                 ! each mesh point falls within a box of the hwind data;
  7633:                 ! we form an array of indices that represent the HWind grid indices
  7634:                 ! of the lower left corners of the boxes that each mesh point falls in
  7635: V======>        x_indices = floor(x_mercator/dh)
  7636: V======>        y_indices = floor(y_mercator/dh)
  7637:                 !
  7638:                 ! calculate bilinear interpolation weights
  7639:                 oneOverW2 = 1.d0 / real(dh**2)
  7640: V======>F       where ( (x_indices.ge.-il).and.(y_indices.ge.-il).and.
  7641: |              &        (x_indices.le.(il-1)).and.(y_indices.le.(il-1)) )
  7642: |                  ! the adcirc node is inside the bounding box of the HWind data;
  7643: |                  ! we will calculate interpolation weights for these nodes
  7644: |                  inside = .true.
  7645: |                  w1 = ((dh*(x_indices+1) - x_mercator)
  7646: |              &       *  (dh*(y_indices+1) - y_mercator)) * oneOverW2
  7647: |                  w2 = ((x_mercator - dh*x_indices)
  7648: |              &       * (dh*(y_indices+1) - y_mercator) ) * oneOverW2
  7649: |                  w3 = ((x_mercator - dh*x_indices)
  7650: |              &       * (y_mercator - dh*y_indices) ) * oneOverW2
  7651: |                  w4 = ((dh*(x_indices+1) - x_mercator )
  7652: |              &       * (y_mercator - dh*y_indices) ) * oneOverW2
  7653: |               elsewhere
  7654: |                  inside = .false.
  7655: V======         end where
  7656:                 !
  7657:                 ! apply interpolation weights to perform bilinear interpolation
  7658:                 ! of wind velocities
  7659: V------>        do i=1,np
  7660: |                  if (inside(i).eqv..false.) then
  7661: |                     cycle
  7662: |                  endif
  7663: |       G          wvnx_work(i) = w1(i)*hwu(x_indices(i),y_indices(i))
  7664: |              &           + w2(i)*hwu(x_indices(i)+1,y_indices(i))
  7665: |              &           + w3(i)*hwu(x_indices(i)+1,y_indices(i)+1)
  7666: |              &           + w4(i)*hwu(x_indices(i),y_indices(i)+1)
  7667: |       G          wvny_work(i) = w1(i)*hwv(x_indices(i),y_indices(i))
  7668: |              &           + w2(i)*hwv(x_indices(i)+1,y_indices(i))
  7669: |              &           + w3(i)*hwv(x_indices(i)+1,y_indices(i)+1)
  7670: |              &           + w4(i)*hwv(x_indices(i),y_indices(i)+1)
  7671: V------         end do
  7672:                 !
  7673:                 ! apply ramp value, time weighting, and user specified
  7674:                 ! wind multiplier; add the contribution of this dataset to the total
  7675:                 ! at this mesh node
  7676: V======>F       where (inside.eqv..true.)
  7677: |                  wvnx = wvnx + ( wvnx_work * rv * tw * hWindMultiplier )
  7678: |                  wvny = wvny + ( wvny_work * rv * tw * hWindMultiplier )
  7679: V======         end where
  7680:           C
  7681:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7682:                 call allMessage(DEBUG,"Return.")
  7683:           #endif
  7684:                 call unsetMessageSource()
  7685:           C
  7686:           C     ----------------------------------------------------------------
  7687:                 end subroutine hWindInterpolateVelocity


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HWINDINTERPOLATEVELOCITY
INLINE LIST

  ROOT: WIND::HWINDINTERPOLATEVELOCITY (wind.F:7606)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7622)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7684)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HWINDINTERPOLATEVELOCITY
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7635)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7635)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7636)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7636)
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7640)
    *** The number of VLOAD, VSTORE. : 20,  6. (wind.F:7640)
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  8,  0. (wind.F:7659)
    *** The number of VLOAD, VSTORE. :  7,  2. (wind.F:7659)
    *** VGT generated (wind.F:7663)
    *** VGT generated (wind.F:7667)
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7676)
    *** The number of VLOAD, VSTORE. :  5,  2. (wind.F:7676)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::HWINDINTERPOLATEVELOCITY
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 58 [s0-s4 s8-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 12848 bytes
      Register spill area      :  6152 bytes
      Parameter area           :    24 bytes
      Register save area       :   176 bytes
      User data area           :  6488 bytes
      Others                   :     8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7635)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 225
  LOOP END

  LOOP BEGIN: (wind.F:7636)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:7640)
    *** Estimated execution cycle                       : 1741
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7659)
    *** Estimated execution cycle                       : 1843
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END

  LOOP BEGIN: (wind.F:7676)
    *** Estimated execution cycle                       : 326
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INIT_GFDL
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7723: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  7728: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  7728: vec( 103): Unvectorized loop.
  7728: vec( 108): Unvectorizable loop structure.
  7729: inl(1222): Inlined: WIND::WINDTERMINATE
  8778: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  7733: opt(1418): Constant-length loop is expanded.
  7739: vec( 103): Unvectorized loop.
  7739: vec( 180): I/O statement obstructs vectorization.
  7739: vec( 108): Unvectorizable loop structure.
  7752: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  7752: vec( 103): Unvectorized loop.
  7752: vec( 108): Unvectorizable loop structure.
  7764: vec( 180): I/O statement obstructs vectorization.
  7764: vec( 181): Allocation obstructs vectorization.
  7764: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::LOGMESSAGE
  7764: vec( 182): Deallocation obstructs vectorization.
  7764: vec( 108): Unvectorizable loop structure.
  7765: opt(1118): This I/O statement inhibits optimization of loop.
  7772: opt(1082): Backward transfers inhibit loop optimization.
  7772: vec( 103): Unvectorized loop.
  7772: vec( 108): Unvectorizable loop structure.
  7792: inl(1222): Inlined: WIND::WINDTERMINATE
  7797: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7797: vec( 103): Unvectorized loop.
  7797: vec( 180): I/O statement obstructs vectorization.
  7797: vec( 182): Deallocation obstructs vectorization.
  7797: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  7797: vec( 109): Vectorization obstructive statement.
  7797: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  7797: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  7797: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  7799: opt(1118): This I/O statement inhibits optimization of loop.
  7802: inl(1222): Inlined: WIND::WINDTERMINATE
  7811: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  7811: vec( 180): I/O statement obstructs vectorization.
  7811: vec( 181): Allocation obstructs vectorization.
  7811: vec( 182): Deallocation obstructs vectorization.
  7811: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  7811: vec( 109): Vectorization obstructive statement.
  7811: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  7811: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  7811: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  7813: opt(1118): This I/O statement inhibits optimization of loop.
  7815: opt(1082): Backward transfers inhibit loop optimization.
  7815: vec( 103): Unvectorized loop.
  7815: vec( 108): Unvectorizable loop structure.
  7817: inl(1222): Inlined: WIND::WINDTERMINATE
  7824: vec( 101): Vectorized loop.
  7828: vec( 101): Vectorized loop.
  7833: vec( 101): Vectorized loop.
  7839: vec( 101): Vectorized loop.
  7840: vec( 126): Idiom detected.: SEARCH
  7876: inl(1214): Expansion routine is too big for automatic expansion.: WIND::GET_GFDL
  7885: vec( 101): Vectorized loop.
  7886: vec( 101): Vectorized loop.
  7887: vec( 101): Vectorized loop.
  7918: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INIT_GFDL
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7703:                  subroutine init_gfdl(timeloc)
  7704:                  use sizes, only : globaldir
  7705:                  use global, only : ihot, nws, nabout, openFileForRead,
  7706:                &                setMessageSource,unsetMessageSource,allMessage,
  7707:                &                logMessage,scratchMessage,DEBUG,ECHO,INFO,
  7708:                &                ERROR,WARNING
  7709:                 USE ADC_CONSTANTS, only: PRBCKGRND,RHOWAT0
  7710:                 use mesh, only : np, x, y, slam0, sfea0
  7711:                 implicit none
  7712:           
  7713:                 real(8), intent(in) :: timeloc ! adcirc time in seconds since coldstart
  7714:           C
  7715:                 logical :: fileFound   ! true if the file could be found
  7716:                 integer :: errorio     ! .gt. 1 if there was an i/o error
  7717:                 integer :: currentLine ! line from fort.22 being processed, used in error msgs
  7718:                 logical :: cycleTimeFound ! true if the adcirc time falls into one
  7719:                                           ! of the gfdl time intervals
  7720:                 integer :: i           ! loop counter
  7721:           
  7722:           C
  7723:                 call setMessageSource("gfdl_init")
  7724:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7725:                 call allMessage(DEBUG,"Enter.")
  7726:           #endif
  7727:                 errorio = 0
  7728:                 call openFileForRead(22,trim(globaldir)//"/fort.22",errorio)
  7729:         I       if (errorio.gt.0) call windTerminate()
  7730:                 !
  7731:                 ! read fort.22 to determine how many GFDL files there are
  7732:                 currentLine = 1
  7733: *------>        do i=1,3
  7734: |                  ! throw header away this time
  7735: |                  read(22,'(A)',end=246,err=248,iostat=errorio) scratchMessage
  7736: |                  currentLine = currentLine + 1
  7737: *------         end do
  7738:                 numFiles = 0
  7739: +------>        do   ! loop until we run out of data, just counting the files this time
  7740: |                  read(22,'(A)',end=123,err=248,iostat=errorio) scratchMessage
  7741: |                  currentLine = currentLine + 1
  7742: |                  numFiles = numFiles + 1
  7743: +------         end do
  7744:            123  continue ! jump to here when we've run out of lines in the fort.22
  7745:                 allocate( gfdl_files(numFiles) )
  7746:           
  7747:                 !
  7748:                 ! now go back to the beginning of the file and read in the data
  7749:                 rewind(22)
  7750:                 currentLine = 1
  7751:                 read(22,'(A)',end=246,err=248,iostat=errorio) metComment
  7752:                 call logMessage(ECHO,"metComment: "//trim(metComment))
  7753:                 currentLine = currentLine + 1
  7754:                 read(22,*,end=246,err=248,iostat=errorio) GFDL_WindMultiplier
  7755:                 currentLine = currentLine + 1
  7756:                 write(scratchMessage,'("WindMultiplier=",E15.8)') GFDL_WindMultiplier
  7757:                 call logMessage(ECHO,scratchMessage)
  7758:                 read(22,*,end=246,err=248,iostat=errorio) GFDL_max_extrap_dist
  7759:                 currentLine = currentLine + 1
  7760:                 write(scratchMessage,
  7761:                &  '("GFDL Maximum Extrapolation Distance=",E15.8)') GFDL_max_extrap_dist
  7762:                 call logMessage(ECHO,scratchMessage)
  7763:           
  7764: +------>        do i=1,numFiles
  7765: |                  read(22,*,end=246,err=248,iostat=errorio)
  7766: |              &     GFDL_Files(i)%cycleTime,
  7767: |              &     GFDL_Files(i)%rampVal,
  7768: |              &     GFDL_Files(i)%file_name
  7769: |         
  7770: |                  GFDL_Files(i)%max_extrap_dist = GFDL_max_extrap_dist
  7771: |                  GFDL_Files(i)%numFiles = numFiles
  7772: |                  write(scratchMessage,
  7773: |              &   '("time=",E15.8," ramp=",E15.8," file_name=",A)')
  7774: |              &       GFDL_Files(i)%cycleTime,
  7775: |              &       GFDL_Files(i)%rampVal, trim(GFDL_Files(i)%file_name)
  7776: |                  call logMessage(ECHO,scratchMessage)
  7777: |                  currentLine = currentLine + 1
  7778: +------         end do
  7779:                 close(22)
  7780:           
  7781:                 ! log the number of GFDL Met files that were specified
  7782:                 write(scratchMessage,
  7783:                &    '("There were ",i0," GFDL Met files specified.")') numFiles
  7784:                 call logMessage(INFO,scratchMessage)
  7785:                 !
  7786:                 ! need at least 2 files so we have something to interpolate between
  7787:                 ! in time
  7788:                 if (numFiles.lt.2) then
  7789:                    call allMessage(ERROR,"Only one GFDL Met file was specified.")
  7790:                    call allMessage(ERROR,
  7791:                &    "ADCIRC requires at least two GFDL Met files for interpolation.")
  7792:         I          call windTerminate()
  7793:                 endif
  7794:                 !
  7795:                 ! check to make sure that the cycleTimes are
  7796:                 ! monotonically increasing
  7797: +------>        do i=1,numFiles-1
  7798: |                  if (GFDL_Files(i)%cycleTime.ge.GFDL_Files(i+1)%cycleTime) then
  7799: |                     write(scratchMessage,
  7800: |              &  '("Cycle time ",i0," must be less cycle time ",i0,".")')i,i+1
  7801: |                     call allMessage(ERROR,scratchMessage)
  7802: |       I             call windTerminate()
  7803: |                  endif
  7804: +------         end do
  7805:           
  7806:                 !
  7807:                 ! check to make sure that all the GFDL met files are actually there;
  7808:                 ! we assume that the file names contain the full path to the file;
  7809:                 ! if the file name contains forward slashes, it must be surrounded
  7810:                 ! by quotation marks
  7811: +------>        do i=1,numFiles-1
  7812: |                  fileFound = .false.
  7813: |                  inquire(file=GFDL_Files(i)%file_name,exist=fileFound)
  7814: |                  if (fileFound.eqv..false.) then
  7815: |                     call allMessage(ERROR,"The GFDL Met file "//
  7816: |              &          trim(GFDL_Files(i)%file_name)//" was not found.")
  7817: |       I             call windTerminate()
  7818: |                  endif
  7819: |                  GFDL_Files(i)%loaded = .false.
  7820: +------         end do
  7821:           
  7822:                 write(scratchMessage,'("All specified GFDL Met Files were found.")')
  7823:                 call logMessage(INFO,scratchMessage)
  7824: V======>        GFDL_Files(:)%loaded = .false.
  7825:           
  7826:                 !
  7827:                 ! relate timing in the files to current ADCIRC time
  7828: V======>        GFDL_Files(:)%cycleTime = GFDL_Files(:)%cycleTime * 3600.d0 ! convert hours to seconds
  7829:                 if  ((nws.lt.0).and.(ihot.ne.0)) then
  7830:                    ! if times are relative to hotstart time, add the hotstart time
  7831:                    ! so that we can consider the times relative to the coldstart
  7832:                    ! time from here on
  7833: V======>           GFDL_Files(:)%cycleTime = GFDL_Files(:)%cycleTime + timeloc
  7834:                 endif
  7835:           
  7836:                 !
  7837:                 ! locate the cycle that is relevant to current ADCIRC time
  7838:                 cycleTimeFound = .false.
  7839: V------>        do i=1,numFiles-1
  7840: |                  if (( GFDL_Files(i)%cycleTime.le.timeloc).and.
  7841: |              &        (GFDL_Files(i+1)%cycleTime.gt.timeloc) ) then
  7842: |                     cycleTimeFound = .true.
  7843: |                     exit
  7844: |                  endif
  7845: V------         end do
  7846:           
  7847:                 currentCycle = i
  7848:           
  7849:                 ! if we couldn't find a relevant time interval, then insert a blank wind field
  7850:                 if (cycleTimeFound.eqv. .false.) then
  7851:                    if ( timeloc.lt.GFDL_Files(1)%cycleTime ) then
  7852:           
  7853:           ! ... tcm 20130801 v51.06.10 replaced error exiting with insertion of blank snaps
  7854:                       write(scratchMessage,'("The current ADCIRC time ",E15.8,
  7855:                &        " (days) is earlier than the first GFDL Met file time: ",
  7856:                &        E15.8, " (days). Inserting a blank wind snap.")')
  7857:                &        timeloc/86400.d0,GFDL_Files(1)%cycleTime/86400.d0
  7858:                       call logMessage(WARNING,scratchMessage)
  7859:                       currentCycle = 1
  7860:                    endif
  7861:           
  7862:                    if ( timeloc.gt.GFDL_Files(numFiles)%cycleTime ) then
  7863:           
  7864:                       write(scratchMessage,'("The current ADCIRC time ",
  7865:                &        E15.8," (days) is later than the last GFDL Met file time: ",
  7866:                &        E15.8, " (days). Inserting a blank wind snap.")')
  7867:                &         timeloc/86400.d0,GFDL_Files(numFiles)%cycleTime/86400.d0
  7868:                       call logMessage(WARNING,scratchMessage)
  7869:                       currentCycle = numFiles-1
  7870:                    endif
  7871:           
  7872:                 endif
  7873:           
  7874:                 if (cycleTimeFound.eqv. .true.) then
  7875:                 ! load up the data for this time interval
  7876:                    call GET_GFDL(NP,WVNX1,WVNY1,PRN1,x,y,
  7877:                &                GFDL_Files(currentCycle)%file_name,
  7878:                &                SLAM0,SFEA0,
  7879:                &                GFDL_Files(currentCycle)%max_extrap_dist)
  7880:                    call GET_GFDL(NP,WVNX2,WVNY2,PRN2,x,y,
  7881:                &                GFDL_Files(currentCycle+1)%file_name,
  7882:                &                SLAM0,SFEA0,
  7883:                &                GFDL_Files(currentCycle)%max_extrap_dist)
  7884:                 else
  7885: V======>           WVNX1(:) = 0.d0
  7886: V======>           WVNY1(:) = 0.d0
  7887: V======>           PRN1(:) = PRBCKGRND*100.D0/(RHOWAT0*G)  !SET TO BACKGROUND PRESSURE 1013.0D0 ADJUSTED for ADCIRC units
  7888:                 endif
  7889:           
  7890:                 !If no errors then return now
  7891:           
  7892:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7893:                 call allMessage(DEBUG,"Return.")
  7894:           #endif
  7895:                 !cleans up the setMessageSource set at the beginning of the subroutine
  7896:                 call unsetMessageSource()
  7897:           
  7898:                 return
  7899:           
  7900:           C
  7901:           C     We jump to this section if there was an error reading a file.
  7902:           246   call allMessage(ERROR,"Unexpectedly reached end-of-file.") ! END jumps here
  7903:           248   call allMessage(ERROR,"I/O error during file access.") !  ERR jumps here
  7904:                 call allMessage(INFO,
  7905:                &   "Check the fort.16 file for more information.")
  7906:                 if (nabout.gt.0) then
  7907:                    call allMessage(INFO,
  7908:                &  "Reducing the value of NABOUT to 0"
  7909:                &  //" will maximize the information written to the fort.16 file,"
  7910:                &  //" which may aid in troubleshooting this issue.")
  7911:                 endif
  7912:                 write(scratchMessage,'("Could not read line ",i0," of fort.22.")')
  7913:                &  currentLine
  7914:                 call allMessage(ERROR,scratchMessage)
  7915:                 write(scratchMessage,'(A,i0,A)')
  7916:                &       'The value of the i/o error flag was ',errorio,'.'
  7917:                 call allMessage(ERROR,scratchMessage)
  7918:         I       CALL windTerminate()
  7919:                 call unsetMessageSource()
  7920:           C ---------------------------------------------------------------------
  7921:                 end subroutine init_gfdl


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INIT_GFDL
INLINE LIST

  ROOT: WIND::INIT_GFDL (wind.F:7703)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7723)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:7728)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7729)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7752)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7757)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7762)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7776)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7784)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7789)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7790)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7792)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7801)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7802)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7815)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7817)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7823)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7858)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:7868)
     *** Source for routine not found.
  -> NOINLINE: WIND::GET_GFDL (wind.F:7876)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: WIND::GET_GFDL (wind.F:7880)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7896)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7902)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7903)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7904)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7907)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7914)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:7917)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:7918)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:7919)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INIT_GFDL
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:7728)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7728)
  LOOP END

  LOOP BEGIN: (wind.F:7739)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7739)
    *** Unvectorizable loop structure. (wind.F:7739)
  LOOP END

  LOOP BEGIN: (wind.F:7752)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:7752)
  LOOP END

  LOOP BEGIN: (wind.F:7764)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7764)
    *** Allocation obstructs vectorization. (wind.F:7764)
    *** Vectorization obstructive procedure reference. : GLOBAL::LOGMESSAGE (wind.F:7764)
    *** Deallocation obstructs vectorization. (wind.F:7764)
    *** Unvectorizable loop structure. (wind.F:7764)

    LOOP BEGIN: (wind.F:7772)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:7772)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7797)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7797)
    *** Deallocation obstructs vectorization. (wind.F:7797)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:7797)
    *** Vectorization obstructive statement. (wind.F:7797)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:7797)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:7797)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:7797)
  LOOP END

  LOOP BEGIN: (wind.F:7811)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:7811)
    *** Allocation obstructs vectorization. (wind.F:7811)
    *** Deallocation obstructs vectorization. (wind.F:7811)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:7811)
    *** Vectorization obstructive statement. (wind.F:7811)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:7811)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:7811)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:7811)

    LOOP BEGIN: (wind.F:7815)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:7815)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7824)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7824)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7824)
  LOOP END

  LOOP BEGIN: (wind.F:7828)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7828)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7828)
  LOOP END

  LOOP BEGIN: (wind.F:7833)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7833)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:7833)
  LOOP END

  LOOP BEGIN: (wind.F:7839)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7839)
    *** The number of VLOAD, VSTORE. :  2,  0. (wind.F:7839)
    *** Idiom detected. : SEARCH (wind.F:7840)
  LOOP END

  LOOP BEGIN: (wind.F:7885)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7885)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7885)
  LOOP END

  LOOP BEGIN: (wind.F:7886)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7886)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7886)
  LOOP END

  LOOP BEGIN: (wind.F:7887)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:7887)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:7887)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INIT_GFDL
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 44 [s0-s12 s15-s16 s18-s39 s57-s63]
      Vector registers         : 16 [v48-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 13376 bytes
      Register spill area      :   496 bytes
      Parameter area           :   104 bytes
      Register save area       :   176 bytes
      User data area           : 12592 bytes
      Others                   :     8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:7728)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7739)
    *** Estimated execution cycle                       : 44
    *** The number of SCALAR REGISTER TRANSFER          : 9
  LOOP END

  LOOP BEGIN: (wind.F:7752)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:7764)
    *** Estimated execution cycle                       : 244
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 9
            Across calls                                : 4
            Over basic blocks                           : 3
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 19
            Across calls                                :  7
            Over basic blocks                           : 11
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 27

    LOOP BEGIN: (wind.F:7772)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7797)
    *** Estimated execution cycle                       : 153
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 8
            Across calls                                : 8
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 15
            Across calls                                : 15
    *** The number of SCALAR REGISTER TRANSFER          : 22
  LOOP END

  LOOP BEGIN: (wind.F:7811)
    *** Estimated execution cycle                       : 251
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 4
            Across calls                                : 4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 15
            Across calls                                :  7
            Over basic blocks                           :  7
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 19

    LOOP BEGIN: (wind.F:7815)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:7824)
    *** Estimated execution cycle                       : 67
  LOOP END

  LOOP BEGIN: (wind.F:7828)
    *** Estimated execution cycle                       : 97
  LOOP END

  LOOP BEGIN: (wind.F:7833)
    *** Estimated execution cycle                       : 97
  LOOP END

  LOOP BEGIN: (wind.F:7839)
    *** Estimated execution cycle                       : 341
  LOOP END

  LOOP BEGIN: (wind.F:7885)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:7886)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:7887)
    *** Estimated execution cycle                       : 63
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GET_GFDL
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7985: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8002: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  8002: vec( 103): Unvectorized loop.
  8002: vec( 108): Unvectorizable loop structure.
  8004: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  8004: vec( 103): Unvectorized loop.
  8004: vec( 108): Unvectorizable loop structure.
  8006: inl(1222): Inlined: WIND::WINDTERMINATE
  8030: vec( 103): Unvectorized loop.
  8030: vec( 180): I/O statement obstructs vectorization.
  8030: vec( 110): Vectorization obstructive procedure reference.: MESH::CYLINDERMAP
  8030: vec( 110): Vectorization obstructive procedure reference.: MESH::DRVSPCOORSROTS0
  8033: opt(1118): This I/O statement inhibits optimization of loop.
  8041: inl(1212): Source for routine not found.: MESH::DRVSPCOORSROTS0
  8045: inl(1212): Source for routine not found.: MESH::CYLINDERMAP
  8060: vec( 101): Vectorized loop.
  8060: vec( 126): Idiom detected.: MAX/MIN
  8061: vec( 101): Vectorized loop.
  8062: opt(1112): Loop fused with previous loop.
  8063: vec( 101): Vectorized loop.
  8064: opt(1112): Loop fused with previous loop.
  8064: vec( 126): Idiom detected.: SUM
  8065: vec( 101): Vectorized loop.
  8065: vec( 126): Idiom detected.: MAX/MIN
  8084: inl(1212): Source for routine not found.: KDTREE2_MODULE::KDTREE2_CREATE
  8095: vec( 101): Vectorized loop.
  8096: opt(1112): Loop fused with previous loop.
  8097: opt(1112): Loop fused with previous loop.
  8100: vec( 110): Vectorization obstructive procedure reference.: KDTREE2_MODULE::KDTREE2_N_NEAREST
  8105: inl(1212): Source for routine not found.: KDTREE2_MODULE::KDTREE2_N_NEAREST
  8105: opt(1097): This statement prevents loop optimization.
  8118: vec( 101): Vectorized loop.
  8139: opt(1082): Backward transfers inhibit loop optimization.
  8139: vec( 103): Unvectorized loop.
  8139: vec( 108): Unvectorizable loop structure.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GET_GFDL
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7950:                  SUBROUTINE GET_GFDL(NADCPTS,ADC_U_WIND,ADC_V_WIND,ADC_PRESS,
  7951:                &                     ADC_X,ADC_Y,FNAME,SLAM0,SFEA0,
  7952:                &                     MAX_INTERP_DIST)
  7953:                  USE SIZES
  7954:                  USE MESH, ONLY: ICS, DRVSPCOORSROTS, CYLINDERMAP
  7955:                  USE ADC_CONSTANTS, ONLY: DEG2RAD,PRBCKGRND,G,RHOWAT0
  7956:                  USE GLOBAL, ONLY: IFSPROTS,
  7957:                &        setMessageSource,unsetMessageSource,allMessage,
  7958:                &        logMessage,scratchMessage,DEBUG,ECHO,INFO,ERROR
  7959:                  USE KDTREE2_MODULE     ! USED FOR FAST SEARCHING
  7960:           
  7961:                  IMPLICIT NONE
  7962:                  REAL(8), ALLOCATABLE :: XY_GFDL(:,:),XLOC(:)
  7963:                  REAL(8), ALLOCATABLE :: PRESS_GFDL(:)
  7964:                  REAL(8), ALLOCATABLE :: U_WIND_GFDL(:),V_WIND_GFDL(:)
  7965:                  REAL(8), ALLOCATABLE :: WTS(:)
  7966:                  INTEGER, ALLOCATABLE :: LOCS(:),II2(:)
  7967:           
  7968:                  REAL(8) :: LON_GFDL,LAT_GFDL,TOL,DIST, LonR, LatR
  7969:                  REAL(8) :: RPTS_GFDL,UTMP,VTMP,TTMP,MTMP,SPTMP,PTMP
  7970:                  REAL(8) :: LONGTMP,LATTMP,HTMP,NTMP,XSTA,YSTA,MAXDIST
  7971:                  REAL(8), INTENT(IN) :: SLAM0,SFEA0
  7972:                  REAL(8), INTENT(IN) :: MAX_INTERP_DIST
  7973:                  REAL(8), INTENT(OUT) :: ADC_U_WIND(NADCPTS),ADC_V_WIND(NADCPTS)
  7974:                  REAL(8), INTENT(OUT) :: ADC_PRESS(NADCPTS)
  7975:                  REAL(8), INTENT(IN)  :: ADC_X(NADCPTS),ADC_Y(NADCPTS)
  7976:           !       REAL(8), PARAMETER ::  PI=3.141592653589793D0
  7977:           !       REAL(8), PARAMETER ::  DEG2RAD = PI/180.D0  ! DEGREES TO RADIANS
  7978:           
  7979:                  INTEGER :: NPTS_GFDL,SRCHDP,LUN,ERRORIO,ITC,I,IEK,IP,INCELL
  7980:                  INTEGER, INTENT(IN) :: NADCPTS
  7981:                  CHARACTER(240),INTENT(IN) :: FNAME
  7982:                  TYPE(KDTREE2), POINTER :: TREE
  7983:                  TYPE(KDTREE2_RESULT), ALLOCATABLE :: KDRESULTS(:)
  7984:           
  7985:                 call setMessageSource("get_gfdl")
  7986:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  7987:                 call allMessage(DEBUG,"Enter.")
  7988:           #endif
  7989:           
  7990:                  SRCHDP = 6  !THE NUMBER OF NEAREST NEIGHBORS TO FIND
  7991:                  TOL = 1.0D-6  !TOLERANCE FOR ESTIMATING ZERO DISTANCE BETWEEN POINTS
  7992:                  IP = 3        !POWER VALUE USED IN THE INVERESE WEIGHTED DISTANCE FORMULA
  7993:                  LUN = 287  !FILE UNIT NUMBER TO OPEN FOR THE GFDL FILE
  7994:           
  7995:           C     INVERSE WEIGHTED DISTANCE FORMULA
  7996:           C     P_I = SUM( {J=1 TO SRCHDP} (P_J/(D_I_J)^IP) )/SUM( {J=1 TO SRCHDP} (1/(D_I_J)^IP ) )
  7997:           C Where
  7998:           C   P_J IS THE VALUE AT LOCATION J
  7999:           C   D_I_J - DISTANCE BETWEEN POINT I AND POINT J
  8000:           C   IP = POWER TO RAISE DISTANCE (THE LARGER IP THE MORE INFLUENCE CLOSER POINTS HAVE)
  8001:           
  8002:                   call logMessage(INFO,"Loading the GFDL Met file '"
  8003:                &                     //trim(fname)//"'.")
  8004:                  call openFileForRead(lun,trim(fname), errorio)
  8005:                  if (errorio.gt.0) then
  8006:         I           call windTerminate()
  8007:                  endif
  8008:           
  8009:           !       OPEN(LUN,FILE=TRIM(FNAME),STATUS='OLD',ACTION='READ',
  8010:           !     &            IOSTAT=ERRORIO)
  8011:           !       IF (ERRORIO.NE.0) THEN
  8012:           !          WRITE(*,25) TRIM(FNAME)
  8013:           !       ENDIF
  8014:           !25      FORMAT("COULD NOT OPEN THE FILE '",A,"'.")
  8015:           
  8016:           
  8017:                  ! READ THE FIRST LINE OF THE GFDL OUTPUT WHICH IS THE NUMBER OF POINTS IN THIS RECORD
  8018:           !       READ(LUN,'(F10.4)') RPTS_GFDL
  8019:           !       NPTS_GFDL = INT(RPTS_GFDL)
  8020:                   read(LUN,'(I10)') NPTS_GFDL
  8021:                   rpts_gfdl = real(npts_gfdl,8)
  8022:           
  8023:           !       tcm 20130507 -- changed the read above due to changes in GFDL ASCII files
  8024:           
  8025:                  ALLOCATE( XY_GFDL(2,NPTS_GFDL) )
  8026:                  ALLOCATE( PRESS_GFDL(NPTS_GFDL) )
  8027:                  ALLOCATE( U_WIND_GFDL(NPTS_GFDL), V_WIND_GFDL(NPTS_GFDL) )
  8028:           
  8029:           ! READ IN EACH GFDL POINT LOCATION INFORMATION
  8030: +------>         DO I=1,NPTS_GFDL
  8031: |         !          READ(LUN,'(10F10.4)') UTMP,VTMP,TTMP,MTMP,SPTMP,PTMP,
  8032: |         !     &                      LONGTMP,LATTMP,HTMP,NTMP
  8033: |                   READ(LUN,'(9F10.4)') UTMP,VTMP,TTMP,MTMP,SPTMP,PTMP,
  8034: |              &                      LONGTMP,LATTMP,HTMP
  8035: |                   LON_GFDL = LONGTMP*DEG2RAD !CONVERT TO RADIANS
  8036: |                   LAT_GFDL = LATTMP*DEG2RAD  !CONVERT TO RADIANS
  8037: |                   U_WIND_GFDL(I) = UTMP
  8038: |                   V_WIND_GFDL(I) = VTMP
  8039: |                   PRESS_GFDL(I) = PTMP
  8040: |                   IF ( IFSPROTS.eq. 1) THEN
  8041: |                      CALL DRVSPCOORSROTS( lonr, latr, LON_GFDL, LAT_GFDL )
  8042: |                   ELSE
  8043: |                      latr = LAT_GFDL ;  lonr = LON_GFDL;
  8044: |                   END IF
  8045: |                   CALL CYLINDERMAP( XY_GFDL(1,I),XY_GFDL(2,I),
  8046: |              &           lonr, latr, SLAM0, SFEA0, ICS) ;
  8047: +------          ENDDO !I
  8048:           
  8049:                  CLOSE(LUN)  !CLOSE THIS GFDL DATA FILE
  8050:           
  8051:                  write(scratchMessage,'("Read ",i0," GFDL Met Points.")')
  8052:                &    NPTS_GFDL
  8053:                 call logMessage(ECHO,scratchMessage)
  8054:           
  8055:           !     IF A MAXIMUM DISTANCE ISN'T SPECIFIED, THEN DETERMINE AN ESTIMATE
  8056:           !     TO GFDL GRID SPACING IN ORDER TO USE FOR MAXIMUM DISTANCE (maxdist = 6*cell spacing)
  8057:                 IF (MAX_INTERP_DIST == -99999.D0 ) THEN
  8058:                     ALLOCATE( XLOC(NPTS_GFDL),II2(NPTS_GFDL) )
  8059:           
  8060: V======>            MAXDIST = MINVAL(XY_GFDL(1,:))  !MINIMUM X VALUE
  8061: V------>            XLOC(:) = XY_GFDL(1,:)
  8062: V------             II2(:) = 0
  8063: V------>            WHERE( ABS(XLOC-MAXDIST) < TOL ) II2 = 1
  8064: V======             INCELL = MAX(SUM(II2)-1,1)
  8065: V======>            MAXDIST = (MAXVAL(XY_GFDL(2,:))-MINVAL(XY_GFDL(2,:)))/REAL(INCELL)  !ESTIMATED CELL SPACING
  8066:                     MAXDIST = 6.0D0*MAXDIST  !MAXIMUM DISTANCE TO LOOK AWAY
  8067:           
  8068:                     DEALLOCATE(XLOC)
  8069:                     DEALLOCATE(II2)
  8070:                  ELSE
  8071:                     MAXDIST = MAX_INTERP_DIST
  8072:                  ENDIF
  8073:           
  8074:                  write(scratchMessage,'("Maximum GFDL Interpolation Distance = ",e24.16)') maxdist
  8075:                  call logMessage(ECHO,scratchMessage)
  8076:           
  8077:           
  8078:           C... ALLOCATE SPACE FOR KDTREE SEARCH
  8079:           C...  BE SURE THE MAXIMUM SEARCH DEPTH IS NOT LARGER THAN
  8080:           C...  THE NUMBER OF ELEMENTS BEING KEPT
  8081:                   IF (NADCPTS.LT.SRCHDP) SRCHDP = NADCPTS
  8082:           
  8083:           C...  CREATE THE SEARCH TREE
  8084:                 TREE => KDTREE2_CREATE(XY_GFDL,REARRANGE=.TRUE.,SORT=.TRUE.)
  8085:           
  8086:           
  8087:           C...  ALLOCATE SPACE FOR THE SEARCH RESULTS FROM THE TREE
  8088:           C...  THIS SPACE WILL BE DEALLOCATED LATER IN THE SUBROUTINE
  8089:                 ALLOCATE(KDRESULTS(SRCHDP))
  8090:           
  8091:                 ALLOCATE (WTS(SRCHDP) )
  8092:                 ALLOCATE (LOCS(SRCHDP) )
  8093:           
  8094:           ! INITIALIZE ADCIRC VARIABLES
  8095: V------>        ADC_PRESS(:) = PRBCKGRND  !SET TO BACKGROUND PRESSURE 1013.0D0
  8096: |               ADC_U_WIND(:) = 0.D0
  8097: V------         ADC_V_WIND(:) = 0.D0
  8098:           
  8099:           !     LOOP OVER EACH ADCIRC NODE
  8100: +------>        DO I=1,NADCPTS
  8101: |                  XSTA = ADC_X(I)  !ADCIRC NODE X-COORDINATE
  8102: |                  YSTA = ADC_Y(I)  !ADCIRC NODE Y-COORDIANTE
  8103: |         
  8104: |         !        FIND THE SRCHDP CLOSEST POINTS TO THIS NODE
  8105: |                  CALL KDTREE2_N_NEAREST(TP=TREE,QV=(/XSTA,YSTA/),
  8106: |              &                  NN=SRCHDP,RESULTS=KDRESULTS)
  8107: |         
  8108: |         !
  8109: |         !     FOR SIMPLE NEAREST NEIGHBOR INTERPOLATION
  8110: |         !         ITC = 1
  8111: |         !         IEK = KDRESULTS(ITC)%IDX  !LOCATION OF CLOSEST POINT
  8112: |         !         ADC_PRESS(I) = PRESS_GFDL(IEK)
  8113: |         !         ADC_U_WIND(I) = U_WIND_GFDL(IEK)
  8114: |         !         ADC_V_WIND(I) = V_WIND_GFDL(IEK)
  8115: |         
  8116: |         !     FOR INVERSE WEIGHTED INTERPOLATION
  8117: |                  !DETERMINE THE WEIGHTS
  8118: |V----->           DO ITC = 1,SRCHDP
  8119: ||                    IEK = KDRESULTS(ITC)%IDX  !LOCATION OF ITC CLOSEST POINT
  8120: ||                    DIST = SQRT(KDRESULTS(ITC)%DIS) !DISTANCE FROM THIS POINT TO THE LOCATION OF THE NODE
  8121: ||                    IF (DIST > TOL) THEN  !CHECK TO SEE HOW FAR AWAY
  8122: ||                       IF (DIST <= MAXDIST) THEN
  8123: ||                          WTS(ITC) = 1.D0/(DIST**IP)
  8124: ||                       ELSE  !POINT IS TOO FAR AWAY TO BE USED
  8125: ||                          WTS(ITC) = -99999.D0
  8126: ||                       ENDIF
  8127: ||                    ELSE  !POINT IS CLOSE ENOUGH TO USE AS DIRECT VALUE
  8128: ||                       WTS(ITC) = -1.0D0
  8129: ||                    ENDIF
  8130: ||                    LOCS(ITC) = IEK
  8131: |V-----            ENDDO  !ITC
  8132: |         
  8133: |                  !COMPUTED THE INVERSE DISTANCE WEIGHTED AVERAGE
  8134: |                  UTMP = 0.D0
  8135: |                  VTMP = 0.D0
  8136: |                  PTMP = 0.D0
  8137: |                  TTMP = 0.D0
  8138: |                  ITC = 1;
  8139: |+----->           DO WHILE (ITC <= SRCHDP)
  8140: ||                    ! IF POINT IS LOCATED AT AN ORIGINAL GFDL GRID THEN USE THAT VALUE ONLY
  8141: ||                    IF (WTS(ITC) == -1.D0) THEN
  8142: ||                       UTMP = U_WIND_GFDL(LOCS(ITC))
  8143: ||                       VTMP = V_WIND_GFDL(LOCS(ITC))
  8144: ||                       PTMP = PRESS_GFDL(LOCS(ITC))
  8145: ||                       TTMP = 1.0D0
  8146: ||                       ITC = SRCHDP + 20
  8147: ||                    ELSEIF (WTS(ITC) == -99999.D0 ) THEN  !THIS LOCATION IS TOO FAR AWAY TO USE
  8148: ||                       ITC = ITC + 1
  8149: ||                    ELSE  !COMPUTE INVERSE WEIGHTED AVERAGING
  8150: ||                       UTMP = UTMP + U_WIND_GFDL(LOCS(ITC))*WTS(ITC)
  8151: ||                       VTMP = VTMP + V_WIND_GFDL(LOCS(ITC))*WTS(ITC)
  8152: ||                       PTMP = PTMP + PRESS_GFDL(LOCS(ITC))*WTS(ITC)  !SUM OF THE VALUES/WEIGHTS
  8153: ||                       TTMP = TTMP + WTS(ITC)     ! SUM OF THE WEIGHTS
  8154: ||                       ITC = ITC + 1
  8155: ||                    ENDIF
  8156: |+-----            ENDDO  !ITC
  8157: |         
  8158: |                  !SET THE NODAL VALUES TO THE WEIGHTED AVERAGE
  8159: |                  IF (TTMP.NE.0.D0) THEN
  8160: |                     ADC_U_WIND(I) = UTMP/TTMP
  8161: |                     ADC_V_WIND(I) = VTMP/TTMP
  8162: |                     ADC_PRESS(I) = (PTMP/TTMP)*100.D0/(RHOWAT0*G)   !CONVERT MILLIBARS TO METERS OF WATER
  8163: |                  ELSE  !NO POINT WAS CLOSE ENOUGH TO INTERPOLATE
  8164: |                     ADC_U_WIND(I) = 0.D0
  8165: |                     ADC_V_WIND(I) = 0.D0
  8166: |                     ADC_PRESS(I) = PRBCKGRND*100.D0/(RHOWAT0*G)
  8167: |                  ENDIF
  8168: |         
  8169: +------         ENDDO !I LOOP OVER ADCIRC NODES
  8170:           
  8171:           ! CLEAN UP MEMORY
  8172:                 DEALLOCATE(KDRESULTS)
  8173:                 DEALLOCATE(U_WIND_GFDL)
  8174:                 DEALLOCATE(V_WIND_GFDL)
  8175:                 DEALLOCATE(PRESS_GFDL)
  8176:                 DEALLOCATE(XY_GFDL)
  8177:                 DEALLOCATE(WTS)
  8178:                 DEALLOCATE(LOCS)
  8179:           
  8180:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8181:                 call allMessage(DEBUG,"Return.")
  8182:           #endif
  8183:                  !cleans up the setMessageSource set at the beginning of the subroutine
  8184:                  call unsetMessageSource()
  8185:           
  8186:                  RETURN
  8187:           C ---------------------------------------------------------------------
  8188:                  END SUBROUTINE GET_GFDL


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GET_GFDL
INLINE LIST

  ROOT: WIND::GET_GFDL (wind.F:7950)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:7985)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8002)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:8004)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8006)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: MESH::DRVSPCOORSROTS0 (wind.F:8041)
     *** Source for routine not found.
  -> NOINLINE: MESH::CYLINDERMAP (wind.F:8045)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8053)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8075)
     *** Source for routine not found.
  -> NOINLINE: KDTREE2_MODULE::KDTREE2_CREATE (wind.F:8084)
     *** Source for routine not found.
  -> NOINLINE: KDTREE2_MODULE::KDTREE2_N_NEAREST (wind.F:8105)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8184)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GET_GFDL
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8002)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8002)
  LOOP END

  LOOP BEGIN: (wind.F:8004)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8004)
  LOOP END

  LOOP BEGIN: (wind.F:8030)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:8030)
    *** Vectorization obstructive procedure reference. : MESH::CYLINDERMAP (wind.F:8030)
    *** Vectorization obstructive procedure reference. : MESH::DRVSPCOORSROTS0 (wind.F:8030)
  LOOP END

  LOOP BEGIN: (wind.F:8060)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8060)
    *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:8060)
    *** Idiom detected. : MAX/MIN (wind.F:8060)
  LOOP END

  LOOP BEGIN: (wind.F:8061)
    <Vectorized loop.>
    **  Fused loop. (wind.F:8061)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8061)
    *** The number of VLOAD, VSTORE. :  1,  2. (wind.F:8061)
  LOOP END

  LOOP BEGIN: (wind.F:8063)
    <Vectorized loop.>
    **  Fused loop. (wind.F:8063)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8063)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:8063)
    *** Idiom detected. : SUM (wind.F:8064)
  LOOP END

  LOOP BEGIN: (wind.F:8065)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8065)
    *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:8065)
    *** Idiom detected. : MAX/MIN (wind.F:8065)
  LOOP END

  LOOP BEGIN: (wind.F:8065)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8065)
    *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:8065)
    *** Idiom detected. : MAX/MIN (wind.F:8065)
  LOOP END

  LOOP BEGIN: (wind.F:8095)
    <Vectorized loop.>
    **  Fused loop. (wind.F:8095)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8095)
    *** The number of VLOAD, VSTORE. :  0,  3. (wind.F:8095)
  LOOP END

  LOOP BEGIN: (wind.F:8100)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : KDTREE2_MODULE::KDTREE2_N_NEAREST (wind.F:8100)

    LOOP BEGIN: (wind.F:8118)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:8118)
      *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:8118)
    LOOP END

    LOOP BEGIN: (wind.F:8139)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:8139)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:14 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GET_GFDL
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 57 [s0-s12 s15-s16 s18-s44 s49-s63]
      Vector registers         : 38 [v0 v27-v63]
      Vector mask registers    :  3 [vm13-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 21552 bytes
      Register spill area      :  8872 bytes
      Parameter area           :    64 bytes
      Register save area       :   176 bytes
      User data area           : 12440 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8002)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8004)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8030)
    *** Estimated execution cycle                       : 270
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 20
            Across calls                                : 15
            Over basic blocks                           :  5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 49
            Across calls                                : 22
            Over basic blocks                           : 27
    *** The number of SCALAR REGISTER TRANSFER          : 52
  LOOP END

  LOOP BEGIN: (wind.F:8060)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (wind.F:8061)
    *** Estimated execution cycle                       : 95
  LOOP END

  LOOP BEGIN: (wind.F:8063)
    *** Estimated execution cycle                       : 256
  LOOP END

  LOOP BEGIN: (wind.F:8065)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (wind.F:8065)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (wind.F:8095)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:8100)
    *** Estimated execution cycle                       : 250
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 12
            Across calls                                :  1
            Over basic blocks                           : 11
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 26
            Across calls                                :  1
            Over basic blocks                           : 25
    *** The number of SCALAR REGISTER TRANSFER          : 26

    LOOP BEGIN: (wind.F:8118)
      *** Estimated execution cycle                     : 1103
      *** The number of VECTOR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
    LOOP END

    LOOP BEGIN: (wind.F:8139)
      *** Estimated execution cycle                     : 58
      *** The number of SCALAR REGISTER TRANSFER        : 4
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS16GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8210: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8220: vec( 101): Vectorized loop.
  8221: vec( 126): Idiom detected.: SEARCH
  8237: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  8264: inl(1214): Expansion routine is too big for automatic expansion.: WIND::GET_GFDL
  8264: opt(3009): Copy-in/out loops have been generated.: WVNX
  8264: opt(3009): Copy-in/out loops have been generated.: WVNY
  8264: opt(3009): Copy-in/out loops have been generated.: PRESS
  8264: opt(3011): Copy-out loop has been generated.: WVNY
  8264: opt(3011): Copy-out loop has been generated.: WVNX
  8264: vec( 101): Vectorized loop.
  8269: vec( 101): Vectorized loop.
  8270: vec( 101): Vectorized loop.
  8271: vec( 101): Vectorized loop.
  8278: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS16GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8195:                 subroutine nws16get(timeloc,wvnx,wvny,press)
  8196:                 use mesh, only : x,y,np,slam0,sfea0
  8197:                 use global, only : setMessageSource,unsetMessageSource,allMessage,
  8198:                &        logMessage,scratchMessage,DEBUG,ECHO,INFO,ERROR,
  8199:                &        WARNING
  8200:                 USE ADC_CONSTANTS, only: PRBCKGRND,RHOWAT0,G
  8201:           
  8202:                 implicit none
  8203:                 integer :: i,numFiles,currentCycle
  8204:                 logical :: cycleTimeFound
  8205:                 real(8), intent(in) :: timeloc   ! adcirc time, seconds since coldstart
  8206:                 real(8), intent(out) :: wvnx(:)  ! wind u-velocity (m/s)
  8207:                 real(8), intent(out) :: wvny(:)  ! wind v-velocity (m/s)
  8208:                 real(8), intent(out) :: press(:)  !barometric pressure (mH20)
  8209:           
  8210:                 call setMessageSource("nws16get")
  8211:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8212:                 call allMessage(DEBUG,"Enter.")
  8213:           #endif
  8214:           
  8215:                 numFiles = GFDL_Files(1)%numFiles  !This is total number of files
  8216:           
  8217:                 !
  8218:                 ! locate the cycle that is relevant to current ADCIRC time
  8219:                 cycleTimeFound = .false.
  8220: V------>        do i=1,numFiles-1
  8221: |                  if (( GFDL_Files(i)%cycleTime.le.timeloc).and.
  8222: |              &        (GFDL_Files(i+1)%cycleTime.gt.timeloc) ) then
  8223: |                     cycleTimeFound = .true.
  8224: |                     exit
  8225: |                  endif
  8226: V------         end do
  8227:                 currentCycle = i
  8228:           
  8229:                 if (cycleTimeFound.eqv. .false.) then
  8230:                    if ( timeloc.lt.GFDL_Files(1)%cycleTime ) then
  8231:           
  8232:           ! ... tcm 20130801 v51.06.10 replaced error exiting with insertion of blank snaps
  8233:                       write(scratchMessage,'("The current ADCIRC time ",
  8234:                &        E15.8," (days) is earlier than the first GFDL Met file time: ",
  8235:                &        E15.8, " (days). Inserting a blank wind snap.")')
  8236:                &        timeloc/86400.d0,GFDL_Files(1)%cycleTime/86400.d0
  8237:                       call logMessage(WARNING,scratchMessage)
  8238:                       currentCycle = 1
  8239:                    endif
  8240:           
  8241:                    if ( timeloc.gt.GFDL_Files(numFiles)%cycleTime ) then
  8242:           
  8243:                       write(scratchMessage,'("The current ADCIRC time ",
  8244:                &        E15.8, " (days) is later than the last GFDL Met file time: ",
  8245:                &        E15.8, " (days). Inserting a blank wind snap.")')
  8246:                &         timeloc/86400.d0,GFDL_Files(numFiles)%cycleTime/86400.d0
  8247:                       call logMessage(WARNING,scratchMessage)
  8248:                       currentCycle = numFiles-1
  8249:                    endif
  8250:           
  8251:                 endif
  8252:           
  8253:           
  8254:                 if (cycleTimeFound.eqv. .true.) then
  8255:                    ! load up the data for this time interval
  8256:           
  8257:                    write(scratchMessage,'("At ADCIRC time: ",
  8258:                &      E15.8," (days), ready to read next GFDL Met File with time: ",
  8259:                &      E15.8," (days).")') timeloc/86400.d0,
  8260:                &         GFDL_Files(currentCycle)%cycleTime/86400.d0
  8261:           
  8262:                    call logMessage(INFO,scratchMessage)
  8263:           
  8264: V======>           call GET_GFDL(NP,WVNX,WVNY,PRess,x,y,
  8265:                &                GFDL_Files(currentCycle)%file_name,
  8266:                &                SLAM0,SFEA0,
  8267:                &                GFDL_Files(currentCycle)%max_extrap_dist)
  8268:                 else
  8269: V======>           WVNX(:) = 0.d0
  8270: V======>           WVNY(:) = 0.d0
  8271: V======>           PRess(:) = PRBCKGRND*100.D0/(RHOWAT0*G)  !SET TO BACKGROUND PRESSURE 1013.0D0 ADJUSTED for ADCIRC units
  8272:                 endif
  8273:           
  8274:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8275:                 call allMessage(DEBUG,"Return.")
  8276:           #endif
  8277:                   !cleans up the setMessageSource set at the beginning of the subroutine
  8278:                   call unsetMessageSource()
  8279:           
  8280:                   return
  8281:                   end subroutine nws16get


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS16GET
INLINE LIST

  ROOT: WIND::NWS16GET (wind.F:8195)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8210)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8237)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8247)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8262)
     *** Source for routine not found.
  -> NOINLINE: WIND::GET_GFDL (wind.F:8264)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8278)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS16GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8220)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8220)
    *** The number of VLOAD, VSTORE. :  2,  0. (wind.F:8220)
    *** Idiom detected. : SEARCH (wind.F:8221)
  LOOP END

  LOOP BEGIN: (wind.F:8269)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8269)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8269)
  LOOP END

  LOOP BEGIN: (wind.F:8270)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8270)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8270)
  LOOP END

  LOOP BEGIN: (wind.F:8271)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8271)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8271)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8264)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8264)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS16GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 45 [s0-s12 s15-s16 s18-s35 s52-s63]
      Vector registers         : 17 [v47-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 4720 bytes
      Register spill area      :   96 bytes
      Parameter area           :   88 bytes
      Register save area       :  176 bytes
      User data area           : 4352 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8220)
    *** Estimated execution cycle                       : 341
  LOOP END

  LOOP BEGIN: (wind.F:8269)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8270)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8271)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8264)
    *** Estimated execution cycle                       : 63
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::RSGET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8314: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8318: vec( 101): Vectorized loop.
  8319: opt(1112): Loop fused with previous loop.
  8322: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  8322: vec( 103): Unvectorized loop.
  8322: vec( 180): I/O statement obstructs vectorization.
  8322: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  8322: vec( 182): Deallocation obstructs vectorization.
  8322: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  8322: vec( 109): Vectorization obstructive statement.
  8322: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  8322: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  8322: vec( 108): Unvectorizable loop structure.
  8325: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8326: inl(1222): Inlined: WIND::WINDTERMINATE
  8331: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  8331: vec( 103): Unvectorized loop.
  8331: vec( 180): I/O statement obstructs vectorization.
  8331: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  8331: vec( 182): Deallocation obstructs vectorization.
  8331: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  8331: vec( 109): Vectorization obstructive statement.
  8331: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  8331: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  8331: vec( 108): Unvectorizable loop structure.
  8341: inl(1222): Inlined: WIND::WINDTERMINATE
  8368: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::RSGET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8302:                 subroutine rsget(rsnx,rsny)
  8303:                 use global, only : nabout
  8304:                 use mesh, only : np
  8305:                 implicit none
  8306:                 real(8), intent(out), dimension(np) :: rsnx
  8307:                 real(8), intent(out), dimension(np) :: rsny
  8308:                 integer :: nhg
  8309:                 integer, save :: lineNum = 0
  8310:                 real(8) :: rsnxRaw, rsnyRaw
  8311:                 character*80 pbljagf
  8312:                 integer :: errorio
  8313:           C
  8314:                 call setMessageSource("rsget")
  8315:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8316:                 call allMessage(DEBUG,"Enter.")
  8317:           #endif
  8318: V------>        rsnx(1:np) = 0.d0
  8319: V------         rsny(1:np) = 0.d0
  8320:           C
  8321:                 lineNum = lineNum + 1
  8322: +------>        do while(.true.)
  8323: |                  read(23,'(a80)',end=500,err=600,iostat=errorio) pbljagf
  8324: |                  if (pbljagf(1:1).eq.'#') then
  8325: |                     call allMessage(ERROR,'Found "#" in column 1 of fort.23.')
  8326: |       I             call windTerminate()
  8327: |                  endif
  8328: |                  if(pbljagf(2:2).ne.'#') exit
  8329: +------         enddo
  8330:                 lineNum = lineNum + 1
  8331: +------>        do while(.true.)
  8332: |                  read(pbljagf,'(i8,5e13.5)',end=500,err=600,iostat=errorio)
  8333: |              &         nhg, rsnxRaw, rsnyRaw
  8334: |                  rsnx(nhg) = rsnxRaw
  8335: |                  rsny(nhg) = rsnyRaw
  8336: |                  lineNum = lineNum + 1
  8337: |                  read(23,'(a80)') pbljagf
  8338: |                  if (pbljagf(1:1).eq.'#') then
  8339: |                     call allMessage(ERROR,'Found "#" in column 1 of fort.23; '//
  8340: |              &         ' this character should only appear in column 2.')
  8341: |       I             call windTerminate()
  8342: |                  endif
  8343: |                  if(pbljagf(2:2).eq.'#') exit
  8344: +------         enddo
  8345:           
  8346:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8347:                 call allMessage(DEBUG,"Return.")
  8348:           #endif
  8349:                 !cleans up the setMessageSource set at the beginning of the subroutine
  8350:                 call unsetMessageSource()
  8351:                 return
  8352:           C
  8353:           C     We jump to this section if there was an error reading a file.
  8354:           500   call allMessage(ERROR,'Unexpectedly reached end-of-file.') ! END jumps here
  8355:           600   call allMessage(ERROR,'I/O error during file access.') !  ERR jumps here
  8356:                 write(scratchMessage,'(a,i0,a)')'Failed to read line ',lineNum,'.'
  8357:                 call allMessage(ERROR,scratchMessage)
  8358:                 call allMessage(ERROR,
  8359:                &                  'Check the fort.16 file for more information.')
  8360:                 if (nabout.gt.0) then
  8361:                    call allMessage(INFO,'Reducing the value of NABOUT to 0'
  8362:                &  //' will maximize the information written to the fort.16 file,'
  8363:                &  //' which may aid in troubleshooting this issue.')
  8364:                 endif
  8365:                 write(scratchMessage,'(a,i0,a)')
  8366:                &       'The value of the i/o error flag was ',errorio,'.'
  8367:                 call allMessage(ERROR,scratchMessage)
  8368:         I       CALL windTerminate()
  8369:           C----------------------------------------------------------------------
  8370:                 end subroutine rsget


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::RSGET
INLINE LIST

  ROOT: WIND::RSGET (wind.F:8302)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8314)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8325)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8326)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8339)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8341)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8350)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8354)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8355)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8357)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8358)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8361)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8367)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8368)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::RSGET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8318)
    <Vectorized loop.>
    **  Fused loop. (wind.F:8318)
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8318)
    *** The number of VLOAD, VSTORE. :  0,  2. (wind.F:8318)
  LOOP END

  LOOP BEGIN: (wind.F:8322)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:8322)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:8322)
    *** Deallocation obstructs vectorization. (wind.F:8322)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:8322)
    *** Vectorization obstructive statement. (wind.F:8322)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:8322)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:8322)
    *** Unvectorizable loop structure. (wind.F:8322)
  LOOP END

  LOOP BEGIN: (wind.F:8331)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:8331)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:8331)
    *** Deallocation obstructs vectorization. (wind.F:8331)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:8331)
    *** Vectorization obstructive statement. (wind.F:8331)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:8331)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:8331)
    *** Unvectorizable loop structure. (wind.F:8331)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::RSGET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 39 [s0-s12 s15-s16 s18-s34 s57-s63]
      Vector registers         :  1 [v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 4832 bytes
      Register spill area      :   96 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 4496 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8318)
    *** Estimated execution cycle                       : 98
  LOOP END

  LOOP BEGIN: (wind.F:8322)
    *** Estimated execution cycle                       : 101
    *** The number of SCALAR REGISTER TRANSFER          : 15
  LOOP END

  LOOP BEGIN: (wind.F:8331)
    *** Estimated execution cycle                       : 159
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITDYNAMICWATERLEVELCORRECTION
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8413: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8421: inl(1212): Source for routine not found.: GLOBAL::OPENFILEFORREAD
  8421: vec( 103): Unvectorized loop.
  8421: vec( 108): Unvectorizable loop structure.
  8426: vec( 103): Unvectorized loop.
  8426: vec( 108): Unvectorizable loop structure.
  8431: inl(1222): Inlined: WIND::WINDTERMINATE
  8436: vec( 101): Vectorized loop.
  8445: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  8445: vec( 103): Unvectorized loop.
  8445: vec( 108): Unvectorizable loop structure.
  8458: inl(1222): Inlined: WIND::WINDTERMINATE
  8467: vec( 101): Vectorized loop.
  8468: vec( 101): Vectorized loop.
  8479: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  8484: inl(1222): Inlined: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
  8494: vec( 103): Unvectorized loop.
  8494: vec( 108): Unvectorizable loop structure.
  8503: inl(1222): Inlined: WIND::WINDTERMINATE
  8506: vec( 103): Unvectorized loop.
  8506: vec( 108): Unvectorizable loop structure.
  8510: inl(1222): Inlined: WIND::WINDTERMINATE
  8517: inl(1222): Inlined: WIND::WINDTERMINATE
  8536: vec( 103): Unvectorized loop.
  8536: vec( 108): Unvectorizable loop structure.
  8542: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITDYNAMICWATERLEVELCORRECTION
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8405:                 subroutine initDynamicWaterLevelCorrection(timesec)
  8406:                 use sizes, only : globaldir
  8407:                 use global, only : nabout, np_g
  8408:                 use mesh, only : np
  8409:                 implicit none
  8410:                 real(8), intent(in) :: timesec ! adcirc model time (s)
  8411:                 integer :: errorio ! i/o error condition code
  8412:           
  8413:                 call setMessageSource("initDynamicWaterLevelCorrection")
  8414:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8415:                 call allMessage(DEBUG,"Enter.")
  8416:           #endif
  8417:                 !
  8418:                 ! Check to make sure the correction file actually exists and if so, open it
  8419:                 errorio = 0
  8420:                 ! jgf: First try looking in the full domain input file directory
  8421:                 call openFileForRead(dynamicWaterLevelCorrectionUn,
  8422:                &   trim(globaldir)//"/"//trim(dynamicWaterLevelCorrectionFileName), errorio)
  8423:                 ! If the file was not found, in the directory with the other
  8424:                 ! full domain input files, perhaps it was provided with a full path?
  8425:                 if (errorio.gt.0) then
  8426:                    call openFileForRead(dynamicWaterLevelCorrectionUn,
  8427:                &          trim(dynamicWaterLevelCorrectionFileName), errorio)
  8428:                 endif
  8429:                 ! give up if the file was still not found
  8430:                 if (errorio.gt.0) then
  8431:         I          call windTerminate()
  8432:                 endif
  8433:                 ! file exists, allocate space to hold the data
  8434:           #ifdef CMPI
  8435:                 allocate(dynamicWaterLevelCorrectionFD(np_g))
  8436: V======>        dynamicWaterLevelCorrectionFD(:) = 0.d0
  8437:           #endif
  8438:                 allocate(dynamicWaterLevelCorrectionsOld_m(np))
  8439:                 allocate(dynamicWaterLevelCorrectionsNew_m(np))
  8440:                 !
  8441:                 ! read header
  8442:                 dynamicWaterLevelCorrectionCurrentLine = 1
  8443:                 ! first line is a comment line
  8444:                 read(dynamicWaterLevelCorrectionUn,'(A)',end=256,err=258,iostat=errorio) dynamicWaterLevelCorrectionComment
  8445:                 call logMessage(ECHO,"dynamicWaterLevelCorrectionComment: "//trim(dynamicWaterLevelCorrectionComment))
  8446:                 dynamicWaterLevelCorrectionCurrentLine = dynamicWaterLevelCorrectionCurrentLine + 1
  8447:                 ! 2nd line is time increment between datasets
  8448:                 read(dynamicWaterLevelCorrectionUn,fmt=*,end=256,err=258,iostat=errorio) dynamicWaterLevelCorrectionTimeIncrement
  8449:                 write(scratchMessage,'(a,f15.7)') "dynamicWaterLevelCorrectionTimeIncrement: ",
  8450:                &    dynamicWaterLevelCorrectionTimeIncrement
  8451:                 call logMessage(ECHO,scratchMessage)
  8452:                 dynamicWaterLevelCorrectionCurrentLine = dynamicWaterLevelCorrectionCurrentLine + 1
  8453:                 ! tga20190628: this "if" is needed because it could lead to NaNs
  8454:                 ! if dynamicWaterLevelCorrectionTimeIncrement is zero, plus no reason for negative.
  8455:                 if (dynamicWaterLevelCorrectionTimeIncrement.le.0.d0) then
  8456:                    call allMessage(ERROR,'Water level correction time increment ' //
  8457:                &       'dynamicWaterLevelCorrectionTimeIncrement must be greater than zero')
  8458:         I          call windTerminate()
  8459:                 endif
  8460:                 ! 3nd line is default correction value
  8461:                 read(dynamicWaterLevelCorrectionUn,fmt=*,end=256,err=258,iostat=errorio) dynamicWaterLevelCorrectionDefaultValue
  8462:                 write(scratchMessage,'(a,f15.7)') "dynamicWaterLevelCorrectionDefaultValue: ",
  8463:                &    dynamicWaterLevelCorrectionDefaultValue
  8464:                 call logMessage(ECHO,scratchMessage)
  8465:                 dynamicWaterLevelCorrectionCurrentLine = dynamicWaterLevelCorrectionCurrentLine + 1
  8466:                 ! initialize array values to zero -- can be used as blank snaps
  8467: V======>        dynamicWaterLevelCorrectionsOld_m(:) = 0.d0
  8468: V======>        dynamicWaterLevelCorrectionsNew_m(:) = 0.d0
  8469:                 !
  8470:                 ! the common case is that dynamicWaterLevelCorrectionSkipSnaps will be 0 and we need
  8471:                 ! to read the first two datasets
  8472:                 !
  8473:                 ! may also need to skip datasets (insert blank datasets if
  8474:                 ! dynamicWaterLevelCorrectionSkipSnaps is negative)
  8475:                 !
  8476:                 ! if there is only one dataset, the correctionIsConstant flag is raised
  8477:                 dynamicWaterLevelCorrectionDataSetCounter = 0
  8478:                 dynamicWaterLevelCorrectionBlankSnaps = 2
  8479: +------>        do while (dynamicWaterLevelCorrectionDataSetCounter.lt.(dynamicWaterLevelCorrectionSkipSnaps+2))
  8480: |                  if (dynamicWaterLevelCorrectionFileEnded.eqv..true.) then
  8481: |                     exit
  8482: |                  endif
  8483: |                  ! read the next snap from file
  8484: |       I          call readDynamicWaterLevelCorrectionDataSet()
  8485: |                  dynamicWaterLevelCorrectionBlankSnaps = dynamicWaterLevelCorrectionBlankSnaps - 1
  8486: +------         end do
  8487:                 !
  8488:                 ! set the time corresponding to the two datasets we are
  8489:                 ! interpolating between
  8490:                 dynamicWaterLevelCorrectionTimeOld = timesec
  8491:                 dynamicWaterLevelCorrectionTimeNew = timesec + dynamicWaterLevelCorrectionTimeIncrement
  8492:                 !
  8493:                 ! set ramp times relative to specified reference
  8494:                 select case(trim(dynamicWaterLevelCorrectionRampReferenceTime))
  8495:                 case('hotstart','Hotstart','HotStart','HOTSTART')
  8496:                    dynamicWaterLevelCorrectionRampStart = timesec + dynamicWaterLevelCorrectionRampStart
  8497:                    dynamicWaterLevelCorrectionRampEnd = timesec + dynamicWaterLevelCorrectionRampEnd
  8498:                 case('coldstart','Coldstart','ColdStart','COLDSTART')
  8499:                    if (dynamicWaterLevelCorrectionRampStart.lt.0.d0.or.dynamicWaterLevelCorrectionRampEnd.lt.0.d0) then
  8500:                       call allMessage(ERROR,'Water level correction ramp reference '//
  8501:                &      'time was set to coldstart but negative ramp time(s) '//
  8502:                &      'were found.')
  8503:                       call windTerminate()
  8504:                    endif
  8505:                 case default
  8506:                    call allMessage(ERROR,'Water level correction ramp '//
  8507:                &   'reference time was set to "'//trim(dynamicWaterLevelCorrectionRampReferenceTime)//
  8508:                &   '" which is not a valid value. The dynamicWaterLevelCorrectionRampReferenceTime '//
  8509:                &   'parameter must be set to "coldstart" or "hotstart".')
  8510:                    call windTerminate()
  8511:                 end select
  8512:                 !
  8513:         I       ! make sure start of ramp occurs before end of ramp
  8514:                 if (dynamicWaterLevelCorrectionRampStart.gt.dynamicWaterLevelCorrectionRampEnd) then
  8515:                    call allMessage(ERROR,
  8516:                &   'dynamicWaterLevelCorrectionRampStart is after dynamicWaterLevelCorrectionRampEnd.')
  8517:         I          call windTerminate()
  8518:                 endif
  8519:           
  8520:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8521:         I       call allMessage(DEBUG,"Return.")
  8522:           #endif
  8523:                 call unsetMessageSource()
  8524:                 return
  8525:           
  8526:           256   call allMessage(ERROR,'Unexpectedly reached end-of-file.') ! END jumps here
  8527:           258   call allMessage(ERROR,'I/O error during file access.') !  ERR jumps here
  8528:                 call allMessage(INFO,
  8529:                &   'Check the fort.16 file for more information.')
  8530:                 if (nabout.gt.0) then
  8531:                    call allMessage(INFO,
  8532:                &  'Reducing the value of NABOUT to 0'
  8533:                &  //' will maximize the information written to the fort.16 file,'
  8534:                &  //' which may aid in troubleshooting this issue.')
  8535:                 endif
  8536:                 write(scratchMessage,'("Could not read line ",i0," of ",a,".")')
  8537:                &  dynamicWaterLevelCorrectionCurrentLine, trim(dynamicWaterLevelCorrectionFileName)
  8538:                 call allMessage(ERROR,scratchMessage)
  8539:                 write(scratchMessage,'(a,i0,a)')
  8540:                &       'The value of the i/o error flag was ',errorio,'.'
  8541:                 call allMessage(ERROR,scratchMessage)
  8542:         I       CALL windTerminate()
  8543:           
  8544:           
  8545:           C----------------------------------------------------------------------
  8546:                 end subroutine initdynamicWaterLevelCorrection


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITDYNAMICWATERLEVELCORRECTION
INLINE LIST

  ROOT: WIND::INITDYNAMICWATERLEVELCORRECTION (wind.F:8405)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8413)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:8421)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::OPENFILEFORREAD (wind.F:8426)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8431)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8445)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8451)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8456)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8458)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8464)
     *** Source for routine not found.
  -> INLINE: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET (wind.F:8484)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8663)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8693)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:8694)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8708)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8713)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8735)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8740)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8741)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8742)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8745)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8752)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8755)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:8756)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8500)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8503)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8506)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8510)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8515)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8517)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8523)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8526)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8527)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8528)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8531)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8538)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8541)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8542)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITDYNAMICWATERLEVELCORRECTION
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8421)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8421)
  LOOP END

  LOOP BEGIN: (wind.F:8421)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8421)
  LOOP END

  LOOP BEGIN: (wind.F:8426)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8426)
  LOOP END

  LOOP BEGIN: (wind.F:8436)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8436)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8436)
  LOOP END

  LOOP BEGIN: (wind.F:8445)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8445)
  LOOP END

  LOOP BEGIN: (wind.F:8467)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8467)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8467)
  LOOP END

  LOOP BEGIN: (wind.F:8468)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8468)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8468)
  LOOP END

  LOOP BEGIN: (wind.F:8479)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:8672)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:8672)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8672)
    LOOP END

    LOOP BEGIN: (wind.F:8673)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:8673)
      *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8673)
    LOOP END

    LOOP BEGIN: (wind.F:8675)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:8675)
      *** Deallocation obstructs vectorization. (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:8675)
      *** Vectorization obstructive statement. (wind.F:8675)
      *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:8675)
      *** Unvectorizable loop structure. (wind.F:8675)
    LOOP END

    LOOP BEGIN: (wind.F:8750)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:8750)
    LOOP END

    LOOP BEGIN: (wind.F:8708)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:8708)
    LOOP END

    LOOP BEGIN: (wind.F:8722)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  1,  0. (wind.F:8722)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8722)
      *** VGT generated (wind.F:8727)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:8494)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8494)
  LOOP END

  LOOP BEGIN: (wind.F:8506)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8506)
  LOOP END

  LOOP BEGIN: (wind.F:8536)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8536)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::INITDYNAMICWATERLEVELCORRECTION
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 53 [s0-s12 s15-s16 s18-s43 s52-s63]
      Vector registers         : 10 [v54-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 12752 bytes
      Register spill area      :   848 bytes
      Parameter area           :    64 bytes
      Register save area       :   176 bytes
      User data area           : 11664 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8421)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8421)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8426)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8436)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8445)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8467)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8468)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8479)
    *** Estimated execution cycle                       : 884
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 56
            Across calls                                : 18
            Over basic blocks                           : 37
            Others                                      :  1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 129
            Across calls                                :  23
            Over basic blocks                           : 104
            Others                                      :   2
    *** The number of SCALAR REGISTER TRANSFER          : 76

    LOOP BEGIN: (wind.F:8672)
      *** Estimated execution cycle                     : 64
    LOOP END

    LOOP BEGIN: (wind.F:8673)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (wind.F:8675)
      *** Estimated execution cycle                     : 227
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  1
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER TRANSFER        : 33
    LOOP END

    LOOP BEGIN: (wind.F:8750)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (wind.F:8708)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (wind.F:8722)
      *** Estimated execution cycle                     : 251
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:8494)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8506)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8536)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETDYNAMICWATERLEVELCORRECTIONS
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8572: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8586: vec( 101): Vectorized loop.
  8590: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  8590: vec( 108): Unvectorizable loop structure.
  8596: inl(1222): Inlined: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
  8607: vec( 101): Vectorized loop.
  8607: vec( 128): Fused multiply-add operation applied.
  8616: vec( 101): Vectorized loop.
  8624: vec( 101): Vectorized loop.
  8630: vec( 101): Vectorized loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETDYNAMICWATERLEVELCORRECTIONS
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8565:                 subroutine getDynamicWaterLevelCorrections(dynamicWaterLevelCorrectionsArray, timesec)
  8566:                 use mesh, only : np
  8567:                 implicit none
  8568:                 real(8), intent(in) :: timesec ! current adcirc time
  8569:                 real(8), intent(out) :: dynamicWaterLevelCorrectionsArray(np)
  8570:                 real(8) :: dynamicWaterLevelCorrectionRamp ! linear time varying ramp value
  8571:                 integer :: i ! jgfdebug
  8572:                 call setMessageSource("getDynamicWaterLevelCorrections")
  8573:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8574:                 call allMessage(DEBUG,"Enter.")
  8575:           #endif
  8576:                 !
  8577:                 ! hold data constant after last snap
  8578:                 if ( dynamicWaterLevelCorrectionIsConstant.eqv..false.) then
  8579:                    if ( (timesec.gt.dynamicWaterLevelCorrectionTimeNew)
  8580:                &        .and.(dynamicWaterLevelCorrectionFileEnded.eqv..true.) ) then
  8581:                       dynamicWaterLevelCorrectionIsConstant = .true.
  8582:                    endif
  8583:                 endif
  8584:                 !
  8585:                 if ( dynamicWaterLevelCorrectionIsConstant.eqv..true. ) then
  8586: V======>           dynamicWaterLevelCorrectionsArray(:) = dynamicWaterLevelCorrectionsNew_m(:)
  8587:                 else
  8588:                    ! read new data if it is time
  8589:                    if ( timesec.gt.dynamicWaterLevelCorrectionTimeNew ) then
  8590: +------>              do while (timesec.gt.dynamicWaterLevelCorrectionTimeNew)
  8591: |                        ! insert blanks if needed
  8592: |                        if (dynamicWaterLevelCorrectionSkipSnaps.lt.(-1*dynamicWaterLevelCorrectionBlankSnaps)) then
  8593: |                           ! both datasets still have all zero values
  8594: |                           dynamicWaterLevelCorrectionBlankSnaps = dynamicWaterLevelCorrectionBlankSnaps + 1
  8595: |                        else
  8596: |       I                   call readDynamicWaterLevelCorrectionDataSet()
  8597: |                        endif
  8598: |                        dynamicWaterLevelCorrectionTimeOld = dynamicWaterLevelCorrectionTimeNew
  8599: |                        dynamicWaterLevelCorrectionTimeNew = dynamicWaterLevelCorrectionTimeNew +
  8600: |              &                  dynamicWaterLevelCorrectionTimeIncrement
  8601: |                        if ( dynamicWaterLevelCorrectionFileEnded.eqv..true.) then
  8602: |                           exit
  8603: |                        endif
  8604: +------               end do
  8605:                    endif
  8606:                    ! perform time interpolation
  8607: V======>F          dynamicWaterLevelCorrectionsArray(:) =
  8608:                &       (timesec - dynamicWaterLevelCorrectionTimeOld) /
  8609:                &              (dynamicWaterLevelCorrectionTimeNew - dynamicWaterLevelCorrectionTimeOld )
  8610:                &       * ( dynamicWaterLevelCorrectionsNew_m(:) - dynamicWaterLevelCorrectionsOld_m(:) )
  8611:                &          + dynamicWaterLevelCorrectionsOld_m(:)
  8612:                 endif
  8613:                 !
  8614:                 ! set to zero everywhere prior to the start of the ramping period
  8615:                 if (timesec.lt.dynamicWaterLevelCorrectionRampStart) then
  8616: V======>           dynamicWaterLevelCorrectionsArray(:) = 0.d0
  8617:                 endif
  8618:                 ! compute and apply linear ramp during ramping period
  8619:                 if ((timesec.ge.dynamicWaterLevelCorrectionRampStart).and.
  8620:                &    (timesec.le.dynamicWaterLevelCorrectionRampEnd)) then
  8621:                    ! compute linear ramp value
  8622:                    dynamicWaterLevelCorrectionRamp = ( timesec - dynamicWaterLevelCorrectionRampStart)
  8623:                &               / ( dynamicWaterLevelCorrectionRampEnd - dynamicWaterLevelCorrectionRampStart )
  8624: V======>           dynamicWaterLevelCorrectionsArray(:) = dynamicWaterLevelCorrectionsArray(:) *
  8625:                &      dynamicWaterLevelCorrectionRamp
  8626:                 endif
  8627:                 ! just leave the raw values alone after the end of ramp period
  8628:                 !
  8629:                 ! apply correction multiplier if any
  8630: V======>        dynamicWaterLevelCorrectionsArray(:) = dynamicWaterLevelCorrectionMultiplier *
  8631:                &  dynamicWaterLevelCorrectionsArray(:)
  8632:           
  8633:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8634:                 call allMessage(DEBUG,"Return.")
  8635:           #endif
  8636:                 call unsetMessageSource()
  8637:                 return
  8638:           
  8639:           C----------------------------------------------------------------------
  8640:                 end subroutine getdynamicWaterLevelCorrections


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETDYNAMICWATERLEVELCORRECTIONS
INLINE LIST

  ROOT: WIND::GETDYNAMICWATERLEVELCORRECTIONS (wind.F:8565)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8572)
     *** Source for routine not found.
  -> INLINE: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET (wind.F:8596)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8663)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8693)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:8694)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8708)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8713)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8735)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8740)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8741)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8742)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8745)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8752)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8755)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:8756)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8636)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETDYNAMICWATERLEVELCORRECTIONS
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8590)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8590)

    LOOP BEGIN: (wind.F:8672)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:8672)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8672)
    LOOP END

    LOOP BEGIN: (wind.F:8673)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:8673)
      *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8673)
    LOOP END

    LOOP BEGIN: (wind.F:8675)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:8675)
      *** Deallocation obstructs vectorization. (wind.F:8675)
      *** Vectorization obstructive statement. (wind.F:8675)
      *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:8675)
      *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:8675)
      *** Unvectorizable loop structure. (wind.F:8675)
    LOOP END

    LOOP BEGIN: (wind.F:8750)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:8750)
    LOOP END

    LOOP BEGIN: (wind.F:8708)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:8708)
    LOOP END

    LOOP BEGIN: (wind.F:8722)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  1,  0. (wind.F:8722)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8722)
      *** VGT generated (wind.F:8727)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:8607)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8607)
    *** The number of VLOAD, VSTORE. :  2,  1. (wind.F:8607)
  LOOP END

  LOOP BEGIN: (wind.F:8586)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8586)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8586)
  LOOP END

  LOOP BEGIN: (wind.F:8616)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8616)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8616)
  LOOP END

  LOOP BEGIN: (wind.F:8624)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8624)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8624)
  LOOP END

  LOOP BEGIN: (wind.F:8630)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8630)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8630)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::GETDYNAMICWATERLEVELCORRECTIONS
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 54 [s0-s12 s15-s16 s18-s43 s51-s63]
      Vector registers         : 17 [v47-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 6832 bytes
      Register spill area      :  648 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 5944 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8590)
    *** Estimated execution cycle                       : 950
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 69
            Across calls                                : 21
            Over basic blocks                           : 43
            Others                                      :  5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 138
            Across calls                                :  29
            Over basic blocks                           : 107
            Others                                      :   2
    *** The number of SCALAR REGISTER TRANSFER          : 77

    LOOP BEGIN: (wind.F:8672)
      *** Estimated execution cycle                     : 64
    LOOP END

    LOOP BEGIN: (wind.F:8673)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (wind.F:8675)
      *** Estimated execution cycle                     : 222
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER TRANSFER        : 37
    LOOP END

    LOOP BEGIN: (wind.F:8750)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (wind.F:8708)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (wind.F:8722)
      *** Estimated execution cycle                     : 251
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:8607)
    *** Estimated execution cycle                       : 162
  LOOP END

  LOOP BEGIN: (wind.F:8586)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:8616)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:8624)
    *** Estimated execution cycle                       : 95
  LOOP END

  LOOP BEGIN: (wind.F:8630)
    *** Estimated execution cycle                       : 95
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8663: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8672: vec( 101): Vectorized loop.
  8673: vec( 101): Vectorized loop.
  8675: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  8675: vec( 103): Unvectorized loop.
  8675: vec( 180): I/O statement obstructs vectorization.
  8675: vec( 109): Vectorization obstructive statement.
  8675: vec( 182): Deallocation obstructs vectorization.
  8675: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::UNSETMESSAGESOURCE
  8675: vec( 110): Vectorization obstructive procedure reference.: MESSENGER::MSG_FINI
  8675: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::ALLMESSAGE
  8675: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::SETMESSAGESOURCE
  8675: vec( 108): Unvectorizable loop structure.
  8693: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8694: inl(1222): Inlined: WIND::WINDTERMINATE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  8708: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  8708: vec( 103): Unvectorized loop.
  8708: vec( 108): Unvectorizable loop structure.
  8722: vec( 101): Vectorized loop.
  8750: vec( 103): Unvectorized loop.
  8750: vec( 108): Unvectorizable loop structure.
  8756: inl(1222): Inlined: WIND::WINDTERMINATE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8651:                 subroutine readDynamicWaterLevelCorrectionDataSet()
  8652:                 use global, only : nabout, np_g, nodes_lg
  8653:                 use mesh, only : np
  8654:                 implicit none
  8655:                 integer :: numCorrectionValues
  8656:                 integer :: nhg ! fulldomain node number
  8657:                 real(8) :: correction_val ! water level correction value at that node
  8658:                 integer :: fd_node_number ! full domain node number
  8659:                 integer :: sd_node_number ! subdomain node number
  8660:                 logical :: nextCorrectionDataSetFound ! true if a # is found in 2nd col
  8661:                 integer :: errorio ! error message code
  8662:           
  8663:                 call setMessageSource("readDynamicWaterLevelCorrectionDataSet")
  8664:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8665:                 call allMessage(DEBUG,"Enter.")
  8666:           #endif
  8667:                 !
  8668:                 numCorrectionValues = np
  8669:           #ifdef CMPI
  8670:                 numCorrectionValues = np_g
  8671:           #endif
  8672: V======>        dynamicWaterLevelCorrectionsOld_m(:) = dynamicWaterLevelCorrectionsNew_m(:)
  8673: V======>        dynamicWaterLevelCorrectionsNew_m(:) = dynamicWaterLevelCorrectionDefaultValue
  8674:                 nextCorrectionDataSetFound = .false.
  8675: +------>        do ! loop until we run out of data or hit a "#" in column 2
  8676: |                  read(dynamicWaterLevelCorrectionUn,fmt='(a)',end=133,err=258,iostat=errorio)
  8677: |              &      scratchMessage
  8678: |                  dynamicWaterLevelCorrectionCurrentLine = dynamicWaterLevelCorrectionCurrentLine + 1
  8679: |                  ! check to see if the next dataset is about to start
  8680: |                  if (scratchMessage(2:2).eq."#") then
  8681: |                     nextCorrectionDataSetFound = .true.
  8682: |                     exit ! break out of do loop
  8683: |                  endif
  8684: |                  ! read the node number and value from the line
  8685: |                  read(scratchMessage,fmt=*,end=256,err=258,iostat=errorio)
  8686: |              &        nhg, correction_val
  8687: |                  ! check to make sure this is a valid node number
  8688: |                  if ( (nhg.lt.1).or.(nhg.gt.numCorrectionValues) ) then
  8689: |                     write(scratchMessage,'(a,i0,a)')
  8690: |              &        'The node number on line ',dynamicWaterLevelCorrectionCurrentLine,
  8691: |              &        ' of the water '//
  8692: |              &        ' correction file is out of range.'
  8693: |                     call allMessage(ERROR,scratchMessage)
  8694: |       I             call windTerminate()
  8695: |                  endif
  8696: |                  ! set the correction value as specified
  8697: |         #ifdef CMPI
  8698: |                  dynamicWaterLevelCorrectionFD(nhg) = correction_val
  8699: |         #else
  8700: |                  dynamicWaterLevelCorrectionsNew_m(nhg) = correction_val
  8701: |         #endif
  8702: +------         end do
  8703:            133  continue ! jump to here if we've run out of lines in the correction file
  8704:                 dynamicWaterLevelCorrectionDataSetCounter = dynamicWaterLevelCorrectionDataSetCounter + 1
  8705:                 ! write log messages if that was the last dataset
  8706:                 if (nextCorrectionDataSetFound.eqv..false.) then
  8707:                    dynamicWaterLevelCorrectionFileEnded = .true.
  8708:                    call logMessage(INFO,
  8709:                &    'Finished reading the final water level correction dataset from "'
  8710:                &      //trim(dynamicWaterLevelCorrectionFileName)//'".')
  8711:                    if ( dynamicWaterLevelCorrectionDataSetCounter.eq.1 ) then
  8712:                       dynamicWaterLevelCorrectionIsConstant = .true.
  8713:                       call logMessage(INFO,
  8714:                &      'Only one water level correction dataset was found. '//
  8715:                &      'The water level correction will therefore be constant in time.')
  8716:                    endif
  8717:                 endif
  8718:           
  8719:           #ifdef CMPI
  8720:                 ! map the full domain node number to the corresponding
  8721:                 ! subdomain node number
  8722: V------>        DO sd_node_number=1,np
  8723: |                  ! get the corresponding fulldomain node number
  8724: |                  fd_node_number = ABS(NODES_LG(sd_node_number))
  8725: |                  ! fill in the subdomain arrays with the corresponding
  8726: |                  ! fulldomain values
  8727: |       G          dynamicWaterLevelCorrectionsNew_m(sd_node_number) = dynamicWaterLevelCorrectionFD(fd_node_number)
  8728: V------         END DO
  8729:           #endif
  8730:           
  8731:           
  8732:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8733:                 call allMessage(DEBUG,"Return.")
  8734:           #endif
  8735:                 call unsetMessageSource()
  8736:                 return
  8737:           
  8738:           C
  8739:           C     We jump to this section if there was an error reading a file.
  8740:           256   call allMessage(ERROR,'Unexpectedly reached end-of-file.') ! END jumps here
  8741:           258   call allMessage(ERROR,'I/O error during file access.') !  ERR jumps here
  8742:                 call allMessage(INFO,
  8743:                &   'Check the fort.16 file for more information.')
  8744:                 if (nabout.gt.0) then
  8745:                    call allMessage(INFO,
  8746:                &  'Reducing the value of NABOUT to 0'
  8747:                &  //' will maximize the information written to the fort.16 file,'
  8748:                &  //' which may aid in troubleshooting this issue.')
  8749:                 endif
  8750:                 write(scratchMessage,'("Could not read line ",i0," of ",a,".")')
  8751:                &  dynamicWaterLevelCorrectionCurrentLine, trim(dynamicWaterLevelCorrectionFileName)
  8752:                 call allMessage(ERROR,scratchMessage)
  8753:                 write(scratchMessage,'(a,i0,a)')
  8754:                &       'The value of the i/o error flag was ',errorio,'.'
  8755:                 call allMessage(ERROR,scratchMessage)
  8756:         I       CALL windTerminate()
  8757:           
  8758:           C----------------------------------------------------------------------
  8759:                 end subroutine readDynamicWaterLevelCorrectionDataSet


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
INLINE LIST

  ROOT: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET (wind.F:8651)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8663)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8693)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8694)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8708)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:8713)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8735)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8740)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8741)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8742)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8745)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8752)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8755)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8756)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:8672)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8672)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8672)
  LOOP END

  LOOP BEGIN: (wind.F:8673)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:8673)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:8673)
  LOOP END

  LOOP BEGIN: (wind.F:8675)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (wind.F:8675)
    *** Vectorization obstructive statement. (wind.F:8675)
    *** Deallocation obstructs vectorization. (wind.F:8675)
    *** Vectorization obstructive procedure reference. : GLOBAL::UNSETMESSAGESOURCE (wind.F:8675)
    *** Vectorization obstructive procedure reference. : MESSENGER::MSG_FINI (wind.F:8675)
    *** Vectorization obstructive procedure reference. : GLOBAL::ALLMESSAGE (wind.F:8675)
    *** Vectorization obstructive procedure reference. : GLOBAL::SETMESSAGESOURCE (wind.F:8675)
    *** Unvectorizable loop structure. (wind.F:8675)
  LOOP END

  LOOP BEGIN: (wind.F:8750)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8750)
  LOOP END

  LOOP BEGIN: (wind.F:8708)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:8708)
  LOOP END

  LOOP BEGIN: (wind.F:8722)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  1,  0. (wind.F:8722)
    *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:8722)
    *** VGT generated (wind.F:8727)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READDYNAMICWATERLEVELCORRECTIONDATASET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 45 [s0-s12 s15-s16 s18-s36 s53-s63]
      Vector registers         :  7 [v57-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 5824 bytes
      Register spill area      :  144 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 5440 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8672)
    *** Estimated execution cycle                       : 64
  LOOP END

  LOOP BEGIN: (wind.F:8673)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (wind.F:8675)
    *** Estimated execution cycle                       : 222
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 37
  LOOP END

  LOOP BEGIN: (wind.F:8750)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8708)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8722)
    *** Estimated execution cycle                       : 251
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDTERMINATE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8773: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8778: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDTERMINATE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8766:                 SUBROUTINE windTerminate()
  8767:           #ifdef CMPI
  8768:                 USE MESSENGER, ONLY : MSG_FINI
  8769:           #endif
  8770:                 IMPLICIT NONE
  8771:                 INTEGER,ALLOCATABLE :: dmy(:)
  8772:           C
  8773:                 call setMessageSource("windTerminate")
  8774:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8775:                 call allMessage(DEBUG,"Enter.")
  8776:           #endif
  8777:           C
  8778:                 call allMessage(ERROR,"ADCIRC terminating.")
  8779:           #ifdef CMPI
  8780:                 call msg_fini()
  8781:           #endif
  8782:                 CALL EXIT(1)
  8783:           C
  8784:           
  8785:           #if defined(WIND_TRACE) || defined(ALL_TRACE)
  8786:                 call allMessage(DEBUG,"Return.")
  8787:           #endif
  8788:                 call unsetMessageSource()
  8789:                 RETURN
  8790:           C----------------------------------------------------------------------
  8791:                 END SUBROUTINE windTerminate


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDTERMINATE
INLINE LIST

  ROOT: WIND::WINDTERMINATE (wind.F:8766)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
     *** Source for routine not found.
  -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDTERMINATE
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDTERMINATE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 14 [s0-s2 s8-s12 s15-s16 s23 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 224 bytes
      Register spill area      :   0 bytes
      Parameter area           :  24 bytes
      Register save area       : 176 bytes
      User data area           :  16 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14INIT
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8807: inl(1212): Source for routine not found.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  8807: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA
  8811: inl(1222): Inlined: WIND::NWS14CHECK_FILETYPE
  8814: inl(1235): Inline halted: code size exceeds limit.: WIND::NWS14INIT
  8821: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WIND::NWS14NC_READ_F22


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14INIT
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8795:                 SUBROUTINE NWS14INIT(NWS)
  8796:           C----------------------------------------------------------------------
  8797:           C.... WJP Adding in subroutines for GRB2 reading below (NWS = 14)
  8798:           C.... or netcdf (depending on what is present)
  8799:           C....
  8800:           C.... CPB 10/2023: reorganized this subroutine to make it more readable
  8801:           C.... as well as to improve input for TACC
  8802:           C----------------------------------------------------------------------
  8803:                 implicit none
  8804:                 INTEGER,INTENT(IN) :: NWS
  8805:            
  8806:                 ! Initialise the datetime
  8807:                 CurDT = basedatetime + timedelta(minutes=floor(WTIME1/60d0))
  8808:                 NT = 0; NTC = 0;
  8809:           
  8810:                 ! check if we are using grib2 or netcdf input files:
  8811:         I       CALL NWS14CHECK_FILETYPE()
  8812:           
  8813:                 ! set filenames appropriately
  8814:                 CALL NWS14SET_FILENAMES()
  8815:           
  8816:                 ! make grib2 .inv files (returns if using netcdf)
  8817:                 CALL NWS14GRB2_MAKE_INV()
  8818:           
  8819:                 ! read fort.22 to get netCDF variable info (returns if using
  8820:                 ! grib2)
  8821:                 CALL NWS14NC_READ_F22(NWS)
  8822:           
  8823:                 ! Calculate the interpolant weights
  8824:                 CALL NWS14_CALC_INTERP_WTS()
  8825:           
  8826:                 call allMessage(ECHO,'Finished init of NWS14')
  8827:           C----------------------------------------------------------------------
  8828:                 END SUBROUTINE NWS14INIT


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14INIT
INLINE LIST

  ROOT: WIND::NWS14INIT (wind.F:8795)
  -> NOINLINE: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:8807)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:8807)
     *** Source for routine not found.
  -> INLINE: WIND::NWS14CHECK_FILETYPE (wind.F:8811)
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8859)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:8862)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
  -> NOINLINE: WIND::NWS14SET_FILENAMES (wind.F:8814)
     *** Inline halted: code size exceeds limit.
  -> NOINLINE: WIND::NWS14NC_READ_F22 (wind.F:8821)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8826)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14INIT
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:8844)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8844)
  LOOP END

  LOOP BEGIN: (wind.F:8844)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8844)
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8853)
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8853)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14INIT
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 33 [s0-s12 s15-s16 s18-s19 s23-s27 s53-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1456 bytes
      Register spill area      :    0 bytes
      Parameter area           :  104 bytes
      Register save area       :  176 bytes
      User data area           : 1168 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8844)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8844)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    *** Estimated execution cycle                       : 5
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14CHECK_FILETYPE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8844: vec( 103): Unvectorized loop.
  8844: vec( 118): Unvectorizable data type.: PFILE
  8853: vec( 103): Unvectorized loop.
  8853: vec( 118): Unvectorizable data type.: PFILE
  8859: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8862: inl(1222): Inlined: WIND::WINDTERMINATE
  8773: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14CHECK_FILETYPE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8831:                 SUBROUTINE NWS14CHECK_FILETYPE()
  8832:           C----------------------------------------------------------------------
  8833:           C     CPB 10/2023: This subroutine simply checks whether we are using
  8834:           C     grib2 or netCDF winds in NWS14 and sets the grb2flag logical
  8835:           C     appropriately. It does this by:
  8836:           C        1. Checking if the pressure grib2 file (fort.221.grb2) exists
  8837:           C        2. If it does not exist or if we are compiled without grib2
  8838:           C           then it checks if the pressure netCDF file (fort.221.nc)
  8839:           C           exists.
  8840:           C        3. If neither exist we abort with an error message.
  8841:           C----------------------------------------------------------------------
  8842:                 implicit none
  8843:                 logical :: Fexists
  8844: +======>        Pfile = 'fort.221.grb2'
  8845:                 INQUIRE(file=Pfile,exist=Fexists)
  8846:           #ifdef GRIB2API
  8847:                 IF (Fexists) THEN
  8848:           
  8849:                    grb2flag = .TRUE.
  8850:                    RETURN
  8851:                 ENDIF
  8852:           #endif
  8853: +======>        Pfile = 'fort.221.nc'
  8854:                 INQUIRE(file=Pfile,exist=Fexists)
  8855:                 IF (Fexists) THEN
  8856:                    grb2flag = .FALSE.
  8857:                    RETURN
  8858:                 ELSE
  8859:                    call allMessage(ERROR,
  8860:                &       'Neither .grb2 nor .nc wind files exist. Or, if .grb2 '//
  8861:                &       'files exist, did you compile with GRIB2 compiler flags?')
  8862:         I          call windTerminate()
  8863:                 ENDIF
  8864:           
  8865:           C----------------------------------------------------------------------
  8866:                 END SUBROUTINE NWS14CHECK_FILETYPE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14CHECK_FILETYPE
INLINE LIST

  ROOT: WIND::NWS14CHECK_FILETYPE (wind.F:8831)
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8859)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8862)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14CHECK_FILETYPE
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:8844)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8844)
  LOOP END

  LOOP BEGIN: (wind.F:8844)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8844)
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8853)
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8853)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14CHECK_FILETYPE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 27 [s0-s12 s15-s16 s18 s23-s27 s58-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1376 bytes
      Register spill area      :    0 bytes
      Parameter area           :  104 bytes
      Register save area       :  176 bytes
      User data area           : 1088 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8844)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8844)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8853)
    *** Estimated execution cycle                       : 5
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14SET_FILENAMES
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  8889: vec( 103): Unvectorized loop.
  8889: vec( 118): Unvectorizable data type.: PFILE
  8890: vec( 103): Unvectorized loop.
  8890: vec( 118): Unvectorizable data type.: PINV
  8891: vec( 103): Unvectorized loop.
  8891: vec( 118): Unvectorizable data type.: WFILE
  8892: vec( 103): Unvectorized loop.
  8892: vec( 118): Unvectorizable data type.: WFILE1
  8893: vec( 103): Unvectorized loop.
  8893: vec( 118): Unvectorizable data type.: WINV
  8894: vec( 103): Unvectorized loop.
  8894: vec( 118): Unvectorizable data type.: CFILE
  8895: vec( 103): Unvectorized loop.
  8895: vec( 118): Unvectorizable data type.: CINV
  8899: vec( 103): Unvectorized loop.
  8899: vec( 118): Unvectorizable data type.: UVAR
  8900: vec( 103): Unvectorized loop.
  8900: vec( 118): Unvectorizable data type.: VVAR
  8901: vec( 103): Unvectorized loop.
  8901: vec( 118): Unvectorizable data type.: CVAR
  8911: vec( 103): Unvectorized loop.
  8911: vec( 118): Unvectorizable data type.: PFILE
  8912: vec( 103): Unvectorized loop.
  8912: vec( 118): Unvectorizable data type.: WFILE
  8913: vec( 103): Unvectorized loop.
  8913: vec( 118): Unvectorizable data type.: WFILE1
  8914: vec( 103): Unvectorized loop.
  8914: vec( 118): Unvectorizable data type.: CFILE
  8919: vec( 103): Unvectorized loop.
  8919: vec( 118): Unvectorizable data type.: WFILE
  8920: vec( 103): Unvectorized loop.
  8920: vec( 118): Unvectorizable data type.: WFILE1
  8935: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  8935: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  8944: inl(1212): Source for routine not found.: MESSENGER::MSG_BARRIER
  8953: inl(1222): Inlined: WIND::WINDTERMINATE
  8773: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8778: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14SET_FILENAMES
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8869:                 SUBROUTINE NWS14SET_FILENAMES()
  8870:           C----------------------------------------------------------------------
  8871:           C     CPB 10/2023: This subroutine sets the met forcing filenames based
  8872:           C     on grb2flag as well as the existence or lack thereof of various
  8873:           C     files. It also opens the netcdf files in read only mode to
  8874:           C     eliminate opening/closing the files repeatedly
  8875:           C----------------------------------------------------------------------
  8876:           #ifdef ADCNETCDF
  8877:                 use netcdf
  8878:                 use netcdf_error, only: check_err
  8879:           #endif
  8880:           #ifdef CMPI
  8881:                 USE MESSENGER, ONLY: MSG_BARRIER
  8882:           #endif
  8883:                 USE SIZES, ONLY : MYPROC
  8884:                 USE GLOBAL, ONLY : NCICE
  8885:                 implicit none
  8886:                 logical :: Fexists
  8887:                 ! grib2
  8888:                 IF (grb2flag) THEN
  8889: +======>           Pfile = 'fort.221.grb2'
  8890: +======>           Pinv  = 'fort.221.inv'
  8891: +======>           Wfile = 'fort.222.grb2'
  8892: +======>           Wfile1 = 'fort.222.grb2'
  8893: +======>           Winv  = 'fort.222.inv'
  8894: +======>           Cfile = 'fort.225.grb2'
  8895: +======>           Cinv  = 'fort.225.inv'
  8896:           
  8897: +======>           Pvar = 'S'  ! searching for PRMSL or MSLET or PRES:SURFACE
  8898:                                ! prev: :PRMSL:mean sea level:'
  8899: +======>           Uvar = ':UGRD:10 m above ground:'
  8900: +======>           Vvar = ':VGRD:10 m above ground:'
  8901: +======>           Cvar = ':ICEC:surface:'
  8902:                    ! Assign dummy values to ncid variables
  8903:                    PfileNCID = -9999
  8904:                    WfileNCID = -9999
  8905:                    Wfile1NCID = -9999
  8906:                    IF (NCICE.EQ.14) THEN
  8907:                       CfileNCID = -9999
  8908:                    ENDIF
  8909:                    RETURN
  8910:                 ELSEIF (.NOT.grb2flag) THEN
  8911: +======>           Pfile = 'fort.221.nc'
  8912: +======>           Wfile = 'fort.222.nc'
  8913: +======>           Wfile1 = 'fort.222.nc'
  8914: +======>           Cfile = 'fort.225.nc'
  8915:                    ! check if we are using two different wind files
  8916:                    INQUIRE(FILE=Wfile,exist=Fexists)
  8917:                    IF (.NOT.Fexists) THEN
  8918:                       ! using 2 wind files
  8919: +======>              Wfile = 'fort.222u.nc'
  8920: +======>              Wfile1 = 'fort.222v.nc'
  8921:                    ENDIF
  8922:                    ! create dummy names for the inventory files
  8923: +======>           Pinv = 'dmy'
  8924: +======>           Winv = 'dmy'
  8925: +======>           Cinv = 'dmy'
  8926:                    ! create dummy names for the grib2 variables
  8927: +======>           Pvar = 'dmy'
  8928: +======>           Uvar = 'dmy'
  8929: +======>           Vvar = 'dmy'
  8930: +======>           Cvar = 'dmy'
  8931:           
  8932:           #ifdef ADCNETCDF ! BEGIN ADCNETCDF
  8933:                    IF ( read_NWS14_NetCdf_using_core_0 ) THEN
  8934:                      IF ( MYPROC .EQ. 0 ) THEN
  8935:                        call Check_err(NF90_OPEN(Pfile,nf90_nowrite,PfileNCID))
  8936:                        call Check_err(NF90_OPEN(Wfile,nf90_nowrite,WfileNCID))
  8937:                        call Check_err(NF90_OPEN(Wfile1,nf90_nowrite,Wfile1NCID))
  8938:                        IF (NCICE.EQ.14) THEN
  8939:                           call Check_err(NF90_OPEN(Cfile,nf90_nowrite,CfileNCID))
  8940:                        ENDIF
  8941:                      END IF
  8942:           #ifdef CMPI
  8943:                    ! wait til proc 0 has opened all the files
  8944:                      CALL MSG_BARRIER()
  8945:           #endif
  8946:                    END IF
  8947:           
  8948:           #endif ! END ADCNETCDF
  8949:           
  8950:                    RETURN
  8951:                 ELSE
  8952:                    ! should be unreachable
  8953:         I          CALL windTerminate()
  8954:                 ENDIF
  8955:           C----------------------------------------------------------------------
  8956:                 END SUBROUTINE NWS14SET_FILENAMES


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14SET_FILENAMES
INLINE LIST

  ROOT: WIND::NWS14SET_FILENAMES (wind.F:8869)
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:8935)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:8935)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:8936)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:8936)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:8937)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:8937)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:8939)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:8939)
     *** Source for routine not found.
  -> NOINLINE: MESSENGER::MSG_BARRIER (wind.F:8944)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:8953)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14SET_FILENAMES
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:8911)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8911)
  LOOP END

  LOOP BEGIN: (wind.F:8911)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8911)
  LOOP END

  LOOP BEGIN: (wind.F:8912)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8912)
  LOOP END

  LOOP BEGIN: (wind.F:8912)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE (wind.F:8912)
  LOOP END

  LOOP BEGIN: (wind.F:8913)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8913)
  LOOP END

  LOOP BEGIN: (wind.F:8913)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE1 (wind.F:8913)
  LOOP END

  LOOP BEGIN: (wind.F:8914)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8914)
  LOOP END

  LOOP BEGIN: (wind.F:8914)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CFILE (wind.F:8914)
  LOOP END

  LOOP BEGIN: (wind.F:8919)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8919)
  LOOP END

  LOOP BEGIN: (wind.F:8919)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE (wind.F:8919)
  LOOP END

  LOOP BEGIN: (wind.F:8920)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8920)
  LOOP END

  LOOP BEGIN: (wind.F:8920)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE1 (wind.F:8920)
  LOOP END

  LOOP BEGIN: (wind.F:8923)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PINV (wind.F:8923)
  LOOP END

  LOOP BEGIN: (wind.F:8924)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINV (wind.F:8924)
  LOOP END

  LOOP BEGIN: (wind.F:8925)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CINV (wind.F:8925)
  LOOP END

  LOOP BEGIN: (wind.F:8927)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PVAR (wind.F:8927)
  LOOP END

  LOOP BEGIN: (wind.F:8928)
    <Unvectorized loop.>
    *** Unvectorizable data type. : UVAR (wind.F:8928)
  LOOP END

  LOOP BEGIN: (wind.F:8929)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VVAR (wind.F:8929)
  LOOP END

  LOOP BEGIN: (wind.F:8930)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CVAR (wind.F:8930)
  LOOP END

  LOOP BEGIN: (wind.F:8889)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8889)
  LOOP END

  LOOP BEGIN: (wind.F:8889)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PFILE (wind.F:8889)
  LOOP END

  LOOP BEGIN: (wind.F:8890)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8890)
  LOOP END

  LOOP BEGIN: (wind.F:8890)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PINV (wind.F:8890)
  LOOP END

  LOOP BEGIN: (wind.F:8891)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8891)
  LOOP END

  LOOP BEGIN: (wind.F:8891)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE (wind.F:8891)
  LOOP END

  LOOP BEGIN: (wind.F:8892)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8892)
  LOOP END

  LOOP BEGIN: (wind.F:8892)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WFILE1 (wind.F:8892)
  LOOP END

  LOOP BEGIN: (wind.F:8893)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8893)
  LOOP END

  LOOP BEGIN: (wind.F:8893)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINV (wind.F:8893)
  LOOP END

  LOOP BEGIN: (wind.F:8894)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8894)
  LOOP END

  LOOP BEGIN: (wind.F:8894)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CFILE (wind.F:8894)
  LOOP END

  LOOP BEGIN: (wind.F:8895)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8895)
  LOOP END

  LOOP BEGIN: (wind.F:8895)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CINV (wind.F:8895)
  LOOP END

  LOOP BEGIN: (wind.F:8897)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PVAR (wind.F:8897)
  LOOP END

  LOOP BEGIN: (wind.F:8899)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8899)
  LOOP END

  LOOP BEGIN: (wind.F:8899)
    <Unvectorized loop.>
    *** Unvectorizable data type. : UVAR (wind.F:8899)
  LOOP END

  LOOP BEGIN: (wind.F:8900)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8900)
  LOOP END

  LOOP BEGIN: (wind.F:8900)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VVAR (wind.F:8900)
  LOOP END

  LOOP BEGIN: (wind.F:8901)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:8901)
  LOOP END

  LOOP BEGIN: (wind.F:8901)
    <Unvectorized loop.>
    *** Unvectorizable data type. : CVAR (wind.F:8901)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14SET_FILENAMES
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 30 [s0-s12 s15-s16 s23-s28 s55-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1408 bytes
      Register spill area      :    0 bytes
      Parameter area           :  104 bytes
      Register save area       :  176 bytes
      User data area           : 1120 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:8911)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8911)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8912)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8912)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8913)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8913)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8914)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8914)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8919)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8919)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8920)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8920)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8923)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8924)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8925)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8927)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8928)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8929)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8930)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8889)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8889)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8890)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8890)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8891)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8891)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8892)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8892)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8893)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8893)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8894)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8894)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8895)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8895)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8897)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8899)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8899)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8900)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8900)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:8901)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:8901)
    *** Estimated execution cycle                       : 5
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GRB2_MAKE_INV
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  No diagnostic message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GRB2_MAKE_INV
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  8959:                 SUBROUTINE NWS14GRB2_MAKE_INV()
  8960:           C----------------------------------------------------------------------
  8961:           C     CPB 10/2023: This subroutine makes the .inv files for grib2
  8962:           C     meteorological forcing files. If we are not using grib2 then it
  8963:           C     just returns
  8964:           C----------------------------------------------------------------------
  8965:                 USE SIZES, ONLY : MYPROC
  8966:           #ifdef GRIB2API
  8967:                 USE wgrib2api
  8968:           #endif
  8969:                 USE GLOBAL, ONLY : NCICE
  8970:           #ifdef CMPI
  8971:                 USE MESSENGER, ONLY: MSG_BARRIER
  8972:           #endif
  8973:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_Int
  8974:                 implicit none
  8975:                 logical :: Fexists
  8976:                 integer :: iret
  8977:                 ! return if we are using netcdf
  8978:                 IF (.NOT.grb2flag) THEN
  8979:                    RETURN
  8980:                 ENDIF
  8981:           #ifdef GRIB2API
  8982:           #ifdef CMPI
  8983:                 ! only do this on proc 0
  8984:                 IF (MYPROC.EQ.0) THEN
  8985:           #endif
  8986:                    ! pressure file (fort.221.grb2)
  8987:                    inquire(file=Pinv,exist=Fexists)
  8988:                    if (.not.Fexists) then
  8989:                       iret = grb2_mk_inv(Pfile, Pinv)
  8990:                       if (iret.ne.0) then
  8991:                          call allMessage(ERROR,
  8992:                &                        'Fatal error in reading fort.221.grb2.')
  8993:                       else
  8994:                          call allMessage(ECHO,'successfully read fort.221.grb2 '
  8995:                &                            //'and wrote out fort.221.inv file')
  8996:                       endif
  8997:                    endif
  8998:                    ! wind file (fort.222.grb2)
  8999:                    inquire(file=Winv,exist=Fexists)
  9000:                    if (.not.Fexists.and.iret.eq.0) then
  9001:                       iret = grb2_mk_inv(Wfile, Winv)
  9002:                       if (iret.ne.0) then
  9003:                          call allMessage(ERROR,
  9004:                &                         'Fatal error in reading fort.222.grb2.')
  9005:                       endif
  9006:                       call allMessage(ECHO,'successfully read fort.222.grb2 '
  9007:                &                         //'and wrote out fort.222.inv file')
  9008:                    endif
  9009:                    ! ice file (if we are using it) (fort.225.grb2)
  9010:                    if (NCICE.eq.14) then
  9011:                       inquire(file=Cinv,exist=Fexists)
  9012:                       if (.not.Fexists.and.iret.eq.0) then
  9013:                          iret = grb2_mk_inv(Cfile, Cinv)
  9014:                          if (iret.ne.0) then
  9015:                             call allMessage(ERROR,
  9016:                &                         'Fatal error in reading fort.225.grb2.')
  9017:                          endif
  9018:                          call allMessage(ECHO,'successfully read fort.225.grb2 '
  9019:                &                         //'and wrote out fort.225.inv file')
  9020:                       endif
  9021:                    endif
  9022:           #ifdef CMPI
  9023:                 ENDIF
  9024:           #endif
  9025:                 CALL BcastToLocal_Int(iret)
  9026:                 if (iret.ne.0) then
  9027:                    call windTerminate()
  9028:                 endif
  9029:                 RETURN
  9030:           #endif
  9031:           C----------------------------------------------------------------------
  9032:                 END SUBROUTINE NWS14GRB2_MAKE_INV


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GRB2_MAKE_INV
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GRB2_MAKE_INV
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GRB2_MAKE_INV
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         :  5 [s8-s11 s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 0 bytes
      Register spill area      : 0 bytes
      Parameter area           : 0 bytes
      Register save area       : 0 bytes
      User data area           : 0 bytes
      Others                   : 0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14NC_READ_F22
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9051: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9055: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  9058: inl(1222): Inlined: WIND::WINDTERMINATE
  9065: inl(1222): Inlined: WIND::WINDTERMINATE
  9084: vec( 103): Unvectorized loop.
  9084: vec( 118): Unvectorizable data type.: PVAR
  9085: vec( 103): Unvectorized loop.
  9085: vec( 108): Unvectorizable loop structure.
  9088: inl(1222): Inlined: WIND::READNWS14_NC_STATIME
  9638: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  9638: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  9641: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_DIMID
  9642: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_DIMENSION
  9647: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  9651: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_VARID
  9652: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_1D_TEXT
  9654: inl(1212): Source for routine not found.: DATETIME_MODULE::STRFTIME
  9668: inl(1212): Source for routine not found.: DATETIME_MODULE::STRPTIME
  9671: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_1D_EIGHTBYTEREAL
  9673: inl(1212): Source for routine not found.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  9673: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA
  9675: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_EQ
  9692: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9697: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14NC_READ_F22
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9035:                 SUBROUTINE NWS14NC_READ_F22(NWS)
  9036:           C----------------------------------------------------------------------
  9037:           C     CPB 10/2023: This subroutine reads the fort.22 file for NWS14 to
  9038:           C     get netcdf variable names as well as starting indices for reading
  9039:           C     in the met data. If we are using grib2 it just returns
  9040:           C----------------------------------------------------------------------
  9041:                 USE SIZES, ONLY : MYPROC
  9042:                 USE GLOBAL, ONLY : NCICE
  9043:                 implicit none
  9044:                 INTEGER,INTENT(IN) :: NWS
  9045:                 logical :: Fexists
  9046:                 integer :: ierr, PvarInd
  9047:                 ! return if we are using grib2
  9048:                 IF (grb2flag) THEN
  9049:                    RETURN
  9050:                 ENDIF
  9051:                 CALL setMessageSource("NWS14NC_READ_F22")
  9052:                 IF (NWS.EQ.-14) THEN
  9053:                    ! For inset OWI winds with netcdf files something needs to be
  9054:                    ! done but I haven't programmed it yet.
  9055:                    CALL allMessage(ERROR,"NWS = -14 has not yet been set up to "
  9056:                &                   //"use netcdf files. Try again with grib2 "
  9057:                &                   //"background wind files.")
  9058:         I          CALL windTerminate()
  9059:                 ENDIF
  9060:                 ! open the fort.22
  9061:                 OPEN(22,file='fort.22',ACTION='READ',IOSTAT=ierr)
  9062:                 ! if we had trouble opening then abort
  9063:                 IF (ierr.NE.0) THEN
  9064:                    call allMessage(ERROR,'Unable to open fort.22.')
  9065:         I          call windTerminate()
  9066:                 ENDIF
  9067:                 read(22,*) Tdim    ! Time dimension name
  9068:                 read(22,*) Tvar    ! Time variable name
  9069:                 read(22,*) Tformat ! Format of time datestr
  9070:                 read(22,*) Londim  ! Lon dimension name
  9071:                 read(22,*) Lonvar  ! Lon var name
  9072:                 read(22,*) Latdim  ! Lat dimension name
  9073:                 read(22,*) Latvar  ! Lat var name
  9074:                 read(22,*) Pvar    ! Pressure var name
  9075:                 read(22,*) Uvar    ! U10 var name
  9076:                 read(22,*) Vvar    ! V10 Var name
  9077:                 if (NCICE.eq.14) then
  9078:                    read(22,*) Cvar ! Ice var name
  9079:                 endif
  9080:                 close(22)
  9081:                 PvarInd = index(Pvar,'HPa')
  9082:                 if (PvarInd > 0) then
  9083:                    rhoWat0g = rhoWat0g/100d0
  9084: +======>           Pvar = Pvar(1:PvarInd-1)
  9085:                    write(16,*) 'Pressure is in Hpa, New Pvar = ',trim(Pvar)
  9086:                 endif
  9087:                 ! get starting time index for netcdf file
  9088:         I       CALL READNWS14_NC_StaTime(Pfile, PfileNCID)
  9089:                 CALL unsetMessageSource()
  9090:                 RETURN
  9091:           C----------------------------------------------------------------------
  9092:                 END SUBROUTINE NWS14NC_READ_F22


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14NC_READ_F22
INLINE LIST

  ROOT: WIND::NWS14NC_READ_F22 (wind.F:9035)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9051)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9055)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:9058)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9064)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:9065)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.
  -> INLINE: WIND::READNWS14_NC_STATIME (wind.F:9088)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9631)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_OPEN (wind.F:9638)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9638)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9641)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9641)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9642)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9642)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9647)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9651)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9651)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_GET_VAR_1D_TEXT (wind.F:9652)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9652)
      *** Source for routine not found.
   -> NOINLINE: DATETIME_MODULE::STRFTIME (wind.F:9654)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9658)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9665)
      *** Source for routine not found.
   -> NOINLINE: DATETIME_MODULE::STRPTIME (wind.F:9668)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9670)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9670)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_GET_VAR_1D_EIGHTBYTEREAL (wind.F:9671)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9671)
      *** Source for routine not found.
   -> NOINLINE: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:9673)
      *** Source for routine not found.
   -> NOINLINE: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:9673)
      *** Source for routine not found.
   -> NOINLINE: DATETIME_MODULE::DATETIME_EQ (wind.F:9675)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9683)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9692)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9692)
      *** Source for routine not found.
   -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9697)
      *** Source for routine not found.
   -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9698)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9701)
      *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9089)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14NC_READ_F22
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:9084)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9084)
  LOOP END

  LOOP BEGIN: (wind.F:9084)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9084)
  LOOP END

  LOOP BEGIN: (wind.F:9084)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PVAR (wind.F:9084)
  LOOP END

  LOOP BEGIN: (wind.F:9085)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9085)
  LOOP END

  LOOP BEGIN: (wind.F:9668)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9668)
  LOOP END

  LOOP BEGIN: (wind.F:9672)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:9672)
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::DATETIME_EQ (wind.F:9672)
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:9672)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable data type. : STR_DATE (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9655)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (wind.F:9655)
    *** Deallocation obstructs vectorization. (wind.F:9655)
    *** Unvectorizable data type. (wind.F:9655)
    *** Unvectorizable loop structure. (wind.F:9655)

    LOOP BEGIN: (wind.F:9656)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:9656)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14NC_READ_F22
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 41 [s0-s12 s15-s16 s18-s38 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2096 bytes
      Register spill area      :   64 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 1696 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9084)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9084)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9084)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:9085)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9668)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9672)
    *** Estimated execution cycle                       : 110
    *** The number of SCALAR REGISTER TRANSFER          : 13
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:9655)
    *** Estimated execution cycle                       : 43
    *** The number of SCALAR REGISTER TRANSFER          : 8

    LOOP BEGIN: (wind.F:9656)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14_CALC_INTERP_WTS
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9127: inl(1219): Nesting level too deep for automatic expansion.: WIND::READNWS14LATLON
  9162: vec( 101): Vectorized loop.
  9163: vec( 101): Vectorized loop.
  9169: opt(1408): Loop interchanged.
  9169: vec( 101): Vectorized loop.
  9177: inl(1212): Source for routine not found.: KDTREE2_MODULE::KDTREE2_CREATE
  9180: vec( 110): Vectorization obstructive procedure reference.: MESH::BL_INTERP
  9180: vec( 110): Vectorization obstructive procedure reference.: MESH::BL_INTERP2
  9183: opt(1592): Outer loop unrolled inside inner loop.
  9183: vec( 101): Vectorized loop.
  9183: vec( 126): Idiom detected.: MAX/MIN
  9186: inl(1212): Source for routine not found.: MESH::BL_INTERP
  9186: opt(1025): Reference to this procedure inhibits optimization.: MESH::BL_INTERP
  9188: inl(1212): Source for routine not found.: MESH::BL_INTERP2
  9190: vec( 101): Vectorized loop.
  9191: vec( 101): Vectorized loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14_CALC_INTERP_WTS
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9095:                 SUBROUTINE NWS14_CALC_INTERP_WTS()
  9096:           C----------------------------------------------------------------------
  9097:           C     CPB 10/2023: This subroutine calculates the interpolation indices
  9098:           C     (indp) and weights (weightsp) to interpolate from the grib2 or
  9099:           C     netcdf input meterological forcing to the ADCIRC grid. NWS = 14
  9100:           C     was originally set up to use NOAA CFSv2/GFS met forcing products.
  9101:           C     These meteorological products provide two different resolutions
  9102:           C     for wind forcing but not for pressure (or ice). To limit
  9103:           C     pre-processing necessary to use these products, this subroutine
  9104:           C     checks to see if the wind and pressure have the same dimensions.
  9105:           C     If so, it only allocates one set of interpolant indices (indp) and
  9106:           C     weights (weightsp). If they are different then it stores two
  9107:           C     different sets. If necessary, it also checks the dimensions of the
  9108:           C     ice forcing and sets the interpolants for ice to be equal to
  9109:           C     either the wind or pressure forcing depending on the grid.
  9110:           C----------------------------------------------------------------------
  9111:                 use mesh, only: NP, SLAM, SFEA, bl_interp, bl_interp2
  9112:                 use kdtree2_module, only: kdtree2, kdtree2_create
  9113:                 USE GLOBAL, ONLY : NCICE
  9114:                 implicit none
  9115:                 integer :: i, ii, nxp, nyp, indt(4), NTkeep, xi, yi, cc
  9116:                 real,allocatable,dimension(:,:) :: Pmsl, U10, V10, Cice, lat, lon
  9117:                 real(8), allocatable ::  lonv(:), latv(:), XY(:,:)
  9118:                 real(8) :: xx, yy, wt(4)
  9119:                 logical :: regular_grid
  9120:                 type(kdtree2), pointer :: tree
  9121:                 ! determine if wind/pressure/ice grids match or not.
  9122:                 ! assume grids are the same to start
  9123:                 ub = 1
  9124:                 ubc = 1 ! index where we store the ice data (will match either
  9125:                         ! wind or pressure). Assume match pressure first.
  9126:                 ! get pressure dimensions
  9127:                 CALL READNWS14LatLon(Pfile,lat,lon,Pinv,Pvar,PfileNCID)
  9128:                 nxp = ubound(lon,1); nyp = ubound(lat,2)
  9129:                 ! get wind dimensions and see if they match pressure
  9130:                 CALL READNWS14LatLon(Wfile,lat,lon,Winv,Uvar,WfileNCID)
  9131:                 if (nxp.NE.ubound(lon,1).OR.nyp.NE.ubound(lat,2)) then
  9132:                    ! if we don't match both lat and lon then we need to store two
  9133:                    ! sets of interpolation indices/weights
  9134:                    ub = 2
  9135:                    nxp = ubound(lon,1)
  9136:                    nyp = ubound(lat,2)
  9137:                 endif
  9138:                 ! If winds and pressure do not match, then check ice file to see
  9139:                 ! whether we should use wind or pressure interpolants. If wind and
  9140:                 ! pressure DO match then we assume ice also matches.
  9141:                 IF (NCICE.EQ.14.AND.ub.EQ.2) THEN
  9142:                    CALL READNWS14LatLon(Cfile,lat,lon,Cinv,Cvar,CfileNCID)
  9143:                    IF (nxp.EQ.ubound(lon,1).AND.nyp.EQ.ubound(lat,2)) THEN
  9144:                       ! match winds
  9145:                       ubc = 2
  9146:                    ENDIF
  9147:                 ENDIF
  9148:                 ! Allocate the indices and weights
  9149:                 allocate(indp(ub,4,np),weightsp(ub,4,np))
  9150:                 ! Make the interpolant weights. If w
  9151: +------>        do ii = 1,ub
  9152: |                  if (ii.eq.1) then
  9153: |                     CALL READNWS14LatLon(Pfile,lat,lon,Pinv,Pvar,PfileNCID)
  9154: |                  else
  9155: |                     CALL READNWS14LatLon(Wfile,lat,lon,Winv,Uvar,WfileNCID)
  9156: |                  endif
  9157: |                  nxp = ubound(lon,1); nyp = ubound(lat,2)
  9158: |                  ! Check if structured regular..
  9159: |                  if (abs(lon(1,1) - lon(1,nyp)) < 1d-6) then
  9160: |                     regular_grid = .true.
  9161: |                     allocate(lonv(nxp),latv(nyp))
  9162: |V=====>              lonv = lon(:,1)
  9163: |V=====>              latv = lat(1,:)
  9164: |                  else
  9165: |                     regular_grid = .false.
  9166: |                     ! Convert point matrices to 2 X (NXP*NYP) point vector
  9167: |                     allocate(XY(2,nxp*nyp))
  9168: |                     cc = 0
  9169: |X----->              do xi = 1,nxp
  9170: ||+---->                 do yi = 1,nyp
  9171: |||                         cc = cc + 1
  9172: |||                         XY(1,cc) = lon(xi,yi)
  9173: |||                         XY(2,cc) = lat(xi,yi)
  9174: ||+----                  enddo
  9175: |X-----               enddo
  9176: |                     ! Create the search tree
  9177: |                     tree => kdtree2_create(XY)
  9178: |                  endif
  9179: |                  ! Loop over each node and interpolate
  9180: |+----->           do i = 1,np
  9181: ||                    xx = rad2deg*slam(i)
  9182: ||                    ! Convert our numbers if grids are 0 to 360
  9183: ||U====>              if (maxval(lon).gt.180d0.and.xx < 0d0) xx = xx + 360d0
  9184: ||                    yy = rad2deg*sfea(i)
  9185: ||                    if (regular_grid) then
  9186: ||                       call bl_interp(nxp,lonv,nyp,latv,xx,yy,indt,wt)
  9187: ||                    else
  9188: ||                       call bl_interp2(nxp,nyp,lon,lat,xx,yy,indt,wt,tree)
  9189: ||                    endif
  9190: ||V====>              indp(ii,:,i) = indt
  9191: ||V====>              weightsp(ii,:,i) = wt
  9192: |+-----            enddo
  9193: |                  if (regular_grid) then
  9194: |                     deallocate(lon,lat,latv,lonv)
  9195: |                  else
  9196: |                     deallocate(lon,lat,XY)
  9197: |                  endif
  9198: +------         enddo
  9199:           C----------------------------------------------------------------------
  9200:                 END SUBROUTINE NWS14_CALC_INTERP_WTS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14_CALC_INTERP_WTS
INLINE LIST

  ROOT: WIND::NWS14_CALC_INTERP_WTS (wind.F:9095)
  -> NOINLINE: WIND::READNWS14LATLON (wind.F:9127)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: KDTREE2_MODULE::KDTREE2_CREATE (wind.F:9177)
     *** Source for routine not found.
  -> NOINLINE: MESH::BL_INTERP (wind.F:9186)
     *** Source for routine not found.
  -> NOINLINE: MESH::BL_INTERP2 (wind.F:9188)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14_CALC_INTERP_WTS
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:9151)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:9170)
      <Unvectorized loop.>

      LOOP BEGIN: (wind.F:9169)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (wind.F:9169)
        *** The number of VLOAD, VSTORE. :  2,  2. (wind.F:9169)
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:9162)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:9162)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:9162)
    LOOP END

    LOOP BEGIN: (wind.F:9163)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:9163)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:9163)
    LOOP END

    LOOP BEGIN: (wind.F:9180)
      <Unvectorized loop.>
      *** Vectorization obstructive procedure reference. : MESH::BL_INTERP (wind.F:9180)
      *** Vectorization obstructive procedure reference. : MESH::BL_INTERP2 (wind.F:9180)

      LOOP BEGIN: (wind.F:9183)
        <Unvectorized loop.>
        **  Copied loop. : FOR UNROLLING (wind.F:9183)

        LOOP BEGIN: (wind.F:9183)
          <Vectorized loop.>
          **  Copied loop. : FOR UNROLLING (wind.F:9183)
          *** The number of VGT,   VSC.    :  0,  0. (wind.F:9183)
          *** The number of VLOAD, VSTORE. :  1,  0. (wind.F:9183)
          *** Idiom detected. : MAX/MIN (wind.F:9183)
        LOOP END
      LOOP END

      LOOP BEGIN: (wind.F:9183)
        <Unvectorized loop.>
        **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (wind.F:9183)

        LOOP BEGIN: (wind.F:9183)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (wind.F:9183)
          *** The number of VLOAD, VSTORE. :  4,  0. (wind.F:9183)
          *** Idiom detected. : MAX/MIN (wind.F:9183)
        LOOP END
      LOOP END

      LOOP BEGIN: (wind.F:9190)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (wind.F:9190)
        *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:9190)
      LOOP END

      LOOP BEGIN: (wind.F:9191)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (wind.F:9191)
        *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:9191)
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14_CALC_INTERP_WTS
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 57 [s0-s12 s15-s16 s18-s35 s40-s63]
      Vector registers         : 19 [v45-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1760 bytes
      Register spill area      :  368 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1136 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9151)
    *** Estimated execution cycle                       : 968
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 49
            Across calls                                :  1
            Over basic blocks                           : 48
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 67
            Across calls                                :  1
            Over basic blocks                           : 66
    *** The number of SCALAR REGISTER TRANSFER          : 173

    LOOP BEGIN: (wind.F:9169)
      *** Estimated execution cycle                     : 52
      *** The number of SCALAR REGISTER TRANSFER        : 16

      LOOP BEGIN: (wind.F:9169)
        *** Estimated execution cycle                   : 162
      LOOP END
    LOOP END

    LOOP BEGIN: (wind.F:9162)
      *** Estimated execution cycle                     : 95
    LOOP END

    LOOP BEGIN: (wind.F:9163)
      *** Estimated execution cycle                     : 95
    LOOP END

    LOOP BEGIN: (wind.F:9180)
      *** Estimated execution cycle                     : 325
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 6
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 88

      LOOP BEGIN: (wind.F:9183)
        *** Estimated execution cycle                   : 100
        *** The number of SCALAR REGISTER TRANSFER      : 8

        LOOP BEGIN: (wind.F:9183)
          *** Estimated execution cycle                 : 96
        LOOP END
      LOOP END

      LOOP BEGIN: (wind.F:9183)
        *** Estimated execution cycle                   : 101
        *** The number of SCALAR REGISTER TRANSFER      : 5

        LOOP BEGIN: (wind.F:9183)
          *** Estimated execution cycle                 : 290
        LOOP END
      LOOP END

      LOOP BEGIN: (wind.F:9190)
        *** Estimated execution cycle                   : 63
      LOOP END

      LOOP BEGIN: (wind.F:9191)
        *** Estimated execution cycle                   : 63
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GET
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9213: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9215: inl(1212): Source for routine not found.: DATETIME_MODULE::STRFTIME
  9215: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  9220: inl(1219): Nesting level too deep for automatic expansion.: WIND::READNWS14
  9253: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  9253: vec( 101): Vectorized loop.
  9257: opt(3014): Moved reference within a conditional branch.
  9257: vec( 128): Fused multiply-add operation applied.
  9266: opt(3014): Moved reference within a conditional branch.
  9266: vec( 128): Fused multiply-add operation applied.
  9270: opt(3014): Moved reference within a conditional branch.
  9270: vec( 128): Fused multiply-add operation applied.
  9279: inl(1212): Source for routine not found.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  9279: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA
  9285: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  9285: vec( 101): Vectorized loop.
  9289: opt(3014): Moved reference within a conditional branch.
  9289: vec( 128): Fused multiply-add operation applied.
  9300: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GET
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9203:                 SUBROUTINE NWS14GET(WVNX2,WVNY2,PRN2,CICE2)
  9204:           C----------------------------------------------------------------------
  9205:           C----------------------------------------------------------------------
  9206:                 use mesh, only: NP
  9207:                 implicit none
  9208:           
  9209:                 real(8),intent(out) :: PRN2(NP), WVNX2(NP), WVNY2(NP)
  9210:                 real(8),intent(out),optional :: CICE2(NP)
  9211:                 integer :: i, NTkeep
  9212:                 real,allocatable,dimension(:,:) :: Pmsl, U10, V10, Cice
  9213:                 CALL setMessageSource('NWS14GET')
  9214:                 ! Show the date in str_date format
  9215:                 call logMessage(ECHO,'CurDT strng: '//
  9216:                &                CurDT%strftime("%Y-%m-%d %H:%M"))
  9217:            
  9218:                 ! Get the Pressure
  9219:                 !':PRMSL:mean sea level:'
  9220:                 call READNWS14(Pfile,Pmsl,Pinv,Pvar,PfileNCID)
  9221:           
  9222:                 ! Get the U-winds
  9223:                 call READNWS14(Wfile,U10,Winv,Uvar,WfileNCID)
  9224:            
  9225:                 ! Get the V-winds
  9226:                 call READNWS14(Wfile1,V10,Winv,Vvar,Wfile1NCID)
  9227:           
  9228:                 ! Get the ice concentration if required
  9229:                 if (present(CICE2)) then
  9230:                    NTkeep = NT; NT = NTC
  9231:                    call READNWS14(Cfile,Cice,Cinv,Cvar,CfileNCID)
  9232:                    NT = NTkeep
  9233:                 endif
  9234:           
  9235:           !      ! Get the Pressure
  9236:           !      !':PRMSL:mean sea level:'
  9237:           !      call READNWS14(Pfile,Pinv,Pvar,Pmsl)
  9238:           !
  9239:           !      ! Get the U-winds
  9240:           !      call READNWS14(Wfile,Winv,Uvar,U10)
  9241:           !
  9242:           !      ! Get the V-winds
  9243:           !      call READNWS14(Wfile1,Winv,Vvar,V10)
  9244:           !
  9245:           !      ! Get the ice concentration if required
  9246:           !      if (present(CICE2)) then
  9247:           !         NTkeep = NT; NT = NTC
  9248:           !         call READNWS14(Cfile,Cinv,Cvar,Cice)
  9249:           !         NT = NTkeep
  9250:           !      endif
  9251:           
  9252:                 ! Doing the interpolation from their grid to ours
  9253: V------>        do i = 1,np
  9254: |                  if (indp(1,1,i) < 0) then
  9255: |                     PRN2(i) = PRBCKGRND_MH2O
  9256: |                  else
  9257: |       G             PRN2(i) = ( Pmsl(indp(1,1,i),indp(1,2,i))*weightsp(1,1,i) +
  9258: |              &             Pmsl(indp(1,3,i),indp(1,2,i))*weightsp(1,2,i)      +
  9259: |              &             Pmsl(indp(1,1,i),indp(1,4,i))*weightsp(1,3,i)      +
  9260: |              &             Pmsl(indp(1,3,i),indp(1,4,i))*weightsp(1,4,i) )
  9261: |              &              / rhoWat0g
  9262: |                  endif
  9263: |                  if (indp(ub,1,i) < 0) then
  9264: |                     WVNX2(i) = 0d0; WVNY2(i) = 0d0
  9265: |                  else
  9266: |       G             WVNX2(i) = U10(indp(ub,1,i),indp(ub,2,i))*weightsp(ub,1,i) +
  9267: |              &              U10(indp(ub,3,i),indp(ub,2,i))*weightsp(ub,2,i)    +
  9268: |              &              U10(indp(ub,1,i),indp(ub,4,i))*weightsp(ub,3,i)    +
  9269: |              &              U10(indp(ub,3,i),indp(ub,4,i))*weightsp(ub,4,i)
  9270: |       G             WVNY2(i) = V10(indp(ub,1,i),indp(ub,2,i))*weightsp(ub,1,i) +
  9271: |              &              V10(indp(ub,3,i),indp(ub,2,i))*weightsp(ub,2,i)    +
  9272: |              &              V10(indp(ub,1,i),indp(ub,4,i))*weightsp(ub,3,i)    +
  9273: |              &              V10(indp(ub,3,i),indp(ub,4,i))*weightsp(ub,4,i)
  9274: |                  endif
  9275: V------         enddo
  9276:                 deallocate(Pmsl,U10,V10)
  9277:            
  9278:                 ! Add WTIMINC on CurDT for next WTIME
  9279:                 CurDT = CurDT + timedelta(minutes=nint(WTIMINC/60d0))
  9280:                 ! Next time index for the netcdf reading
  9281:                 NT = NT + 1
  9282:            
  9283:                 ! If ice concentration is present
  9284:                 if (present(CICE2)) then
  9285: V------>           do i = 1,np
  9286: |                     if (indp(ubc,1,i) < 0) then
  9287: |                        CICE2(i) = 0d0;
  9288: |                     else
  9289: |       G                CICE2(i) =
  9290: |              &             Cice(indp(ubc,1,i),indp(ubc,2,i))*weightsp(ubc,1,i) +
  9291: |              &             Cice(indp(ubc,3,i),indp(ubc,2,i))*weightsp(ubc,2,i) +
  9292: |              &             Cice(indp(ubc,1,i),indp(ubc,4,i))*weightsp(ubc,3,i) +
  9293: |              &             Cice(indp(ubc,3,i),indp(ubc,4,i))*weightsp(ubc,4,i)
  9294: |                     endif
  9295: V------            enddo
  9296:                    deallocate(Cice)
  9297:                    ! Next ice time index for the netcdf reading
  9298:                    NTC = NTC + 1
  9299:                 endif
  9300:                 CALL unsetMessageSource()
  9301:                 RETURN
  9302:           C----------------------------------------------------------------------
  9303:                 END SUBROUTINE NWS14GET


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GET
INLINE LIST

  ROOT: WIND::NWS14GET (wind.F:9203)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9213)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::STRFTIME (wind.F:9215)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9215)
     *** Source for routine not found.
  -> NOINLINE: WIND::READNWS14 (wind.F:9220)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:9279)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:9279)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9300)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GET
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:9253)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    : 12,  0. (wind.F:9253)
    *** The number of VLOAD, VSTORE. : 16,  3. (wind.F:9253)
    *** VGT generated (wind.F:9257)
    *** VGT generated (wind.F:9266)
    *** VGT generated (wind.F:9270)
  LOOP END

  LOOP BEGIN: (wind.F:9285)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  4,  0. (wind.F:9285)
    *** The number of VLOAD, VSTORE. :  8,  1. (wind.F:9285)
    *** VGT generated (wind.F:9289)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::NWS14GET
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  2 [vm14-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 41632 bytes
      Register spill area      : 20512 bytes
      Parameter area           :    64 bytes
      Register save area       :   176 bytes
      User data area           : 20880 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9253)
    *** Estimated execution cycle                       : 3901
    *** The number of VECTOR REGISTER SPILL
          Total                                         : 1
            Not enough registers                        : 1
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 9
            Not enough registers                        : 1
            Over basic blocks                           : 8
  LOOP END

  LOOP BEGIN: (wind.F:9285)
    *** Estimated execution cycle                       : 1356
    *** The number of VECTOR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9318: inl(1222): Inlined: WIND::READNWS14_NETCDF
  9407: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9414: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_DIMID
  9414: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  9415: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_DIMENSION
  9419: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9423: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_VARID
  9424: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL
  9427: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY
  9430: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  9441: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9445: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  9320: inl(1235): Inline halted: code size exceeds limit.: WIND::READNWS14


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9306:                 SUBROUTINE READNWS14(fileN,data2,invN,var,ncid)
  9307:           C----------------------------------------------------------------------
  9308:           C     CPB 10/2023: Added to make NWS = 14 more more readable. Simply
  9309:           C     calls the appropriate subroutine based on the filetype we are
  9310:           C     using.
  9311:           C----------------------------------------------------------------------
  9312:                 implicit none
  9313:                 CHARACTER(LEN=200),INTENT(IN) :: fileN
  9314:                 REAL,ALLOCATABLE,INTENT(OUT) :: data2(:,:)
  9315:                 CHARACTER(LEN=200),INTENT(IN) :: invN, var
  9316:                 INTEGER,INTENT(INOUT) :: ncid
  9317:                 IF (.NOT.grb2flag) THEN
  9318:         I          CALL READNWS14_netCDF(fileN, ncid, var, data2)
  9319:                 ELSEIF (grb2flag) THEN
  9320:                    CALL READNWS14_grib2(fileN, invN, var, data2)
  9321:                 ELSE
  9322:                    ! should be unreachable
  9323:                    CALL windterminate()
  9324:                 ENDIF
  9325:           C----------------------------------------------------------------------
  9326:                 END SUBROUTINE READNWS14


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14
INLINE LIST

  ROOT: WIND::READNWS14 (wind.F:9306)
  -> INLINE: WIND::READNWS14_NETCDF (wind.F:9318)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9407)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9414)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9414)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9415)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9415)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9416)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9416)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9417)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9417)
      *** Source for routine not found.
   -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9419)
      *** Source for routine not found.
   -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9420)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9423)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9423)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9424)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9424)
      *** Source for routine not found.
   -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9427)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_OPEN (wind.F:9430)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9430)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9431)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9431)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9432)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9432)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9433)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9433)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9434)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9434)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9437)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9437)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9438)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9438)
      *** Source for routine not found.
   -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9441)
      *** Source for routine not found.
   -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9441)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9445)
      *** Source for routine not found.
  -> NOINLINE: WIND::READNWS14_GRIB2 (wind.F:9320)
     *** Inline halted: code size exceeds limit.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 30 [s0-s12 s15-s16 s18 s23-s32 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 688 bytes
      Register spill area      :   0 bytes
      Parameter area           :  80 bytes
      Register save area       : 176 bytes
      User data area           : 432 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_GRIB2
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9346: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9349: inl(1212): Source for routine not found.: DATETIME_MODULE::STRFTIME
  9349: vec( 103): Unvectorized loop.
  9349: vec( 118): Unvectorizable data type.: STR_DATE
  9351: vec( 103): Unvectorized loop.
  9351: vec( 181): Allocation obstructs vectorization.
  9351: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::LOGMESSAGE
  9351: vec( 182): Deallocation obstructs vectorization.
  9351: vec( 110): Vectorization obstructive procedure reference.: SLEEP
  9353: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  9354: inl(1212): Source for routine not found.: SLEEP
  9367: opt(1317): Logical clause simplified.
  9370: inl(1222): Inlined: WIND::ARNOLDSCHWARZENEGGER
  9729: inl(1222): Inlined: WIND::WINDTERMINATE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  9375: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9380: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_GRIB2
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9329:                 SUBROUTINE READNWS14_grib2(fileN,invN,var,data2)
  9330:           C----------------------------------------------------------------------
  9331:           C       CPB 10/2023: Reads in grib2 format met forcing for NWS = 14.
  9332:           C       NOTE: reads in on Proc 0 and broadcasts.
  9333:           C----------------------------------------------------------------------
  9334:           #ifdef GRIB2API
  9335:                 use wgrib2api
  9336:           #endif
  9337:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_2DRealArray,
  9338:                &                           BcastToLocal_Int
  9339:                 USE SIZES, ONLY : MYPROC
  9340:                 implicit none
  9341:                 integer :: iret, iter
  9342:                 character(len=200),intent(in) :: var, fileN, invN
  9343:                 real,allocatable,intent(out) :: data2(:,:)
  9344:                 character(len=200) :: str_date
  9345:                 integer :: NX, NY
  9346:                 CALL setMessageSource("READNWS14_grib2")
  9347:                 IF (MYPROC.EQ.0) THEN
  9348:                    ! Getting the date in str_date format
  9349: +======>           str_date = ':start_FT='//CurDT%strftime("%Y%m%d%H")//'0000:'
  9350:                    iret = -1; iter = 0
  9351: +------>           do while (iret.le.0.and.iter < 10)
  9352: |                     if (iter > 0) then
  9353: |                        call logMessage(WARNING,'Trying to read again '//var)
  9354: |                        call sleep(5)
  9355: |                     endif
  9356: |         #ifdef GRIB2API
  9357: |                     iret = grb2_inq(fileN,invN,var,str_date,data2=data2)
  9358: |                     if (iret.gt.1.and.iter.eq.0) then
  9359: |                        ! May have two entries bcause of forecast/DA overlap
  9360: |                        call logMessage(DEBUG,'> 1 msg, trying to read '//var)
  9361: |                        iret = grb2_inq(fileN,invN,var,':anl:',
  9362: |              &                         str_date,data2=data2)
  9363: |                     endif
  9364: |         #endif
  9365: |                     iter = iter + 1
  9366: +------            enddo
  9367:                    if (iret.gt.0) then
  9368:                       call logMessage(DEBUG,'Successfully read '//var)
  9369:                    else
  9370:         I             call ArnoldSchwarzenegger(iret,var,fileN)
  9371:                    endif
  9372:                    NX = UBOUND(data2,1)
  9373:                    NY = UBOUND(data2,2)
  9374:                 ENDIF
  9375:                 CALL BcastToLocal_Int(NX)
  9376:                 CALL BcastToLocal_INT(NY)
  9377:                 IF (MYPROC.NE.0) THEN
  9378:                    ALLOCATE( data2(NX,NY) )
  9379:                 ENDIF
  9380:                 CALL BcastToLocal_2DRealArray(data2,NX,NY)
  9381:                 CALL unsetMessageSource()
  9382:                 RETURN
  9383:           C----------------------------------------------------------------------
  9384:                 END SUBROUTINE READNWS14_grib2


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_GRIB2
INLINE LIST

  ROOT: WIND::READNWS14_GRIB2 (wind.F:9329)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9346)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::STRFTIME (wind.F:9349)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9353)
     *** Source for routine not found.
  -> NOINLINE: SLEEP (wind.F:9354)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9368)
     *** Source for routine not found.
  -> INLINE: WIND::ARNOLDSCHWARZENEGGER (wind.F:9370)
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9717)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9720)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9723)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:9729)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9375)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9376)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9380)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9381)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_GRIB2
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:9349)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9349)
  LOOP END

  LOOP BEGIN: (wind.F:9349)
    <Unvectorized loop.>
    *** Unvectorizable data type. : STR_DATE (wind.F:9349)
  LOOP END

  LOOP BEGIN: (wind.F:9351)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (wind.F:9351)
    *** Vectorization obstructive procedure reference. : GLOBAL::LOGMESSAGE (wind.F:9351)
    *** Deallocation obstructs vectorization. (wind.F:9351)
    *** Vectorization obstructive procedure reference. : SLEEP (wind.F:9351)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_GRIB2
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 39 [s0-s5 s8-s12 s15-s16 s18-s36 s57-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 656 bytes
      Register spill area      :  24 bytes
      Parameter area           :  48 bytes
      Register save area       : 176 bytes
      User data area           : 408 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9349)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9349)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:9351)
    *** Estimated execution cycle                       : 64
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NETCDF
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9407: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9414: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_DIMID
  9414: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  9415: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_DIMENSION
  9419: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9423: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_VARID
  9424: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL
  9427: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY
  9430: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  9441: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9445: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NETCDF
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9387:                 SUBROUTINE READNWS14_netCDF(fileN, NC_ID,var,data2)
  9388:           C----------------------------------------------------------------------
  9389:           C       CPB 10/2023: Reads in netCDF format met forcing for NWS = 14.
  9390:           C       NOTE: reads in on Proc 0 and broadcasts.
  9391:           C----------------------------------------------------------------------
  9392:           #ifdef ADCNETCDF
  9393:                 use netcdf
  9394:                 use netcdf_error, only: check_err
  9395:           #endif
  9396:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_2DRealArray,
  9397:                &                           BcastToLocal_Int
  9398:                 USE SIZES, ONLY : MYPROC
  9399:                 implicit none
  9400:           
  9401:                 character(len=*),intent(in):: fileN
  9402:                 character(len=200),intent(in) :: var
  9403:                 real,allocatable,intent(out) :: data2(:,:)
  9404:                 INTEGER,INTENT(INOUT) :: NC_ID
  9405:                 integer :: i, Temp_ID, Lat_ID, Lon_ID, NX, NY
  9406:           
  9407:                 CALL setMessageSource('READNWS14_netCDF')
  9408:           
  9409:           #ifdef ADCNETCDF
  9410:                 IF ( read_NWS14_NetCdf_using_core_0 ) THEN
  9411:                   ! Use core zero to read data
  9412:                   ! and then broadcast them
  9413:                   IF (MYPROC.EQ.0) THEN
  9414:                      call Check_err(NF90_INQ_DIMID(NC_ID,Latdim,Temp_ID))
  9415:                      call Check_err(NF90_INQUIRE_DIMENSION(NC_ID,Temp_ID,len=NY))
  9416:                      call Check_err(NF90_INQ_DIMID(NC_ID,Londim,Temp_ID))
  9417:                      call Check_err(NF90_INQUIRE_DIMENSION(NC_ID,Temp_ID,len=NX))
  9418:                   ENDIF
  9419:                   CALL BcastToLocal_Int(NX)
  9420:                   CALL BcastToLocal_Int(NY)
  9421:                   allocate(data2(NX,NY))
  9422:                   IF (MYPROC.EQ.0) THEN
  9423:                      call Check_err(NF90_INQ_VARID(NC_ID,var,Temp_ID))
  9424:                      call Check_err(NF90_GET_VAR(NC_ID,Temp_ID,data2,
  9425:                &                  start=[1, 1, NT],count=[NX, NY, 1]))
  9426:                   ENDIF
  9427:                   CALL BCastToLocal_2DRealArray(Data2,NX,NY)
  9428:                 ELSE
  9429:                   ! Each core read data
  9430:                   call Check_err(NF90_OPEN(fileN,nf90_nowrite,NC_ID))
  9431:                   call Check_err(NF90_INQ_DIMID(NC_ID,Latdim,Temp_ID))
  9432:                   call Check_err(NF90_INQUIRE_DIMENSION(NC_ID,Temp_ID,len=NY))
  9433:                   call Check_err(NF90_INQ_DIMID(NC_ID,Londim,Temp_ID))
  9434:                   call Check_err(NF90_INQUIRE_DIMENSION(NC_ID,Temp_ID,len=NX))
  9435:           
  9436:                   allocate(data2(NX,NY))
  9437:                   call Check_err(NF90_INQ_VARID(NC_ID,var,Temp_ID))
  9438:                   call Check_err(NF90_GET_VAR(NC_ID,Temp_ID,data2,
  9439:                &                  start=[1, 1, NT],count=[NX, NY, 1]))
  9440:           
  9441:                   call Check_err(NF90_CLOSE(NC_ID))
  9442:                 ENDIF
  9443:           
  9444:           #endif
  9445:                 CALL unsetMessageSource()
  9446:                 RETURN
  9447:           C----------------------------------------------------------------------
  9448:                 END SUBROUTINE READNWS14_netCDF


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NETCDF
INLINE LIST

  ROOT: WIND::READNWS14_NETCDF (wind.F:9387)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9407)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9414)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9414)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9415)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9415)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9416)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9416)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9417)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9417)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9419)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9420)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9423)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9423)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9424)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9424)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9427)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:9430)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9430)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9431)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9431)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9432)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9432)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9433)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9433)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9434)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9434)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9437)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9437)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9438)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9438)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9441)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9441)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9445)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NETCDF
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NETCDF
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 28 [s0-s12 s15-s16 s18 s23-s31 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 688 bytes
      Register spill area      :   0 bytes
      Parameter area           :  80 bytes
      Register save area       : 176 bytes
      User data area           : 432 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9463: inl(1219): Nesting level too deep for automatic expansion.: WIND::READNWS14LATLON_GRIB2
  9465: inl(1214): Expansion routine is too big for automatic expansion.: WIND::READNWS14LATLON_NETCDF
  9468: inl(1222): Inlined: WIND::WINDTERMINATE
  8773: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8778: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9451:                 SUBROUTINE READNWS14LatLon(fileN,lat,lon,invN,var,ncid)
  9452:           C----------------------------------------------------------------------
  9453:           C     CPB 10/2023: Added to make NWS = 14 more more readable. Simply
  9454:           C     calls the appropriate subroutine based on the filetype we are
  9455:           C     using.
  9456:           C----------------------------------------------------------------------
  9457:                 implicit none
  9458:                 CHARACTER(len=200),INTENT(IN) :: fileN
  9459:                 REAL,ALLOCATABLE,INTENT(OUT) :: lat(:,:),lon(:,:)
  9460:                 CHARACTER(LEN=200),INTENT(IN),OPTIONAL :: var, invN
  9461:                 INTEGER,INTENT(INOUT),OPTIONAL :: ncid
  9462:                 IF (grb2flag) THEN
  9463:                    CALL READNWS14LatLon_grib2(fileN,invN,var,lat,lon)
  9464:                 ELSEIF (.NOT.grb2flag) THEN
  9465:                    CALL READNWS14LatLon_netCDF(fileN,ncid,lat,lon)
  9466:                 ELSE
  9467:                    ! should be unreachable
  9468:         I          CALL windterminate()
  9469:                 ENDIF
  9470:           C----------------------------------------------------------------------
  9471:                 END SUBROUTINE READNWS14LatLon


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON
INLINE LIST

  ROOT: WIND::READNWS14LATLON (wind.F:9451)
  -> NOINLINE: WIND::READNWS14LATLON_GRIB2 (wind.F:9463)
     *** Nesting level too deep for automatic expansion.
  -> NOINLINE: WIND::READNWS14LATLON_NETCDF (wind.F:9465)
     *** Expansion routine is too big for automatic expansion.
  -> INLINE: WIND::WINDTERMINATE (wind.F:9468)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 25 [s0-s12 s15-s16 s18 s23-s28 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 288 bytes
      Register spill area      :   0 bytes
      Parameter area           :  64 bytes
      Register save area       : 176 bytes
      User data area           :  48 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_GRIB2
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9491: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9493: inl(1212): Source for routine not found.: DATETIME_MODULE::STRFTIME
  9493: vec( 103): Unvectorized loop.
  9493: vec( 118): Unvectorizable data type.: STR_DATE
  9497: vec( 103): Unvectorized loop.
  9497: vec( 181): Allocation obstructs vectorization.
  9497: vec( 110): Vectorization obstructive procedure reference.: GLOBAL::LOGMESSAGE
  9497: vec( 182): Deallocation obstructs vectorization.
  9497: vec( 110): Vectorization obstructive procedure reference.: SLEEP
  9499: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  9500: inl(1212): Source for routine not found.: SLEEP
  9508: opt(1317): Logical clause simplified.
  9511: inl(1222): Inlined: WIND::ARNOLDSCHWARZENEGGER
  9729: inl(1222): Inlined: WIND::WINDTERMINATE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE
  9519: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9525: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_GRIB2
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9474:                 SUBROUTINE READNWS14LatLon_grib2(fileN,invN,var,lat,lon)
  9475:           C----------------------------------------------------------------------
  9476:           C     CPB 10/2023: Reads in the lat and lon from a grib2 format
  9477:           C     meteorological file. NOTE: reads in on Proc 0 and broadcasts
  9478:           C----------------------------------------------------------------------
  9479:           #ifdef GRIB2API
  9480:                 use wgrib2api
  9481:           #endif
  9482:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_2DRealArray,
  9483:                &                           BcastToLocal_Int
  9484:                 USE SIZES, ONLY : MYPROC
  9485:                 implicit none
  9486:                 integer :: iret, iter
  9487:                 character(len=200),intent(in) :: var, fileN, invN
  9488:                 real,allocatable,intent(out) :: lat(:,:), lon(:,: )
  9489:                 integer :: NX, NY
  9490:                 character(len=200) :: str_date
  9491:                 CALL setMessageSource("READNWS14LatLon_grib2")
  9492:                 ! Getting the date in str_date format
  9493: +======>        str_date = ':start_FT='//CurDT%strftime("%Y%m%d%H")//'0000:'
  9494:                 ! read in on core 0
  9495:                 IF (MYPROC.EQ.0) THEN
  9496:                    iret = -1; iter = 0
  9497: +------>           do while (iret.le.0.and.iter < 10)
  9498: |                     if (iter > 0) then
  9499: |                        call logMessage(WARNING,'Trying to read again '//var)
  9500: |                        call sleep(5)
  9501: |                     endif
  9502: |         #ifdef GRIB2API
  9503: |                     iret = grb2_inq(fileN,invN,var,str_date,
  9504: |              &                      lat=lat,lon=lon)
  9505: |         #endif
  9506: |                     iter = iter + 1
  9507: +------            enddo
  9508:                    if (iret.gt.0) then
  9509:                       call logMessage(ECHO,'Successfully read LatLon '//var)
  9510:                    else
  9511:         I             call ArnoldSchwarzenegger(iret,var,fileN)
  9512:                    endif
  9513:                 ENDIF
  9514:                 ! broadcast data
  9515:                 IF (MYPROC.EQ.0) THEN
  9516:                    NX = UBOUND(lon,1)
  9517:                    NY = UBOUND(lat,2)
  9518:                 ENDIF
  9519:                 CALL BcastToLocaL_Int(NX)
  9520:                 Call BcastToLocal_Int(NY)
  9521:                 IF (MYPROC.NE.0) THEN
  9522:                    ALLOCATE( lat(NX,NY), lon(NX,NY) )
  9523:                 ENDIF
  9524:                 ! latitude
  9525:                 CALL BcastToLocal_2DRealArray(lat,NX,NY)
  9526:                 ! longitude
  9527:                 CALL BcastToLocal_2DRealArray(lon,NX,NY)
  9528:                 CALL unsetMessageSource()
  9529:                 RETURN
  9530:           C----------------------------------------------------------------------
  9531:                 END SUBROUTINE READNWS14LatLon_grib2


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_GRIB2
INLINE LIST

  ROOT: WIND::READNWS14LATLON_GRIB2 (wind.F:9474)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9491)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::STRFTIME (wind.F:9493)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9499)
     *** Source for routine not found.
  -> NOINLINE: SLEEP (wind.F:9500)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9509)
     *** Source for routine not found.
  -> INLINE: WIND::ARNOLDSCHWARZENEGGER (wind.F:9511)
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9717)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9720)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9723)
      *** Source for routine not found.
   -> INLINE: WIND::WINDTERMINATE (wind.F:9729)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
       *** Source for routine not found.
    -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
       *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9519)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9520)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9525)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9527)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9528)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_GRIB2
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:9493)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9493)
  LOOP END

  LOOP BEGIN: (wind.F:9493)
    <Unvectorized loop.>
    *** Unvectorizable data type. : STR_DATE (wind.F:9493)
  LOOP END

  LOOP BEGIN: (wind.F:9497)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (wind.F:9497)
    *** Vectorization obstructive procedure reference. : GLOBAL::LOGMESSAGE (wind.F:9497)
    *** Deallocation obstructs vectorization. (wind.F:9497)
    *** Vectorization obstructive procedure reference. : SLEEP (wind.F:9497)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:15 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_GRIB2
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 39 [s0-s5 s8-s12 s15-s16 s18-s36 s57-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 736 bytes
      Register spill area      :  32 bytes
      Parameter area           :  48 bytes
      Register save area       : 176 bytes
      User data area           : 480 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9493)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9493)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:9497)
    *** Estimated execution cycle                       : 64
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_NETCDF
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9552: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9557: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  9557: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  9560: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_DIMID
  9561: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_DIMENSION
  9567: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_VARID
  9568: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_VARIABLE
  9572: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL
  9580: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_1D_FOURBYTEREAL
  9582: opt(1589): Outer loop moved inside inner loop(s).: I
  9582: vec( 101): Vectorized loop.
  9585: vec( 101): Vectorized loop.
  9586: vec( 101): Vectorized loop.
  9591: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9595: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9600: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY
  9603: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_NETCDF
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9534:                 SUBROUTINE READNWS14LatLon_netCDF(fileN,ncid,lat,lon)
  9535:           C----------------------------------------------------------------------
  9536:           C     CPB 10/2023: Reads in the lat and lon from a netCDF format
  9537:           C     meteorological forcing file. NOTE: reads in on Proc 0 and
  9538:           C     broadcasts.
  9539:           C----------------------------------------------------------------------
  9540:           #ifdef ADCNETCDF
  9541:                 use netcdf
  9542:                 use netcdf_error, only: check_err
  9543:           #endif
  9544:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_2DRealArray,
  9545:                &                           BcastToLocal_Int
  9546:                 USE SIZES, ONLY : MYPROC
  9547:                 implicit none
  9548:                 INTEGER,INTENT(INOUT) :: ncid ! already opened ncid tag
  9549:                 character(len=200),intent(in) :: fileN
  9550:                 real,allocatable,intent(out) :: lat(:,:), lon(:,:)
  9551:                 integer :: i, Temp_ID, Lat_ID, Lon_ID, NX, NY, ndims
  9552:                 CALL setMessageSource("READNWS14LatLon_netCDF")
  9553:           #ifdef ADCNETCDF
  9554:                 IF (MYPROC.EQ.0) THEN
  9555:            
  9556:                    IF ( .NOT. read_NWS14_NetCdf_using_core_0 ) THEN
  9557:                      call Check_err(NF90_OPEN(FileN,nf90_nowrite,ncid))
  9558:                    END IF
  9559:            
  9560:                    call Check_err(NF90_INQ_DIMID(ncid,Latdim,Temp_ID))
  9561:                    call Check_err(NF90_INQUIRE_DIMENSION(ncid,Temp_ID,
  9562:                &                                         len=NY))
  9563:                    call Check_err(NF90_INQ_DIMID(ncid,Londim,Temp_ID))
  9564:                    call Check_err(NF90_INQUIRE_DIMENSION(ncid,Temp_ID,
  9565:                &                                         len=NX))
  9566:                    allocate(lon(NX,NY),lat(NX,NY))
  9567:                    call Check_err(NF90_INQ_VARID(ncid,Latvar,Lat_ID))
  9568:                    call Check_err(nf90_inquire_variable(ncid,Lat_ID,
  9569:                &               ndims=ndims))
  9570:                    call Check_err(NF90_INQ_VARID(ncid,Lonvar,Lon_ID))
  9571:                    if (ndims.eq.3) then
  9572:                       call Check_err(NF90_GET_VAR(ncid,Lat_ID,lat,
  9573:                &                     start=[1, 1, NT],count=[NX, NY, 1]))
  9574:                       call Check_err(NF90_GET_VAR(ncid,Lon_ID,lon,
  9575:                &                     start=[1, 1, NT],count=[NX, NY, 1]))
  9576:                    elseif (ndims.eq.2) then
  9577:                       call Check_err(NF90_GET_VAR(ncid,Lat_ID,lat))
  9578:                       call Check_err(NF90_GET_VAR(ncid,Lon_ID,lon))
  9579:                    else
  9580:                       call Check_err(NF90_GET_VAR(ncid,Lat_ID,lat(1,:)))
  9581:                       call Check_err(NF90_GET_VAR(ncid,Lon_ID,lon(:,1)))
  9582: X------>              do i = 2,NX
  9583: |+=====>                 lat(i,:) = lat(1,:)
  9584: X------               enddo
  9585: V------>              do i = 2,NY
  9586: |V=====>                 lon(:,i) = lon(:,1)
  9587: V------               enddo
  9588:                    endif
  9589:           
  9590:                    IF ( .NOT. read_NWS14_NetCdf_using_core_0 ) THEN
  9591:                      call Check_err(NF90_CLOSE(ncid))
  9592:                    END IF
  9593:           
  9594:                 ENDIF
  9595:                 CALL BcastToLocal_Int(NX)
  9596:                 CALL BcastToLocal_Int(NY)
  9597:                 IF (MYPROC.NE.0) THEN
  9598:                    ALLOCATE( lon(NX,NY), lat(NX,NY) )
  9599:                 ENDIF
  9600:                 CALL BcastToLocal_2DRealArray(lon,NX,NY)
  9601:                 CALL BcastToLocal_2DRealArray(lat,NX,NY)
  9602:           #endif
  9603:                 CALL unsetMessageSource()
  9604:                 RETURN
  9605:           C----------------------------------------------------------------------
  9606:                 END SUBROUTINE READNWS14LatLon_netCDF


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_NETCDF
INLINE LIST

  ROOT: WIND::READNWS14LATLON_NETCDF (wind.F:9534)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9552)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:9557)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9557)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9560)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9560)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9561)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9561)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9563)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9563)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9564)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9564)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9567)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9567)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_VARIABLE (wind.F:9568)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9568)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9570)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9570)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9572)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9572)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9574)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9574)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9577)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9577)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_2D_FOURBYTEREAL (wind.F:9578)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9578)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_1D_FOURBYTEREAL (wind.F:9580)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9580)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_1D_FOURBYTEREAL (wind.F:9581)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9581)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9591)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9591)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9595)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9596)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9600)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_2DREALARRAY (wind.F:9601)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9603)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_NETCDF
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (wind.F:9583)
    <Unvectorized loop.>

    LOOP BEGIN: (wind.F:9582)
      <Vectorized loop.>
      **  Interchanged loop. (wind.F:9582)
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:9582)
      *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:9582)
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:9585)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (wind.F:9585)
    *** The number of VLOAD, VSTORE. :  0,  1. (wind.F:9585)

    LOOP BEGIN: (wind.F:9586)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (wind.F:9586)
      *** The number of VLOAD, VSTORE. :  1,  1. (wind.F:9586)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14LATLON_NETCDF
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 47 [s0-s12 s15-s16 s18-s19 s23-s36 s48-s63]
      Vector registers         :  3 [v61-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1088 bytes
      Register spill area      :   24 bytes
      Parameter area           :  136 bytes
      Register save area       :  176 bytes
      User data area           :  744 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9582)
    *** Estimated execution cycle                       : 39
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (wind.F:9582)
      *** Estimated execution cycle                     : 65
    LOOP END
  LOOP END

  LOOP BEGIN: (wind.F:9585)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (wind.F:9585)
    *** Estimated execution cycle                       : 46
    *** The number of SCALAR REGISTER TRANSFER          : 13

    LOOP BEGIN: (wind.F:9586)
      *** Estimated execution cycle                     : 64
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NC_STATIME
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9631: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9638: inl(1212): Source for routine not found.: NETCDF::NF90_OPEN
  9638: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR
  9641: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_DIMID
  9642: inl(1212): Source for routine not found.: NETCDF::NF90_INQUIRE_DIMENSION
  9647: inl(1212): Source for routine not found.: GLOBAL::LOGMESSAGE
  9651: inl(1212): Source for routine not found.: NETCDF::NF90_INQ_VARID
  9652: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_1D_TEXT
  9654: inl(1212): Source for routine not found.: DATETIME_MODULE::STRFTIME
  9654: vec( 103): Unvectorized loop.
  9654: vec( 108): Unvectorizable loop structure.
  9654: vec( 118): Unvectorizable data type.: STR_DATE
  9655: vec( 181): Allocation obstructs vectorization.
  9655: vec( 182): Deallocation obstructs vectorization.
  9655: vec( 118): Unvectorizable data type.
  9655: vec( 108): Unvectorizable loop structure.
  9656: opt(1082): Backward transfers inhibit loop optimization.
  9656: opt(1097): This statement prevents loop optimization.
  9656: vec( 103): Unvectorized loop.
  9656: vec( 108): Unvectorizable loop structure.
  9668: inl(1212): Source for routine not found.: DATETIME_MODULE::STRPTIME
  9668: vec( 103): Unvectorized loop.
  9668: vec( 108): Unvectorizable loop structure.
  9671: inl(1212): Source for routine not found.: NETCDF::NF90_GET_VAR_1D_EIGHTBYTEREAL
  9672: vec( 103): Unvectorized loop.
  9672: vec( 110): Vectorization obstructive procedure reference.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  9672: vec( 110): Vectorization obstructive procedure reference.: DATETIME_MODULE::DATETIME_EQ
  9672: vec( 110): Vectorization obstructive procedure reference.: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA
  9673: inl(1212): Source for routine not found.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  9673: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA
  9673: opt(1025): Reference to this procedure inhibits optimization.: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR
  9675: inl(1212): Source for routine not found.: DATETIME_MODULE::DATETIME_EQ
  9692: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9697: inl(1212): Source for routine not found.: GL2LOC_MAPPING::BCASTTOLOCAL_INT
  9701: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NC_STATIME
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9609:                 SUBROUTINE READNWS14_NC_StaTime(FileN, NC_ID)
  9610:           C----------------------------------------------------------------------
  9611:           C       CPB 10/2023: Sets the time index from which we start reading in
  9612:           C       netCDF meteorological forcing. NOTE: reads in on proc 0 and
  9613:           C       broadcasts.
  9614:           C----------------------------------------------------------------------
  9615:           #ifdef ADCNETCDF
  9616:                 use netcdf
  9617:                 use netcdf_error, only: check_err
  9618:           #endif
  9619:                 USE GL2LOC_MAPPING ,ONLY : BcastToLocal_Int
  9620:                 USE SIZES, ONLY : MYPROC
  9621:                 USE NETCDF_ERROR, ONLY: CHECK_ERR
  9622:                 implicit none
  9623:                 integer :: iret, iter
  9624:                 INTEGER,INTENT(INOUT) :: NC_ID
  9625:                 character(len=200),intent(in) :: fileN
  9626:                 character(len=19),allocatable :: TimeStr(:)
  9627:                 character(len=200) :: str_date
  9628:                 integer :: i, Temp_ID, TL
  9629:                 ! CPB 4/20/2023
  9630:                 REAL(8),ALLOCATABLE :: NCTIMES(:)
  9631:                 CALL setMessageSource('READNWS14_NC_StaTime')
  9632:           #ifdef ADCNETCDF
  9633:           #ifdef CMPI
  9634:                 IF (MYPROC.EQ.0) THEN
  9635:           #endif
  9636:           
  9637:                    IF ( .NOT. read_NWS14_NetCdf_using_core_0 ) THEN
  9638:                       call Check_err(NF90_OPEN(FileN,nf90_nowrite,NC_ID))
  9639:                    END IF
  9640:           
  9641:                    call Check_err(NF90_INQ_DIMID(NC_ID,Tdim,Temp_ID))
  9642:                    call Check_err(NF90_INQUIRE_DIMENSION(NC_ID,Temp_ID,
  9643:                &                                         len=TL))
  9644:                    IF (Tformat(1:1).eq.'%') THEN
  9645:                       ! in this case the netCDF files have a datetime variable
  9646:                       ! so we can determine where to start based off of that
  9647:                       CALL logMessage(ECHO,"fort.22 indicates that a "
  9648:                &          //"datetime variable is provided. Starting index "
  9649:                &          //"will be calculated.")
  9650:                       ALLOCATE( TIMESTR(TL) )
  9651:                       call Check_err(NF90_INQ_VARID(NC_ID,Tvar,Temp_ID))
  9652:                       call Check_err(NF90_GET_VAR(NC_ID,Temp_ID,TimeStr))
  9653:                       ! Determine the first timestep index
  9654: +======>              str_date = CurDT%strftime(trim(Tformat))
  9655: +------>              do NT = 1,TL
  9656: |                        if (trim(str_date).eq.TimeStr(NT)) exit
  9657: +------               enddo
  9658:                       call logMessage(ECHO,'Starting from '//TimeStr(NT))
  9659:                       DEALLOCATE( TIMESTR )
  9660:                    ELSEIF (Tvar.eq.'refdate') THEN
  9661:                       ! in this case the reference date for the netCDF file is
  9662:                       ! provided in the fort.22 and the units of the time
  9663:                       ! variable are in the form of "seconds since refdate".
  9664:                       ! This allows us to find the start index
  9665:                       CALL logMessage(ECHO,"fort.22 provides a reference "
  9666:                &          //"date. Starting time index will be calculated.")
  9667:                       ALLOCATE( NCTIMES(TL) )
  9668:                       refdate = strptime(trim(Tformat),
  9669:                &                         "%Y-%m-%dT%H:%M:%S")
  9670:                       CALL CHECK_ERR(NF90_INQ_VARID(NC_ID,TDIM,TEMP_ID))
  9671:                       call Check_err(NF90_GET_VAR(NC_ID,Temp_ID,NCTIMES))
  9672: +------>              DO NT = 1,TL
  9673: |                        stepdate = refdate +
  9674: |              &                    timedelta(seconds=INT(NCTIMES(NT)))
  9675: |                        IF (stepdate.EQ.curDT) THEN
  9676: |                           EXIT
  9677: |                        ENDIF
  9678: +------               ENDDO
  9679:                       DEALLOCATE( NCTIMES )
  9680:                    else
  9681:                       ! If neither of those two things are true we just assume
  9682:                       ! we start at the beginning of the file
  9683:                       call logMessage(ECHO,
  9684:                &                      'Neither a datetime variable nor a '
  9685:                &          //'reference date were provided. Assume met forcing '
  9686:                &          //'starts at the beginning of the netCDF file.')
  9687:                       NT = 1
  9688:                    endif
  9689:                    NTC = NT
  9690:           
  9691:                    IF ( .NOT. read_NWS14_NetCdf_using_core_0 ) THEN
  9692:                       call Check_err(NF90_CLOSE(NC_ID))
  9693:                    END IF
  9694:           
  9695:           #ifdef CMPI
  9696:                 endif
  9697:                 CALL BcastToLocal_Int(NT)
  9698:                 CALL BcastToLocal_Int(NTC)
  9699:           #endif
  9700:           #endif
  9701:                 CALL unsetMessageSource()
  9702:                 return
  9703:           C----------------------------------------------------------------------
  9704:                 END SUBROUTINE READNWS14_NC_StaTime


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NC_STATIME
INLINE LIST

  ROOT: WIND::READNWS14_NC_STATIME (wind.F:9609)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9631)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_OPEN (wind.F:9638)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9638)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_DIMID (wind.F:9641)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9641)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQUIRE_DIMENSION (wind.F:9642)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9642)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9647)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9651)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9651)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_1D_TEXT (wind.F:9652)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9652)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::STRFTIME (wind.F:9654)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9658)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9665)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::STRPTIME (wind.F:9668)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_INQ_VARID (wind.F:9670)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9670)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_GET_VAR_1D_EIGHTBYTEREAL (wind.F:9671)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9671)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:9673)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:9673)
     *** Source for routine not found.
  -> NOINLINE: DATETIME_MODULE::DATETIME_EQ (wind.F:9675)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::LOGMESSAGE (wind.F:9683)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9692)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9692)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9697)
     *** Source for routine not found.
  -> NOINLINE: GL2LOC_MAPPING::BCASTTOLOCAL_INT (wind.F:9698)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9701)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NC_STATIME
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:9668)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9668)
  LOOP END

  LOOP BEGIN: (wind.F:9672)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::TIMEDELTA_CONSTRUCTOR (wind.F:9672)
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::DATETIME_EQ (wind.F:9672)
    *** Vectorization obstructive procedure reference. : DATETIME_MODULE::DATETIME_PLUS_TIMEDELTA (wind.F:9672)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable data type. (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    <Unvectorized loop.>
    *** Unvectorizable data type. : STR_DATE (wind.F:9654)
  LOOP END

  LOOP BEGIN: (wind.F:9655)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (wind.F:9655)
    *** Deallocation obstructs vectorization. (wind.F:9655)
    *** Unvectorizable data type. (wind.F:9655)
    *** Unvectorizable loop structure. (wind.F:9655)

    LOOP BEGIN: (wind.F:9656)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (wind.F:9656)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::READNWS14_NC_STATIME
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 41 [s0-s12 s15-s16 s18-s38 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 912 bytes
      Register spill area      :  80 bytes
      Parameter area           :  80 bytes
      Register save area       : 176 bytes
      User data area           : 576 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9668)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9672)
    *** Estimated execution cycle                       : 110
    *** The number of SCALAR REGISTER TRANSFER          : 13
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (wind.F:9654)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (wind.F:9655)
    *** Estimated execution cycle                       : 43
    *** The number of SCALAR REGISTER TRANSFER          : 8

    LOOP BEGIN: (wind.F:9656)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::ARNOLDSCHWARZENEGGER
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9717: inl(1212): Source for routine not found.: GLOBAL::ALLMESSAGE
  9717: vec( 103): Unvectorized loop.
  9717: vec( 108): Unvectorizable loop structure.
  9720: vec( 103): Unvectorized loop.
  9720: vec( 108): Unvectorizable loop structure.
  9723: vec( 103): Unvectorized loop.
  9723: vec( 108): Unvectorizable loop structure.
  9729: inl(1222): Inlined: WIND::WINDTERMINATE
  8773: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  8780: inl(1212): Source for routine not found.: MESSENGER::MSG_FINI
  8788: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::ARNOLDSCHWARZENEGGER
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9707:                 SUBROUTINE ArnoldSchwarzenegger(iret,var,fileN)
  9708:           C----------------------------------------------------------------------
  9709:           #ifdef CMPI
  9710:                 USE MESSENGER, ONLY : subdomainFatalError
  9711:           #endif
  9712:                 IMPLICIT NONE
  9713:                 integer,intent(in) :: iret
  9714:                 character(len=200),intent(in) :: var, fileN
  9715:           C
  9716:                 if (iret.eq.0) then
  9717:                    call allMessage(ERROR,'Cound not find message when reading '
  9718:                &                         //trim(var)//' in '//trim(fileN)//'.')
  9719:                 elseif (iret.lt.0) then
  9720:                    call allMessage(ERROR,'Fatal error when reading '
  9721:                &                         //trim(var)//' in '//trim(fileN)//'.')
  9722:                 elseif (iret.gt.1) then
  9723:                    call allMessage(ERROR,'Found multiple messages when reading '
  9724:                &                         //trim(var)//' in '//trim(fileN)//'.')
  9725:                 endif
  9726:           #ifdef CMPI
  9727:                 subdomainFatalError = .true.
  9728:           #endif
  9729:         I       call windTerminate()
  9730:           C----------------------------------------------------------------------
  9731:                 END SUBROUTINE ArnoldSchwarzenegger


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::ARNOLDSCHWARZENEGGER
INLINE LIST

  ROOT: WIND::ARNOLDSCHWARZENEGGER (wind.F:9707)
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9717)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9720)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:9723)
     *** Source for routine not found.
  -> INLINE: WIND::WINDTERMINATE (wind.F:9729)
   -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:8773)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (wind.F:8778)
      *** Source for routine not found.
   -> NOINLINE: MESSENGER::MSG_FINI (wind.F:8780)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:8788)
      *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::ARNOLDSCHWARZENEGGER
VECTORIZATION LIST

  LOOP BEGIN: (wind.F:9723)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9723)
  LOOP END

  LOOP BEGIN: (wind.F:9723)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9723)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9720)
  LOOP END

  LOOP BEGIN: (wind.F:9717)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9717)
  LOOP END

  LOOP BEGIN: (wind.F:9717)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (wind.F:9717)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::ARNOLDSCHWARZENEGGER
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 31 [s0-s2 s8-s12 s15-s16 s23-s36 s57-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 352 bytes
      Register spill area      :  24 bytes
      Parameter area           :  24 bytes
      Register save area       : 176 bytes
      User data area           : 120 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (wind.F:9723)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9723)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9720)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9717)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (wind.F:9717)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CLOSE_MET_FILES
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9754: inl(1212): Source for routine not found.: NETCDF::NF90_CLOSE
  9754: inl(1212): Source for routine not found.: NETCDF_ERROR::CHECK_ERR


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CLOSE_MET_FILES
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9738:                 SUBROUTINE CLOSE_MET_FILES()
  9739:                   use global, only: NWS, NCICE
  9740:                   USE SIZES, ONLY : MYPROC
  9741:            
  9742:           #ifdef ADCNETCDF
  9743:                   use netcdf
  9744:                   use netcdf_error, only: check_err
  9745:           #endif
  9746:           
  9747:                   IMPLICIT NONE
  9748:           
  9749:           #ifdef DATETIME
  9750:           #ifdef ADCNETCDF
  9751:                   IF ( NWS == 14 ) THEN
  9752:                     IF ( (.not. grb2flag) .AND. read_NWS14_NetCdf_using_core_0 )  THEN
  9753:                        IF ( MYPROC == 0 ) THEN
  9754:                          call Check_err(NF90_CLOSE(PfileNCID))
  9755:                          call Check_err(NF90_CLOSE(WfileNCID))
  9756:                          call Check_err(NF90_CLOSE(Wfile1NCID))
  9757:           
  9758:                          IF (NCICE.EQ.14) THEN
  9759:                             call Check_err(NF90_CLOSE(CfileNCID))
  9760:                          ENDIF
  9761:                        ENDIF
  9762:                     END IF
  9763:                   END IF
  9764:           #endif
  9765:           #endif
  9766:           
  9767:                   RETURN ;
  9768:                 END SUBROUTINE CLOSE_MET_FILES


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CLOSE_MET_FILES
INLINE LIST

  ROOT: WIND::CLOSE_MET_FILES (wind.F:9738)
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9754)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9754)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9755)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9755)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9756)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9756)
     *** Source for routine not found.
  -> NOINLINE: NETCDF::NF90_CLOSE (wind.F:9759)
     *** Source for routine not found.
  -> NOINLINE: NETCDF_ERROR::CHECK_ERR (wind.F:9759)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CLOSE_MET_FILES
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::CLOSE_MET_FILES
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 15 [s0 s8-s12 s15-s16 s23-s25 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 208 bytes
      Register spill area      :   0 bytes
      Parameter area           :   8 bytes
      Register save area       : 176 bytes
      User data area           :  16 bytes
      Others                   :   8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDLIMITER
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9788: inl(1212): Source for routine not found.: GLOBAL::SETMESSAGESOURCE
  9802: inl(1212): Source for routine not found.: GLOBAL::UNSETMESSAGESOURCE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDLIMITER
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9780:                 subroutine windLimiter(H,fwind)
  9781:                 use global, only : h0
  9782:            
  9783:                 IMPLICIT NONE
  9784:            
  9785:                 REAL(8), intent(in) :: H
  9786:                 REAL(8), intent(out) :: fwind
  9787:            
  9788:                 call setMessageSource("windLimiter")
  9789:           #ifdef ALL_TRACE
  9790:                 call allMessage(DEBUG,"Enter.")
  9791:           #endif
  9792:                 fwind = 1.d0
  9793:                 IF ((H .LE. 4.d0*H0) .AND. (H .GT. H0)) THEN
  9794:                    fwind = .5d0*tanh(8.d0*(H-(2.5d0*H0))/(4.d0*H0))+.5d0
  9795:                 ELSEIF (H .LE. H0) THEN
  9796:                    fwind = 0.d0
  9797:                 ENDIF
  9798:           
  9799:           #ifdef ALL_TRACE
  9800:                 call allMessage(DEBUG,"Return.")
  9801:           #endif
  9802:                 call unsetMessageSource()
  9803:           C-----------------------------------------------------------------------
  9804:                 end subroutine WindLimiter


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDLIMITER
INLINE LIST

  ROOT: WIND::WINDLIMITER (wind.F:9780)
  -> NOINLINE: GLOBAL::SETMESSAGESOURCE (wind.F:9788)
     *** Source for routine not found.
  -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (wind.F:9802)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDLIMITER
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:45:16 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/wind.F

PROCEDURE NAME: WIND::WINDLIMITER
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 19 [s0-s1 s8-s12 s15-s16 s23-s24 s56-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 192 bytes
      Register spill area      :   0 bytes
      Parameter area           :  16 bytes
      Register save area       : 176 bytes
      User data area           :   0 bytes
      Others                   :   0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


