NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME : /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

  COMPILER OPTIONS : -fpp -stdlib=compat -DADCNETCDF -I/include -DHAVE_NETCDF4 -DDATETIME -c -I. -I/S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep -O3 -fextend-source -report-all -finline-functions -finline-max-function-size=200 -finline-file=/S/home01/G6012/d0954/DATA/model_run/adcirc_src/src/nodalattr.F -DES_TUNE -DADCNETCDF -I/include -DHAVE_NETCDF4 -DDATETIME -DREAL8 -DLINUX -DADCSWAN -I /S/home01/G6012/d0954/DATA/model_run/adcirc_src/work/odir1/ -I/S/home01/G6012/d0954/util/datetime/datetime-fortran/include -o /S/home01/G6012/d0954/DATA/model_run/adcirc_src/work/odir1/prep.o

  PARAMETER :

      Optimization Options :
        -On                                      : 3
        -fargument-alias                         : disable
        -fargument-noalias                       : enable
        -fassociative-math                       : enable
        -faggressive-associative-math            : disable
        -fassume-contiguous                      : disable
        -fcopyin-intent-out                      : enable
        -fcse-after-vectorization                : enable
        -ffast-formatted-io                      : enable
        -ffast-math                              : enable
        -ffast-math-check                        : disable
        -fignore-asynchronous                    : disable
        -fignore-induction-variable-overflow     : disable
        -fignore-volatile                        : disable
        -fivdep                                  : disable
        -fivdep-omp-worksharing-loop             : disable
        -floop-collapse                          : enable
        -floop-count                             : 5000
        -floop-fusion                            : enable
        -floop-interchange                       : enable
        -floop-normalize                         : enable
        -floop-split                             : disable
        -floop-strip-mine                        : enable
        -floop-unroll                            : enable
        -floop-unroll-complete                   : 4
        -floop-unroll-complete-nest              : 3
        -floop-unroll-max-times                  : auto
        -fmatrix-multiply                        : enable
        -fmove-loop-invariants                   : enable
        -fmove-loop-invariants-if                : enable
        -fmove-loop-invariants-unsafe            : disable
        -fmove-nested-loop-invariants-outer      : enable
        -fnamed-alias                            : disable
        -fnamed-noalias                          : enable
        -fnamed-noalias-aggressive               : disable
        -fouterloop-unroll                       : enable
        -fouterloop-unroll-max-size              : 4
        -fouterloop-unroll-max-times             : 4
        -fprecise-math                           : disable
        -freciprocal-math                        : enable
        -freorder-logical-expression             : enable
        -freplace-loop-equation                  : disable
        -freplace-matmul-to-matrix-multiply      : enable
        -marray-io                               : enable
        -mconditional-index-test                 : enable
        -mlist-vector                            : disable
        -mretain-'keyword'                       : all
        -msched-'keyword'                        : block
        -mstack-arrays                           : enable
        -mvector                                 : enable
        -mvector-advance-gather                  : enable
        -mvector-advance-gather-limit            : 56
        -mvector-assignment-threshold            : 64
        -mvector-dependency-test                 : enable
        -mvector-floating-divide-instruction     : disable
        -mvector-fma                             : enable
        -mvector-intrinsic-check                 : disable
        -mvector-iteration                       : enable
        -mvector-iteration-unsafe                : enable
        -mvector-loop-count-test                 : disable
        -mvector-low-precise-divide-function     : disable
        -mvector-merge-conditional               : enable
        -mvector-neighbors                       : disable
        -mvector-packed                          : disable
        -mvector-power-to-explog                 : disable
        -mvector-power-to-sqrt                   : enable
        -mvector-reduction                       : enable
        -mvector-shortloop-reduction             : disable
        -mvector-sqrt-instruction                : disable
        -mvector-threshold                       : 5
        -mwork-vector-kind=none                  : disable

      Parallelization Options :
        -fopenmp                                 : disable
        -mparallel                               : disable
        -mparallel-innerloop                     : disable
        -mparallel-omp-routine                   : enable
        -mparallel-outerloop-strip-mine          : disable
        -mparallel-sections                      : disable
        -mparallel-threshold                     : 2000
        -mschedule-dynamic                       : disable
        -mschedule-runtime                       : disable
        -mschedule-static                        : disable
        -mschedule-chunk-size                    : 0
        -pthread                                 : disable

      Inlining Options :
        -finline-copy-arguments                  : enable
        -finline-functions                       : enable
        -finline-max-depth                       : 2
        -finline-max-function-size               : 200
        -finline-max-times                       : 6

      Code Generation Options :
        -finstrument-functions                   : disable
        -fpic | -fPIC                            : disable
        -ftrace                                  : disable
        -march                                   : ve1
        -mfp16-format                            : none
        -p                                       : disable

      Debugging Options :
        -fbounds-check                           : disable
        -fcheck=all                              : disable
        -fcheck=alias                            : disable
        -fcheck=bits                             : disable
        -fcheck=bounds                           : disable
        -fcheck=dangling                         : disable
        -fcheck=do                               : disable
        -fcheck=iovf                             : disable
        -fcheck=pointer                          : disable
        -fcheck=present                          : disable
        -fcheck=recursion                        : disable
        -g                                       : disable
        -minit-stack                             : no
        -mmemory-trace                           : disable
        -mmemory-trace-full                      : disable
        -traceback                               : disable

      Language Options :
        -bss                                     : disable
        -fdefault-integer                        : 4
        -fdefault-double                         : 8
        -fdefault-real                           : 4
        -fextend-source                          : enable
        -ffree-form                              : disable
        -ffixed-form                             : enable
        -ff90-sign                               : disable
        -fmax-continuation-lines                 : 1023
        -frealloc-lhs-array                      : enable
        -frealloc-lhs-scalar                     : enable
        -save                                    : disable
        -std                                     : Fortran 2008

      Message Options :
        -Wall                                    : disable
        -Werror                                  : disable
        -Wextension                              : enable
        -Wobsolescent                            : enable
        -Woverflow                               : disable
        -Woverflow-errors                        : disable
        -fdiag-inline                            : 1
        -fdiag-parallel                          : 1
        -fdiag-vector                            : 1
        -pedantic-errors                         : disable
        -w                                       : disable

      List Output Options :
        -report-file                             : not specified
        -report-append-mode                      : disable
        -report-all                              : enable
        -report-cg                               : enable
        -report-diagnostics                      : enable
        -report-format                           : enable
        -report-inline                           : enable
        -report-option                           : enable
        -report-vector                           : enable

      Directory Options :
        -fintrinsic-modules-path                 : /opt/nec/ve/nfort/5.2.0/include
        -module                                  : not specified

      Miscellaneous Options :
        -v                                       : disable


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP10
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

    72: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: OPENPREPFILES
    85: vec( 103): Unvectorized loop.
    85: vec( 180): I/O statement obstructs vectorization.
    86: opt(1118): This I/O statement inhibits optimization of loop.
   105: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
   106: vec( 103): Unvectorized loop.
   106: vec( 180): I/O statement obstructs vectorization.
   107: opt(1118): This I/O statement inhibits optimization of loop.
   115: vec( 103): Unvectorized loop.
   115: vec( 180): I/O statement obstructs vectorization.
   117: opt(1118): This I/O statement inhibits optimization of loop.
   122: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
   131: vec( 103): Unvectorized loop.
   131: vec( 180): I/O statement obstructs vectorization.
   132: opt(1118): This I/O statement inhibits optimization of loop.
   142: vec( 103): Unvectorized loop.
   142: vec( 180): I/O statement obstructs vectorization.
   144: opt(1118): This I/O statement inhibits optimization of loop.
   155: vec( 103): Unvectorized loop.
   155: vec( 180): I/O statement obstructs vectorization.
   156: opt(1118): This I/O statement inhibits optimization of loop.
   161: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP10
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

    51:                 SUBROUTINE PREP10()
    52:           C---------------------------------------------------------------------------
    53:                 USE PRE_GLOBAL
    54:                 use memory_usage
    55:                 IMPLICIT NONE
    56:                 integer(8) :: nbytes = 0
    57:                 INTEGER I,J
    58:                 INTEGER iproc          ! subdomain index
    59:                 CHARACTER*80 header1, header2  ! header comments in unit 10 files
    60:                 CHARACTER*80 nvn_nvp           ! string representing nfen, np
    61:                 REAL(8) nvn           ! number of vertical nodes from unit 10 file
    62:                 REAL(8) nvp           ! number of horizontal nodes from unit 10 file
    63:                 INTEGER nhnn           ! horizontal nodes counter
    64:                 INTEGER nvnn           ! vertical nodes counter
    65:                 INTEGER sdu(nproc)     ! subdomain unit numbers for unit 10 files
    66:                 REAL(8), ALLOCATABLE :: fdData2D(:)   !(MNP)      full domain data
    67:                 REAL(8), ALLOCATABLE :: fdData3D(:,:) !(MNP,NFEN) full domain data
    68:                 REAL(8), ALLOCATABLE :: sdData2D(:)   !(MNP)      subdomain data
    69:                 REAL(8), ALLOCATABLE :: sdData3D(:,:) !(MNP,NFEN) subdomain data
    70:                 LOGICAL success        ! .true. if all files opened successfully
    71:           
    72:                 CALL OpenPrepFiles(10, 'initial concentration         ',
    73:                &     1, nproc, sdu, success)
    74:           
    75:                 IF (.not.success) THEN
    76:                    WRITE(*,*) 'WARNING: Unit 10 files not preprocessed.'
    77:                    RETURN ! note early return
    78:                 ENDIF
    79:           C
    80:           C     Read header information from full domain unit 10 file
    81:                 READ(10,80) header1
    82:                 READ(10,80) header2
    83:           C
    84:           C     Transcribe header information.
    85: +------>        DO iproc = 1, nproc
    86: |                  WRITE(sdu(iproc),80)  header1
    87: |                  WRITE(sdu(iproc),80)  header2
    88: +------         ENDDO
    89:           C
    90:           C     Check node number data for consistency (paranoia).
    91:                 READ(10,80) nvn_nvp
    92:                 READ(nvn_nvp,*) nvn, nvp
    93:                 IF ( nvn .ne. nfen .or. nvp .ne. nnodg ) then
    94:                    WRITE(*,*) 'ERROR: NVN or NVP not consistent with input data.'
    95:                    WRITE(*,*) 'NVN=',nvn,' although NFEN=',nfen
    96:                    WRITE(*,*) 'NVP=',nvp,' although NNODG=',nnodg
    97:                 ENDIF
    98:           C
    99:           C     Decompose concentration data
   100:           C
   101:                 IF (C2D_PTrans) THEN
   102:           c     read in the full domain data
   103:                    ALLOCATE ( fdData2D(MNP) )
   104:                    nbytes = 8*mnp
   105:                    call memory_alloc(nbytes)
   106: +------>           DO i=1, NNODG
   107: |                     READ(10,*) nhnn, fdData2D(nhnn)
   108: +------            ENDDO
   109:           c     write out subdomain data
   110:                    ALLOCATE ( sdData2D(MNP) )
   111:                    nbytes = 8*mnp
   112:                    call memory_alloc(nbytes)
   113: +------>           DO iproc = 1, nproc
   114: |                     WRITE(sdu(iproc),*) nnodp(iproc)
   115: |+----->              DO i=1, nnodp(iproc)
   116: ||                       sdData2D(i) = fdData2D(IMAP_NOD_LG(i,iproc))
   117: ||                       WRITE(sdu(iproc),*) i, sdData2D(i)
   118: |+-----               ENDDO
   119: +------            ENDDO
   120:                    DEALLOCATE ( fdData2D, sdData2D )
   121:                    nbytes = 16*mnp
   122:                    call memory_dealloc(nbytes)
   123:                 ENDIF
   124:           C
   125:                 IF (C3D_PTrans) THEN
   126:           c     read in the full domain data
   127:                    ALLOCATE ( fdData3D(MNP,NFEN) )
   128:                    nbytes = 8*mnp*nfen
   129:                    call memory_alloc(nbytes)
   130: +------>           DO i=1, NNODG
   131: |+----->              DO j=1, nfen
   132: ||                       READ(10,*) nhnn, nvnn, fdData3D(nhnn,nvnn)
   133: |+-----               ENDDO
   134: +------            ENDDO
   135:           c     write out subdomain data
   136:                    ALLOCATE ( sdData3D(MNP,NFEN) )
   137:                    nbytes = 8*mnp*nfen
   138:                    call memory_alloc(nbytes)
   139: +------>           DO iproc = 1, nproc
   140: |                     WRITE(sdu(iproc),*) nfen, nnodp(iproc)
   141: |+----->              DO i=1, nnodp(iproc)
   142: ||+---->                 DO j=1, nfen
   143: |||                         sdData3D(i,j) = fdData3D(IMAP_NOD_LG(i,iproc),j)
   144: |||                         WRITE(sdu(iproc),*) i, j, sdData3D(i,j)
   145: ||+----                  ENDDO
   146: |+-----               ENDDO
   147: +------            ENDDO
   148:                    DEALLOCATE ( fdData3D, sdData3D )
   149:                    nbytes = 16*mnp*nfen
   150:                    call memory_dealloc(nbytes)
   151:                 ENDIF
   152:           C
   153:           C     Close full domain file and all subdomain files
   154:                 CLOSE(10)
   155: +------>        DO iproc=1, nproc
   156: |                  CLOSE(sdu(iproc))
   157: +------         ENDDO
   158:           C
   159:             80  FORMAT(A80)
   160:           C
   161:                 call memory_status()
   162:                 RETURN
   163:           C---------------------------------------------------------------------------
   164:                 END SUBROUTINE PREP10


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP10
INLINE LIST

  ROOT: PREP10 (prep.F:51)
  -> NOINLINE: OPENPREPFILES (prep.F:72)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:105)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:112)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:122)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:129)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:138)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:150)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:161)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP10
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:85)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:85)
  LOOP END

  LOOP BEGIN: (prep.F:106)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:106)
  LOOP END

  LOOP BEGIN: (prep.F:113)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:115)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:115)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:130)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:131)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:131)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:139)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:141)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:142)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:142)
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:155)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:155)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP10
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 48 [s0-s12 s15-s16 s18-s43 s57-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3616 bytes
      Register spill area      :  512 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 2848 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:85)
    *** Estimated execution cycle                       : 73
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Across calls                                : 3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 3
    *** The number of SCALAR REGISTER TRANSFER          : 14
  LOOP END

  LOOP BEGIN: (prep.F:106)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:113)
    *** Estimated execution cycle                       : 75
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 3
            Across calls                                : 1
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Across calls                                : 2
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 12

    LOOP BEGIN: (prep.F:115)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Across calls                              : 2
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:130)
    *** Estimated execution cycle                       : 10
    *** The number of SCALAR REGISTER TRANSFER          : 4

    LOOP BEGIN: (prep.F:131)
      *** Estimated execution cycle                     : 50
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:139)
    *** Estimated execution cycle                       : 91
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 8
            Across calls                                : 1
            Over basic blocks                           : 5
            Others                                      : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 9
            Across calls                                : 1
            Over basic blocks                           : 8
    *** The number of SCALAR REGISTER TRANSFER          : 13

    LOOP BEGIN: (prep.F:141)
      *** Estimated execution cycle                     : 26
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (prep.F:142)
        *** Estimated execution cycle                   : 98
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 7
                Across calls                            : 7
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 14
                Across calls                            :  9
                Over basic blocks                       :  5
        *** The number of SCALAR REGISTER TRANSFER      : 16
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:155)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP11
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   231: vec( 103): Unvectorized loop.
   231: vec( 180): I/O statement obstructs vectorization.
   232: opt(1118): This I/O statement inhibits optimization of loop.
   258: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
   259: vec( 103): Unvectorized loop.
   259: vec( 118): Unvectorizable data type.
   266: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   266: vec( 108): Unvectorizable loop structure.
   268: vec( 180): I/O statement obstructs vectorization.
   268: vec( 108): Unvectorizable loop structure.
   269: opt(1118): This I/O statement inhibits optimization of loop.
   270: opt(1082): Backward transfers inhibit loop optimization.
   270: vec( 103): Unvectorized loop.
   270: vec( 108): Unvectorizable loop structure.
   270: vec( 118): Unvectorizable data type.: DUMMY
   274: vec( 103): Unvectorized loop.
   274: vec( 118): Unvectorizable data type.: FD2D_MSG
   278: vec( 108): Unvectorizable loop structure.
   279: vec( 103): Unvectorized loop.
   279: vec( 180): I/O statement obstructs vectorization.
   280: opt(1118): This I/O statement inhibits optimization of loop.
   291: vec( 102): Partially vectorized loop.
   291: vec( 118): Unvectorizable data type.: FD2D_MSG
   292: opt(1082): Backward transfers inhibit loop optimization.
   292: vec( 103): Unvectorized loop.
   292: vec( 108): Unvectorizable loop structure.
   292: vec( 118): Unvectorizable data type.: FD2D_MSG
   298: vec( 180): I/O statement obstructs vectorization.
   299: opt(1082): Backward transfers inhibit loop optimization.
   299: vec( 103): Unvectorized loop.
   299: vec( 108): Unvectorizable loop structure.
   300: opt(1118): This I/O statement inhibits optimization of loop.
   300: opt(3014): Moved reference within a conditional branch.
   308: vec( 103): Unvectorized loop.
   308: vec( 180): I/O statement obstructs vectorization.
   310: opt(1118): This I/O statement inhibits optimization of loop.
   310: opt(3014): Moved reference within a conditional branch.
   318: vec( 103): Unvectorized loop.
   318: vec( 180): I/O statement obstructs vectorization.
   319: opt(1118): This I/O statement inhibits optimization of loop.
   482: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP11
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   183:                 SUBROUTINE PREP11()
   184:           C---------------------------------------------------------------------------
   185:                 USE PRE_GLOBAL
   186:                 use memory_usage
   187:                 use presizes, only: IDEN
   188:                 IMPLICIT NONE
   189:                 integer(8) :: nbytes = 0
   190:                 INTEGER I,J,eof,K
   191:                 INTEGER iproc          ! subdomain index
   192:                 CHARACTER*80 header1, header2  ! header comments in unit 11 files
   193:                 CHARACTER*80 nvn_nvp
   194:                 CHARACTER*120 Dummy    ! string representing nfen, np
   195:                 integer nvn           ! number of vertical nodes from unit 11 file
   196:                 integer nvp           ! number of horizontal nodes from unit 11 file
   197:                 INTEGER nhnn           ! horizontal nodes counter
   198:                 INTEGER nvnn           ! vertical nodes counter
   199:                 INTEGER sdu(nproc)     ! subdomain unit numbers for unit 11 files
   200:                 INTEGER looper         ! timesnap looper
   201:                 INTEGER nodepnw
   202:                 CHARACTER*120, ALLOCATABLE :: FD2D_MSG(:), FD_MSG(:,:)
   203:           !      REAL(8), ALLOCATABLE :: fdData1(:,:) !(MNP,NFEN) full domain data
   204:           !      REAL(8), ALLOCATABLE :: fdData2(:,:) !(MNP,NFEN) full domain data
   205:           !      REAL(8), ALLOCATABLE :: sdData1(:,:) !(MNP,NFEN) subdomain data
   206:           !      REAL(8), ALLOCATABLE :: sdData2(:,:) !(MNP,NFEN) subdomain data
   207:           !      REAL(8), ALLOCATABLE :: fdData2D(:)  !(MNP)    2D full domain data
   208:           !      REAL(8), ALLOCATABLE :: sdData2D(:)  !(MNP)    2D subdomain data
   209:           !      REAL(8), ALLOCATABLE :: fdData2D2(:) !(MNP)    2D full domain data
   210:           !      REAL(8), ALLOCATABLE :: sdData2D2(:) !(MNP)    2D subdomain data
   211:                 LOGICAL success        ! .true. if all files opened successfully
   212:           
   213:                 if (IDEN.lt.5) then
   214:                    CALL OpenPrepFiles(11, 'initial density forcing       ',
   215:                &                      1, nproc, sdu, success)
   216:                 else
   217:                    WRITE(*,*) 'NOTE: Unit 11 file will be from netCDF.'
   218:                    RETURN ! note early return
   219:                 endif
   220:           
   221:                 IF (.not.success) THEN
   222:                   WRITE(*,*) 'WARNING: Unit 11 files not preprocessed.'
   223:                   RETURN ! note early return
   224:                 ENDIF
   225:           C
   226:           C     Read header information from full domain unit 11 file
   227:                 READ(11,80) header1
   228:                 READ(11,80) header2
   229:           C
   230:           C     Transcribe header information.
   231: +------>        DO iproc = 1, nproc
   232: |                  WRITE(sdu(iproc),80)  header1
   233: |                  WRITE(sdu(iproc),80)  header2
   234: +------         ENDDO
   235:           C
   236:           C     Check node number data for consistency (paranoia).
   237:                 READ(11,80) nvn_nvp
   238:                 IF (C2DDI) THEN
   239:                    READ(nvn_nvp,*) nvp
   240:                    nvn = nfen
   241:                 ELSE
   242:                    READ(nvn_nvp,*) nvn, nvp
   243:                 ENDIF
   244:                 IF ( nvn .ne. nfen .or. nvp .ne. nnodg ) then
   245:                    WRITE(*,*) 'WARNING: NVN or NVP not consistent with input data'
   246:                    WRITE(*,*) 'NVN=',nvn,' although NFEN=',nfen
   247:                    WRITE(*,*) 'NVP=',nvp,' although NNODG=',nnodg
   248:                 ENDIF
   249:           C
   250:           C     Decompose density forcing data; format based on value of IDEN.
   251:           C     jgf45.12 This is designed to work for baroclinic 3D runs only, not
   252:           C     2D runs.
   253:           C     WJP 03.11.2018 made to work for 2D runs too
   254:           
   255:                 IF (C2DDI) THEN
   256:                    ALLOCATE ( FD2D_MSG(MNP) )
   257:                    nbytes = 120*mnp
   258:                    call memory_alloc(nbytes)
   259: +======>           FD2D_MSG = '';
   260:                 ELSE
   261:                    ALLOCATE ( FD_MSG(MNP,NFEN) )
   262:                    nbytes = 120*mnp*nfen
   263:                    call memory_alloc(nbytes)
   264:                 ENDIF
   265:           
   266: +------>        DO looper = 1,100000 ! until end
   267: |                  IF (C2DDI) THEN
   268: |+----->              DO i=1, nvp
   269: ||                       READ(11,'(A120)',END=411) Dummy ! get a flo val for this f.d. flow node
   270: ||+---->                 do k = 1,len_trim(Dummy)
   271: |||                         if (Dummy(k:k).eq.' '.or.Dummy(k:k).eq.',') exit
   272: ||+----                  enddo
   273: ||                       READ(Dummy(1:k-1),*) nhnn
   274: ||+====>                 FD2D_MSG(nhnn) = Dummy(k+1:120)
   275: ||                       !write(6,*) nhnn, FD2D_MSG(nhnn)
   276: |+-----               ENDDO
   277: |                  ELSE
   278: |+----->              DO i=1, nvp
   279: ||+---->                 DO j=1, nfen
   280: |||                         READ(11,*,END=411) nhnn, nvnn, FD_MSG(nhnn,nvnn) ! get a flo val for this f.d. flow node
   281: |||                         READ(FD_MSG,*) nvn, nvp
   282: ||+----                  ENDDO
   283: |+-----               ENDDO
   284: |                  ENDIF
   285: |         
   286: |                  IF (C2DDI) THEN
   287: |+----->              DO iproc = 1, nproc
   288: ||                       IF (looper.eq.1) THEN
   289: ||                          nodepnw = 0
   290: ||                          ! Find number of nodes with non-zero values for this processor
   291: ||S---->                    DO i=1, nnodp(iproc)
   292: |||                            IF (len_trim(FD2D_MSG(IMAP_NOD_LG(i,iproc))).gt.0) THEN
   293: |||                               nodepnw = nodepnw + 1
   294: |||                            ENDIF
   295: ||S----                     ENDDO
   296: ||                          WRITE(sdu(iproc),*) nodepnw
   297: ||                       ENDIF
   298: ||+---->                 DO i=1, nnodp(iproc)
   299: |||                         IF (len_trim(FD2D_MSG(IMAP_NOD_LG(i,iproc))).gt.0) THEN
   300: |||                            WRITE(sdu(iproc),81) i, FD2D_MSG(IMAP_NOD_LG(i,iproc))
   301: |||                         ENDIF
   302: ||+----                  ENDDO
   303: |+-----               ENDDO
   304: |                  ELSE
   305: |+----->              DO iproc = 1, nproc
   306: ||                      IF (looper.eq.1) WRITE(sdu(iproc),*) nfen, nnodp(iproc)
   307: ||+---->                 DO i=1, nnodp(iproc)
   308: |||+--->                    DO j=1, nfen
   309: ||||                          IF (FD_MSG(IMAP_NOD_LG(i,iproc),j)(1:1).ne.' ') THEN
   310: ||||                             WRITE(sdu(iproc),82) i, j, FD_MSG(IMAP_NOD_LG(i,iproc),j)
   311: ||||                          ENDIF
   312: |||+---                     ENDDO
   313: ||+----                  ENDDO
   314: |+-----               ENDDO
   315: |                  ENDIF
   316: +------         END DO
   317:            411  CLOSE (11)
   318: +------>        DO IPROC=1, NPROC
   319: |                  CLOSE (SDU(IPROC))
   320: +------         ENDDO
   321:           
   322:           
   323:           
   324:           
   325:           !      SELECT CASE (ABS(IDEN))
   326:           
   327:           
   328:           c     read in the full domain data
   329:           !         IF (C2DDI) THEN
   330:           !            ALLOCATE ( fdData2D(MNP) )
   331:           !            nbytes = 8*mnp
   332:           !            call memory_alloc(nbytes)
   333:           !            DO i=1, NNODG
   334:           !               READ(11,*) nhnn, fdData2D(nhnn)
   335:           !            ENDDO
   336:           !         ELSE
   337:           !            ALLOCATE ( fdData1(MNP,NFEN) )
   338:           !            nbytes = 8*mnp*nfen
   339:           !            call memory_alloc(nbytes)
   340:           !            DO i=1, NNODG
   341:           !               DO j=1, nfen
   342:           !                 READ(11,*) nhnn, nvnn, fdData1(nhnn,nvnn)
   343:           !               ENDDO
   344:           !           ENDDO
   345:           !         ENDIF
   346:           
   347:           c     write out subdomain data
   348:           !         IF (C2DDI) THEN
   349:           !            ALLOCATE ( sdData2D(MNP) )
   350:           !            nbytes = 8*mnp
   351:           !            call memory_alloc(nbytes)
   352:           !            DO iproc = 1, nproc
   353:           !               WRITE(sdu(iproc),*) nnodp(iproc)
   354:           !               DO i=1, nnodp(iproc)
   355:           !                  sdData2D(i) = fdData2D(IMAP_NOD_LG(i,iproc))
   356:           !                  WRITE(sdu(iproc),*) i, sdData2D(i)
   357:           !               ENDDO
   358:           !            ENDDO
   359:           !            DEALLOCATE ( fdData2D, sdData2D )
   360:           !            nbytes = 16*mnp
   361:           !            call memory_dealloc(nbytes)
   362:           !         ELSE
   363:           !            ALLOCATE ( sdData1(MNP,NFEN) )
   364:           !            nbytes = 8*mnp*nfen
   365:           !            call memory_alloc(nbytes)
   366:           !            DO iproc = 1, nproc
   367:           !               WRITE(sdu(iproc),*) nfen, nnodp(iproc)
   368:           !                DO i=1, nnodp(iproc)
   369:           c                  DO j=1, nfen
   370:           !                     sdData1(i,j) = fdData1(IMAP_NOD_LG(i,iproc),j)
   371:           !                     WRITE(sdu(iproc),*) i, j, sdData1(i,j)
   372:           !                  ENDDO
   373:           c               ENDDO
   374:           !           ENDDO
   375:           !            DEALLOCATE ( fdData1, sdData1 )
   376:           !            nbytes = 16*mnp*nfen
   377:           !            call memory_dealloc(nbytes)
   378:           !         ENDIF
   379:           !
   380:           !
   381:           !      CASE(4,5)
   382:           !
   383:           !C start by allocating
   384:           !         IF (C2DDI) THEN
   385:           !            ALLOCATE ( fdData2D(MNP), fdData2D2(MNP) )
   386:           !            fdData2D = 0.0d0; fdData2D2 = 0.0d0
   387:           !            nbytes = 16*mnp
   388:           !            call memory_alloc(nbytes)
   389:           !            ALLOCATE ( sdData2D(MNP), sdData2D2(MNP) )
   390:           !            nbytes = 16*mnp
   391:           !             call memory_alloc(nbytes)
   392:           c         ELSE
   393:           !            ALLOCATE ( fdData1(MNP,NFEN) )
   394:           !            ALLOCATE ( fdData2(MNP,NFEN) )
   395:           !            nbytes = 16*mnp*nfen
   396:           !            call memory_alloc(nbytes)
   397:           !            ALLOCATE ( sdData1(MNP,NFEN) )
   398:           !            ALLOCATE ( sdData2(MNP,NFEN) )
   399:           !            nbytes = 16*mnp*nfen
   400:           !            call memory_alloc(nbytes)
   401:           !         ENDIF
   402:           !C
   403:           !C--While ( NOT EOF ) Read densities from Global File
   404:           !C
   405:           !      looper = 0
   406:           !      DO WHILE(.true.)
   407:           !
   408:           !         looper = looper + 1
   409:           !
   410:           !c     read in the full domain data
   411:           !         IF (C2DDI) THEN
   412:           !            DO i=1, nvp
   413:           !               READ(11,*,iostat=eof) nhnn,fdData2D(nhnn),fdData2D2(nhnn)
   414:           c               IF (eof.ne.0) EXIT
   415:           !            ENDDO
   416:           !         ELSE
   417:           !            DO i=1, nvp
   418:           !              DO j=1, nfen
   419:           !                  READ(11,*,iostat=eof) nhnn, nvnn,
   420:           !     &                fdData1(nhnn,nvnn),fdData2(nhnn,nvnn)
   421:           !                  IF (eof.ne.0) EXIT
   422:           !               ENDDO
   423:           !               IF (eof.ne.0) EXIT
   424:           !            ENDDO
   425:           c         ENDIF
   426:           !
   427:           !C        EOF reached, lets exit
   428:           !         IF (eof < 0) EXIT
   429:           c
   430:           !c     write out subdomain data
   431:           !         IF (C2DDI) THEN
   432:           !            DO iproc = 1, nproc
   433:           !               IF (looper.eq.1) WRITE(sdu(iproc),*) nnodp(iproc)
   434:           !               DO i=1, nnodp(iproc)
   435:           !                  sdData2D(i) = fdData2D(IMAP_NOD_LG(i,iproc))
   436:           !                  sdData2D2(i) = fdData2D2(IMAP_NOD_LG(i,iproc))
   437:           !                  WRITE(sdu(iproc),*) i, sdData2D(i), sdData2D2(i)
   438:           !               ENDDO
   439:           !            ENDDO
   440:           !         ELSE
   441:           !            DO iproc = 1, nproc
   442:           !              IF (looper.eq.1) WRITE(sdu(iproc),*) nfen, nnodp(iproc)
   443:           !               DO i=1, nnodp(iproc)
   444:           !                  DO j=1, nfen
   445:           !                    sdData1(i,j) = fdData1(IMAP_NOD_LG(i,iproc),j)
   446:           !                    sdData2(i,j) = fdData2(IMAP_NOD_LG(i,iproc),j)
   447:           !                    WRITE(sdu(iproc),*) i, j, sdData1(i,j), sdData2(i,j)
   448:           c                  ENDDO
   449:           !               ENDDO
   450:           !            ENDDO
   451:           !         ENDIF
   452:           !
   453:           !      ENDDO
   454:           !
   455:           !C       deallocating
   456:           !         IF (C2DDI) THEN
   457:           !            DEALLOCATE ( fdData2D, sdData2D )
   458:           !            DEALLOCATE ( fdData2D2, sdData2D2 )
   459:           !            nbytes = 32*mnp
   460:           !            call memory_dealloc(nbytes)
   461:           !         ELSE
   462:           !            DEALLOCATE ( fdData1, fdData2 )
   463:           !            DEALLOCATE ( sdData1, sdData2 )
   464:           !            nbytes = 32*mnp*nfen
   465:           !            call memory_dealloc(nbytes)
   466:           !         ENDIF
   467:           !
   468:           !      END SELECT
   469:           !
   470:           cC
   471:           !C     Close full domain file and all subdomain files
   472:           !      CLOSE(11)
   473:           !      DO iproc=1, nproc
   474:           !          CLOSE(sdu(iproc))
   475:           !      ENDDO
   476:           C
   477:             80  FORMAT(A80)
   478:             81  FORMAT(I10,1x,A120)
   479:             82  FORMAT(2(I10),1x,A120)
   480:            1100 FORMAT(I10,32000(2X,E16.8))
   481:           C
   482:                 call memory_status()
   483:                 RETURN
   484:           C---------------------------------------------------------------------------
   485:                 END SUBROUTINE PREP11


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP11
INLINE LIST

  ROOT: PREP11 (prep.F:183)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:258)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:263)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:482)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP11
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:231)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:231)
  LOOP END

  LOOP BEGIN: (prep.F:259)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:259)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:259)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:266)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:266)

    LOOP BEGIN: (prep.F:278)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:278)

      LOOP BEGIN: (prep.F:279)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:279)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:268)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:268)
      *** Unvectorizable loop structure. (prep.F:268)

      LOOP BEGIN: (prep.F:270)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:270)
      LOOP END

      LOOP BEGIN: (prep.F:270)
        <Unvectorized loop.>
        *** Unvectorizable data type. : DUMMY (prep.F:270)
      LOOP END

      LOOP BEGIN: (prep.F:274)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:274)
      LOOP END

      LOOP BEGIN: (prep.F:274)
        <Unvectorized loop.>
        *** Unvectorizable data type. : FD2D_MSG (prep.F:274)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:305)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:307)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:308)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:308)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:287)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:291)
        <Partially vectorized loop.>
        *** Unvectorizable data type. : FD2D_MSG (prep.F:291)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:291)
        *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:291)

        LOOP BEGIN: (prep.F:292)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:292)
          *** Unvectorizable data type. : FD2D_MSG (prep.F:292)
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:298)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:298)

        LOOP BEGIN: (prep.F:299)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:299)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:318)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:318)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:20 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP11
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 53 [s0-s12 s15-s16 s18-s38 s47-s63]
      Vector registers         :  8 [v56-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 6976 bytes
      Register spill area      :  552 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 6168 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:231)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER TRANSFER          : 14
  LOOP END

  LOOP BEGIN: (prep.F:259)
    *** Estimated execution cycle                       : 5

    LOOP BEGIN: (prep.F:259)
      *** Estimated execution cycle                     : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:266)
    *** Estimated execution cycle                       : 329
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 68
            Over basic blocks                           : 68
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 70
            Over basic blocks                           : 70
    *** The number of SCALAR REGISTER TRANSFER          : 37

    LOOP BEGIN: (prep.F:278)
      *** Estimated execution cycle                     : 13
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 3

      LOOP BEGIN: (prep.F:279)
        *** Estimated execution cycle                   : 131
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 2
                Across calls                            : 1
                Others                                  : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 4
                Across calls                            : 1
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER TRANSFER      : 21
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:268)
      *** Estimated execution cycle                     : 178
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 2
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 2
              Over basic blocks                         : 7
      *** The number of SCALAR REGISTER TRANSFER        : 64

      LOOP BEGIN: (prep.F:270)
        *** Estimated execution cycle                   : 7
      LOOP END

      LOOP BEGIN: (prep.F:270)
        *** Estimated execution cycle                   : 16
      LOOP END

      LOOP BEGIN: (prep.F:274)
        *** Estimated execution cycle                   : 6
      LOOP END

      LOOP BEGIN: (prep.F:274)
        *** Estimated execution cycle                   : 5
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:305)
      *** Estimated execution cycle                     : 91
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Across calls                              : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 24

      LOOP BEGIN: (prep.F:307)
        *** Estimated execution cycle                   : 14
        *** The number of SCALAR REGISTER TRANSFER      : 4

        LOOP BEGIN: (prep.F:308)
          *** Estimated execution cycle                 : 118
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 4
                  Across calls                          : 4
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 7
                  Across calls                          : 7
          *** The number of SCALAR REGISTER TRANSFER    : 22
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:287)
      *** Estimated execution cycle                     : 194
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 4
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 4
              Over basic blocks                         : 3
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 48

      LOOP BEGIN: (prep.F:291)
        *** Estimated execution cycle                   : 224
      LOOP END

      LOOP BEGIN: (prep.F:291)
        *** Estimated execution cycle                   : 15
        *** The number of SCALAR REGISTER TRANSFER      : 3

        LOOP BEGIN: (prep.F:292)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:291)
        *** Estimated execution cycle                   : 118
      LOOP END

      LOOP BEGIN: (prep.F:298)
        *** Estimated execution cycle                   : 102
        *** The number of SCALAR REGISTER TRANSFER      : 24

        LOOP BEGIN: (prep.F:299)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:318)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: RELOCALIZE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   517: vec( 101): Vectorized loop.
   524: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
   545: vec( 110): Vectorization obstructive procedure reference.: IWRITE
   545: vec( 180): I/O statement obstructs vectorization.
   547: inl(1212): Source for routine not found.: IWRITE
   547: opt(1025): Reference to this procedure inhibits optimization.: IWRITE
   553: vec( 103): Unvectorized loop.
   553: vec( 180): I/O statement obstructs vectorization.
   554: opt(1118): This I/O statement inhibits optimization of loop.
   567: vec( 103): Unvectorized loop.
   567: vec( 180): I/O statement obstructs vectorization.
   569: opt(1118): This I/O statement inhibits optimization of loop.
   575: vec( 103): Unvectorized loop.
   575: vec( 180): I/O statement obstructs vectorization.
   576: opt(1118): This I/O statement inhibits optimization of loop.
   587: vec( 103): Unvectorized loop.
   587: vec( 180): I/O statement obstructs vectorization.
   588: opt(1118): This I/O statement inhibits optimization of loop.
   596: vec( 103): Unvectorized loop.
   596: vec( 180): I/O statement obstructs vectorization.
   597: opt(1118): This I/O statement inhibits optimization of loop.
   601: vec( 103): Unvectorized loop.
   601: vec( 180): I/O statement obstructs vectorization.
   602: opt(1118): This I/O statement inhibits optimization of loop.
   613: vec( 103): Unvectorized loop.
   613: vec( 180): I/O statement obstructs vectorization.
   614: opt(1118): This I/O statement inhibits optimization of loop.
   625: vec( 101): Vectorized loop.
   628: vec( 103): Unvectorized loop.
   628: vec( 113): Overhead of loop division is too large.
   629: vec( 102): Partially vectorized loop.
   631: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: ITOTPROC
   635: vec( 101): Vectorized loop.
   636: vec( 126): Idiom detected.: MAX/MIN
   647: vec( 101): Vectorized loop.
   650: vec( 103): Unvectorized loop.
   650: vec( 113): Overhead of loop division is too large.
   651: vec( 102): Partially vectorized loop.
   653: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: ITOTPROC
   655: vec( 122): Dependency unknown. Unvectorizable dependency is assumed.: IMAP_NOD_GL2
   669: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   669: vec( 101): Vectorized loop.
   670: vec( 101): Vectorized loop.
   673: opt(3014): Moved reference within a conditional branch.
   683: vec( 101): Vectorized loop.
   684: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   684: vec( 102): Partially vectorized loop.
   687: opt(3014): Moved reference within a conditional branch.
   687: vec( 101): Vectorized loop.
   692: opt(3014): Moved reference within a conditional branch.
   692: vec( 101): Vectorized loop.
   699: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   699: vec( 101): Vectorized loop.
   700: vec( 101): Vectorized loop.
   703: opt(3014): Moved reference within a conditional branch.
   706: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: RELOCALIZE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   500:                 SUBROUTINE RELOCALIZE()
   501:           C---------------------------------------------------------------------------
   502:                 USE PRE_GLOBAL
   503:                 USE PREP_WEIR,ONLY:NWEIRBNDRY
   504:                 use memory_usage
   505:                 IMPLICIT NONE
   506:                 integer(8) :: nbytes = 0
   507:                 INTEGER I, J, K, IPROC, INDX, ITEMP, idumy
   508:                 CHARACTER(14) LOCFN
   509:                 CHARACTER(80) skipped
   510:                 INTEGER,ALLOCATABLE :: LUNP(:)
   511:                 LOGICAL,ALLOCATABLE :: ISWEIR(:)
   512:           C
   513:                 print *, "entering relocalize"
   514:           !      print *, "nproc = ", nproc
   515:           
   516:                 allocate( lunp(nproc) )  ! logical unit number for each subdomain
   517: V------>        do iproc=1, nproc
   518: |                  lunp(iproc) = 105 + (iproc-1)
   519: V------         enddo
   520:           
   521:                 if (.not.allocated(nnodp)) then
   522:                   ALLOCATE(NNODP(NPROC))
   523:                   nbytes = 4*nproc
   524:                   call memory_alloc(nbytes)
   525:                 endif
   526:           
   527:                 if (.not.allocated(nelp)) then
   528:                   ALLOCATE(NELP(NPROC))
   529:                   nbytes = 4*nproc
   530:                   call memory_alloc(nbytes)
   531:                 endif
   532:           
   533:                 if (.not.allocated(netap)) then
   534:                   ALLOCATE(NETAP(NPROC))
   535:                   nbytes = 4*nproc
   536:                   call memory_alloc(nbytes)
   537:                 endif
   538:           
   539:                 if (.not.allocated(nfluxfp)) then
   540:                   ALLOCATE(NFLUXFP(NPROC))
   541:                   nbytes = 4*nproc
   542:                   call memory_alloc(nbytes)
   543:                 endif
   544:           
   545: +------>        DO IPROC = 1,NPROC
   546: |+=====>           LOCFN(1:14) = 'PE0000/fort.18'
   547: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
   548: |                  OPEN (LUNP(IPROC),FILE=LOCFN)
   549: +------         ENDDO
   550:           
   551:           
   552:                 print *, "from relocalize: reading local-to-global element maps"
   553: +------>        DO IPROC = 1,NPROC
   554: |                  READ(LUNP(IPROC),'(A)') skipped    !  read past fileFmt header
   555: |         Casey 100208: Changed I8 to I12.
   556: |                  READ(LUNP(IPROC),'(8X,3I12)') NELG, MNEP, NELP(IPROC)
   557: +------         ENDDO
   558:           !      print *, "nelg = ", nelg
   559:           
   560:                 if (.not.allocated(imap_el_lg)) then
   561:                   ALLOCATE ( IMAP_EL_LG(MNEP, NPROC) )
   562:                   nbytes = 4*nproc*mnep
   563:                   call memory_alloc(nbytes)
   564:                 endif
   565:           
   566: +------>        DO IPROC = 1,NPROC
   567: |+----->        DO I=1, NELP(IPROC)
   568: ||        Casey 100208: Changed I8 to I12.
   569: ||                 READ(LUNP(IPROC),'(I12)') idumy
   570: ||                 IMAP_EL_LG(I,IPROC) = abs(idumy)
   571: |+-----         ENDDO
   572: +------         ENDDO
   573:           
   574:                 print *, "from relocalize: reading local-to-global node maps"
   575: +------>        DO IPROC = 1,NPROC
   576: |                  READ(LUNP(IPROC),'(8X,3I12)') NNODG, MNPP, NNODP(IPROC)   !tcm v50.21
   577: +------         ENDDO
   578:           !      print *, "nnodg = ", nnodg
   579:           
   580:                 if (.not.allocated(imap_nod_lg)) then
   581:                    ALLOCATE ( IMAP_NOD_LG(MNPP, NPROC) )
   582:                    nbytes = 4*nproc*mnpp
   583:                    call memory_alloc(nbytes)
   584:                 endif
   585:           
   586: +------>        DO IPROC = 1,NPROC
   587: |+----->        DO I=1, NNODP(IPROC)
   588: ||                 READ(LUNP(IPROC),'(I12)') idumy        !tcm v50.21
   589: ||                 IMAP_NOD_LG(I,IPROC) = abs(idumy)
   590: |+-----         ENDDO
   591: +------         ENDDO
   592:           
   593:           C  This section for prep15
   594:                 IF ((PREP_15.eqv..true.).or.(PREP_20.eqv..true.)) THEN
   595:                   print *, "from relocalize: reading nfluxf for each subdomain"
   596: +------>          DO IPROC = 1,NPROC
   597: |                    READ(LUNP(IPROC),'(8X,I12)') NFLUXFP(IPROC)        !tcm v50.21
   598: +------           ENDDO
   599:           
   600:                   print *, "from relocalize: reading neta for each subdomain"
   601: +------>          DO IPROC = 1,NPROC
   602: |                    READ(LUNP(IPROC),'(8X,3I12)') idumy, NETA_MAX, NETAP(IPROC)   !tcm v50.21
   603: +------           ENDDO
   604:           
   605:                   if (.not.allocated(obnode_lg)) then
   606:                      ALLOCATE ( OBNODE_LG(NETA_MAX, NPROC) )
   607:                      nbytes = 4*nproc*neta_max
   608:                      call memory_alloc(nbytes)
   609:                   endif
   610:           
   611:                   print *, "from relocalize: reading open boundary table"
   612: +------>          DO IPROC = 1,NPROC
   613: |+----->             DO I=1, NETAP(IPROC)
   614: ||                      READ(LUNP(IPROC),'(I12)') OBNODE_LG(I,IPROC)    !tcm v50.21
   615: |+-----              ENDDO
   616: +------           ENDDO
   617:                 ENDIF
   618:           
   619:           ! Build Global-to-Local Node Map
   620:                 if (.not.allocated(itotproc)) then
   621:                   ALLOCATE ( ITOTPROC(NNODG) )
   622:                   nbytes = 4*nnodg
   623:                   call memory_alloc(nbytes)
   624:                 endif
   625: V------>        DO I = 1,NNODG
   626: |                  ITOTPROC(I) = 0
   627: V------         ENDDO
   628: +------>        DO IPROC = 1,NPROC
   629: |S----->           DO I = 1,NNODP(IPROC)
   630: ||                    INDX = IMAP_NOD_LG(I,IPROC)
   631: ||                    ITOTPROC(INDX) = ITOTPROC(INDX) + 1
   632: |S-----            ENDDO
   633: +------         ENDDO
   634:                 MNEI = 0
   635: V------>        DO I = 1,NNODG
   636: |                  IF (ITOTPROC(I) .gt. MNEI) MNEI = ITOTPROC(I)
   637: V------         ENDDO
   638:                 print *, "MNEI = ", MNEI
   639:           
   640:                 if (.not.allocated(imap_nod_gl2)) then
   641:                   ALLOCATE( IMAP_NOD_GL2( 2*MNEI, NNODG) )
   642:                   nbytes = 8*mnei*nnodg
   643:                   call memory_alloc(nbytes)
   644:                 endif
   645:                 print *, "allocated imap_nod_GL2"
   646:           
   647: V------>        DO I = 1,NNODG
   648: |                  ITOTPROC(I) = 0
   649: V------         ENDDO
   650: +------>        DO IPROC = 1,NPROC
   651: |S----->           DO J = 1,NNODP(IPROC)
   652: ||                    INDX = IMAP_NOD_LG(J,IPROC)
   653: ||                    ITOTPROC(INDX) = ITOTPROC(INDX) + 1
   654: ||                    ITEMP = (ITOTPROC(INDX)-1)*2 + 1
   655: ||                    IMAP_NOD_GL2(ITEMP,INDX) = IPROC
   656: ||                    IMAP_NOD_GL2(ITEMP+1,INDX) = J
   657: |S-----            ENDDO
   658: +------         ENDDO
   659:           
   660:                 !jgf50.35: Need this for --prep13 option.
   661:                 if (.not.allocated(imap_nod_gl)) then
   662:                    ALLOCATE (IMAP_NOD_GL(2,NNODG))
   663:                    nbytes = nbytes + 8*mnp
   664:                    call memory_alloc(nbytes)
   665:                 endif
   666:                 print *, "allocated imap_nod_GL"
   667:                 ! jgf50.35: Formulate the global-to-local
   668:                 ! mapping for resident nodes
   669: V------>        DO IPROC=1,NPROC
   670: |V----->           DO J=1,NNODP(IPROC)
   671: ||                    INDX = IMAP_NOD_LG(J,IPROC)
   672: ||      G             IF (ITOTPROC(INDX).eq.1) THEN
   673: ||      C                IMAP_NOD_GL(1,INDX) = IPROC
   674: ||      C                IMAP_NOD_GL(2,INDX) = J
   675: ||                    ENDIF
   676: |V-----            ENDDO
   677: V------         ENDDO
   678:                 !zc...If we're using time varying weirs, we need to
   679:                 !     find out which processors have weir (4,24,64) boundaries
   680:                 !     in the case that we're not passing through PREP14
   681:                 IF(USE_TVW)THEN
   682:                   ALLOCATE(ISWEIR(1:NNODG))
   683: V======>          ISWEIR(:) = .FALSE.
   684: S------>          DO K=1,NBOU
   685: |                     SELECT CASE(IBTYPE(K))
   686: |                         CASE(4,24,64,5,25)
   687: |V----->                      DO J=1,NVELL(K)
   688: ||      C                         ISWEIR(NBVV(K,J))=.TRUE.
   689: ||      C                         ISWEIR(IBCONNR(K,J))=.TRUE.
   690: |V-----                       ENDDO
   691: |                         CASE(3,13,23)
   692: |V----->                      DO J=1,NVELL(K)
   693: ||      C                         ISWEIR(NBVV(K,J))=.TRUE.
   694: |V-----                       ENDDO
   695: |                         CASE DEFAULT
   696: |                             I=I+NVELL(K)
   697: |                     END SELECT
   698: S------           ENDDO
   699: V------>          DO IPROC=1,NPROC
   700: |V----->              DO J=1,NNODP(IPROC)
   701: ||                        INDX=IMAP_NOD_LG(J,IPROC)
   702: ||      G                 IF(ISWEIR(INDX))NWEIRBNDRY(IPROC)=1
   703: |V-----               ENDDO
   704: V------           ENDDO
   705:                 ENDIF
   706:                 call memory_status()
   707:                 print *, "leaving relocalize"
   708:                 RETURN
   709:           C---------------------------------------------------------------------------
   710:                 END SUBROUTINE RELOCALIZE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: RELOCALIZE
INLINE LIST

  ROOT: RELOCALIZE (prep.F:500)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:524)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:530)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:536)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:542)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:547)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:563)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:583)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:608)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:623)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:643)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:664)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:706)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: RELOCALIZE
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:517)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:517)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:517)
  LOOP END

  LOOP BEGIN: (prep.F:545)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:545)
    *** I/O statement obstructs vectorization. (prep.F:545)

    LOOP BEGIN: (prep.F:546)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:546)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:553)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:553)
  LOOP END

  LOOP BEGIN: (prep.F:566)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:567)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:567)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:575)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:575)
  LOOP END

  LOOP BEGIN: (prep.F:586)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:587)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:587)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:596)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:596)
  LOOP END

  LOOP BEGIN: (prep.F:601)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:601)
  LOOP END

  LOOP BEGIN: (prep.F:612)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:613)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:613)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:625)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:625)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:625)
  LOOP END

  LOOP BEGIN: (prep.F:628)
    <Unvectorized loop.>
    *** Overhead of loop division is too large. (prep.F:628)

    LOOP BEGIN: (prep.F:629)
      <Partially vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:629)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:629)
      *** Dependency unknown. Unvectorizable dependency is assumed. : ITOTPROC (prep.F:631)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:635)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:635)
    *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:635)
    *** Idiom detected. : MAX/MIN (prep.F:636)
  LOOP END

  LOOP BEGIN: (prep.F:647)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:647)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:647)
  LOOP END

  LOOP BEGIN: (prep.F:650)
    <Unvectorized loop.>
    *** Overhead of loop division is too large. (prep.F:650)

    LOOP BEGIN: (prep.F:651)
      <Partially vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:651)
      *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:651)
      *** Dependency unknown. Unvectorizable dependency is assumed. : ITOTPROC (prep.F:653)
      *** Dependency unknown. Unvectorizable dependency is assumed. : IMAP_NOD_GL2 (prep.F:655)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:669)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:669)
    *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:669)

    LOOP BEGIN: (prep.F:670)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  1,  2. (prep.F:670)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:670)
      *** VGT generated (prep.F:672)
      *** VSC generated (prep.F:673)
      *** VSC generated (prep.F:674)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:683)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:683)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:683)
  LOOP END

  LOOP BEGIN: (prep.F:684)
    <Partially vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:684)
    *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:684)

    LOOP BEGIN: (prep.F:687)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  2. (prep.F:687)
      *** The number of VLOAD, VSTORE. :  2,  0. (prep.F:687)
      *** VSC generated (prep.F:688)
      *** VSC generated (prep.F:689)
    LOOP END

    LOOP BEGIN: (prep.F:692)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  1. (prep.F:692)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:692)
      *** VSC generated (prep.F:693)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:699)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:699)
    *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:699)

    LOOP BEGIN: (prep.F:700)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  1,  0. (prep.F:700)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:700)
      *** VGT generated (prep.F:702)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: RELOCALIZE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 56 [s0-s12 s15-s16 s18-s35 s41-s63]
      Vector registers         : 44 [v20-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 1840 bytes
      Register spill area      :  184 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 1320 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:517)
    *** Estimated execution cycle                       : 67
  LOOP END

  LOOP BEGIN: (prep.F:545)
    *** Estimated execution cycle                       : 82
    *** The number of SCALAR REGISTER TRANSFER          : 11

    LOOP BEGIN: (prep.F:546)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:553)
    *** Estimated execution cycle                       : 100
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Across calls                                : 5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 6
            Across calls                                : 6
    *** The number of SCALAR REGISTER TRANSFER          : 17
  LOOP END

  LOOP BEGIN: (prep.F:566)
    *** Estimated execution cycle                       : 23
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:567)
      *** Estimated execution cycle                     : 44
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:575)
    *** Estimated execution cycle                       : 50
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:586)
    *** Estimated execution cycle                       : 23
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:587)
      *** Estimated execution cycle                     : 44
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:596)
    *** Estimated execution cycle                       : 39
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:601)
    *** Estimated execution cycle                       : 50
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:612)
    *** Estimated execution cycle                       : 23
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:613)
      *** Estimated execution cycle                     : 42
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:625)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (prep.F:628)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER TRANSFER          : 15

    LOOP BEGIN: (prep.F:629)
      *** Estimated execution cycle                     : 160
    LOOP END

    LOOP BEGIN: (prep.F:629)
      *** Estimated execution cycle                     : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:635)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (prep.F:647)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (prep.F:650)
    *** Estimated execution cycle                       : 75
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER TRANSFER          : 20

    LOOP BEGIN: (prep.F:651)
      *** Estimated execution cycle                     : 224
    LOOP END

    LOOP BEGIN: (prep.F:651)
      *** Estimated execution cycle                     : 25
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:669)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (prep.F:669)
    *** Estimated execution cycle                       : 82
    *** The number of SCALAR REGISTER TRANSFER          : 22

    LOOP BEGIN: (prep.F:670)
      *** Estimated execution cycle                     : 459
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:683)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (prep.F:684)
    *** Estimated execution cycle                       : 61
  LOOP END

  LOOP BEGIN: (prep.F:684)
    *** Estimated execution cycle                       : 124
    *** The number of SCALAR REGISTER TRANSFER          : 24

    LOOP BEGIN: (prep.F:687)
      *** Estimated execution cycle                     : 209
    LOOP END

    LOOP BEGIN: (prep.F:692)
      *** Estimated execution cycle                     : 145
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:699)
    *** Estimated execution cycle                       : 96
  LOOP END

  LOOP BEGIN: (prep.F:699)
    *** Estimated execution cycle                       : 38
    *** The number of SCALAR REGISTER TRANSFER          : 13

    LOOP BEGIN: (prep.F:700)
      *** Estimated execution cycle                     : 200
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   766: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   766: vec( 108): Unvectorizable loop structure.
   788: opt(3014): Moved reference within a conditional branch.
   797: vec( 103): Unvectorized loop.
   797: vec( 180): I/O statement obstructs vectorization.
   798: opt(1118): This I/O statement inhibits optimization of loop.
   816: vec( 103): Unvectorized loop.
   816: vec( 108): Unvectorizable loop structure.
   816: vec( 118): Unvectorizable data type.: ATTRNAME
   816: vec( 118): Unvectorizable data type.
   817: opt(1118): This I/O statement inhibits optimization of loop.
   817: vec( 103): Unvectorized loop.
   817: vec( 180): I/O statement obstructs vectorization.
   830: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
   831: opt(1589): Outer loop moved inside inner loop(s).: IPROC
   831: vec( 101): Vectorized loop.
   832: opt(1592): Outer loop unrolled inside inner loop.: K
   838: inl(1214): Expansion routine is too big for automatic expansion.: PROCESSNODALATTR
   843: opt(1418): Constant-length loop is expanded.
   846: vec( 103): Unvectorized loop.
   846: vec( 180): I/O statement obstructs vectorization.
   847: opt(1418): Constant-length loop is expanded.
   848: opt(1118): This I/O statement inhibits optimization of loop.
   859: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
   863: vec( 103): Unvectorized loop.
   863: vec( 180): I/O statement obstructs vectorization.
   864: opt(1118): This I/O statement inhibits optimization of loop.
   877: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   732:                 subroutine prep13()
   733:           C---------------------------------------------------------------------------
   734:                 use pre_global, only : useNodalAttrNames, nnodg, nnodp, nproc,
   735:                &                       prep5354flag, prep2001flag
   736:                 use memory_usage
   737:                 use nodalattributes
   738:                 IMPLICIT NONE
   739:           C
   740:                 integer(8) :: nbytes = 0
   741:                 INTEGER ll             ! line loop counter
   742:                 INTEGER m              ! attribute default value counter
   743:                 INTEGER :: k
   744:                 INTEGER iproc          ! subdomain loop counter
   745:                 INTEGER sdu(nproc)     ! subdomain unit number for unit 13 files
   746:                 INTEGER NumNotDefault  ! number of nodes specified in the file
   747:                 CHARACTER(len=80) header   ! header comments in unit 13 files
   748:                 CHARACTER(len=80),ALLOCATABLE ::  AttrName(:) ! label for attribute!tgaf13mod
   749:                 CHARACTER(len=80) Units    ! label for physical units
   750:                 CHARACTER(len=80) Skipped  ! data we want to skip over
   751:                 REAL(8) DefaultVal(12) ! default value of attribute
   752:                 INTEGER, ALLOCATABLE :: NoOfVals(:) ! at each node for each attribute
   753:                 INTEGER Mode           !=0 to count, =1 to write
   754:                 LOGICAL success        ! .true. if all files opened successfully
   755:                 INTEGER, ALLOCATABLE :: SDNumND(:,:)  ! subdomain # of nodes not default
   756:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
   757:           C     time ... some platforms/compilers limit the number of files that
   758:           C     can be open at any one time.
   759:                 INTEGER, PARAMETER :: maxOpenFiles = 256
   760:                 INTEGER startProc
   761:                 INTEGER endProc
   762:                 INTEGER deltaProc
   763:           C
   764:           C     Perform decomposition over range of subdomains.
   765:                 startProc = 1
   766: +------>        DO WHILE ( startProc .le. nproc )
   767: |                  deltaProc = nproc - startProc
   768: |                  IF ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
   769: |                  endProc = startProc + deltaProc
   770: |         C
   771: |         C        Open full domain and subdomain fort.13 files.
   772: |                  CALL OpenPrepFiles(13, 'nodal attributes              ',
   773: |              &       startProc, endProc, sdu, success)
   774: |         C
   775: |                  IF (.not.success) THEN
   776: |                     WRITE(*,*) 'WARNING: Unit 13 files not preprocessed.'
   777: |                     RETURN ! note early return
   778: |                  ENDIF
   779: |         C
   780: |         C        Read header information from full domain unit 13 file
   781: |                  READ(13,'(A80)') header
   782: |                  READ(13,*) NumOfNodes     ! number of nodes according to unit 13
   783: |                  READ(13,*) NAttr          ! number of attributes in the unit 13 file
   784: |         C
   785: |         C        Check to make sure that the number of nodes in the nodal
   786: |         C        attributes file is the same as in the grid file (unit 14).
   787: |                  IF (NumOfNodes.NE.NNODG) THEN
   788: |                     WRITE(6,9900)
   789: |          9900       FORMAT(////,1X,'!!!!!!!!!!  FATAL ERROR  !!!!!!!!!',
   790: |              &        //,1X,'The number of nodes in the grid file (unit 14) and'
   791: |              &        /,1X,'the nodal attributes file (unit 13) must match.',
   792: |              &        //,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
   793: |                     CALL EXIT(1)                   ! We're toast.
   794: |                  ENDIF
   795: |         C
   796: |         C        Transcribe header information into subdomain unit 13 files
   797: |+----->           DO iproc = startProc, endProc
   798: ||                    WRITE(sdu(iproc),'(A80)') header
   799: ||                    WRITE(sdu(iproc),*) NNODP(iproc)
   800: ||                    WRITE(sdu(iproc),*) NAttr
   801: |+-----            ENDDO
   802: |         C
   803: |         C        Transcribe attribute names from full domain file to subdomains.
   804: |                  ALLOCATE(NoOfVals(NAttr))
   805: |                  ALLOCATE(AttrName(NAttr))!tgaf13mod
   806: |          
   807: |+----->           DO k=1, NAttr
   808: ||                    READ(13,'(A80)') AttrName(k)!tgaf13mod
   809: ||                    READ(13,'(A80)') Units
   810: ||                    READ(13,*) NoOfVals(k)
   811: ||+---->              READ(13,*) (DefaultVal(m),m=1,NoOfVals(k))
   812: ||+---->              DO iproc=startProc, endProc
   813: |||                      WRITE(sdu(IPROC),'(A80)') AttrName(k)!tgaf13mod
   814: |||                      WRITE(sdu(IPROC),'(A80)') Units
   815: |||                      WRITE(sdu(IPROC),*) NoOfVals(k)
   816: |||                      if (trim(adjustl(AttrName(k))).eq."condensed_nodes") then !sb20221013
   817: |||+--->                    WRITE(sdu(IPROC),'(99(1x,i10))')
   818: |||            &             (NINT(DefaultVal(m)),m=1,NoOfVals(k))
   819: |||                      else
   820: |||+--->                    WRITE(sdu(IPROC),'(12(1x,e16.9))')
   821: |||            &             (DefaultVal(m),m=1,NoOfVals(k))
   822: |||                      end if
   823: ||+----               END DO
   824: |+-----            END DO
   825: |         C
   826: |         C        Allocate and initialize the matrix for the number of Non Default
   827: |         C        nodes in each SubDomain for each nodal attribute
   828: |                  ALLOCATE(SDNumND(nproc,NAttr))
   829: |                  nbytes = 8*nproc*nattr
   830: |                  call memory_alloc(nbytes)
   831: |X----->           DO iproc=startProc,endProc
   832: ||U---->              DO k=1, NAttr
   833: |||                      SDNumND(iproc,k)=0
   834: ||U----               END DO
   835: |X-----            END DO
   836: |         C        We need to figure out how many nodes go into each subdomain
   837: |         C        for each attribute.
   838: |                  CALL processNodalAttr(NAttr, NoOfVals, 0, sdu, SDNumND,
   839: |              &      startProc, endProc, naType,AttrName)!tgaf13mod
   840: |         C
   841: |         C     Now rewind and advance to the beginning of the data again
   842: |                  REWIND(13)
   843: |*----->           DO ll=1, 3
   844: ||                    READ(13,*) skipped    ! skip header, NumOfNodes, NAttr
   845: |*-----            END DO
   846: |+----->           DO k=1, NAttr
   847: ||*---->              DO ll=1, 4
   848: |||                      READ(13,*) skipped ! skip AttrName,Units,NoOfVals,Default
   849: ||*----               END DO
   850: |+-----            END DO
   851: |         C
   852: |         C        Now read each of the nodal attributes and transcribe them to the
   853: |         C        appropriate subdomain.
   854: |                  CALL processNodalAttr(NAttr, NoOfVals, 1, sdu, SDNumND,
   855: |              &      startProc, endProc, naType,AttrName)!tgaf13mod
   856: |                  DEALLOCATE(SDNumND,NoOfVals)
   857: |                  DEALLOCATE(AttrName)!tgaf13mod
   858: |                  nbytes = 8*nproc*nattr
   859: |                  call memory_dealloc(nbytes)
   860: |         C
   861: |         C        Close full domain and subdomain files
   862: |                  CLOSE (13)
   863: |+----->           DO iproc=startProc, endProc
   864: ||                    CLOSE(sdu(iproc))
   865: |+-----            ENDDO
   866: |                  startProc = endProc + 1
   867: +------         END DO
   868:           C     DW
   869:                 IF ( .NOT. prep5354flag .and. .NOT. prep2001flag) THEN
   870:                    if (allocated(useNodalAttrNames)) then
   871:                       DEALLOCATE(useNodalAttrNames)
   872:                       nbytes = 4*nwp
   873:                       call memory_dealloc(nbytes)
   874:                    endif
   875:                 ENDIF
   876:           C
   877:                 call memory_status()
   878:                 RETURN
   879:           C---------------------------------------------------------------------------
   880:                 END SUBROUTINE PREP13


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13
INLINE LIST

  ROOT: PREP13 (prep.F:732)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:830)
     *** Source for routine not found.
  -> NOINLINE: PROCESSNODALATTR (prep.F:838)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: PROCESSNODALATTR (prep.F:854)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:859)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:873)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:877)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:766)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:766)

    LOOP BEGIN: (prep.F:797)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:797)
    LOOP END

    LOOP BEGIN: (prep.F:807)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:812)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:816)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:816)
        LOOP END

        LOOP BEGIN: (prep.F:816)
          <Unvectorized loop.>
          *** Unvectorizable data type. : ATTRNAME (prep.F:816)
        LOOP END

        LOOP BEGIN: (prep.F:816)
          <Unvectorized loop.>
          *** Unvectorizable data type. (prep.F:816)
        LOOP END

        LOOP BEGIN: (prep.F:816)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:816)
        LOOP END

        LOOP BEGIN: (prep.F:817)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:817)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:832)
      <Unvectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:832)

      LOOP BEGIN: (prep.F:831)
        <Vectorized loop.>
        **  Copied loop. : FOR UNROLLING (prep.F:831)
        **  Interchanged loop. (prep.F:831)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:831)
        *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:831)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:832)
      <Unvectorized loop.>
      **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:832)

      LOOP BEGIN: (prep.F:831)
        <Vectorized loop.>
        **  Interchanged loop. (prep.F:831)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:831)
        *** The number of VLOAD, VSTORE. :  0,  4. (prep.F:831)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:846)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:846)
    LOOP END

    LOOP BEGIN: (prep.F:863)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:863)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  2 [v62-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2928 bytes
      Register spill area      :  640 bytes
      Parameter area           :   80 bytes
      Register save area       :  176 bytes
      User data area           : 2032 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:732)
    *** Estimated execution cycle                       : 984
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 75
            Across calls                                :  9
            Over basic blocks                           : 56
            Others                                      : 10
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 107
            Across calls                                :  13
            Over basic blocks                           :  94
    *** The number of SCALAR REGISTER TRANSFER          : 151

    LOOP BEGIN: (prep.F:797)
      *** Estimated execution cycle                     : 117
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 8
      *** The number of SCALAR REGISTER TRANSFER        : 18
    LOOP END

    LOOP BEGIN: (prep.F:807)
      *** Estimated execution cycle                     : 204
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 11
              Across calls                              :  6
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 25
              Across calls                              : 11
              Over basic blocks                         : 14
      *** The number of SCALAR REGISTER TRANSFER        : 33

      LOOP BEGIN: (prep.F:812)
        *** Estimated execution cycle                   : 290
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 11
                Across calls                            :  7
                Over basic blocks                       :  3
                Others                                  :  1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 19
                Across calls                            : 11
                Over basic blocks                       :  7
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 65

        LOOP BEGIN: (prep.F:816)
          *** Estimated execution cycle                 : 8
        LOOP END

        LOOP BEGIN: (prep.F:816)
          *** Estimated execution cycle                 : 6
        LOOP END

        LOOP BEGIN: (prep.F:816)
          *** Estimated execution cycle                 : 5
        LOOP END

        LOOP BEGIN: (prep.F:816)
          *** Estimated execution cycle                 : 7
        LOOP END

        LOOP BEGIN: (prep.F:817)
          *** Estimated execution cycle                 : 23
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:831)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 9

      LOOP BEGIN: (prep.F:831)
        *** Estimated execution cycle                   : 63
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:831)
      *** Estimated execution cycle                     : 53
      *** The number of SCALAR REGISTER TRANSFER        : 18

      LOOP BEGIN: (prep.F:831)
        *** Estimated execution cycle                   : 164
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:846)
      *** Estimated execution cycle                     : 128
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  9
              Over basic blocks                         :  2
      *** The number of SCALAR REGISTER TRANSFER        : 23
    LOOP END

    LOOP BEGIN: (prep.F:863)
      *** Estimated execution cycle                     : 15
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESSNODALATTR
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

   929: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
   934: vec( 103): Unvectorized loop.
   934: vec( 108): Unvectorizable loop structure.
   934: vec( 118): Unvectorizable data type.: NA%ATTRNAME
   934: vec( 118): Unvectorizable data type.: CURATTRNAME
   941: vec( 103): Unvectorized loop.
   941: vec( 180): I/O statement obstructs vectorization.
   942: opt(1118): This I/O statement inhibits optimization of loop.
   947: vec( 181): Allocation obstructs vectorization.
   947: vec( 182): Deallocation obstructs vectorization.
   947: vec( 118): Unvectorizable data type.
   947: vec( 108): Unvectorizable loop structure.
   948: opt(1082): Backward transfers inhibit loop optimization.
   948: opt(1097): This statement prevents loop optimization.
   948: vec( 103): Unvectorized loop.
   948: vec( 108): Unvectorizable loop structure.
   948: vec( 118): Unvectorizable data type.: CURATTRNAME
   948: vec( 118): Unvectorizable data type.: ATTRNAME
   971: vec( 103): Unvectorized loop.
   971: vec( 180): I/O statement obstructs vectorization.
   972: opt(1118): This I/O statement inhibits optimization of loop.
   987: vec( 101): Vectorized loop.
   994: vec( 101): Vectorized loop.
  1008: vec( 103): Unvectorized loop.
  1008: vec( 108): Unvectorizable loop structure.
  1008: vec( 118): Unvectorizable data type.: CURATTRNAME
  1008: vec( 118): Unvectorizable data type.
  1009: opt(1118): This I/O statement inhibits optimization of loop.
  1009: opt(3014): Moved reference within a conditional branch.
  1009: vec( 103): Unvectorized loop.
  1009: vec( 180): I/O statement obstructs vectorization.
  1012: opt(3014): Moved reference within a conditional branch.
  1026: vec( 103): Unvectorized loop.
  1026: vec( 108): Unvectorizable loop structure.
  1026: vec( 118): Unvectorizable data type.: CURATTRNAME
  1026: vec( 118): Unvectorizable data type.
  1027: opt(1118): This I/O statement inhibits optimization of loop.
  1027: opt(3014): Moved reference within a conditional branch.
  1027: vec( 103): Unvectorized loop.
  1027: vec( 180): I/O statement obstructs vectorization.
  1030: opt(3014): Moved reference within a conditional branch.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESSNODALATTR
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

   898:                 subroutine processNodalAttr(NAttr, NumCol, mode, sdu, SDNumND,
   899:                &   startProc, endProc, naType,AttrName)!tgaf13mod
   900:                 use pre_global
   901:                 use sizes, only : ASCII, XDMF
   902:                 use nodalattributes, only : na
   903:                 implicit none
   904:           C
   905:                 INTEGER,intent(in) :: NAttr  ! number of attributes in the file
   906:                 INTEGER,intent(in),dimension(NAttr) :: NumCol !NumCol for attribute
   907:                 INTEGER,intent(in) :: Mode   !=0 to count and return, =1 to write
   908:                 INTEGER,intent(in),dimension(nproc) :: sdu !i/o unit number array
   909:                 INTEGER,intent(inout),dimension(nproc,NAttr) :: SDNumND
   910:                 INTEGER,intent(in) :: startProc
   911:                 INTEGER,intent(in) :: endProc
   912:                 INTEGER,intent(in) :: naType ! ascii and xdmf are supported
   913:                 CHARACTER(len=80),intent(in),dimension(NAttr) ::  AttrName ! label for attribute!tgaf13mod
   914:                 INTEGER NumNotDefault      ! number of nodes specified in the file
   915:                 INTEGER NodeNum            ! full domain node number
   916:                 INTEGER SDNode             ! subdomain node number
   917:                 INTEGER i                  ! node loop counter
   918:                 INTEGER j                  ! column loop counter
   919:                 INTEGER k                  ! attribute loop counter
   920:                 INTEGER m                  ! mapping loop counter
   921:                 INTEGER iproc              ! subdomain loop counter
   922:                 INTEGER iproc2             ! mapped subdomain
   923:                 CHARACTER(len=80) curAttrName ! label for current attribute!tgaf13mod
   924:                 REAL(8), ALLOCATABLE :: AttrData(:)  ! attribute data
   925:                 INTEGER :: curAttrInd      ! index corresponding to currently named attribute
   926:           
   927:                 CHARACTER(len=80) Skipped  ! data we want to skip over
   928:           C
   929: +------>        DO k=1, NAttr
   930: |                  select case(naType)
   931: |                  case(ASCII)
   932: |                     read(13,*) curAttrName!tgaf13mod
   933: |                  case(XDMF)
   934: |+=====>              curattrName = trim(adjustl(na(k)%attrName))!tgaf13mod
   935: |                  case default
   936: |                     write(6,'(a,i0,a)') 'ERROR: Nodal attribute file format ',naType,
   937: |              &         ' is not supported by adcprep.'
   938: |                    CALL EXIT(1)
   939: |                  end select
   940: |                  IF (Mode.eq.1) THEN
   941: |+----->              DO iproc=startProc,endProc
   942: ||                       WRITE(sdu(iproc),'(A80)') curAttrName!tgaf13mod
   943: |+-----               END DO
   944: |                  ENDIF
   945: |         CTGA 20180524: Adjusted code to better handle out-of-order attributes in the body
   946: |                  curAttrInd=-1
   947: |+----->           DO i=1,NAttr
   948: ||                    IF (TRIM(ADJUSTL(curAttrName)).eq.TRIM(ADJUSTL(AttrName(i)))) THEN
   949: ||                       curAttrInd=i
   950: ||                       EXIT
   951: ||                    ENDIF
   952: |+-----            ENDDO
   953: |                  !If a matching attribute wasn't found, write error and stop
   954: |                  IF (curAttrInd.EQ.-1) THEN
   955: |                     WRITE(6,'(A)')'ERROR: Nodal attribute in body could not be '
   956: |              &                    //'found in header: '//curAttrName
   957: |                     CALL EXIT(1)
   958: |                  ENDIF
   959: |                  ALLOCATE(attrData(numCol(curAttrInd)))!tgaf13mod
   960: |                  select case(naType)
   961: |                  case(ASCII)
   962: |                     read(13,*) numNotDefault
   963: |                  case(XDMF)
   964: |                     numNotDefault = na(k) % numNodesNotDefault
   965: |                  case default
   966: |                     write(6,'(a,i0,a)') 'ERROR: Nodal attribute file format ',naType,
   967: |              &         ' is not supported by adcprep.'
   968: |                    CALL EXIT(1)
   969: |                  end select
   970: |                  IF (Mode.eq.1) THEN
   971: |+----->              DO iproc=startProc,endProc
   972: ||                       WRITE(sdu(iproc),*) SDNumND(iproc,k)
   973: |+-----               END DO
   974: |                  ENDIF
   975: |+----->           DO i=1, NumNotDefault
   976: ||                    select case(naType)
   977: ||                    case(ASCII)
   978: ||+---->                 READ(13,*) nodeNum, (AttrData(j),j=1,NumCol(curAttrInd))!tgaf13mod
   979: ||                       IF (curAttrName.eq."sponge_generator_layer") THEN
   980: ||                          IF (AttrData(NumCol(curAttrInd)) > 0) THEN
   981: ||                             prep5354flag = .true.
   982: ||                          ENDIF
   983: ||                          IF (AttrData(NumCol(curAttrInd)).eq.-1.or.
   984: ||             &                AttrData(NumCol(curAttrInd)).eq.2) THEN
   985: ||                             prep2001flag = .true.
   986: ||                             IF (.not.allocated(nodeNumSP)) THEN
   987: ||V====>                           allocate(nodeNumSP(NumNotDefault)); nodeNumSP=0
   988: ||                             ENDIF
   989: ||                             nodeNumSP(i) = nodeNum
   990: ||                          ENDIF
   991: ||                       ENDIF
   992: ||                    case(XDMF)
   993: ||                       nodeNum = na(k) % nonDefaultNodes(i)
   994: ||V====>                 attrData(:) = na(k) % nonDefaultVals(:,nodeNum)
   995: ||                    case default
   996: ||                       write(6,'(a,i0,a)') 'ERROR: Nodal attribute file format ',naType,
   997: ||             &         ' is not supported by adcprep.'
   998: ||                       CALL EXIT(1)
   999: ||                    end select
  1000: ||                    IF (ITOTPROC(NodeNum).eq.1) THEN
  1001: ||                       iproc = IMAP_NOD_GL(1,NodeNum)
  1002: ||                       IF ( (iproc.lt.startProc) .or. (iproc.gt.endProc) ) THEN
  1003: ||                          CYCLE ! skip it if it does not map to our range of procs
  1004: ||                       ENDIF
  1005: ||                       IF (Mode.eq.0) SDNumND(iproc,k) = SDNumND(iproc,k)+1
  1006: ||                       IF (Mode.eq.1) THEN
  1007: ||                          SDNode = IMAP_NOD_GL(2,NodeNum)
  1008: ||                          IF (trim(adjustl(curAttrName)).eq."condensed_nodes") THEN !sb20221022
  1009: ||+---->                       WRITE(sdu(iproc),1101) NodeNum,
  1010: ||             &                  (NINT(AttrData(j)),j=1,NumCol(curAttrInd))!tgaf13mod
  1011: ||                          ELSE
  1012: ||+---->                       WRITE(sdu(iproc),1100) NodeNum,
  1013: ||             &                  (AttrData(j),j=1,NumCol(curAttrInd))!tgaf13mod
  1014: ||                          ENDIF
  1015: ||                       ENDIF
  1016: ||                    ELSE
  1017: ||+---->                 DO m=1, ITOTPROC(NodeNum)
  1018: |||                         iproc2 = IMAP_NOD_GL2(2*(m-1)+1,NodeNum)
  1019: |||+--->                    DO iproc=startProc, endProc
  1020: ||||                           IF (iproc.EQ.iproc2) THEN !f.d. node maps to this s.d.
  1021: ||||                              IF (Mode.eq.0) THEN
  1022: ||||                                 SDNumND(iproc,k)=SDNumND(iproc,k)+1
  1023: ||||                              ENDIF
  1024: ||||                              IF (Mode.eq.1) THEN
  1025: ||||                                 SDNode = IMAP_NOD_GL2(2*(m-1)+2,NodeNum)
  1026: ||||                                 IF (trim(adjustl(curAttrName)).eq."condensed_nodes") THEN !sb20221022
  1027: ||||+-->                                WRITE(sdu(iproc),1101) NodeNum,
  1028: ||||           &                             (NINT(AttrData(j)),j=1,NumCol(curAttrInd))
  1029: ||||                                 ELSE
  1030: ||||+-->                                WRITE(sdu(iproc),1100) NodeNum,
  1031: ||||           &                             (AttrData(j),j=1,NumCol(curAttrInd))!tgaf13mod
  1032: ||||                                 ENDIF
  1033: ||||                              ENDIF
  1034: ||||                           ENDIF
  1035: |||+---                     END DO
  1036: ||+----                  END DO
  1037: ||                    END IF
  1038: |+-----            END DO
  1039: |                  DEALLOCATE(AttrData)
  1040: |                  IF (Mode.eq.1) THEN
  1041: |                     WRITE(6,'(A25,A80)') '     Finished processing ', curAttrName!tgaf13mod
  1042: |                     WRITE(6,*) 'for processor range ',startProc,' to ',endProc
  1043: |                  ENDIF
  1044: +------         END DO
  1045:           C
  1046:           C
  1047:            1001 FORMAT('ERROR: The Nodal Attributes File (unit 13)')
  1048:            1021 FORMAT('contains invalid name: ',A80)
  1049:            1031 FORMAT('WARNING: Processed only one column of unrecognized ',A80)
  1050:            1100 FORMAT(I10,32000(2X,E16.8))
  1051:            1101 FORMAT(I10,32000(2X,I10))
  1052:           C
  1053:                 RETURN
  1054:           C     ----------------------------------------------------------------
  1055:                 END SUBROUTINE ProcessNodalAttr


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESSNODALATTR
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESSNODALATTR
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:929)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NA%ATTRNAME (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:934)
      <Unvectorized loop.>
      *** Unvectorizable data type. : CURATTRNAME (prep.F:934)
    LOOP END

    LOOP BEGIN: (prep.F:941)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:941)
    LOOP END

    LOOP BEGIN: (prep.F:947)
      <Unvectorized loop.>
      *** Allocation obstructs vectorization. (prep.F:947)
      *** Deallocation obstructs vectorization. (prep.F:947)
      *** Unvectorizable data type. (prep.F:947)
      *** Unvectorizable loop structure. (prep.F:947)

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable data type. : CURATTRNAME (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable data type. : ATTRNAME (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:948)
      LOOP END

      LOOP BEGIN: (prep.F:948)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:948)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:971)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:971)
    LOOP END

    LOOP BEGIN: (prep.F:975)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:987)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:987)
        *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:987)
      LOOP END

      LOOP BEGIN: (prep.F:994)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:994)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:994)
      LOOP END

      LOOP BEGIN: (prep.F:1017)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:1019)
          <Unvectorized loop.>

          LOOP BEGIN: (prep.F:1026)
            <Unvectorized loop.>
            *** Unvectorizable loop structure. (prep.F:1026)
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            <Unvectorized loop.>
            *** Unvectorizable data type. : CURATTRNAME (prep.F:1026)
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            <Unvectorized loop.>
            *** Unvectorizable data type. (prep.F:1026)
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            <Unvectorized loop.>
            *** Unvectorizable loop structure. (prep.F:1026)
          LOOP END

          LOOP BEGIN: (prep.F:1027)
            <Unvectorized loop.>
            *** I/O statement obstructs vectorization. (prep.F:1027)
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:1008)
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        <Unvectorized loop.>
        *** Unvectorizable data type. : CURATTRNAME (prep.F:1008)
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1008)
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:1008)
      LOOP END

      LOOP BEGIN: (prep.F:1009)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1009)
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESSNODALATTR
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 50 [s0-s12 s15-s16 s18-s35 s47-s63]
      Vector registers         :  2 [v62-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2816 bytes
      Register spill area      :  720 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1856 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:898)
    *** Estimated execution cycle                       : 1049
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 82
            Across calls                                : 10
            Over basic blocks                           : 70
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 125
            Across calls                                :  11
            Over basic blocks                           : 111
            Others                                      :   3
    *** The number of SCALAR REGISTER TRANSFER          : 246

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:934)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:941)
      *** Estimated execution cycle                     : 31
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:947)
      *** Estimated execution cycle                     : 165
      *** The number of SCALAR REGISTER TRANSFER        : 59

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 8
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 6
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 5
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 7
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 8
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 6
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 5
      LOOP END

      LOOP BEGIN: (prep.F:948)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:971)
      *** Estimated execution cycle                     : 27
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END

    LOOP BEGIN: (prep.F:975)
      *** Estimated execution cycle                     : 821
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 55
              Across calls                              : 24
              Over basic blocks                         : 29
              Others                                    :  2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 96
              Across calls                              : 28
              Over basic blocks                         : 67
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 130

      LOOP BEGIN: (prep.F:987)
        *** Estimated execution cycle                   : 63
      LOOP END

      LOOP BEGIN: (prep.F:994)
        *** Estimated execution cycle                   : 64
      LOOP END

      LOOP BEGIN: (prep.F:1017)
        *** Estimated execution cycle                   : 57
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Over basic blocks                       : 6
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 6
                Over basic blocks                       : 6
        *** The number of SCALAR REGISTER TRANSFER      : 9

        LOOP BEGIN: (prep.F:1019)
          *** Estimated execution cycle                 : 201
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 2
                  Over basic blocks                     : 2
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 6
                  Over basic blocks                     : 6
          *** The number of SCALAR REGISTER TRANSFER    : 65

          LOOP BEGIN: (prep.F:1026)
            *** Estimated execution cycle               : 8
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            *** Estimated execution cycle               : 6
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            *** Estimated execution cycle               : 5
          LOOP END

          LOOP BEGIN: (prep.F:1026)
            *** Estimated execution cycle               : 7
          LOOP END

          LOOP BEGIN: (prep.F:1027)
            *** Estimated execution cycle               : 23
            *** The number of SCALAR REGISTER TRANSFER  : 2
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        *** Estimated execution cycle                   : 8
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        *** Estimated execution cycle                   : 6
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        *** Estimated execution cycle                   : 5
      LOOP END

      LOOP BEGIN: (prep.F:1008)
        *** Estimated execution cycle                   : 7
      LOOP END

      LOOP BEGIN: (prep.F:1009)
        *** Estimated execution cycle                   : 23
        *** The number of SCALAR REGISTER TRANSFER      : 2
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13XDMF
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  1088: inl(1222): Inlined: NODALATTRIBUTES::READNODALATTRXDMF
  1092: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1092: vec( 181): Allocation obstructs vectorization.
  1092: vec( 182): Deallocation obstructs vectorization.
  1096: vec( 101): Vectorized loop.
  1097: vec( 101): Vectorized loop.
  1104: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1104: vec( 101): Vectorized loop.
  1106: opt(1019): Feedback of scalar value from one loop pass to another.: NONDEFAULTCOUNT
  1106: opt(3014): Moved reference within a conditional branch.
  1107: opt(3014): Moved reference within a conditional branch.
  1113: opt(3014): Moved reference within a conditional branch.
  1113: vec( 101): Vectorized loop.
  1114: vec( 103): Unvectorized loop.
  1114: vec( 113): Overhead of loop division is too large.
  1115: vec( 101): Vectorized loop.
  1122: opt(3014): Moved reference within a conditional branch.
  1122: vec( 101): Vectorized loop.
  1126: opt(1135): Outer loop conditionally executes inner loop.
  1126: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1126: vec( 102): Partially vectorized loop.
  1128: opt(3014): Moved reference within a conditional branch.
  1129: vec( 101): Vectorized loop.
  1146: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  1146: vec( 180): I/O statement obstructs vectorization.
  1146: vec( 181): Allocation obstructs vectorization.
  1146: vec( 182): Deallocation obstructs vectorization.
  1146: vec( 109): Vectorization obstructive statement.
  1148: vec( 103): Unvectorized loop.
  1148: vec( 118): Unvectorizable data type.: SDFILENAME
  1149: inl(1212): Source for routine not found.: IWRITE
  1149: opt(1025): Reference to this procedure inhibits optimization.: IWRITE
  1153: opt(1082): Backward transfers inhibit loop optimization.
  1153: vec( 103): Unvectorized loop.
  1153: vec( 108): Unvectorizable loop structure.
  1162: vec( 103): Unvectorized loop.
  1162: vec( 108): Unvectorizable loop structure.
  1162: vec( 118): Unvectorizable data type.: NODALATTRIBUTESCOMMENT
  1162: vec( 118): Unvectorizable data type.
  1166: vec( 103): Unvectorized loop.
  1166: vec( 108): Unvectorizable loop structure.
  1166: vec( 118): Unvectorizable data type.: NA%ATTRNAME
  1166: vec( 118): Unvectorizable data type.
  1167: vec( 103): Unvectorized loop.
  1167: vec( 108): Unvectorizable loop structure.
  1167: vec( 118): Unvectorizable data type.: NA%UNITS
  1167: vec( 118): Unvectorizable data type.
  1169: vec( 103): Unvectorized loop.
  1169: vec( 108): Unvectorizable loop structure.
  1169: vec( 118): Unvectorizable data type.: NA%ATTRNAME
  1169: vec( 118): Unvectorizable data type.
  1170: opt(1118): This I/O statement inhibits optimization of loop.
  1170: vec( 103): Unvectorized loop.
  1170: vec( 180): I/O statement obstructs vectorization.
  1172: opt(1118): This I/O statement inhibits optimization of loop.
  1172: vec( 103): Unvectorized loop.
  1172: vec( 180): I/O statement obstructs vectorization.
  1181: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  1182: opt(1592): Outer loop unrolled inside inner loop.
  1182: vec( 101): Vectorized loop.
  1185: inl(1214): Expansion routine is too big for automatic expansion.: PROCESSNODALATTR
  1185: opt(3009): Copy-in/out loops have been generated.: NA
  1185: opt(3009): Copy-in/out loops have been generated.
  1185: opt(3011): Copy-out loop has been generated.: NA
  1185: opt(1592): Outer loop unrolled inside inner loop.
  1185: vec( 101): Vectorized loop.
  1190: opt(3009): Copy-in/out loops have been generated.: NA
  1190: opt(3009): Copy-in/out loops have been generated.
  1190: opt(3011): Copy-out loop has been generated.: NA
  1190: opt(1592): Outer loop unrolled inside inner loop.
  1190: vec( 101): Vectorized loop.
  1194: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  1197: vec( 103): Unvectorized loop.
  1197: vec( 180): I/O statement obstructs vectorization.
  1198: opt(1118): This I/O statement inhibits optimization of loop.
  1209: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13XDMF
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  1060:                 subroutine prep13XDMF()
  1061:           C---------------------------------------------------------------------------
  1062:                 use pre_global, only : useNodalAttrNames, nnodg, nnodp, nproc
  1063:                 use memory_usage
  1064:                 use nodalattributes
  1065:                 use sizes, only : naFileName
  1066:                 implicit none
  1067:           
  1068:                 integer(8) :: nbytes = 0
  1069:                 integer :: iproc          ! subdomain loop counter
  1070:                 integer :: sdu(nproc)     ! subdomain unit number for unit 13 files
  1071:                 integer :: Mode           !=0 to count, =1 to write
  1072:                 logical :: success        ! .true. if all files opened successfully
  1073:                 character(len=15) sdFileName     ! subdomain file name   !increased from 14 to 15 tcm v50.66.03
  1074:                 integer, allocatable :: SDNumND(:,:)  ! subdomain # of nodes not default
  1075:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
  1076:           C     time ... some platforms/compilers limit the number of files that
  1077:           C     can be open at any one time.
  1078:                 integer, parameter :: maxOpenFiles = 256
  1079:                 integer :: startProc
  1080:                 integer :: endProc
  1081:                 integer :: deltaProc
  1082:                 integer :: errorIO
  1083:                 real(8), allocatable :: diff(:) ! difference between nodal value and default value
  1084:                 logical, allocatable :: areDefaultValues(:)
  1085:                 integer :: nonDefaultCount
  1086:                 integer :: i,j,k
  1087:           C
  1088:         I       call readNodalAttrXDMF()
  1089:                 !
  1090:                 ! we need to compute the number of nondefault values and
  1091:                 ! create a list of nodes with nondefault values
  1092: +------>        do i=1,nAttr
  1093: |                  if (na(i)%numVals.eq.1) then
  1094: |                     ! machine precision prevents us from simply checking whether the
  1095: |                     ! value .ne. the default value
  1096: |V=====>              diff = abs(na(i)%xdmfArray - na(i)%defaultVals(1))
  1097: |V=====>              na(i)%numNodesNotDefault = count(diff.gt.1.e-6)
  1098: |                     ! now allocate space for the non default values and populate them
  1099: |                     allocate(na(i)%nonDefaultVals(1,na(i)%numNodesNotDefault))
  1100: |                     allocate(na(i)%nonDefaultNodes(na(i)%numNodesNotDefault))
  1101: |                     ! now record the node number and value where the values are not
  1102: |                     ! the default
  1103: |                     nonDefaultCount = 1
  1104: |V----->              do j=1,nnodg
  1105: ||                       if (diff(j).gt.1.e-6) then
  1106: ||                          na(i)%nonDefaultNodes(nonDefaultCount) = j
  1107: ||                          na(i)%nonDefaultVals(1,nonDefaultCount) = na(i)%xdmfArray(j)
  1108: ||                          nonDefaultCount = nonDefaultCount + 1
  1109: ||                       endif
  1110: |V-----               end do
  1111: |                  else
  1112: |                     ! determine the number of nondefault values
  1113: |V=====>              areDefaultValues = .true.
  1114: |+----->              do j=1,nnodg
  1115: ||V---->                 do k=1,na(i)%numVals
  1116: |||                         if (abs(na(i)%xdmfMatrix(k,j)-na(i)%defaultVals(k)).gt.1.e-6) then
  1117: |||                            areDefaultValues(j) = .false.
  1118: |||                         endif
  1119: ||V----                  enddo
  1120: |+-----               enddo
  1121: |                     ! now allocate space for the non default values and populate them
  1122: |V=====>              na(i)%numNodesNotDefault = count(areDefaultValues.eqv..false.)
  1123: |                     allocate(na(i)%nonDefaultVals(na(i)%numVals,na(i)%numNodesNotDefault))
  1124: |                     allocate(na(i)%nonDefaultNodes(na(i)%numNodesNotDefault))
  1125: |                     nonDefaultCount = 1
  1126: |S----->              do j=1,nnodg
  1127: ||                       if (areDefaultValues(j).eqv..false.) then
  1128: ||                          na(i)%nonDefaultNodes(nonDefaultCount) = j
  1129: ||V---->                    do k=1,na(i)%numVals
  1130: |||                            na(i)%nonDefaultVals(k,nonDefaultCount) =
  1131: |||            &                   na(i)%xdmfMatrix(k,j)
  1132: ||V----                     end do
  1133: ||                          nonDefaultCount = nonDefaultCount + 1
  1134: ||                       endif
  1135: |S-----               end do
  1136: |                  endif
  1137: +------         end do
  1138:           C
  1139:           C     Perform decomposition over range of subdomains.
  1140:                 startProc = 1
  1141: +------>        do while ( startProc .lt. nproc )
  1142: |                  deltaProc = nproc - startProc
  1143: |                  if ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
  1144: |                  endProc = startProc + deltaProc
  1145: |                  ! Open each of the subdomain files
  1146: |+----->           do iproc = startProc, endProc
  1147: ||                    sdu(iproc) = 105 + (iproc-1)
  1148: ||+====>              sdFileName = 'PE0000/fort.13'
  1149: ||                    call iwrite(sdFileName, 3, 6, iproc-1)
  1150: ||                    open(unit=sdu(iproc), file=sdFileName, iostat=ErrorIO)
  1151: ||                    Success = .true.
  1152: ||                    IF ( ErrorIO .GT. 0 ) THEN
  1153: ||                       write(6,'(a,a,a)') "ERROR: Subdomain file "
  1154: ||             &             // trim(sdFileName) // " cannot be opened."
  1155: ||                       Success = .false.
  1156: ||                       CALL EXIT(1)
  1157: ||                    endif
  1158: |+-----            enddo
  1159: |         C
  1160: |         C        Transcribe header information into subdomain unit 13 files
  1161: |+----->           do iproc = startProc, endProc
  1162: ||                    write(sdu(iproc),'(a)') trim(adjustl(nodalAttributesComment))
  1163: ||                    write(sdu(iproc),*) NNODP(iproc)
  1164: ||                    write(sdu(iproc),*) NAttr
  1165: ||+---->              do i=1,nAttr
  1166: |||                      write(sdu(iproc),'(a)') trim(adjustl(na(i)%attrName))
  1167: |||                      write(sdu(iproc),'(a)') trim(adjustl(na(i)%units))
  1168: |||                      write(sdu(iproc),'(99(i0))') na(i)%numVals
  1169: |||                      if (trim(adjustl(na(i)%attrName)).eq."condensed_nodes") then !sb20221013
  1170: |||+--->                    write(sdu(iproc),'(99(I10))') (nint(na(i)%defaultVals(j)), j=1,na(i)%numVals)
  1171: |||                      else
  1172: |||+--->                    write(sdu(iproc),'(99(F15.7))') (na(i)%defaultVals(j), j=1,na(i)%numVals)
  1173: |||                      end if
  1174: ||+----            end do
  1175: |+-----            end do
  1176: |         C
  1177: |         C        Allocate and initialize the matrix for the number of Non Default
  1178: |         C        nodes in each SubDomain for each nodal attribute
  1179: |                  ALLOCATE(SDNumND(nproc,nAttr))
  1180: |                  nbytes = 8*nproc*nattr
  1181: |                  call memory_alloc(nbytes)
  1182: |U=====>           SDNumND(:,:)=0
  1183: |         C        We need to figure out how many nodes go into each subdomain
  1184: |         C        for each attribute.
  1185: |U=====>           CALL processNodalAttr(NAttr, na%numVals, 0, sdu, SDNumND,
  1186: |              &      startProc, endProc, naType,na%attrName)!tgaf13mod
  1187: |         C
  1188: |         C        Now read each of the nodal attributes and transcribe them to the
  1189: |         C        appropriate subdomain.
  1190: |U=====>           CALL processNodalAttr(NAttr, na%numVals, 1, sdu, SDNumND,
  1191: |              &      startProc, endProc, naType,na%attrName)!tgaf13mod
  1192: |                  DEALLOCATE(SDNumND)
  1193: |                  nbytes = 8*nproc*nattr
  1194: |                  call memory_dealloc(nbytes)
  1195: |         C
  1196: |         C        Close subdomain files
  1197: |+----->           DO iproc=startProc, endProc
  1198: ||                    CLOSE(sdu(iproc))
  1199: |+-----            ENDDO
  1200: |                  startProc = endProc + 1
  1201: +------         END DO
  1202:           C
  1203:                 if (allocated(useNodalAttrNames)) then
  1204:                    DEALLOCATE(useNodalAttrNames)
  1205:                    nbytes = 4*nwp
  1206:                    call memory_dealloc(nbytes)
  1207:                 endif
  1208:           C
  1209:                 call memory_status()
  1210:           C---------------------------------------------------------------------------
  1211:                 end subroutine prep13XDMF


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13XDMF
INLINE LIST

  ROOT: PREP13XDMF (prep.F:1060)
  -> INLINE: NODALATTRIBUTES::READNODALATTRXDMF (prep.F:1088)
   -> NOINLINE: GLOBAL::ALLMESSAGE (prep.F:1088)
      *** Source for routine not found.
   -> NOINLINE: GLOBAL::ALLMESSAGE (prep.F:1088)
      *** Source for routine not found.
   -> INLINE: NODALATTRIBUTES::NA_TERMINATE (prep.F:1088)
    -> NOINLINE: GLOBAL::SETMESSAGESOURCE (prep.F:1088)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::ALLMESSAGE (prep.F:1088)
       *** Source for routine not found.
    -> NOINLINE: GLOBAL::UNSETMESSAGESOURCE (prep.F:1088)
       *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:1149)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:1181)
     *** Source for routine not found.
  -> NOINLINE: PROCESSNODALATTR (prep.F:1185)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: PROCESSNODALATTR (prep.F:1190)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:1194)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:1206)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:1209)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13XDMF
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:1092)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (prep.F:1092)
    *** Deallocation obstructs vectorization. (prep.F:1092)
    *** Run-time checking obstructs vectorization. (prep.F:1092)

    LOOP BEGIN: (prep.F:1113)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1113)
      *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1113)
    LOOP END

    LOOP BEGIN: (prep.F:1114)
      <Unvectorized loop.>
      *** Overhead of loop division is too large. (prep.F:1114)

      LOOP BEGIN: (prep.F:1115)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1115)
        *** The number of VLOAD, VSTORE. :  2,  0. (prep.F:1115)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1122)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1122)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1122)
    LOOP END

    LOOP BEGIN: (prep.F:1126)
      <Partially vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1126)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1126)

      LOOP BEGIN: (prep.F:1129)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1129)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1129)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1096)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1096)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1096)
    LOOP END

    LOOP BEGIN: (prep.F:1096)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1096)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1096)
    LOOP END

    LOOP BEGIN: (prep.F:1097)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1097)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1097)
    LOOP END

    LOOP BEGIN: (prep.F:1104)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1104)
      *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:1104)
      *** The number of VCOMPRESS, VEXPAND. :  2,  0. (prep.F:1104)
      *** VCOMPRESS generated (prep.F:1106)
      *** VCOMPRESS generated (prep.F:1107)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:1141)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:1146)
      <Unvectorized loop.>
      *** Vectorization obstructive procedure reference. : IWRITE (prep.F:1146)
      *** I/O statement obstructs vectorization. (prep.F:1146)
      *** Allocation obstructs vectorization. (prep.F:1146)
      *** Deallocation obstructs vectorization. (prep.F:1146)
      *** Vectorization obstructive statement. (prep.F:1146)

      LOOP BEGIN: (prep.F:1148)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1148)
      LOOP END

      LOOP BEGIN: (prep.F:1153)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:1153)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1161)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1162)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:1162)
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        <Unvectorized loop.>
        *** Unvectorizable data type. : NODALATTRIBUTESCOMMENT (prep.F:1162)
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1162)
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:1162)
      LOOP END

      LOOP BEGIN: (prep.F:1165)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:1166)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1166)
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          <Unvectorized loop.>
          *** Unvectorizable data type. : NA%ATTRNAME (prep.F:1166)
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          <Unvectorized loop.>
          *** Unvectorizable data type. (prep.F:1166)
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1166)
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1167)
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          <Unvectorized loop.>
          *** Unvectorizable data type. : NA%UNITS (prep.F:1167)
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          <Unvectorized loop.>
          *** Unvectorizable data type. (prep.F:1167)
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1167)
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1169)
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          <Unvectorized loop.>
          *** Unvectorizable data type. : NA%ATTRNAME (prep.F:1169)
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          <Unvectorized loop.>
          *** Unvectorizable data type. (prep.F:1169)
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1169)
        LOOP END

        LOOP BEGIN: (prep.F:1172)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:1172)
        LOOP END

        LOOP BEGIN: (prep.F:1170)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:1170)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1182)
      <Unvectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:1182)

      LOOP BEGIN: (prep.F:1182)
        <Vectorized loop.>
        **  Copied loop. : FOR UNROLLING (prep.F:1182)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1182)
        *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1182)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1182)
      <Unvectorized loop.>
      **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:1182)

      LOOP BEGIN: (prep.F:1182)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1182)
        *** The number of VLOAD, VSTORE. :  0,  4. (prep.F:1182)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1185)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1185)
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      <Unvectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:1185)

      LOOP BEGIN: (prep.F:1185)
        <Unvectorized loop.>
        **  Copied loop. : FOR UNROLLING (prep.F:1185)
        *** Unvectorizable data type. (prep.F:1185)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      <Unvectorized loop.>
      **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:1185)

      LOOP BEGIN: (prep.F:1185)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1185)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1185)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1185)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1185)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1185)
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1190)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1190)
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      <Unvectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:1190)

      LOOP BEGIN: (prep.F:1190)
        <Unvectorized loop.>
        **  Copied loop. : FOR UNROLLING (prep.F:1190)
        *** Unvectorizable data type. (prep.F:1190)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      <Unvectorized loop.>
      **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:1190)

      LOOP BEGIN: (prep.F:1190)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1190)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1190)
        <Unvectorized loop.>
        *** Unvectorizable data type. (prep.F:1190)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1190)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1190)
    LOOP END

    LOOP BEGIN: (prep.F:1197)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1197)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:21 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP13XDMF
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 60 [s0-s12 s15-s16 s18-s39 s41-s63]
      Vector registers         : 29 [v35-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 4048 bytes
      Register spill area      : 1072 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2640 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:1060)
    *** Estimated execution cycle                       : 755
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 14
            Across calls                                :  1
            Over basic blocks                           : 13
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 24
            Across calls                                :  1
            Over basic blocks                           : 23
    *** The number of SCALAR REGISTER TRANSFER          : 105

    LOOP BEGIN: (prep.F:1113)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1114)
      *** Estimated execution cycle                     : 37
      *** The number of SCALAR REGISTER TRANSFER        : 13

      LOOP BEGIN: (prep.F:1115)
        *** Estimated execution cycle                   : 241
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1122)
      *** Estimated execution cycle                     : 55
    LOOP END

    LOOP BEGIN: (prep.F:1126)
      *** Estimated execution cycle                     : 62
    LOOP END

    LOOP BEGIN: (prep.F:1126)
      *** Estimated execution cycle                     : 56
      *** The number of SCALAR REGISTER TRANSFER        : 18

      LOOP BEGIN: (prep.F:1129)
        *** Estimated execution cycle                   : 64
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1096)
      *** Estimated execution cycle                     : 160
    LOOP END

    LOOP BEGIN: (prep.F:1096)
      *** Estimated execution cycle                     : 64
    LOOP END

    LOOP BEGIN: (prep.F:1097)
      *** Estimated execution cycle                     : 84
    LOOP END

    LOOP BEGIN: (prep.F:1104)
      *** Estimated execution cycle                     : 271
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:1060)
    *** Estimated execution cycle                       : 1175
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 87
            Across calls                                :  2
            Over basic blocks                           : 79
            Others                                      :  6
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 126
            Across calls                                :   2
            Over basic blocks                           : 124
    *** The number of SCALAR REGISTER TRANSFER          : 126

    LOOP BEGIN: (prep.F:1146)
      *** Estimated execution cycle                     : 287
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 13
              Across calls                              : 10
              Over basic blocks                         :  3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 26
              Across calls                              : 16
              Over basic blocks                         :  9
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 30

      LOOP BEGIN: (prep.F:1148)
        *** Estimated execution cycle                   : 7
      LOOP END

      LOOP BEGIN: (prep.F:1153)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1161)
      *** Estimated execution cycle                     : 244
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 17
              Across calls                              :  7
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 22
              Across calls                              : 10
              Over basic blocks                         : 11
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 40

      LOOP BEGIN: (prep.F:1162)
        *** Estimated execution cycle                   : 8
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        *** Estimated execution cycle                   : 6
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        *** Estimated execution cycle                   : 5
      LOOP END

      LOOP BEGIN: (prep.F:1162)
        *** Estimated execution cycle                   : 7
      LOOP END

      LOOP BEGIN: (prep.F:1165)
        *** Estimated execution cycle                   : 571
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 24
                Across calls                            : 11
                Over basic blocks                       : 12
                Others                                  :  1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 44
                Across calls                            : 20
                Over basic blocks                       : 21
                Others                                  :  3
        *** The number of SCALAR REGISTER TRANSFER      : 107

        LOOP BEGIN: (prep.F:1166)
          *** Estimated execution cycle                 : 8
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          *** Estimated execution cycle                 : 6
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          *** Estimated execution cycle                 : 5
        LOOP END

        LOOP BEGIN: (prep.F:1166)
          *** Estimated execution cycle                 : 7
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          *** Estimated execution cycle                 : 8
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          *** Estimated execution cycle                 : 6
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          *** Estimated execution cycle                 : 5
        LOOP END

        LOOP BEGIN: (prep.F:1167)
          *** Estimated execution cycle                 : 7
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          *** Estimated execution cycle                 : 8
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          *** Estimated execution cycle                 : 6
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          *** Estimated execution cycle                 : 5
        LOOP END

        LOOP BEGIN: (prep.F:1169)
          *** Estimated execution cycle                 : 7
        LOOP END

        LOOP BEGIN: (prep.F:1172)
          *** Estimated execution cycle                 : 25
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END

        LOOP BEGIN: (prep.F:1170)
          *** Estimated execution cycle                 : 39
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1182)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 9

      LOOP BEGIN: (prep.F:1182)
        *** Estimated execution cycle                   : 63
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1182)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:1182)
        *** Estimated execution cycle                   : 164
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      *** Estimated execution cycle                     : 8

      LOOP BEGIN: (prep.F:1185)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      *** Estimated execution cycle                     : 23

      LOOP BEGIN: (prep.F:1185)
        *** Estimated execution cycle                   : 22
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      *** Estimated execution cycle                     : 8

      LOOP BEGIN: (prep.F:1185)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1185)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      *** Estimated execution cycle                     : 8

      LOOP BEGIN: (prep.F:1190)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      *** Estimated execution cycle                     : 23

      LOOP BEGIN: (prep.F:1190)
        *** Estimated execution cycle                   : 22
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      *** Estimated execution cycle                     : 8

      LOOP BEGIN: (prep.F:1190)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1190)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1197)
      *** Estimated execution cycle                     : 15
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:22 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP14
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  1255: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1258: inl(1212): Source for routine not found.: IWRITE
  1268: opt(1589): Outer loop moved inside inner loop(s).: K
  1268: vec( 101): Vectorized loop.
  1270: opt(1592): Outer loop unrolled inside inner loop.: J
  1270: vec( 101): Vectorized loop.
  1277: opt(1135): Outer loop conditionally executes inner loop.
  1277: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1277: vec( 103): Unvectorized loop.
  1277: vec( 113): Overhead of loop division is too large.
  1278: vec( 101): Vectorized loop.
  1281: vec( 101): Vectorized loop.
  1286: opt(1019): Feedback of scalar value from one loop pass to another.: NETAP
  1286: opt(3014): Moved reference within a conditional branch.
  1287: opt(1019): Feedback of scalar value from one loop pass to another.: NVDLLP
  1287: opt(3014): Moved reference within a conditional branch.
  1288: opt(3014): Moved reference within a conditional branch.
  1289: opt(3014): Moved reference within a conditional branch.
  1297: vec( 101): Vectorized loop.
  1311: vec( 101): Vectorized loop.
  1316: vec( 180): I/O statement obstructs vectorization.
  1326: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1326: vec( 102): Partially vectorized loop.
  1329: opt(1135): Outer loop conditionally executes inner loop.
  1329: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1329: vec( 102): Partially vectorized loop.
  1333: opt(3014): Moved reference within a conditional branch.
  1334: vec( 101): Vectorized loop.
  1339: opt(3014): Moved reference within a conditional branch.
  1340: opt(1019): Feedback of scalar value from one loop pass to another.: NVELLP
  1340: opt(3014): Moved reference within a conditional branch.
  1341: opt(3014): Moved reference within a conditional branch.
  1342: opt(3014): Moved reference within a conditional branch.
  1343: opt(3014): Moved reference within a conditional branch.
  1354: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1354: vec( 102): Partially vectorized loop.
  1359: opt(1135): Outer loop conditionally executes inner loop.
  1359: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1359: vec( 102): Partially vectorized loop.
  1364: opt(3014): Moved reference within a conditional branch.
  1365: vec( 101): Vectorized loop.
  1371: opt(3014): Moved reference within a conditional branch.
  1372: opt(1019): Feedback of scalar value from one loop pass to another.: NVELLP
  1372: opt(3014): Moved reference within a conditional branch.
  1374: opt(3014): Moved reference within a conditional branch.
  1375: opt(3014): Moved reference within a conditional branch.
  1379: opt(3014): Moved reference within a conditional branch.
  1394: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1394: vec( 101): Vectorized loop.
  1399: vec( 101): Vectorized loop.
  1409: opt(3014): Moved reference within a conditional branch.
  1412: opt(1019): Feedback of scalar value from one loop pass to another.: NVELLP
  1412: opt(3014): Moved reference within a conditional branch.
  1416: opt(3014): Moved reference within a conditional branch.
  1419: opt(3014): Moved reference within a conditional branch.
  1485: vec( 103): Unvectorized loop.
  1485: vec( 180): I/O statement obstructs vectorization.
  1487: opt(1118): This I/O statement inhibits optimization of loop.
  1502: vec( 101): Vectorized loop.
  1518: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1518: vec( 103): Unvectorized loop.
  1518: vec( 113): Overhead of loop division is too large.
  1522: opt(3014): Moved reference within a conditional branch.
  1546: opt(1841): Conditional-index testing optimization.
  1546: opt(1409): Alternate code generated.: I
  1546: vec( 103): Unvectorized loop.
  1546: vec( 101): Vectorized loop.
  1546: vec( 113): Overhead of loop division is too large.
  1548: opt(1394): Moved invariant if outside of an inner loop.
  1553: opt(1019): Feedback of scalar value from one loop pass to another.: I1
  1560: opt(3014): Moved reference within a conditional branch.
  1560: vec( 121): Unvectorizable dependency.
  1580: opt(1135): Outer loop conditionally executes inner loop.
  1580: vec( 102): Partially vectorized loop.
  1581: vec( 101): Vectorized loop.
  1591: vec( 101): Vectorized loop.
  1620: vec( 103): Unvectorized loop.
  1620: vec( 180): I/O statement obstructs vectorization.
  1622: opt(1118): This I/O statement inhibits optimization of loop.
  1625: vec( 103): Unvectorized loop.
  1625: vec( 180): I/O statement obstructs vectorization.
  1628: opt(1118): This I/O statement inhibits optimization of loop.
  1638: inl(1212): Source for routine not found.: NEWINDEX
  1656: inl(1212): Source for routine not found.: INSERT
  1658: opt(3014): Moved reference within a conditional branch.
  1659: vec( 103): Unvectorized loop.
  1659: vec( 180): I/O statement obstructs vectorization.
  1660: opt(1118): This I/O statement inhibits optimization of loop.
  1687: opt(3014): Moved reference within a conditional branch.
  1691: vec( 103): Unvectorized loop.
  1691: vec( 180): I/O statement obstructs vectorization.
  1692: opt(1118): This I/O statement inhibits optimization of loop.
  1696: vec( 103): Unvectorized loop.
  1696: vec( 180): I/O statement obstructs vectorization.
  1698: opt(1118): This I/O statement inhibits optimization of loop.
  1703: vec( 103): Unvectorized loop.
  1703: vec( 180): I/O statement obstructs vectorization.
  1705: opt(1118): This I/O statement inhibits optimization of loop.
  1710: vec( 103): Unvectorized loop.
  1710: vec( 180): I/O statement obstructs vectorization.
  1712: opt(1118): This I/O statement inhibits optimization of loop.
  1719: vec( 103): Unvectorized loop.
  1719: vec( 180): I/O statement obstructs vectorization.
  1721: opt(1118): This I/O statement inhibits optimization of loop.
  1738: vec( 103): Unvectorized loop.
  1738: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  1738: vec( 180): I/O statement obstructs vectorization.
  1740: opt(1025): Reference to this procedure inhibits optimization.: IWRITE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP14
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  1216:                 SUBROUTINE PREP14()
  1217:                 USE PRE_GLOBAL
  1218:                 USE PREP_WEIR,ONLY:NWEIRBNDRY
  1219:           C
  1220:           C---------------------------------------------------------------------------C
  1221:           C                     (  Serial Version  2/28/98  )                         C
  1222:           C  This routine writes a Local Grid file "fort.14" file for each subdomain  C
  1223:           C  using the domain decomposition of the ADCIRC grid created by the routine C
  1224:           C  DECOMP.                                                                  C
  1225:           C                                                                           C
  1226:           C  The Decomposition Variables are defined in the include file adcprep.inc  C
  1227:           C  This version is compatible with ADCIRC version 34.03                     C
  1228:           C                                                                           C
  1229:           C---------------------------------------------------------------------------C
  1230:           C
  1231:                 IMPLICIT NONE
  1232:                 INTEGER I,I1,J,K,M,ETYPE,ITEMP,ITEMP2,ILNODE,ILNODE2,ILNODE3
  1233:                 INTEGER JD,JG,JP,IPROC,IPROC2,IPROC3,DISC,BBN,IBP,IBPPipe
  1234:                 INTEGER INDX,INDEX2,ITOT,ITYPE,NUMS(10)
  1235:                 CHARACTER LOCFN*14,PE*6
  1236:                 CHARACTER*80 OUTMSG
  1237:           C..... DW
  1238:                 INTEGER:: IPER, II
  1239:           C..... DW
  1240:                 !
  1241:                 ! NVELLP(K,PE) Number of Land Boundary Nodes of Segment K on PE
  1242:                 ! IMAP_NOD_GL2(2(PE-1)+1,I)  = PE assigned to Global Node I
  1243:                 ! IMAP_NOD_GL2(2(PE-1)+2,I)  = Local Node Number of Global Node I on PE
  1244:                 ! vjp modified array to drop last dimension to save memory space
  1245:                 ! LBINDEX_LG(K,I,PE) = Global Index of I-th Node on Land Boundary Segment K on PE
  1246:           C
  1247:                 ETYPE = 3   ! The only Element-Type supported by ADCIRC is 3.
  1248:           C
  1249:           C--------------------------------------------------------------------------
  1250:           C--MAIN LOOP:   Write a Local Grid File ( fort.14 ) for each PE
  1251:           C--------------------------------------------------------------------------
  1252:           C
  1253:                 NETA_MAX = 0   ! max number of open boundary nodes on any subdomain
  1254:           C
  1255: +------>        DO IPROC = 1,NPROC
  1256: |         C
  1257: |+=====>           LOCFN(1:14) = 'PE0000/fort.14'
  1258: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
  1259: |                  OPEN (14,FILE=LOCFN)
  1260: |         C
  1261: |         C--------------------------------------------------------------------------
  1262: |         C--OPEN BOUNDARY NODES PROCESSING BEGINS HERE
  1263: |         C--------------------------------------------------------------------------
  1264: |         C
  1265: |         C--Partition the open boundary nodes between various processors
  1266: |         C
  1267: |                  NETAP(IPROC) = 0
  1268: |X----->           DO K=1, NOPE
  1269: ||                    NVDLLP(K) = 0
  1270: ||U---->              DO J=1, NETA
  1271: |||                      OBNODE_LG(J,IPROC) = 0
  1272: |||                      NBDVP(K,J) = 0
  1273: ||U----               ENDDO
  1274: |X-----            ENDDO
  1275: |         C
  1276: |                  ITOT = 0
  1277: |+----->           DO K = 1,NOPE
  1278: ||V---->              DO I = 1,NVDLL(K)
  1279: |||                      ITOT = ITOT + 1
  1280: |||     G                INDX = NBDV(K,I)
  1281: |||V--->                 DO J = 1,ITOTPROC(INDX)
  1282: ||||                        ITEMP = (J-1)*2+1
  1283: ||||                        IPROC2 = IMAP_NOD_GL2(ITEMP,INDX)
  1284: ||||                        ILNODE = IMAP_NOD_GL2(ITEMP+1,INDX)
  1285: ||||                        IF (IPROC.EQ.IPROC2) THEN
  1286: ||||                          NETAP(IPROC) = NETAP(IPROC)+1
  1287: ||||                          NVDLLP(K) = NVDLLP(K) + 1
  1288: ||||                          NBDVP(K,NVDLLP(K)) = ILNODE
  1289: ||||                          OBNODE_LG(NETAP(IPROC),IPROC)=ITOT
  1290: ||||                        ENDIF
  1291: |||V---                  ENDDO
  1292: ||V----               ENDDO
  1293: |+-----            ENDDO
  1294: |                  IF (NETAP(IPROC) > NETA_MAX) NETA_MAX = NETAP(IPROC)
  1295: |         C
  1296: |                  NOPEP(IPROC) = 0
  1297: |V----->           DO K = 1,NOPE
  1298: ||                    IF (NVDLLP(K).NE.0) THEN
  1299: ||                      NOPEP(IPROC) = NOPEP(IPROC) + 1
  1300: ||                    ENDIF
  1301: |V-----            ENDDO
  1302: |         C
  1303: |         C
  1304: |         C--------------------------------------------------------------------------
  1305: |         C--LAND BOUNDARY NODES PROCESSING BEGINS HERE
  1306: |         C--------------------------------------------------------------------------
  1307: |         C
  1308: |         C--Partition Land Boundary Segments between PEs
  1309: |         C
  1310: |                  NVELP(IPROC) = 0
  1311: |V----->           DO K = 1,NBOU
  1312: ||                    NVELLP(K) = 0
  1313: ||                    IBTYPEP(K,IPROC) = IBTYPE(K)
  1314: |V-----            ENDDO
  1315: |         C
  1316: |+----->           DO K = 1,NBOU
  1317: ||        C
  1318: ||        C--Weir Land Boundary Node-Pair Case
  1319: ||        Cmod vjp 3/8/99
  1320: ||        C  mod to allow that each of Weir-node pair might be ghosts nodes
  1321: ||        C
  1322: ||                    select case(IBTYPE(K))
  1323: ||                    !
  1324: ||                    ! weir boundaries
  1325: ||                    case(4,24,64,5,25)
  1326: ||S---->                 DO I = 1,NVELL(K)
  1327: |||                         INDX = NBVV(K,I)
  1328: |||     G                   INDEX2 = IBCONNR(K,I)
  1329: |||S--->                    DO J = 1,ITOTPROC(INDX)
  1330: ||||                           ITEMP = (J-1)*2 + 1
  1331: ||||                           IPROC2  =  IMAP_NOD_GL2(ITEMP,INDX)
  1332: ||||                           ILNODE2 =  IMAP_NOD_GL2(ITEMP+1,INDX)
  1333: ||||                           IF (IPROC.EQ.IPROC2) THEN
  1334: ||||V-->                          DO JD = 1, ITOTPROC(INDEX2)
  1335: |||||                                ITEMP2 = (JD-1)*2 + 1
  1336: |||||                                IPROC3  = IMAP_NOD_GL2(ITEMP2,INDEX2)
  1337: |||||                                ILNODE3 = IMAP_NOD_GL2(ITEMP2+1,INDEX2)
  1338: |||||                                IF (IPROC.EQ.IPROC3) THEN
  1339: |||||                                   NVELP(IPROC) = NVELP(IPROC) + 1
  1340: |||||                                   NVELLP(K) = NVELLP(K) + 1
  1341: |||||                                   LBINDEX_LG(K,NVELLP(K)) = I
  1342: |||||                                   NBVVP(K,NVELLP(K))   = ILNODE2
  1343: |||||                                   IBCONNRP(K,NVELLP(K)) = ILNODE3
  1344: |||||                                ENDIF
  1345: ||||V--                           ENDDO
  1346: ||||                           ENDIF
  1347: |||S---                     ENDDO
  1348: ||S----                  ENDDO
  1349: ||        
  1350: ||                    case(94)
  1351: ||        C.... BEG DW, periodic boundary condition
  1352: ||        C.... 2018: use similar trick used in weir-node pair
  1353: ||                       II = 0 ;
  1354: ||S---->                 DO I = IPERPTR(K), IPERPTR(K+1) - 1
  1355: |||                          INDX = IPERCONN(I,1) ; ! global index: primary node
  1356: |||                          INDEX2 = IPERCONN(I,2) ; ! global idnex: its slave node
  1357: |||        
  1358: |||     G                    II = II + 1 ;
  1359: |||S--->                     DO J = 1, ITOTPROC(INDX)
  1360: ||||                             ITEMP = (J-1)*2 + 1 ;
  1361: ||||                             IPROC2 = IMAP_NOD_GL2(ITEMP,INDX) ; ! processor (may not be resident)
  1362: ||||                             ILNODE2 = IMAP_NOD_GL2(ITEMP+1,INDX) ; ! local index
  1363: ||||                             !
  1364: ||||                             IF ( IPROC .EQ. IPROC2 ) THEN
  1365: ||||V-->                            DO JD = 1, ITOTPROC(INDEX2)
  1366: |||||                                 ITEMP2 = (JD - 1)*2 + 1 ;
  1367: |||||                                 IPROC3 = IMAP_NOD_GL2(ITEMP2,INDEX2) ;
  1368: |||||                                 ILNODE3 = IMAP_NOD_GL2(ITEMP2+1,INDEX2) ;
  1369: |||||     
  1370: |||||                                 IF ( IPROC .EQ. IPROC3 ) THEN
  1371: |||||                                    NVELP(IPROC) = NVELP(IPROC) + 1 ;
  1372: |||||                                    NVELLP(K) = NVELLP(K) + 1 ;
  1373: |||||     
  1374: |||||                                    LBINDEX_LG(K,NVELLP(K)) = II ;
  1375: |||||                                    NBVVP(K,NVELLP(K)) = ILNODE2 ;
  1376: |||||     C.... For now, use an exisitng interal boundary array
  1377: |||||     C     to hold the index of the slave node. In the future,
  1378: |||||     C     if need be, change to a CRS format to save memory.
  1379: |||||                                    IBCONNRP(K,NVELLP(K)) = ILNODE3 ;
  1380: |||||                                 END IF
  1381: |||||      
  1382: ||||V--                             END DO
  1383: ||||                             END IF
  1384: ||||                             !
  1385: |||S---                      END DO
  1386: ||S----                  END DO
  1387: ||        C.......... END DW, periodic bcs
  1388: ||        C
  1389: ||        C--All Other Land Boundary Node types
  1390: ||        C
  1391: ||                    case default
  1392: ||        C
  1393: ||                       ! for each node in this non-weir flux boundary
  1394: ||V---->                 DO I = 1,NVELL(K)
  1395: |||                         ! find full domain node number
  1396: |||     G                   INDX = NBVV(K,I)
  1397: |||                         ! iterate over the subdomains where this boundary
  1398: |||                         ! node is found
  1399: |||V--->                    DO J = 1,ITOTPROC(INDX)
  1400: ||||                           ITEMP = (J-1)*2 + 1
  1401: ||||                           ! look up subdomain number
  1402: ||||                           IPROC2 =  IMAP_NOD_GL2(ITEMP,INDX)
  1403: ||||                           ! look up node number in this subdomain
  1404: ||||                           ILNODE =  IMAP_NOD_GL2(ITEMP+1,INDX)
  1405: ||||                           ! if the current subdomain matches this one
  1406: ||||                           IF (IPROC.EQ.IPROC2) THEN
  1407: ||||                              ! increment the total number of flux boundary nodes
  1408: ||||                              ! on this subdomain
  1409: ||||                              NVELP(IPROC) = NVELP(IPROC) + 1
  1410: ||||                              ! increment number of nodes from this boundary
  1411: ||||                              ! that occur in this subdomain
  1412: ||||                              NVELLP(K) = NVELLP(K) + 1
  1413: ||||                              ! add fulldomain node number for this boundary
  1414: ||||                              ! and subdomain node array position on this boundary
  1415: ||||                              ! to mapping
  1416: ||||                              LBINDEX_LG(K,NVELLP(K)) = I
  1417: ||||                              ! record subdomain node number for this boundary
  1418: ||||                              ! and subdomain boundary position
  1419: ||||                              NBVVP(K,NVELLP(K)) = ILNODE
  1420: ||||                           ENDIF
  1421: |||V---                     ENDDO
  1422: ||V----                  ENDDO
  1423: ||                       !
  1424: ||                       ! @jasonfleming: it is possible for a single node of an
  1425: ||                       ! island boundary to appear as a ghost node in a nearby
  1426: ||                       ! subdomain, and if this single node is the first node
  1427: ||                       ! on the fulldomain island boundary, it will also be the
  1428: ||                       ! last node on the fulldomain boundary (because adcirc
  1429: ||                       ! requires island boundaries to be closed). As a result,
  1430: ||                       ! it can be erroneously translated as a two node subdomain
  1431: ||                       ! boundary with the same node number listed twice.
  1432: ||                       if ( nvellp(k).eq.2 ) then
  1433: ||                          if ( nbvvp(k,1).eq.nbvvp(k,2) ) then
  1434: ||                             write(*,'(a)')
  1435: ||             &          'ERROR: Two node boundary with identical node numbers.'
  1436: ||                             if (strictBoundaries.eqv..false.) then
  1437: ||                                NVELLP(K) = 0
  1438: ||                                write(*,'(a)')
  1439: ||             &                     'INFO: Eliminating hanging boundary'
  1440: ||             &                     //' node from this subdomain.'
  1441: ||                             endif
  1442: ||                          endif
  1443: ||                       endif
  1444: ||        C
  1445: ||                    end select
  1446: ||        C
  1447: |+-----            ENDDO  ! end loop over flux specified boundaries
  1448: |         C
  1449: |         Cmod 05/18/2004 rl -- I don't think this next part is the correct
  1450: |         c  way to handle islands.  Rather, if an island is split by a domain, it
  1451: |         c  should remain an island.  This will ensure that the boundary is
  1452: |         c  closed.  The only error would occur in ghost node space, which is
  1453: |         c  not a problem since the answers are not used there anyway.
  1454: |         
  1455: |         Cmod 12/18/98 vjp --this section re-written
  1456: |         C--If a PE has only part of a closed internal land boundary
  1457: |         C  modify its local IBTYPE to be an external land boundary segment
  1458: |         C  of the same type by decrementing its IBTYPE.
  1459: |         C  and remove a closing loop node if present
  1460: |         
  1461: |         C
  1462: |         c        DO K=1, NBOU
  1463: |         c          IF (NVELLP(K).LT.NVELL(K)) THEN
  1464: |         c            IF (  (IBTYPEP(K,IPROC).EQ.1)
  1465: |         c    &         .OR.(IBTYPEP(K,IPROC).EQ.11)
  1466: |         c    &         .OR.(IBTYPEP(K,IPROC).EQ.21)) THEN
  1467: |         c decrement ibtype
  1468: |         c              IBTYPEP(K,IPROC) = IBTYPEP(K,IPROC)-1
  1469: |         C remove loop closing node
  1470: |         c              IF (NVELLP(K).GT.1.AND.
  1471: |         c    &           NBVVP(K,NVELLP(K)).EQ.NBVVP(K,1)) THEN
  1472: |         c                NVELLP(K) = NVELLP(K)-1
  1473: |         c              ENDIF
  1474: |         c            ENDIF
  1475: |         c          ENDIF
  1476: |         c        ENDDO
  1477: |         
  1478: |         C If a segment contains only one node, remove the segment from the list
  1479: |         C (NOTE: rl 5/18/04 I don't see how this could possibly happen, including
  1480: |         C  ghost nodes)
  1481: |                  !
  1482: |                  ! @jasonfleming: it is possible for a single node of a
  1483: |                  ! land boundary to appear as a ghost node in a nearby
  1484: |                  ! subdomain.
  1485: |+----->           DO K=1, NBOU
  1486: ||                    IF (NVELLP(K).EQ.1) THEN
  1487: ||                       write(*,'(a,i0,a,i0,a)')
  1488: ||             &           'ERROR: The land boundary number ',k,
  1489: ||             &           ' is only one node long in subdomain ',iproc,'.'
  1490: ||                       if ( strictBoundaries.eqv..false. ) then
  1491: ||                          NVELLP(K) = 0
  1492: ||                          write(*,'(a)') 'INFO: Eliminating hanging boundary'
  1493: ||             &            //' node from this subdomain.'
  1494: ||                       endif
  1495: ||                    ENDIF
  1496: |+-----            ENDDO
  1497: |         
  1498: |         C
  1499: |         C--Count the number of land boundary segments on PE IPROC.
  1500: |         C
  1501: |                  NBOUP(IPROC) = 0
  1502: |V----->           DO K = 1,NBOU
  1503: ||                    IF (NVELLP(K).NE.0) THEN
  1504: ||                      NBOUP(IPROC) = NBOUP(IPROC) + 1
  1505: ||                    ENDIF
  1506: |V-----            ENDDO
  1507: |         C
  1508: |         C--Count to check correctness of NVELP
  1509: |         C
  1510: |                  DISC=0  ! LB Nodes with non-zero normal discharge (river)
  1511: |                  BBN=0   ! Mainland Barrier Boundary Nodes (external overflow)
  1512: |                  IBP=0   ! Internal Barrier Boundary Pairs (levee)
  1513: |                  IBPPipe=0 ! internal barrier boundary pairs (levee with cross barrier pipes)
  1514: |                  ITEMP = 0 ! mainland and island
  1515: |                  IPER = 0
  1516: |         C
  1517: |         C     jgf46.21 Added support for IBTYPE=52.
  1518: |+----->           DO K=1,NBOU
  1519: ||                    IF (NVELLP(K).EQ.0) THEN
  1520: ||                       cycle
  1521: ||                    ENDIF
  1522: ||                    ITYPE = IBTYPEP(K,IPROC)
  1523: ||        ! kmd - added for rivers in baroclinic simulation
  1524: ||                    IF (ABS(ITYPE/100).EQ.1) THEN
  1525: ||                       ITYPE = (ABS(ITYPE)-100)*(ITYPE/ABS(ITYPE))
  1526: ||                    END IF
  1527: ||                    ! jgf50.21: Added support for IBTYPE=32 and replaced
  1528: ||                    ! if/then statements with a select statement.
  1529: ||                    select case(ITYPE)
  1530: ||                    case(2,12,22,32,52)
  1531: ||                       DISC = DISC + NVELLP(K)
  1532: ||                    case(3,13,23)
  1533: ||                       BBN = BBN + NVELLP(K)
  1534: ||                    case(4,24,64)
  1535: ||                       IBP = IBP + NVELLP(K)
  1536: ||                    case(5,25)
  1537: ||                       IBPPipe = IBPPipe + NVELLP(K)
  1538: ||                    case(94)
  1539: ||        !           DW/WP periodic boundary
  1540: ||                       IPER = IPER + NVELLP(K)
  1541: ||                    case default
  1542: ||                       ITEMP = ITEMP + NVELLP(K)
  1543: ||                    end select
  1544: ||                    I1 = 0
  1545: ||                    ! loop over all boundary nodes on this subdomain
  1546: ||C---->              DO I=1,NVELLP(K)
  1547: |||                      ! if the boundary is an island boundary
  1548: |||                      IF ((ITYPE.EQ.1).OR.(ITYPE.EQ.11).OR.(ITYPE.EQ.21)) THEN
  1549: |||                         ! if this is the last boundary node on this subdomain
  1550: |||                         ! and
  1551: |||                         ! if the subdomain node number is not equal to
  1552: |||                         ! the first subdomain node number
  1553: |||                         IF ((I.EQ.NVELLP(K)).AND.(NBVVP(K,I).NE.I1)) THEN
  1554: |||                            ITEMP = ITEMP + 1 ! increment the number of nodes associated with this boundary on this subdomain
  1555: |||                         ENDIF
  1556: |||                      ENDIF
  1557: |||                      ! set i1 equal to the subdomain node number for the first
  1558: |||                      ! node on this boundary
  1559: |||                      IF (I.EQ.1) THEN
  1560: |||                         I1 = NBVVP(K,I)
  1561: |||                      ENDIF
  1562: ||C----               ENDDO
  1563: |+-----            END DO
  1564: |         C
  1565: |         c        print *, IPROC-1,ITEMP,DISC,BBN,2*IBP
  1566: |                  ITEMP  = ITEMP + DISC + BBN + 2*IBP + 2*IBPPipe + IPER;
  1567: |                  IF (ITEMP.NE.NVELP(IPROC)) THEN
  1568: |         c          print *, "changed value from ",NVELP(IPROC)," to ",ITEMP
  1569: |                    NVELP(IPROC) = ITEMP
  1570: |                  ENDIF
  1571: |                  IF (NVELP(IPROC)+1.GT.MNVEL) THEN
  1572: |                    print *, "NVEL exceeds parameter value MNVEL on PE",IPROC
  1573: |                    print *, "local NVEL value = ",ITEMP
  1574: |                    CALL EXIT(1)
  1575: |                  ENDIF
  1576: |         C
  1577: |         C--Construct a LBCODE for each Land Boundary Node of this PE
  1578: |         C
  1579: |                  JP=0
  1580: |S----->           DO K = 1,NBOU
  1581: ||V---->              DO I=1, NVELLP(K)
  1582: |||                      JP = JP+1
  1583: |||                      LBCODEP(JP,IPROC) = IBTYPEP(K,IPROC)
  1584: ||V----               ENDDO
  1585: |S-----            ENDDO
  1586: |         C
  1587: |         C--Determine whether there are any normal flow boundaries local to PE
  1588: |         C
  1589: |         ! kmd - changed for rivers in baroclinic simulations
  1590: |                  NFLUXFP(IPROC) = 0
  1591: |V----->           DO K=1, NBOU
  1592: ||                    IF (NVELLP(K).GT.0) THEN
  1593: ||                       ITYPE=IBTYPE(K)
  1594: ||                       IF (ABS(ITYPE/100).EQ.1) THEN
  1595: ||                          ITYPE = (ABS(ITYPE)-100)*(ITYPE/ABS(ITYPE))
  1596: ||                       END IF
  1597: ||                       IF ((ITYPE.EQ.2).OR.(ITYPE.EQ.12)
  1598: ||             &             .OR.(ITYPE.EQ.32)
  1599: ||             &             .OR.(ITYPE.EQ.22).OR.(ITYPE.EQ.52)) THEN
  1600: ||                          NFLUXFP(IPROC) = 1
  1601: ||                       ENDIF
  1602: ||                    ENDIF
  1603: |V-----            ENDDO
  1604: |         C
  1605: |         C--------------------------------------------------------------------------
  1606: |         C--BEGIN WRITING LOCAL GRID ( fort.14 ) FILE HERE
  1607: |         C--------------------------------------------------------------------------
  1608: |         C
  1609: |         C--Write Mesh Data
  1610: |         C
  1611: |                   WRITE(14,80) AGRID
  1612: |         C
  1613: |                   NUMS(1) = NELP(IPROC)
  1614: |                   NUMS(2) = NNODP(IPROC)
  1615: |         c
  1616: |         cjgf45.06    CALL INSERT(SIZEMSG,OUTMSG,NUMS,2)
  1617: |         cjgf45.06    WRITE(14,80) OUTMSG
  1618: |                   WRITE(14,43) NELP(IPROC),NNODP(IPROC) !jgf45.06
  1619: |         C
  1620: |+----->            DO J = 1,NNODP(IPROC)
  1621: ||                     INDX = IMAP_NOD_LG(J,IPROC)
  1622: ||                     WRITE(14,44) LABELS(INDX),X(INDX),Y(INDX),DP(INDX)
  1623: |+-----             ENDDO
  1624: |         c
  1625: |+----->            DO J = 1,NELP(IPROC)
  1626: ||        !             WRITE(14,45) J,ETYPE,NNEP(1,J,IPROC),NNEP(2,J,IPROC),
  1627: ||        !     &                           NNEP(3,J,IPROC)
  1628: ||                      WRITE(14,45) J,ETYPE,LABELS(IMAP_NOD_LG(NNEP(1,J,IPROC),IPROC)),
  1629: ||             &                     LABELS(IMAP_NOD_LG(NNEP(2,J,IPROC),IPROC)),
  1630: ||             &                     LABELS(IMAP_NOD_LG(NNEP(3,J,IPROC),IPROC))
  1631: |+-----             ENDDO
  1632: |          43       FORMAT(2I8)
  1633: |          44       FORMAT(I8,3(E20.12))
  1634: |          45       FORMAT(I8,I2,3(I9))
  1635: |         C
  1636: |         C--Write Open Boundary Data
  1637: |         C
  1638: |                  CALL NEWINDEX(NOPEMSG,OUTMSG,NOPEP(IPROC))
  1639: |                  WRITE(14,80) OUTMSG
  1640: |         C
  1641: |                  CALL NEWINDEX(NETAMSG,OUTMSG,NETAP(IPROC))
  1642: |                  WRITE(14,80) OUTMSG
  1643: |         C
  1644: |                  ITOT = 0
  1645: |+----->           DO K = 1,NOPE
  1646: ||                    IF (NVDLLP(K).GT.0)THEN
  1647: ||                       ITOT = ITOT + 1
  1648: ||        Casey 090304: Added the following section.  If we are coupling to SWAN,
  1649: ||        C             then we also want to give the global number of each
  1650: ||        C             boundary segment.
  1651: ||        #ifndef ADCSWAN
  1652: ||                       CALL NEWINDEX(NVDLLMSG(K),OUTMSG,NVDLLP(K))
  1653: ||        #else
  1654: ||                       NUMS(1) = NVDLLP(K)
  1655: ||                       NUMS(2) = K
  1656: ||                       CALL INSERT(NVDLLMSG(K),OUTMSG,NUMS,2)
  1657: ||        #endif
  1658: ||                       WRITE(14,80) OUTMSG
  1659: ||+---->                 DO I = 1,NVDLLP(K)
  1660: |||                         WRITE(14,*) LABELS(IMAP_NOD_LG(NBDVP(K,I),IPROC))
  1661: ||+----                  ENDDO
  1662: ||                    ENDIF
  1663: |+-----            ENDDO
  1664: |         C
  1665: |         C--Write Land Boundary Data
  1666: |         C
  1667: |                  CALL NEWINDEX(NBOUMSG,OUTMSG,NBOUP(IPROC))
  1668: |                  WRITE(14,80) OUTMSG
  1669: |         C
  1670: |                  CALL NEWINDEX(NVELMSG,OUTMSG,NVELP(IPROC))
  1671: |                  WRITE(14,80) OUTMSG
  1672: |         C
  1673: |+----->           DO K = 1,NBOU
  1674: ||                    IF(NVELLP(K).GT.0)THEN
  1675: ||                       ITYPE = IBTYPEP(K,IPROC)
  1676: ||                       NUMS(1) = NVELLP(K)
  1677: ||                       NUMS(2) = ITYPE
  1678: ||        Casey 090304: Added the following section.  If we are coupling to SWAN,
  1679: ||        C             then we also want to give the global number of each
  1680: ||        C             boundary segment.
  1681: ||        #ifndef ADCSWAN
  1682: ||                       CALL INSERT(NVELLMSG(K),OUTMSG,NUMS,2)
  1683: ||        #else
  1684: ||                       NUMS(3) = NOPE + K
  1685: ||                       CALL INSERT(NVELLMSG(K),OUTMSG,NUMS,3)
  1686: ||        #endif
  1687: ||                       WRITE(14,80) OUTMSG
  1688: ||        C
  1689: ||                       select case(itype)
  1690: ||                       case default
  1691: ||+---->                    DO I = 1,NVELLP(K)
  1692: |||                            WRITE(14,'(I8)') LABELS(IMAP_NOD_LG(NBVVP(K,I),IPROC))
  1693: ||+----                     ENDDO
  1694: ||                       case(3,13,23)
  1695: ||                          IF(USE_TVW)NWEIRBNDRY(IPROC) = 1
  1696: ||+---->                    DO I = 1,NVELLP(K)
  1697: |||                            INDX = LBINDEX_LG(K,I)
  1698: |||                            WRITE(14,81) LABELS(IMAP_NOD_LG(NBVVP(K,I),IPROC)),
  1699: |||            &                            BAR1(K,INDX),BAR2(K,INDX)
  1700: ||+----                     ENDDO
  1701: ||                       case(4,24,64)
  1702: ||                          IF(USE_TVW)NWEIRBNDRY(IPROC) = 1
  1703: ||+---->                    DO I = 1,NVELLP(K)
  1704: |||                            INDX = LBINDEX_LG(K,I)
  1705: |||                            WRITE(14,82) LABELS(IMAP_NOD_LG(NBVVP(K,I),IPROC)),
  1706: |||            &                        LABELS(IMAP_NOD_LG(IBCONNRP(K,I),IPROC)),
  1707: |||            &                        BAR1(K,INDX),BAR2(K,INDX),BAR3(K,INDX)
  1708: ||+----                     ENDDO
  1709: ||                       case(5,25)
  1710: ||+---->                    DO I = 1,NVELLP(K)
  1711: |||                            INDX = LBINDEX_LG(K,I)
  1712: |||                            WRITE(14,83) LABELS(IMAP_NOD_LG(NBVVP(K,I),IPROC)),
  1713: |||            &                      LABELS(IMAP_NOD_LG(IBCONNRP(K,I),IPROC)),
  1714: |||            &                      BAR1(K,INDX),BAR2(K,INDX),BAR3(K,INDX),
  1715: |||            &                      BAR4(K,INDX),BAR5(K,INDX),BAR6(K,INDX)
  1716: ||+----                     ENDDO
  1717: ||                       case(94)
  1718: ||        C..... DW add support for ITYPE = 94
  1719: ||+---->                    DO I = 1,NVELLP(K)
  1720: |||                            INDX = LBINDEX_LG(K,I)
  1721: |||                            WRITE(14,84) LABELS(IMAP_NOD_LG(NBVVP(K,I),IPROC)),
  1722: |||            &                          LABELS(IMAP_NOD_LG(IBCONNRP(K,I),IPROC))
  1723: ||+----                     ENDDO
  1724: ||                       end select
  1725: ||                    ENDIF
  1726: |+-----            ENDDO
  1727: |         C
  1728: |                  CLOSE(14)
  1729: |         C
  1730: +------         END DO ! end loop over subdomains
  1731:           C
  1732:           C--Print Summary of Boundary Node Decomposition
  1733:           C
  1734:                 print *, " "
  1735:                 print *, "Boundary Node Decomposition Data"
  1736:                 print *, "DOMAIN      NOPE    NETA    NBOU  NVEL    NWEIR"
  1737:                 WRITE(*,90)  "GLOBAL",NOPE, NETA, NBOU, NVEL, NWEIR
  1738: +------>        DO IPROC=1, NPROC
  1739: |                  PE(1:6) = 'PE0000'
  1740: |                  CALL IWRITE(PE,3,6,IPROC-1)
  1741: |                  WRITE(*,90)  PE,NOPEP(IPROC),NETAP(IPROC),
  1742: |              &                NBOUP(IPROC),NVELP(IPROC),NWEIRP(IPROC)
  1743: +------         ENDDO
  1744:           C
  1745:             80  FORMAT(A80)
  1746:             81  FORMAT(I8,2X,E13.6,2X,E13.6)
  1747:             82  FORMAT(I8,2X,I8,2X,E13.6,2X,E13.6,2X,E13.6)
  1748:             83  FORMAT(I8,2X,I8,6(2X,E13.6))
  1749:             84  FORMAT(I8,2X,I8)
  1750:             90  FORMAT(1X,A6,5I8)
  1751:           C
  1752:                 RETURN
  1753:                 END SUBROUTINE PREP14


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:22 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP14
INLINE LIST

  ROOT: PREP14 (prep.F:1216)
  -> NOINLINE: IWRITE (prep.F:1258)
     *** Source for routine not found.
  -> NOINLINE: NEWINDEX (prep.F:1638)
     *** Source for routine not found.
  -> NOINLINE: NEWINDEX (prep.F:1641)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:1656)
     *** Source for routine not found.
  -> NOINLINE: NEWINDEX (prep.F:1667)
     *** Source for routine not found.
  -> NOINLINE: NEWINDEX (prep.F:1670)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:1685)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:1740)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:22 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP14
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:1255)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:1257)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:1257)
    LOOP END

    LOOP BEGIN: (prep.F:1268)
      <Vectorized loop.>
      **  Interchanged loop. (prep.F:1268)
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1268)
      *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1268)
    LOOP END

    LOOP BEGIN: (prep.F:1270)
      <Unvectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:1270)

      LOOP BEGIN: (prep.F:1270)
        <Vectorized loop.>
        **  Copied loop. : FOR UNROLLING (prep.F:1270)
        **  Interchanged loop. (prep.F:1270)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1270)
        *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1270)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1270)
      <Unvectorized loop.>
      **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:1270)

      LOOP BEGIN: (prep.F:1270)
        <Vectorized loop.>
        **  Interchanged loop. (prep.F:1270)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1270)
        *** The number of VLOAD, VSTORE. :  0,  4. (prep.F:1270)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1277)
      <Unvectorized loop.>
      *** Overhead of loop division is too large. (prep.F:1277)

      LOOP BEGIN: (prep.F:1278)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  1,  0. (prep.F:1278)
        *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:1278)
        *** VGT generated (prep.F:1280)

        LOOP BEGIN: (prep.F:1281)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:1281)
          *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:1281)
          *** The number of VCOMPRESS, VEXPAND. :  2,  0. (prep.F:1281)
          *** VCOMPRESS generated (prep.F:1288)
          *** VCOMPRESS generated (prep.F:1289)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1297)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1297)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1297)
    LOOP END

    LOOP BEGIN: (prep.F:1311)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1311)
      *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:1311)
    LOOP END

    LOOP BEGIN: (prep.F:1316)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1316)

      LOOP BEGIN: (prep.F:1394)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  1,  0. (prep.F:1394)
        *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:1394)
        *** VGT generated (prep.F:1396)

        LOOP BEGIN: (prep.F:1399)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:1399)
          *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:1399)
          *** The number of VCOMPRESS, VEXPAND. :  2,  0. (prep.F:1399)
          *** VCOMPRESS generated (prep.F:1416)
          *** VCOMPRESS generated (prep.F:1419)
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1354)
        <Partially vectorized loop.>
        *** The number of VGT,   VSC.    :  1,  0. (prep.F:1354)
        *** The number of VLOAD, VSTORE. :  2,  3. (prep.F:1354)
        *** VGT generated (prep.F:1358)

        LOOP BEGIN: (prep.F:1359)
          <Partially vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:1359)
          *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:1359)

          LOOP BEGIN: (prep.F:1365)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:1365)
            *** The number of VLOAD, VSTORE. :  2,  3. (prep.F:1365)
            *** The number of VCOMPRESS, VEXPAND. :  3,  0. (prep.F:1365)
            *** VCOMPRESS generated (prep.F:1374)
            *** VCOMPRESS generated (prep.F:1375)
            *** VCOMPRESS generated (prep.F:1379)
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1326)
        <Partially vectorized loop.>
        *** The number of VGT,   VSC.    :  1,  0. (prep.F:1326)
        *** The number of VLOAD, VSTORE. :  2,  3. (prep.F:1326)
        *** VGT generated (prep.F:1328)

        LOOP BEGIN: (prep.F:1329)
          <Partially vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:1329)
          *** The number of VLOAD, VSTORE. :  2,  2. (prep.F:1329)

          LOOP BEGIN: (prep.F:1334)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:1334)
            *** The number of VLOAD, VSTORE. :  2,  3. (prep.F:1334)
            *** The number of VCOMPRESS, VEXPAND. :  3,  0. (prep.F:1334)
            *** VCOMPRESS generated (prep.F:1341)
            *** VCOMPRESS generated (prep.F:1342)
            *** VCOMPRESS generated (prep.F:1343)
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1485)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1485)
    LOOP END

    LOOP BEGIN: (prep.F:1502)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1502)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1502)
    LOOP END

    LOOP BEGIN: (prep.F:1518)
      <Unvectorized loop.>
      *** Overhead of loop division is too large. (prep.F:1518)

      LOOP BEGIN: (prep.F:1546)
        <Vectorized loop.>
        **  Copied loop. : FOR REMOVING INVARIANT IF (prep.F:1546)
        **  Runtime-tested scalar loop. (prep.F:1546)
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1546)
        *** The number of VLOAD, VSTORE. :  0,  0. (prep.F:1546)
      LOOP END

      LOOP BEGIN: (prep.F:1546)
        <Unvectorized loop.>
        *** Overhead of loop division is too large. (prep.F:1546)
        *** Unvectorizable dependency. (prep.F:1560)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1580)
      <Partially vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1580)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1580)

      LOOP BEGIN: (prep.F:1581)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1581)
        *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1581)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1591)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1591)
      *** The number of VLOAD, VSTORE. :  2,  0. (prep.F:1591)
    LOOP END

    LOOP BEGIN: (prep.F:1620)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1620)
    LOOP END

    LOOP BEGIN: (prep.F:1625)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1625)
    LOOP END

    LOOP BEGIN: (prep.F:1645)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1659)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1659)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1673)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1691)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1691)
      LOOP END

      LOOP BEGIN: (prep.F:1719)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1719)
      LOOP END

      LOOP BEGIN: (prep.F:1710)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1710)
      LOOP END

      LOOP BEGIN: (prep.F:1703)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1703)
      LOOP END

      LOOP BEGIN: (prep.F:1696)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1696)
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:1738)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:1738)
    *** I/O statement obstructs vectorization. (prep.F:1738)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:22 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP14
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 64 [v0-v63]
      Vector mask registers    :  6 [vm10-vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 806192 bytes
      Register spill area      :   2336 bytes
      Parameter area           :    160 bytes
      Register save area       :    176 bytes
      User data area           : 803520 bytes
      Others                   :      0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:1255)
    *** Estimated execution cycle                       : 2067
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 180
            Across calls                                :  37
            Over basic blocks                           : 141
            Others                                      :   2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 262
            Across calls                                :  47
            Over basic blocks                           : 212
            Others                                      :   3
    *** The number of SCALAR REGISTER TRANSFER          : 287

    LOOP BEGIN: (prep.F:1257)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:1268)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:1270)
      *** Estimated execution cycle                     : 38
      *** The number of SCALAR REGISTER TRANSFER        : 2

      LOOP BEGIN: (prep.F:1270)
        *** Estimated execution cycle                   : 63
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1270)
      *** Estimated execution cycle                     : 57
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:1270)
        *** Estimated execution cycle                   : 164
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1277)
      *** Estimated execution cycle                     : 83
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 36

      LOOP BEGIN: (prep.F:1278)
        *** Estimated execution cycle                   : 218
      LOOP END

      LOOP BEGIN: (prep.F:1278)
        *** Estimated execution cycle                   : 67
        *** The number of SCALAR REGISTER TRANSFER      : 18

        LOOP BEGIN: (prep.F:1281)
          *** Estimated execution cycle                 : 267
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1297)
      *** Estimated execution cycle                     : 52
    LOOP END

    LOOP BEGIN: (prep.F:1311)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (prep.F:1316)
      *** Estimated execution cycle                     : 957
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 74
              Across calls                              : 18
              Over basic blocks                         : 51
              Others                                    :  5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 117
              Across calls                              :  18
              Over basic blocks                         :  99
      *** The number of SCALAR REGISTER TRANSFER        : 144

      LOOP BEGIN: (prep.F:1394)
        *** Estimated execution cycle                   : 218
      LOOP END

      LOOP BEGIN: (prep.F:1394)
        *** Estimated execution cycle                   : 57
        *** The number of SCALAR REGISTER TRANSFER      : 7

        LOOP BEGIN: (prep.F:1399)
          *** Estimated execution cycle                 : 291
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1354)
        *** Estimated execution cycle                   : 252
      LOOP END

      LOOP BEGIN: (prep.F:1354)
        *** Estimated execution cycle                   : 117
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 1
                Over basic blocks                       : 8
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 9
                Across calls                            : 1
                Over basic blocks                       : 8
        *** The number of SCALAR REGISTER TRANSFER      : 31

        LOOP BEGIN: (prep.F:1359)
          *** Estimated execution cycle                 : 96
        LOOP END

        LOOP BEGIN: (prep.F:1359)
          *** Estimated execution cycle                 : 59
          *** The number of SCALAR REGISTER TRANSFER    : 11

          LOOP BEGIN: (prep.F:1365)
            *** Estimated execution cycle               : 365
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:1326)
        *** Estimated execution cycle                   : 250
      LOOP END

      LOOP BEGIN: (prep.F:1326)
        *** Estimated execution cycle                   : 95
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER TRANSFER      : 15

        LOOP BEGIN: (prep.F:1329)
          *** Estimated execution cycle                 : 96
        LOOP END

        LOOP BEGIN: (prep.F:1329)
          *** Estimated execution cycle                 : 59
          *** The number of SCALAR REGISTER TRANSFER    : 11

          LOOP BEGIN: (prep.F:1334)
            *** Estimated execution cycle               : 365
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1485)
      *** Estimated execution cycle                     : 186
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 13
              Across calls                              :  9
              Others                                    :  4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 24
              Across calls                              : 14
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER TRANSFER        : 31
    LOOP END

    LOOP BEGIN: (prep.F:1502)
      *** Estimated execution cycle                     : 52
    LOOP END

    LOOP BEGIN: (prep.F:1518)
      *** Estimated execution cycle                     : 131
      *** The number of SCALAR REGISTER TRANSFER        : 20

      LOOP BEGIN: (prep.F:1546)
        *** Estimated execution cycle                   : 4
      LOOP END

      LOOP BEGIN: (prep.F:1546)
        *** Estimated execution cycle                   : 26
        *** The number of SCALAR REGISTER TRANSFER      : 6
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1580)
      *** Estimated execution cycle                     : 61
    LOOP END

    LOOP BEGIN: (prep.F:1580)
      *** Estimated execution cycle                     : 43
      *** The number of SCALAR REGISTER TRANSFER        : 3

      LOOP BEGIN: (prep.F:1581)
        *** Estimated execution cycle                   : 63
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1591)
      *** Estimated execution cycle                     : 747
    LOOP END

    LOOP BEGIN: (prep.F:1620)
      *** Estimated execution cycle                     : 142
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 11
              Across calls                              :  8
              Over basic blocks                         :  2
              Others                                    :  1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 18
              Across calls                              : 11
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 17
    LOOP END

    LOOP BEGIN: (prep.F:1625)
      *** Estimated execution cycle                     : 220
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 9
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 30
              Across calls                              : 23
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 17
    LOOP END

    LOOP BEGIN: (prep.F:1645)
      *** Estimated execution cycle                     : 145
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 10
              Across calls                              :  4
              Over basic blocks                         :  6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 14
              Across calls                              :  4
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER TRANSFER        : 20

      LOOP BEGIN: (prep.F:1659)
        *** Estimated execution cycle                   : 57
        *** The number of SCALAR REGISTER TRANSFER      : 5
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1673)
      *** Estimated execution cycle                     : 560
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 23
              Across calls                              :  4
              Over basic blocks                         : 19
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 140
              Across calls                              :   4
              Over basic blocks                         : 136
      *** The number of SCALAR REGISTER TRANSFER        : 46

      LOOP BEGIN: (prep.F:1691)
        *** Estimated execution cycle                   : 114
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 9
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 17
                Across calls                            :  9
                Over basic blocks                       :  7
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 14
      LOOP END

      LOOP BEGIN: (prep.F:1719)
        *** Estimated execution cycle                   : 166
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 11
                Across calls                            : 11
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 25
                Across calls                            : 16
                Over basic blocks                       :  8
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 16
      LOOP END

      LOOP BEGIN: (prep.F:1710)
        *** Estimated execution cycle                   : 307
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 15
                Across calls                            : 14
                Others                                  :  1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 45
                Across calls                            : 33
                Over basic blocks                       : 11
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 24
      LOOP END

      LOOP BEGIN: (prep.F:1703)
        *** Estimated execution cycle                   : 257
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 16
                Across calls                            : 15
                Others                                  :  1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 38
                Across calls                            : 26
                Over basic blocks                       : 11
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 21
      LOOP END

      LOOP BEGIN: (prep.F:1696)
        *** Estimated execution cycle                   : 173
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 13
                Across calls                            : 12
                Others                                  :  1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 21
                Across calls                            : 12
                Over basic blocks                       :  8
                Others                                  :  1
        *** The number of SCALAR REGISTER TRANSFER      : 16
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:1738)
    *** Estimated execution cycle                       : 281
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 21
            Across calls                                : 17
            Over basic blocks                           :  4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 50
            Across calls                                : 32
            Over basic blocks                           : 17
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 27
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  1790: vec( 101): Vectorized loop.
  1792: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1795: vec( 103): Unvectorized loop.
  1795: vec( 118): Unvectorizable data type.: LOCFN
  1796: inl(1212): Source for routine not found.: IWRITE
  1797: vec( 103): Unvectorized loop.
  1797: vec( 108): Unvectorizable loop structure.
  1810: opt(3014): Moved reference within a conditional branch.
  1818: vec( 103): Unvectorized loop.
  1818: vec( 180): I/O statement obstructs vectorization.
  1819: opt(1118): This I/O statement inhibits optimization of loop.
  1828: opt(3014): Moved reference within a conditional branch.
  1836: opt(3014): Moved reference within a conditional branch.
  1844: opt(3014): Moved reference within a conditional branch.
  1845: opt(3014): Moved reference within a conditional branch.
  1865: opt(3014): Moved reference within a conditional branch.
  1868: opt(3014): Moved reference within a conditional branch.
  1869: opt(3014): Moved reference within a conditional branch.
  1881: vec( 103): Unvectorized loop.
  1881: vec( 180): I/O statement obstructs vectorization.
  1882: opt(1118): This I/O statement inhibits optimization of loop.
  1887: vec( 103): Unvectorized loop.
  1887: vec( 180): I/O statement obstructs vectorization.
  1888: opt(1118): This I/O statement inhibits optimization of loop.
  1893: vec( 103): Unvectorized loop.
  1893: vec( 180): I/O statement obstructs vectorization.
  1894: opt(1118): This I/O statement inhibits optimization of loop.
  1908: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1908: vec( 101): Vectorized loop.
  1910: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1910: vec( 101): Vectorized loop.
  1913: opt(1019): Feedback of scalar value from one loop pass to another.: NFLBNP
  1914: opt(3014): Moved reference within a conditional branch.
  1919: opt(3014): Moved reference within a conditional branch.
  1921: vec( 103): Unvectorized loop.
  1921: vec( 180): I/O statement obstructs vectorization.
  1922: opt(1118): This I/O statement inhibits optimization of loop.
  1927: vec( 103): Unvectorized loop.
  1927: vec( 180): I/O statement obstructs vectorization.
  1928: opt(1118): This I/O statement inhibits optimization of loop.
  1944: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1944: vec( 102): Partially vectorized loop.
  1946: vec( 101): Vectorized loop.
  1955: vec( 103): Unvectorized loop.
  1955: vec( 108): Unvectorizable loop structure.
  1955: vec( 118): Unvectorizable data type.: LOCFN
  1957: vec( 103): Unvectorized loop.
  1957: vec( 108): Unvectorizable loop structure.
  1964: vec( 180): I/O statement obstructs vectorization.
  1964: vec( 181): Allocation obstructs vectorization.
  1964: vec( 182): Deallocation obstructs vectorization.
  1966: opt(1082): Backward transfers inhibit loop optimization.
  1966: opt(1118): This I/O statement inhibits optimization of loop.
  1966: vec( 103): Unvectorized loop.
  1966: vec( 108): Unvectorizable loop structure.
  1966: vec( 118): Unvectorizable data type.: TIMEVARYINGWEIRMSSG
  1966: vec( 118): Unvectorizable data type.
  1987: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  1988: vec( 101): Vectorized loop.
  1990: vec( 126): Idiom detected.: SEARCH
  1991: opt(1019): Feedback of scalar value from one loop pass to another.: NSTAEP
  1991: opt(3014): Moved reference within a conditional branch.
  1993: opt(3014): Moved reference within a conditional branch.
  1994: opt(1019): Feedback of scalar value from one loop pass to another.: KK
  1994: opt(3014): Moved reference within a conditional branch.
  1995: opt(3014): Moved reference within a conditional branch.
  2006: inl(1212): Source for routine not found.: INSERT
  2007: opt(3014): Moved reference within a conditional branch.
  2014: opt(3014): Moved reference within a conditional branch.
  2017: opt(3014): Moved reference within a conditional branch.
  2021: vec( 103): Unvectorized loop.
  2021: vec( 180): I/O statement obstructs vectorization.
  2024: opt(1118): This I/O statement inhibits optimization of loop.
  2024: opt(3014): Moved reference within a conditional branch.
  2026: opt(3014): Moved reference within a conditional branch.
  2037: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2038: vec( 101): Vectorized loop.
  2040: vec( 126): Idiom detected.: SEARCH
  2041: opt(1019): Feedback of scalar value from one loop pass to another.: NSTAVP
  2041: opt(3014): Moved reference within a conditional branch.
  2043: opt(3014): Moved reference within a conditional branch.
  2044: opt(1019): Feedback of scalar value from one loop pass to another.: KK
  2044: opt(3014): Moved reference within a conditional branch.
  2045: opt(3014): Moved reference within a conditional branch.
  2055: opt(3014): Moved reference within a conditional branch.
  2062: opt(3014): Moved reference within a conditional branch.
  2065: opt(3014): Moved reference within a conditional branch.
  2069: vec( 103): Unvectorized loop.
  2069: vec( 180): I/O statement obstructs vectorization.
  2072: opt(1118): This I/O statement inhibits optimization of loop.
  2072: opt(3014): Moved reference within a conditional branch.
  2074: opt(3014): Moved reference within a conditional branch.
  2088: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2089: vec( 101): Vectorized loop.
  2091: vec( 126): Idiom detected.: SEARCH
  2092: opt(1019): Feedback of scalar value from one loop pass to another.: NSTACP
  2092: opt(3014): Moved reference within a conditional branch.
  2094: opt(3014): Moved reference within a conditional branch.
  2095: opt(1019): Feedback of scalar value from one loop pass to another.: KK
  2095: opt(3014): Moved reference within a conditional branch.
  2096: opt(3014): Moved reference within a conditional branch.
  2107: opt(3014): Moved reference within a conditional branch.
  2114: opt(3014): Moved reference within a conditional branch.
  2117: opt(3014): Moved reference within a conditional branch.
  2120: vec( 103): Unvectorized loop.
  2120: vec( 180): I/O statement obstructs vectorization.
  2123: opt(1118): This I/O statement inhibits optimization of loop.
  2123: opt(3014): Moved reference within a conditional branch.
  2125: opt(3014): Moved reference within a conditional branch.
  2138: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2139: vec( 101): Vectorized loop.
  2141: vec( 126): Idiom detected.: SEARCH
  2142: opt(1019): Feedback of scalar value from one loop pass to another.: NSTAMP
  2142: opt(3014): Moved reference within a conditional branch.
  2144: opt(3014): Moved reference within a conditional branch.
  2145: opt(1019): Feedback of scalar value from one loop pass to another.: KK
  2145: opt(3014): Moved reference within a conditional branch.
  2146: opt(3014): Moved reference within a conditional branch.
  2157: opt(3014): Moved reference within a conditional branch.
  2164: opt(3014): Moved reference within a conditional branch.
  2167: opt(3014): Moved reference within a conditional branch.
  2171: vec( 103): Unvectorized loop.
  2171: vec( 180): I/O statement obstructs vectorization.
  2174: opt(1118): This I/O statement inhibits optimization of loop.
  2174: opt(3014): Moved reference within a conditional branch.
  2176: opt(3014): Moved reference within a conditional branch.
  2206: vec( 103): Unvectorized loop.
  2206: vec( 180): I/O statement obstructs vectorization.
  2207: opt(1118): This I/O statement inhibits optimization of loop.
  2226: inl(1222): Inlined: PREP15_3DVS
  2234: vec( 103): Unvectorized loop.
  2234: vec( 108): Unvectorizable loop structure.
  2234: vec( 118): Unvectorizable data type.: TITLE
  2234: vec( 118): Unvectorizable data type.
  2235: vec( 103): Unvectorized loop.
  2235: vec( 108): Unvectorizable loop structure.
  2235: vec( 118): Unvectorizable data type.: INSTITUTION
  2235: vec( 118): Unvectorizable data type.
  2236: vec( 103): Unvectorized loop.
  2236: vec( 108): Unvectorizable loop structure.
  2236: vec( 118): Unvectorizable data type.: SOURCE
  2236: vec( 118): Unvectorizable data type.
  2237: vec( 103): Unvectorized loop.
  2237: vec( 108): Unvectorizable loop structure.
  2237: vec( 118): Unvectorizable data type.: HISTORY
  2237: vec( 118): Unvectorizable data type.
  2238: vec( 103): Unvectorized loop.
  2238: vec( 108): Unvectorizable loop structure.
  2238: vec( 118): Unvectorizable data type.: REFERENCES
  2238: vec( 118): Unvectorizable data type.
  2239: vec( 103): Unvectorized loop.
  2239: vec( 108): Unvectorizable loop structure.
  2239: vec( 118): Unvectorizable data type.: COMMENTS
  2239: vec( 118): Unvectorizable data type.
  2240: vec( 103): Unvectorized loop.
  2240: vec( 108): Unvectorizable loop structure.
  2240: vec( 118): Unvectorizable data type.: HOST
  2240: vec( 118): Unvectorizable data type.
  2241: vec( 103): Unvectorized loop.
  2241: vec( 108): Unvectorizable loop structure.
  2241: vec( 118): Unvectorizable data type.: CONVENTION
  2241: vec( 118): Unvectorizable data type.
  2242: vec( 103): Unvectorized loop.
  2242: vec( 108): Unvectorizable loop structure.
  2242: vec( 118): Unvectorizable data type.: CONTACT
  2242: vec( 118): Unvectorizable data type.
  2243: vec( 103): Unvectorized loop.
  2243: vec( 108): Unvectorizable loop structure.
  2243: vec( 118): Unvectorizable data type.: BASE_DATE
  2243: vec( 118): Unvectorizable data type.
  2274: vec( 103): Unvectorized loop.
  2274: vec( 108): Unvectorizable loop structure.
  2288: vec( 103): Unvectorized loop.
  2288: vec( 108): Unvectorizable loop structure.
  2288: vec( 118): Unvectorizable data type.: TVW_FILE
  2288: vec( 118): Unvectorizable data type.
  2307: vec( 103): Unvectorized loop.
  2307: vec( 108): Unvectorizable loop structure.
  2307: vec( 118): Unvectorizable data type.: NWS13FILE
  2307: vec( 118): Unvectorizable data type.: NWS13COLDSTARTSTRING
  2307: vec( 118): Unvectorizable data type.: NWS13WINDMULTIPLIER
  2307: vec( 118): Unvectorizable data type.: NWS13GROUPFORPOWELL
  2333: vec( 103): Unvectorized loop.
  2333: vec( 108): Unvectorizable loop structure.
  2333: vec( 118): Unvectorizable data type.: SUBGRIDFILENAME
  2333: vec( 118): Unvectorizable data type.
  2370: vec( 103): Unvectorized loop.
  2370: vec( 108): Unvectorizable loop structure.
  2370: vec( 118): Unvectorizable data type.: DYNAMICWATERLEVELCORRECTIONFILENAME
  2370: vec( 118): Unvectorizable data type.
  2404: vec( 103): Unvectorized loop.
  2404: vec( 108): Unvectorizable loop structure.
  2406: vec( 103): Unvectorized loop.
  2406: vec( 108): Unvectorizable loop structure.
  2408: vec( 103): Unvectorized loop.
  2408: vec( 108): Unvectorizable loop structure.
  2419: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  2430: vec( 103): Unvectorized loop.
  2430: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  2430: vec( 180): I/O statement obstructs vectorization.
  2432: opt(1025): Reference to this procedure inhibits optimization.: IWRITE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  1766:                 SUBROUTINE PREP15()
  1767:                 USE PRE_GLOBAL
  1768:                 use memory_usage
  1769:                 USE PREP_WEIR
  1770:                 USE HARM, ONLY : NAMEFR
  1771:                 use subprep, only : subdomainOn, found_sm_nml ! NCSU Subdomain Modeling
  1772:                 use nodalattributes, only : outputTau0
  1773:                 IMPLICIT NONE
  1774:                 integer(8) :: nbytes = 0
  1775:                 INTEGER I,J,K,M,JG,JP,KK, ios_stations
  1776:                 INTEGER INDX,ITOT,ILNODE,IPROC,IPROC2,ITYPE,NUMS(10)
  1777:                 CHARACTER LOCFN*80,PE*6,LOCSTATFN*20
  1778:                 INTEGER,ALLOCATABLE :: NTIMEVARYINGWEIRP(:)
  1779:                 CHARACTER*80 OUTMSG
  1780:           
  1781:                 CHARACTER (LEN=20):: FMT
  1782:           C
  1783:           C--Write a Local Input file ( fort.15 ) for each PE
  1784:           C
  1785:                 ! max number of stations in any subdomain
  1786:                 NSTAE_MAX = 0; NSTAV_MAX = 0; NSTAM_MAX = 0; NSTAC_MAX = 0
  1787:           C
  1788:           
  1789:                 ALLOCATE(NTIMEVARYINGWEIRP(NPROC))
  1790: V======>        NTIMEVARYINGWEIRP(:)=0
  1791:           
  1792: +------>        DO 1000 IPROC = 1,NPROC
  1793: |         C
  1794: |         
  1795: |+=====>           LOCFN = 'PE0000/fort.15'
  1796: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
  1797: |                  OPEN (15,FILE=TRIM(LOCFN))
  1798: |         C
  1799: |                  WRITE(15,80) RUNDES
  1800: |                  WRITE(15,80) RUNID
  1801: |                  WRITE(15,80) OVERMSG
  1802: |                  WRITE(15,80) ABOUTMSG
  1803: |                  WRITE(15,80) SCREENMSG
  1804: |                  WRITE(15,80) HOTMSG
  1805: |                  WRITE(15,80) ICSMSG
  1806: |                  WRITE(15,80) IMMSG
  1807: |         Casey 140701: Debug.
  1808: |         C        IF (CBaroclinic) THEN  !jgf46.28
  1809: |                  IF (CBaroclinic.AND.IM.GE.10) THEN  !jgf46.28
  1810: |                     WRITE(15,80) IDENMSG
  1811: |                  ENDIF
  1812: |                  WRITE(15,80) IBFMSG
  1813: |                  WRITE(15,80) IFAMSG
  1814: |                  WRITE(15,80) ICAMSG
  1815: |                  WRITE(15,80) ICATMSG
  1816: |                  WRITE(15,80) NWPMSG
  1817: |                  IF (NWP.gt.0) THEN !jgf46.00 write nodal attributes
  1818: |+----->              DO I=1, NWP
  1819: ||                       WRITE(15,80) useNodalAttrNames(I)
  1820: |+-----               ENDDO
  1821: |                  ENDIF
  1822: |                  WRITE(15,80) NCORMSG
  1823: |                  WRITE(15,80) NTIPMSG
  1824: |         C     jgfdebug46.02 Added check for NWS=45 to write NWS=5
  1825: |                  IF (NWS.EQ.45) THEN
  1826: |                     WRITE(15,'(A1)') "5"
  1827: |                  ELSE
  1828: |                     WRITE(15,80) NWSMSG
  1829: |                  ENDIF
  1830: |                  WRITE(15,80) RAMPMSG
  1831: |                  WRITE(15,80) GMSG
  1832: |                  WRITE(15,80) TAU0MSG
  1833: |         
  1834: |         C        jgf47.11 Added writing of limits for time varying tau0
  1835: |                  IF ( (TAU0.le.-5.d0).AND.(TAU0.gt.-6.d0) ) THEN
  1836: |                      WRITE(15,80) TAU0LIMMSG
  1837: |                  ENDIF
  1838: |         
  1839: |                  WRITE(15,80) DTMSG
  1840: |                  WRITE(15,80) STATMSG
  1841: |                  WRITE(15,80) REFTMSG
  1842: |         
  1843: |         !       tcm v49.64.01 No changes needed here for the use of ICE
  1844: |                  IF((NWS.EQ.0).AND.(NRS.GE.1)) WRITE(15,80) RSTIMMSG  ! sb46.28sb03
  1845: |                  IF((NWS.EQ.1).AND.(NRS.GE.1)) WRITE(15,80) RSTIMMSG  ! sb46.28sb03
  1846: |         C     jgfdebug46.02 Added check for NWS=45.
  1847: |         C     jgf46.02 Added NWS=8.
  1848: |         C     jgf46.16 Merged:
  1849: |         C     rjw added NWS=19: asymmetric hurricane wind model v2.0
  1850: |         C     jie added NWS=20: generalized asymmetric vortex model
  1851: |         C     sb46.28sb01 added NWS=12: OWI format
  1852: |         C     jgf50.38.05: added NWS=15: HWind format
  1853: |         C     tcm v51.06.02 added NWS=16: GFDL Met Data
  1854: |         C     xyc v52.30 added NWS=7 to be consistent with NWS=6
  1855: |         C     arc added nws13 190110
  1856: |         C     jgf: Added NWS=30 (GAHM+OWI)
  1857: |                  IF ((ABS(NWS).EQ.2).OR.(ABS(NWS).EQ.4).OR.(ABS(NWS).EQ.45).OR.
  1858: |              &        (ABS(NWS).EQ.5).OR.(ABS(NWS).EQ.6).OR.(ABS(NWS).EQ.7)
  1859: |              &       .OR.(ABS(NWS).EQ.8).OR.(ABS(NWS).EQ.10).OR.(ABS(NWS).EQ.12)
  1860: |              &       .OR.(ABS(NWS).EQ.15).OR.(ABS(NWS).EQ.14)
  1861: |              &       .OR.(ABS(NWS).EQ.16).OR.(ABS(NWS).EQ.30)
  1862: |              &       .OR.(ABS(NWS).EQ.19).OR.(ABS(NWS).EQ.29)
  1863: |              &       .OR.(ABS(NWS).EQ.20).OR.(ABS(NWS).EQ.13)
  1864: |              &       .OR.(ABS(NWS).EQ.17)) THEN ! for NUOPC: added by PV, SM
  1865: |                     WRITE(15,80) WSMSG1
  1866: |                  ENDIF
  1867: |                  IF (NWS.EQ.3) THEN
  1868: |                     WRITE(15,80) WSMSG1
  1869: |                     WRITE(15,80) WSMSG2
  1870: |                  ENDIF
  1871: |         
  1872: |                  WRITE(15,80) RNDAYMSG
  1873: |                  WRITE(15,80) DRAMPMSG
  1874: |                  WRITE(15,80) COEFMSG
  1875: |                  WRITE(15,80) H0MSG
  1876: |                  WRITE(15,80) SLMSG
  1877: |                  WRITE(15,80) TAUMSG
  1878: |                  WRITE(15,80) ESLMSG
  1879: |                  WRITE(15,80) CORIMSG
  1880: |                  WRITE(15,80) NTIFMSG
  1881: |+----->           DO I=1,NTIF
  1882: ||                    WRITE(15,80)  TIPOTAG(I)
  1883: ||                    WRITE(15,80)  TPKMSG(I)
  1884: |+-----            ENDDO
  1885: |         
  1886: |                  WRITE(15,80) NBFRMSG
  1887: |+----->           DO I=1,NBFR
  1888: ||                    WRITE(15,80) BOUNTAG(I)
  1889: ||                    WRITE(15,80) AMIGMSG(I)
  1890: |+-----            ENDDO
  1891: |+----->           DO I=1,NBFR
  1892: ||                    WRITE(15,80) ALPHA1(I)
  1893: ||+---->              DO J=1,NETAP(IPROC)
  1894: |||                      WRITE(15,80) EMOMSG(I,OBNODE_LG(J,IPROC))
  1895: ||+----               ENDDO
  1896: |+-----            ENDDO
  1897: |         
  1898: |                  WRITE(15,80) ANGMSG
  1899: |         C
  1900: |         C--If there were any normal flow boundaries local to PE, process them
  1901: |         C
  1902: |         C         PRINT *, NFFRMSG
  1903: |         C         PRINT *, "NFLUXFP(",IPROC,") = ", NFLUXFP(IPROC)
  1904: |         
  1905: |                  IF (NFLUXFP(IPROC).EQ.1) THEN
  1906: |         C
  1907: |                     NFLBNP = 0
  1908: |V----->              DO I=1, NFLBN
  1909: ||      G                INDX = FLBN(I)
  1910: ||V---->                 DO J=1, ITOTPROC(INDX)
  1911: |||                         IPROC2 = IMAP_NOD_GL2(2*(J-1)+1,INDX)
  1912: |||                         IF (IPROC.EQ.IPROC2) THEN
  1913: |||                            NFLBNP = NFLBNP + 1
  1914: |||                            FLBNXP(NFLBNP) = FLBNX(I)
  1915: |||                         ENDIF
  1916: ||V----                  ENDDO
  1917: |V-----               ENDDO
  1918: |         C
  1919: |                     WRITE(15,80) NFFRMSG
  1920: |                     IF ((NFFR.NE.0).AND.(NFFR.NE.-1)) THEN
  1921: |+----->                 DO I=1,NFFR
  1922: ||                          WRITE(15,80) FBOUNTAG(I)
  1923: ||                          WRITE(15,80) FREQMSG(I)
  1924: |+-----                  ENDDO
  1925: |+----->                 DO I=1,NFFR
  1926: ||                          WRITE(15,80) ALPHA2(I)
  1927: ||+---->                    DO J=1,NFLBNP
  1928: |||                            WRITE(15,80) QNMSG(I,FLBNXP(J))
  1929: |||       cdebug               print *, "PE=",IPROC," FLUXNODE=",FLBNXP(J)
  1930: ||+----                     ENDDO
  1931: |+-----                  ENDDO
  1932: |                     ENDIF
  1933: |         C
  1934: |                  ENDIF
  1935: |         
  1936: |         Cobell
  1937: |         C--IF THERE ARE INTERNAL/EXTERNAL TIME VARYING FLUX BOUNDARIES, PARSE TO PEs
  1938: |         C
  1939: |                 IF(USE_TVW)THEN
  1940: |                     IF(ALLOCATED(NWEIRBNDRY).AND.NTIMEVARYINGWEIR.GT.0)THEN
  1941: |                         IF(NWEIRBNDRY(IPROC).EQ.1)THEN
  1942: |                         !...If this processor has Time varying weirs, count them
  1943: |                             NTIMEVARYINGWEIRP(IPROC) = 0
  1944: |S----->                      DO I=1,NNODP(IPROC)
  1945: ||                                INDX = IMAP_NOD_LG(I,IPROC)
  1946: ||V---->                          DO J = 1,NTIMEVARYINGWEIR
  1947: |||                                   IF(INDX.EQ.NODES_TVW(J))THEN
  1948: |||                                       NTIMEVARYINGWEIRP(IPROC) =
  1949: |||            &                              NTIMEVARYINGWEIRP(IPROC) + 1
  1950: |||                                   ENDIF
  1951: ||V----                           ENDDO
  1952: |S-----                       ENDDO
  1953: |                         ENDIF
  1954: |                         !...Open the local PE fort.tvw
  1955: |+=====>                  LOCFN = 'PE0000/'//TRIM(tvw_file)
  1956: |                         CALL IWRITE(LOCFN,3,6,IPROC-1)
  1957: |                         OPEN(FILE=TRIM(LOCFN),UNIT=98,ACTION="WRITE")
  1958: |                         IF(NTIMEVARYINGWEIRP(IPROC).GT.0)THEN
  1959: |                             !...Write fort.tvw namelist file for the
  1960: |                             !   local PE
  1961: |                             WRITE(98,*) NTIMEVARYINGWEIRP(IPROC)
  1962: |+----->                      DO I=1,NNODP(IPROC)
  1963: ||                                INDX = IMAP_NOD_LG(I,IPROC)
  1964: ||+---->                          DO J = 1,NTIMEVARYINGWEIR
  1965: |||                                   IF(INDX.EQ.NODES_TVW(J))THEN
  1966: |||                                       WRITE(98,'(A)')
  1967: |||            &                              TRIM(ADJUSTL(TIMEVARYINGWEIRMSSG(J)))
  1968: |||                                   ENDIF
  1969: ||+----                           ENDDO
  1970: |+-----                       ENDDO
  1971: |                         ELSE
  1972: |                             !...Write an empty fort.tvw to avoid old files from
  1973: |                             !   previous decompositions
  1974: |                             WRITE(98,*) 0
  1975: |                         ENDIF
  1976: |                         CLOSE(98)
  1977: |                     ENDIF
  1978: |                 ENDIF
  1979: |         C
  1980: |         C--Write Local Elevation Station Info:
  1981: |         C--Create Local-to-Global element "ownership" of an elevation station
  1982: |         C
  1983: |         C     WRITE(15,80) STAEMSG !jgf45.07 we may have changed NOUTE in adcprep
  1984: |                  WRITE(15,*) NOUTE,TOUTSE,TOUTFE,NSPOOLE
  1985: |         C
  1986: |                  NSTAEP(IPROC) = 0
  1987: |+----->           DO K = 1,abs(NSTAE)                          !tcm -- added the comments below
  1988: ||V---->              DO J=1,NELP(IPROC)                        !nelp(iproc) lists the number of elements from processor iproc
  1989: |||                      INDX = abs(IMAP_EL_LG(J,IPROC))        ! global element number
  1990: |||                      IF (INDX.EQ.NNSEG(K)) THEN             !nnseg(k) contains the element number station k resides in
  1991: |||                         NSTAEP(IPROC) = NSTAEP(IPROC) + 1
  1992: |||                         KK = K
  1993: |||                         if (STAE_SHARE(K) > -1) KK = -K
  1994: |||                         IMAP_STAE_LG(NSTAEP(IPROC),IPROC) = KK
  1995: |||                         STAE_SHARE(K) = IPROC
  1996: |||                         ! tcm v51.20.03 once found exit the element loop
  1997: |||                         exit
  1998: |||                      ENDIF
  1999: ||V----               ENDDO
  2000: |+-----            ENDDO
  2001: |                  NSTAE_MAX = MAX(NSTAEP(IPROC),NSTAE_MAX)
  2002: |         C
  2003: |         C...     update the number of stations for this proc's domain
  2004: |         
  2005: |                  if (use_elev_stat_file ) then  !tcm v51.20.03
  2006: |                     CALL INSERT(NSTAEMSG,OUTMSG,(/-NSTAEP(IPROC)/),1)  !keep the negative sign for fort.15
  2007: |                     write(15,80) OUTMSG
  2008: |                     CALL INSERT(NSTAEMSG,OUTMSG,NSTAEP(IPROC),1)
  2009: |+=====>              LOCSTATFN(1:20) = 'PE0000/elev_stat.151'
  2010: |                     CALL IWRITE(LOCstatFN,3,6,IPROC-1)
  2011: |                     ios_stations = 0
  2012: |                     open(unit=151,file=locstatfn,
  2013: |              &                    status='unknown',iostat=ios_stations)
  2014: |                     write(151,80) OUTMSG
  2015: |                  else
  2016: |                     CALL INSERT(NSTAEMSG,OUTMSG,NSTAEP(IPROC),1)
  2017: |                     write(15,80) OUTMSG
  2018: |                  endif
  2019: |         C
  2020: |         C...     write the stations located in this proc's domain
  2021: |+----->           DO K=1,NSTAEP(IPROC)
  2022: ||                    INDX = abs(IMAP_STAE_LG(K,IPROC))
  2023: ||                    if (use_elev_stat_file) then
  2024: ||                       write(151,80) STAELOC(INDX)
  2025: ||                    else
  2026: ||                       WRITE(15,80) STAELOC(INDX)
  2027: ||                    endif
  2028: |+-----            ENDDO
  2029: |                  if (use_elev_stat_file ) close(151)
  2030: |         C
  2031: |         C--Write Local Velocity Station Info:
  2032: |         C--Create Local-to-Global element "ownership" of an velocity station
  2033: |         C
  2034: |                  WRITE(15,*) NOUTV,TOUTSV,TOUTFV,NSPOOLV
  2035: |         C
  2036: |                  NSTAVP(IPROC) = 0
  2037: |+----->           DO K = 1,abs(NSTAV)
  2038: ||V---->              DO J=1,NELP(IPROC)
  2039: |||                      INDX = abs(IMAP_EL_LG(J,IPROC))
  2040: |||                      IF (INDX.EQ.NNSVG(K)) THEN
  2041: |||                         NSTAVP(IPROC) = NSTAVP(IPROC) + 1
  2042: |||                         KK = K
  2043: |||                         if (STAV_SHARE(K) > -1) KK = -K
  2044: |||                         IMAP_STAV_LG(NSTAVP(IPROC),IPROC) = KK
  2045: |||                         STAV_SHARE(K) = IPROC
  2046: |||                         ! tcm v51.20.03 once found exit the element loop
  2047: |||                         exit
  2048: |||                      ENDIF
  2049: ||V----               ENDDO
  2050: |+-----            ENDDO
  2051: |                  NSTAV_MAX = MAX(NSTAVP(IPROC),NSTAV_MAX)
  2052: |         C
  2053: |                  if (use_vel_stat_file ) then  !tcm v51.20.03
  2054: |                     CALL INSERT(NSTAVMSG,OUTMSG,(/-NSTAVP(IPROC)/),1)  !keep the negative sign for fort.15
  2055: |                     write(15,80) OUTMSG
  2056: |                     CALL INSERT(NSTAVMSG,OUTMSG,NSTAVP(IPROC),1)
  2057: |+=====>              LOCSTATFN(1:19) = 'PE0000/vel_stat.151'
  2058: |                     CALL IWRITE(LOCstatFN,3,6,IPROC-1)
  2059: |                     ios_stations = 0
  2060: |                     open(unit=151,file=locstatfn(1:19),
  2061: |              &                    status='unknown',iostat=ios_stations)
  2062: |                     write(151,80) OUTMSG
  2063: |                  else
  2064: |                     CALL INSERT(NSTAVMSG,OUTMSG,NSTAVP(IPROC),1)
  2065: |                     write(15,80) OUTMSG
  2066: |                  endif
  2067: |         
  2068: |         C
  2069: |+----->           DO K=1,NSTAVP(IPROC)
  2070: ||                    INDX = abs(IMAP_STAV_LG(K,IPROC))
  2071: ||                    if (use_vel_stat_file ) then
  2072: ||                       WRITE(151,80) STAVLOC(INDX)
  2073: ||                    else
  2074: ||                       WRITE(15,80) STAVLOC(INDX)
  2075: ||                    endif
  2076: |+-----            ENDDO
  2077: |                  if (use_vel_stat_file  ) close(151)
  2078: |         C
  2079: |         C--If IM=10 Write Concentration Station Info:
  2080: |         C--Create Local-to-Global element "ownership" of an concentration station
  2081: |         C
  2082: |                  NSTACP(IPROC) = 0
  2083: |                  IF (C2D_PTrans.or.C3D_PTrans) THEN !jgf46.28
  2084: |         C
  2085: |         C     WRITE(15,80) STACMSG   !jgf45.07 we may have changed NOUTC in adcprep
  2086: |                     WRITE(15,*) NOUTC,TOUTSC,TOUTFC,NSPOOLC
  2087: |         C
  2088: |+----->              DO K = 1,abs(NSTAC)
  2089: ||V---->                 DO J=1,NELP(IPROC)
  2090: |||                         INDX = abs(IMAP_EL_LG(J,IPROC))
  2091: |||                         IF (INDX.EQ.NNSCG(K)) THEN
  2092: |||                            NSTACP(IPROC) = NSTACP(IPROC) + 1
  2093: |||                            KK = K
  2094: |||                            if (STAC_SHARE(K) > -1) KK = -K
  2095: |||                            IMAP_STAC_LG(NSTACP(IPROC),IPROC) = KK
  2096: |||                            STAC_SHARE(K) = IPROC
  2097: |||                            ! tcm v51.20.03 once found exit the element loop
  2098: |||                            exit
  2099: |||                         ENDIF
  2100: ||V----                  ENDDO
  2101: |+-----               ENDDO
  2102: |                     NSTAC_MAX = MAX(NSTACP(IPROC),NSTAC_MAX)
  2103: |         C
  2104: |         C...     update the number of stations for this proc's domain
  2105: |                  if (use_conc_stat_file ) then  !tcm v51.20.03
  2106: |                     CALL INSERT(NSTACMSG,OUTMSG,(/-NSTACP(IPROC)/),1)  !keep the negative sign for fort.15
  2107: |                     write(15,80) OUTMSG
  2108: |                     CALL INSERT(NSTACMSG,OUTMSG,NSTACP(IPROC),1)
  2109: |+=====>              LOCSTATFN(1:20) = 'PE0000/conc_stat.151'
  2110: |                     CALL IWRITE(LOCstatFN,3,6,IPROC-1)
  2111: |                     ios_stations = 0
  2112: |                     open(unit=151,file=locstatfn,
  2113: |              &                    status='unknown',iostat=ios_stations)
  2114: |                     write(151,80) OUTMSG
  2115: |                  else
  2116: |                     CALL INSERT(NSTACMSG,OUTMSG,NSTACP(IPROC),1)
  2117: |                     write(15,80) OUTMSG
  2118: |                  endif
  2119: |         C ... write the stations located in this proc's domain
  2120: |+----->              DO K=1,NSTACP(IPROC)
  2121: ||                       INDX = abs(IMAP_STAC_LG(K,IPROC))
  2122: ||                       IF (use_conc_stat_file) then
  2123: ||                          write(151,80) STACLOC(INDX)
  2124: ||                       ELSE
  2125: ||                          WRITE(15,80) STACLOC(INDX)
  2126: ||                       ENDIF
  2127: |+-----               ENDDO
  2128: |                     IF (use_conc_stat_file) close(151)
  2129: |         C
  2130: |                  ENDIF
  2131: |         C
  2132: |         C--Write Local Meterological Station Info:
  2133: |         C--Create Local-to-Global element "ownership" of an elevation station
  2134: |         C
  2135: |                  NSTAMP(IPROC) = 0
  2136: |                  IF (NWS.NE.0) THEN
  2137: |                     WRITE(15,*) NOUTM,TOUTSM,TOUTFM,NSPOOLM
  2138: |+----->              DO K = 1,abs(NSTAM)
  2139: ||V---->                 DO J=1,NELP(IPROC)
  2140: |||                         INDX = abs(IMAP_EL_LG(J,IPROC))
  2141: |||                         IF (INDX.EQ.NNSMG(K)) THEN
  2142: |||                            NSTAMP(IPROC) = NSTAMP(IPROC) + 1
  2143: |||                            KK = K
  2144: |||                            if (STAM_SHARE(K) > -1) KK = -K
  2145: |||                            IMAP_STAM_LG(NSTAMP(IPROC),IPROC) = KK
  2146: |||                            STAM_SHARE(K) = IPROC
  2147: |||                            ! tcm v51.20.03 once found exit the element loop
  2148: |||                            exit
  2149: |||                         ENDIF
  2150: ||V----                  ENDDO
  2151: |+-----               ENDDO
  2152: |                     NSTAM_MAX = MAX(NSTAMP(IPROC),NSTAM_MAX)
  2153: |         C
  2154: |         C...        update the number of stations for this proc's domain
  2155: |                  if (use_met_stat_file ) then  !tcm v51.20.03
  2156: |                     CALL INSERT(NSTAMMSG,OUTMSG,(/-NSTAMP(IPROC)/),1)  !keep the negative sign for fort.15
  2157: |                     write(15,80) OUTMSG
  2158: |                     CALL INSERT(NSTAMMSG,OUTMSG,NSTAMP(IPROC),1)
  2159: |+=====>              LOCSTATFN(1:19) = 'PE0000/met_stat.151'
  2160: |                     CALL IWRITE(LOCstatFN,3,6,IPROC-1)
  2161: |                     ios_stations = 0
  2162: |                     open(unit=151,file=locstatfn(1:19),
  2163: |              &                    status='unknown',iostat=ios_stations)
  2164: |                     write(151,80) OUTMSG
  2165: |                  else
  2166: |                     CALL INSERT(NSTAMMSG,OUTMSG,NSTAMP(IPROC),1)
  2167: |                     write(15,80) OUTMSG
  2168: |                  endif
  2169: |         C
  2170: |         C...        write the stations located in this proc's domain
  2171: |+----->              DO K=1,NSTAMP(IPROC)
  2172: ||                       INDX = abs(IMAP_STAM_LG(K,IPROC))
  2173: ||                       IF (use_met_stat_file) then
  2174: ||                          WRITE(151,80) STAMLOC(INDX)
  2175: ||                       ELSE
  2176: ||                          WRITE(15,80) STAMLOC(INDX)
  2177: ||                       ENDIF
  2178: |+-----               ENDDO
  2179: |                     IF (use_met_stat_file) CLOSE(151)
  2180: |                  ENDIF
  2181: |         
  2182: |         C
  2183: |         C--Write Local Elevation Data Output Info
  2184: |         C
  2185: |         C      WRITE(15,80) OUTGEMSG !jgf45.07 we may have changed NOUTGE in adcprep
  2186: |                  WRITE(15,*) NOUTGE,TOUTSGE,TOUTFGE,NSPOOLGE
  2187: |         C
  2188: |         C--Write Local Velocity Data Output Info
  2189: |         C
  2190: |         C     WRITE(15,80) OUTGVMSG !jgf45.07 we may have changed NOUTGV in adcprep
  2191: |                  WRITE(15,*) NOUTGV,TOUTSGV,TOUTFGV,NSPOOLGV
  2192: |         C
  2193: |         C     jgf45.07 write subdomain concentration data output info if necessary
  2194: |         C
  2195: |                  IF (IM.EQ.10) WRITE(15,*) NOUTGC,TOUTSGC,TOUTFGC,NSPOOLGC
  2196: |         C
  2197: |         C--Write Local Wind Velocity Data Output Info ( added 4/16/98 vjp )
  2198: |         C
  2199: |         C     jgf45.07 we may have changed NOUTGW in adcprep
  2200: |         C     IF (NWS.NE.0) WRITE(15,80) OUTGWMSG
  2201: |                  IF (NWS.NE.0) WRITE(15,*) NOUTGW,TOUTSGW,TOUTFGW,NSPOOLGW
  2202: |         C
  2203: |         C--Write Harmonic Analysis Data
  2204: |         C
  2205: |                  WRITE(15,80) HARFRMSG
  2206: |+----->           DO I=1,NHARFR
  2207: ||                    WRITE(15,'(A10)') NAMEFR(I)
  2208: ||                    WRITE(15,80) HAFREMSG(I)
  2209: ||        c           WRITE(15,*) HAFREQ(I),HAFF(I),HAFACE(I)
  2210: |+-----            ENDDO
  2211: |         C
  2212: |                  WRITE(15,80) HARPARMSG
  2213: |                  WRITE(15,80) OUTHARMSG
  2214: |         C
  2215: |         C--Write Hot Start Info
  2216: |         C
  2217: |                  WRITE(15,80) HSTARMSG
  2218: |         C
  2219: |         C--Write Solver Info
  2220: |         C
  2221: |                  WRITE(15,80) SOLVMSG
  2222: |         C
  2223: |         C--Write 3DVS Info
  2224: |         C
  2225: |                  IF(C3DVS) THEN
  2226: |       I             CALL PREP15_3DVS(IPROC)
  2227: |         c        ELSEIF(C3DDSS) THEN
  2228: |         c           CALL PREP15_3DDSS(IPROC)
  2229: |                  ENDIF
  2230: |         C
  2231: |         C     jgf48.03 Write netCDF metadata, if necessary
  2232: |                  IF (useNetCDF.eqv..true.) THEN
  2233: |+=====>              FMT = "(1X,A)" ;
  2234: |                     WRITE(15,FMT) trim(adjustl(title))
  2235: |                     WRITE(15,FMT) trim(adjustl(institution))
  2236: |                     WRITE(15,FMT) trim(adjustl(source))
  2237: |                     WRITE(15,FMT) trim(adjustl(history))
  2238: |                     WRITE(15,FMT) trim(adjustl(references))
  2239: |                     WRITE(15,FMT) trim(adjustl(comments))
  2240: |                     WRITE(15,FMT) trim(adjustl(host))
  2241: |                     WRITE(15,FMT) trim(adjustl(convention))
  2242: |                     WRITE(15,FMT) trim(adjustl(contact))
  2243: |                     WRITE(15,FMT) trim(adjustl(base_date))
  2244: |                  ENDIF
  2245: |         
  2246: |         c...     tcm v50.66.02 additions for time varying bathymetry
  2247: |                  IF (FOUND_TBC_NML) then  !If there was a namelist in the original fort.15 put it in the decomp 15's
  2248: |         !         IF (NDDT.NE.0) THEN
  2249: |                     write(15,*) '! -- Begin Time Varying Bathymetry Inputs --'
  2250: |                     write(15,TimeBathyControl)
  2251: |                     write(15,*) '! -- End Time Varying Bathymetry Inputs --'
  2252: |                  ENDIF
  2253: |         C
  2254: |         #if defined CSWAN || defined ADCSWAN
  2255: |                  write(15,*) '! -- Begin SWAN Output Control Namelist --'
  2256: |                  write(15,SWANOutputControl)
  2257: |                  write(15,*) '! -- End SWAN Output Control Namelist --'
  2258: |         #endif
  2259: |         
  2260: |         ! tcm v50.79 Changed so that metControl namelist is only written if it was found in the
  2261: |         ! original fort.15 file.  Also changed the single line write, which is missing some commas
  2262: |         ! to a multiple line write.  The single line write was causing problems on
  2263: |         ! some compilers because the character DragLawString could end up being written
  2264: |         ! on multiple lines and this caused issues.  This section
  2265: |         ! should only be written if there was a namelist in the original fort.15.
  2266: |         !
  2267: |                  if (found_metCon_nml) then  !metControl namelist was found so write it in the parsed files
  2268: |                     write(15,*) '! -- Begin Met Control Namelist --'
  2269: |         !         write(15,*) "&metControl WindDragLimit=",WindDragLimit,
  2270: |         !     &         " DragLawString='",DragLawString,"' rhoAir=",rhoAir," /"
  2271: |         
  2272: |                     write(15,*) "&metControl "
  2273: |                     write(15,*) "    WindDragLimit=",Winddraglimit,","
  2274: |                     write(15,*) "    DragLawString='",trim(Draglawstring),"',"
  2275: |                     write(15,*) "    outputWindDrag=",outputWindDrag,","
  2276: |                     write(15,*) "    rhoAir=",rhoAir,","
  2277: |                     write(15,*) "    invertedBarometerOnElevationBoundary=",
  2278: |              &                        invertedBarometerOnElevationBoundary,","
  2279: |                     write(15,*) "    nPowellSearchDomains=",nPowellSearchDomains
  2280: |                     write(15,*) "/"
  2281: |                     write(15,*) '! -- End Met Control Namelist --'
  2282: |                  endif
  2283: |         
  2284: |                  if (found_tvw_nml) then
  2285: |                      write(15,*) '! -- Begin TVW Control Namelist --'
  2286: |                      write(15,*) "&TVWControl "
  2287: |                      write(15,*) "    USE_TVW=",USE_TVW,","
  2288: |                      write(15,*) "    TVW_FILE='",TRIM(ADJUSTL(TVW_FILE)),"',"
  2289: |                      write(15,*) "    NOUT_TVW=",NOUT_TVW,","
  2290: |                      write(15,*) "    TOUTS_TVW=",TOUTS_TVW,","
  2291: |                      write(15,*) "    TOUTF_TVW=",TOUTF_TVW,","
  2292: |                      write(15,*) "    NSPOOL_TVW=",NSPOOL_TVW
  2293: |                      write(15,*) "/"
  2294: |                      write(15,*) '! -- End TVW Control Namelist --'
  2295: |                  endif
  2296: |         
  2297: |         Casey 121019: Added multiplication factor to be used before sending winds to coupled wave models.
  2298: |                  IF(FOUND_WC_NML)THEN
  2299: |                     WRITE(15,*) '! -- Begin Wave Coupling Namelist --'
  2300: |                     WRITE(15,waveCoupling)
  2301: |                     WRITE(15,*) '! -- End Wave Coupling Namelist --'
  2302: |                  ENDIF
  2303: |         
  2304: |         #ifdef ADCNETCDF
  2305: |         Casey 180318: Added NWS=13
  2306: |                  if(FOUND_OWINC_NML)then
  2307: |                     write(15,'(a,a,a,a,a,a,a)')
  2308: |              &         "&owiWindNetcdf NWS13File='",TRIM(ADJUSTL(NWS13File)),
  2309: |              &         "' NWS13ColdStartString='",
  2310: |              &         TRIM(ADJUSTL(NWS13ColdStartString)),
  2311: |              &         "' NWS13WindMultiplier='",
  2312: |              &         TRIM(ADJUSTL(NWS13WindMultiplier)),
  2313: |              &         "' NWS13GroupForPowell='",
  2314: |              &         TRIM(ADJUSTL(NWS13GroupForPowell)),"' /"
  2315: |                  endif
  2316: |         #endif
  2317: |         
  2318: |         #ifdef DATETIME
  2319: |                  IF ( found_NWS14Grib2NetCdf_namelist ) THEN
  2320: |                      write(15,'(a,L3,a)') "&WindGrib2NetCdf"//
  2321: |              &          " read_NWS14_NetCdf_using_core_0 = ", read_NWS14_NetCdf_using_core_0, "/"
  2322: |         
  2323: |                  END IF
  2324: |         #endif
  2325: |         
  2326: |                  ! NCSU Subdomain Modeling
  2327: |                  if (FOUND_SM_NML) then
  2328: |                  WRITE(15,*) "&subdomainModeling subdomainOn=",subdomainOn," /"
  2329: |                  endif
  2330: |         
  2331: |         !JLW: adding subgridcontrol namelist
  2332: |                  if(foundSubgridControlNamelist)then
  2333: |                     WRITE(15,*)
  2334: |              &         "&subgridControl",
  2335: |              &         " subgridFilename='",trim(adjustl(subgridFilename)),
  2336: |              &         "' level0=",level0,
  2337: |              &         " level1=",level1," /"
  2338: |                  endif
  2339: |         
  2340: |         
  2341: |                  ! wet dry control
  2342: |                  if (foundWetDryControlNameList) then
  2343: |                     WRITE(15,'(a,l,a,l,a,l,a,l,a,i1,a,f15.4,a,l,a,l,a,l,a)')
  2344: |              &         "&wetDryControl outputNodeCode=",outputNodeCode,
  2345: |              &         " outputNOFF=",outputNOFF," noffActive=",noffActive,
  2346: |              &         " StatPartWetFix=",StatPartWetFix,
  2347: |              &         " How2FixStatPartWet=",How2FixStatPartWet,
  2348: |         C....    DMW 202207 Add in options for controlling slope/wind limiting and "new" formula for computing vel in wetting/drying routine
  2349: |              &         " slim=",slim,
  2350: |              &         " windlim=",windlim,
  2351: |              &         " directvelWD=",directvelWD,
  2352: |              &         " useHF=",useHF," /"
  2353: |         C....    DMW
  2354: |                  endif
  2355: |                  ! jgf52.08.02: inundation output control
  2356: |                  if (foundInundationOutputControlNamelist) then
  2357: |                     write(15,'(a,l,a,f15.8,a)')
  2358: |              &       '&inundationOutputControl inundationOutput=',
  2359: |              &       inundationOutput,' inunThresh=',inunThresh," /"
  2360: |                  endif
  2361: |         
  2362: |         c...     tcm v52.30.01 additions for Smag_Control Namelist
  2363: |                  IF (FOUND_SMAG_NML) then  !If there was a namelist in the original fort.15 put it in the decomp 15's
  2364: |                     write(15,*) '! -- Begin Smagorinski Inputs --'
  2365: |                     write(15,Smag_Control)
  2366: |                     write(15,*) '! -- End Smagorinski Inputs --'
  2367: |                  ENDIF
  2368: |                  ! jgf: dynamicWaterlevel control namelist
  2369: |                  if (foundCorrectionControlNamelist) then
  2370: |                     write(15,'(a,a, a,i0, a,f15.8, a,a, a,f20.8, a,f20.8, a)')
  2371: |              &       '&dynamicWaterLevelCorrectionControl dynamicWaterLevelCorrectionFileName="',
  2372: |              &       trim(adjustl(dynamicWaterLevelCorrectionFileName)),
  2373: |              &       '",  dynamicWaterLevelCorrectionSkipSnaps=',dynamicWaterLevelCorrectionSkipSnaps,
  2374: |              &       ', dynamicWaterlevelCorrectionMultiplier=',dynamicWaterLevelCorrectionMultiplier,
  2375: |              &       ', dynamicWaterLevelCorrectionRampReferenceTime="',
  2376: |              &       trim(dynamicWaterLevelCorrectionRampReferenceTime),
  2377: |              &       '", dynamicWaterLevelCorrectionRampStart=',dynamicWaterLevelCorrectionRampStart,
  2378: |              &       ', dynamicWaterLevelCorrectionRampEnd=',dynamicWaterLevelCorrectionRampEnd,'  /'
  2379: |                  endif
  2380: |         
  2381: |         C....    SB VEW1D channel control namelist
  2382: |                  if (foundVEW1DChannelControlNamelist) then
  2383: |                     write(15,'(a,l,a)')
  2384: |              &       '&VEW1DChannelControl activateVEW1DChannelWetPerimeter=',
  2385: |              &       activateVEW1DChannelWetPerimeter," /"
  2386: |                  endif
  2387: |         
  2388: |         C...     wjp additions for WarnElev Namelist
  2389: |                  IF (FOUND_WARNELEV_NML) then  !If there was a namelist in the original fort.15 put it in the decomp 15's
  2390: |                     write(15,*) '! -- Begin WarnElev Control NameList --'
  2391: |                     write(15,WarnElevControl)
  2392: |                     write(15,*) '! -- End WarnElev Control NameList --'
  2393: |                  ENDIF
  2394: |         
  2395: |         c...     wjp additions for Ali Dispersion Control Namelist
  2396: |                  IF (FOUND_ALIDISP_NML) then  !If there was a namelist in the original fort.15 put it in the decomp 15's
  2397: |                     write(15,*) '! -- Begin AliDispersion Control NameList --'
  2398: |                     write(15,AliDispersionControl)
  2399: |                     write(15,*) '! -- End AliDispersion Control NameList --'
  2400: |                  ENDIF
  2401: |         c...     wjp additions for density Control Namelist
  2402: |                  IF (FOUND_DENSITY_NML) then  !If there was a namelist in the original fort.15 put it in the decomp 15's
  2403: |                     write(15,*) '! -- Begin density Control NameList --'
  2404: |                     write(15,'(3A)') '&densityControl densityRunType="',
  2405: |              &                        TRIM(densityRunType),'",'
  2406: |                     write(15,'(3A)') '  densityFilename="',TRIM(densityFilename),'"'
  2407: |                     write(15,'(A,I0,A)') '  densityTimeIterator=',densityTimeIterator,","
  2408: |                     write(15,'(3A)') '  densityForcingType="',TRIM(densityForcingType),'"   /'
  2409: |                     write(15,*) '! -- End density Control NameList --'
  2410: |                  ENDIF
  2411: |         
  2412: |                  CLOSE(15)
  2413: |         C
  2414: +------    1000 CONTINUE
  2415:           
  2416:                 IF(C3DVS.and.(IEVC.EQ.0)) THEN
  2417:                    DEALLOCATE ( EVTot )
  2418:                    nbytes = 8*nfen
  2419:                    call memory_dealloc(nbytes)
  2420:                 ENDIF
  2421:           
  2422:           C
  2423:           C--Print Summary of Stations
  2424:           C
  2425:                 print *, " "
  2426:                 print *, "Station Data"
  2427:                 print *, "DOMAIN      NSTAE   NSTAV    NSTAC    NSTAM"
  2428:                 WRITE(*,92)  "GLOBAL",abs(NSTAE),abs(NSTAV),
  2429:                &                      abs(NSTAC),abs(NSTAM)
  2430: +------>        DO IPROC=1, NPROC
  2431: |                  PE(1:6) = 'PE0000'
  2432: |                  CALL IWRITE(PE,3,6,IPROC-1)
  2433: |                  WRITE(*,92)  PE,NSTAEP(IPROC),NSTAVP(IPROC),
  2434: |              .        NSTACP(IPROC),NSTAMP(IPROC)
  2435: +------         ENDDO
  2436:           C
  2437:                 RETURN
  2438:            80   FORMAT(A80)
  2439:            92   FORMAT(1X,A6,4I8)
  2440:                 END SUBROUTINE PREP15


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15
INLINE LIST

  ROOT: PREP15 (prep.F:1766)
  -> NOINLINE: IWRITE (prep.F:1796)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:1956)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2006)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2008)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2010)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2016)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2054)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2056)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2058)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2064)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2106)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2108)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2110)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2116)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2156)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2158)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2160)
     *** Source for routine not found.
  -> NOINLINE: INSERT (prep.F:2166)
     *** Source for routine not found.
  -> INLINE: PREP15_3DVS (prep.F:2226)
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:2419)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2432)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:1790)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:1790)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:1790)
  LOOP END

  LOOP BEGIN: (prep.F:1792)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:1795)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:1795)
    LOOP END

    LOOP BEGIN: (prep.F:1795)
      <Unvectorized loop.>
      *** Unvectorizable data type. : LOCFN (prep.F:1795)
    LOOP END

    LOOP BEGIN: (prep.F:1797)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:1797)
    LOOP END

    LOOP BEGIN: (prep.F:1818)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1818)
    LOOP END

    LOOP BEGIN: (prep.F:1881)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1881)
    LOOP END

    LOOP BEGIN: (prep.F:1887)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1887)
    LOOP END

    LOOP BEGIN: (prep.F:1891)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1893)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1893)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1908)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  1,  0. (prep.F:1908)
      *** The number of VLOAD, VSTORE. :  1,  2. (prep.F:1908)
      *** VGT generated (prep.F:1909)

      LOOP BEGIN: (prep.F:1910)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1910)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1910)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:1910)
        *** VCOMPRESS generated (prep.F:1914)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1921)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:1921)
    LOOP END

    LOOP BEGIN: (prep.F:1925)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1927)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1927)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1944)
      <Partially vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:1944)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:1944)

      LOOP BEGIN: (prep.F:1946)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1946)
        *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1946)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:1955)
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:1955)
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      <Unvectorized loop.>
      *** Unvectorizable data type. : LOCFN (prep.F:1955)
    LOOP END

    LOOP BEGIN: (prep.F:1957)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:1957)
    LOOP END

    LOOP BEGIN: (prep.F:1962)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1964)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:1964)
        *** Allocation obstructs vectorization. (prep.F:1964)
        *** Deallocation obstructs vectorization. (prep.F:1964)

        LOOP BEGIN: (prep.F:1966)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1966)
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          <Unvectorized loop.>
          *** Unvectorizable data type. : TIMEVARYINGWEIRMSSG (prep.F:1966)
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          <Unvectorized loop.>
          *** Unvectorizable data type. (prep.F:1966)
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:1966)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1987)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:1988)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:1988)
        *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:1988)
        *** Idiom detected. : SEARCH (prep.F:1990)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2009)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2009)
    LOOP END

    LOOP BEGIN: (prep.F:2021)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2021)
    LOOP END

    LOOP BEGIN: (prep.F:2037)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2038)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2038)
        *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2038)
        *** Idiom detected. : SEARCH (prep.F:2040)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2057)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2057)
    LOOP END

    LOOP BEGIN: (prep.F:2069)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2069)
    LOOP END

    LOOP BEGIN: (prep.F:2088)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2089)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2089)
        *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2089)
        *** Idiom detected. : SEARCH (prep.F:2091)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2109)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2109)
    LOOP END

    LOOP BEGIN: (prep.F:2120)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2120)
    LOOP END

    LOOP BEGIN: (prep.F:2138)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2139)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2139)
        *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2139)
        *** Idiom detected. : SEARCH (prep.F:2141)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2159)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2159)
    LOOP END

    LOOP BEGIN: (prep.F:2171)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2171)
    LOOP END

    LOOP BEGIN: (prep.F:2206)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2206)
    LOOP END

    LOOP BEGIN: (prep.F:2475)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2475)
    LOOP END

    LOOP BEGIN: (prep.F:2482)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2482)
    LOOP END

    LOOP BEGIN: (prep.F:2496)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2497)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2497)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2497)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2497)
        *** VCOMPRESS generated (prep.F:2501)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2506)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2506)
    LOOP END

    LOOP BEGIN: (prep.F:2522)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2523)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2523)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2523)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2523)
        *** VCOMPRESS generated (prep.F:2527)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2532)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2532)
    LOOP END

    LOOP BEGIN: (prep.F:2548)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2549)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  0,  0. (prep.F:2549)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2549)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2549)
        *** VCOMPRESS generated (prep.F:2553)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2558)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2558)
    LOOP END

    LOOP BEGIN: (prep.F:2233)
      <Unvectorized loop.>
      *** Unvectorizable data type. : FMT (prep.F:2233)
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2234)
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      <Unvectorized loop.>
      *** Unvectorizable data type. : TITLE (prep.F:2234)
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2234)
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2234)
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2235)
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      <Unvectorized loop.>
      *** Unvectorizable data type. : INSTITUTION (prep.F:2235)
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2235)
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2235)
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2236)
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      <Unvectorized loop.>
      *** Unvectorizable data type. : SOURCE (prep.F:2236)
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2236)
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2236)
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2237)
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      <Unvectorized loop.>
      *** Unvectorizable data type. : HISTORY (prep.F:2237)
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2237)
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2237)
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2238)
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      <Unvectorized loop.>
      *** Unvectorizable data type. : REFERENCES (prep.F:2238)
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2238)
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2238)
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2239)
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      <Unvectorized loop.>
      *** Unvectorizable data type. : COMMENTS (prep.F:2239)
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2239)
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2239)
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2240)
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      <Unvectorized loop.>
      *** Unvectorizable data type. : HOST (prep.F:2240)
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2240)
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2240)
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2241)
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      <Unvectorized loop.>
      *** Unvectorizable data type. : CONVENTION (prep.F:2241)
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2241)
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2241)
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2242)
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      <Unvectorized loop.>
      *** Unvectorizable data type. : CONTACT (prep.F:2242)
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2242)
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2242)
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2243)
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      <Unvectorized loop.>
      *** Unvectorizable data type. : BASE_DATE (prep.F:2243)
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2243)
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2243)
    LOOP END

    LOOP BEGIN: (prep.F:2274)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2274)
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2288)
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      <Unvectorized loop.>
      *** Unvectorizable data type. : TVW_FILE (prep.F:2288)
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2288)
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2288)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NWS13FILE (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NWS13COLDSTARTSTRING (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NWS13WINDMULTIPLIER (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. : NWS13GROUPFORPOWELL (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2307)
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2333)
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      <Unvectorized loop.>
      *** Unvectorizable data type. : SUBGRIDFILENAME (prep.F:2333)
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2333)
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2333)
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2370)
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      <Unvectorized loop.>
      *** Unvectorizable data type. : DYNAMICWATERLEVELCORRECTIONFILENAME (prep.F:2370)
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2370)
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2370)
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2370)
    LOOP END

    LOOP BEGIN: (prep.F:2404)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2404)
    LOOP END

    LOOP BEGIN: (prep.F:2406)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2406)
    LOOP END

    LOOP BEGIN: (prep.F:2408)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:2408)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2430)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:2430)
    *** I/O statement obstructs vectorization. (prep.F:2430)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 45 [v19-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 14016 bytes
      Register spill area      :  5632 bytes
      Parameter area           :   160 bytes
      Register save area       :   176 bytes
      User data area           :  8048 bytes
      Others                   :     0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:1790)
    *** Estimated execution cycle                       : 63
  LOOP END

  LOOP BEGIN: (prep.F:1792)
    *** Estimated execution cycle                       : 13331
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 619
            Across calls                                : 257
            Over basic blocks                           : 355
            Others                                      :   7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1982
            Across calls                                :  378
            Over basic blocks                           : 1577
            Others                                      :   27
    *** The number of SCALAR REGISTER TRANSFER          : 1678

    LOOP BEGIN: (prep.F:1795)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:1795)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:1797)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:1818)
      *** Estimated execution cycle                     : 61
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 4
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:1881)
      *** Estimated execution cycle                     : 108
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  7
              Over basic blocks                         :  3
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 17
    LOOP END

    LOOP BEGIN: (prep.F:1887)
      *** Estimated execution cycle                     : 108
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  7
              Over basic blocks                         :  3
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 17
    LOOP END

    LOOP BEGIN: (prep.F:1891)
      *** Estimated execution cycle                     : 77
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 3
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 3
              Over basic blocks                         : 5
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 10

      LOOP BEGIN: (prep.F:1893)
        *** Estimated execution cycle                   : 66
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 2
                Across calls                            : 2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 3
                Across calls                            : 2
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER TRANSFER      : 8
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1908)
      *** Estimated execution cycle                     : 220
    LOOP END

    LOOP BEGIN: (prep.F:1908)
      *** Estimated execution cycle                     : 53
      *** The number of SCALAR REGISTER TRANSFER        : 2

      LOOP BEGIN: (prep.F:1910)
        *** Estimated execution cycle                   : 193
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1921)
      *** Estimated execution cycle                     : 108
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  7
              Over basic blocks                         :  3
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 18
    LOOP END

    LOOP BEGIN: (prep.F:1925)
      *** Estimated execution cycle                     : 76
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 1
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  3
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 15

      LOOP BEGIN: (prep.F:1927)
        *** Estimated execution cycle                   : 66
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 3
                Across calls                            : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 5
                Across calls                            : 3
                Over basic blocks                       : 2
        *** The number of SCALAR REGISTER TRANSFER      : 9
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1944)
      *** Estimated execution cycle                     : 62
    LOOP END

    LOOP BEGIN: (prep.F:1944)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER TRANSFER        : 4

      LOOP BEGIN: (prep.F:1946)
        *** Estimated execution cycle                   : 84
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:1955)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:1957)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:1962)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 12

      LOOP BEGIN: (prep.F:1964)
        *** Estimated execution cycle                   : 166
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Across calls                            : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 10
                Across calls                            :  3
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 34

        LOOP BEGIN: (prep.F:1966)
          *** Estimated execution cycle                 : 8
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          *** Estimated execution cycle                 : 6
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          *** Estimated execution cycle                 : 5
        LOOP END

        LOOP BEGIN: (prep.F:1966)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:1987)
      *** Estimated execution cycle                     : 55
      *** The number of SCALAR REGISTER TRANSFER        : 10

      LOOP BEGIN: (prep.F:1988)
        *** Estimated execution cycle                   : 182
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2009)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2021)
      *** Estimated execution cycle                     : 139
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER TRANSFER        : 31
    LOOP END

    LOOP BEGIN: (prep.F:2037)
      *** Estimated execution cycle                     : 55
      *** The number of SCALAR REGISTER TRANSFER        : 10

      LOOP BEGIN: (prep.F:2038)
        *** Estimated execution cycle                   : 182
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2057)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2069)
      *** Estimated execution cycle                     : 139
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER TRANSFER        : 31
    LOOP END

    LOOP BEGIN: (prep.F:2088)
      *** Estimated execution cycle                     : 55
      *** The number of SCALAR REGISTER TRANSFER        : 13

      LOOP BEGIN: (prep.F:2089)
        *** Estimated execution cycle                   : 182
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2109)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2120)
      *** Estimated execution cycle                     : 139
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 6
              Others                                    : 2
      *** The number of SCALAR REGISTER TRANSFER        : 31
    LOOP END

    LOOP BEGIN: (prep.F:2138)
      *** Estimated execution cycle                     : 55
      *** The number of SCALAR REGISTER TRANSFER        : 13

      LOOP BEGIN: (prep.F:2139)
        *** Estimated execution cycle                   : 182
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2159)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2171)
      *** Estimated execution cycle                     : 149
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 10
              Across calls                              :  8
              Others                                    :  2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  8
              Others                                    :  2
      *** The number of SCALAR REGISTER TRANSFER        : 33
    LOOP END

    LOOP BEGIN: (prep.F:2206)
      *** Estimated execution cycle                     : 113
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 7
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 13
              Across calls                              :  8
              Over basic blocks                         :  4
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 17
    LOOP END

    LOOP BEGIN: (prep.F:2475)
      *** Estimated execution cycle                     : 78
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 7
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  9
              Over basic blocks                         :  5
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:2482)
      *** Estimated execution cycle                     : 78
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 7
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  9
              Over basic blocks                         :  5
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:2496)
      *** Estimated execution cycle                     : 43
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:2497)
        *** Estimated execution cycle                   : 257
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2506)
      *** Estimated execution cycle                     : 98
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 6
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  8
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2522)
      *** Estimated execution cycle                     : 43
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:2523)
        *** Estimated execution cycle                   : 257
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2532)
      *** Estimated execution cycle                     : 98
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 6
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  8
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2548)
      *** Estimated execution cycle                     : 43
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:2549)
        *** Estimated execution cycle                   : 257
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2558)
      *** Estimated execution cycle                     : 98
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 6
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  8
              Over basic blocks                         :  6
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2233)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2234)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2235)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2236)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2237)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2238)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2239)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2240)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2241)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2242)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2243)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2274)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2288)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2307)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2333)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      *** Estimated execution cycle                     : 8
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2370)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2404)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2406)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2408)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2430)
    *** Estimated execution cycle                       : 258
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 20
            Across calls                                : 16
            Over basic blocks                           :  4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 45
            Across calls                                : 28
            Over basic blocks                           : 16
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 24
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15_3DVS
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  2475: vec( 103): Unvectorized loop.
  2475: vec( 180): I/O statement obstructs vectorization.
  2476: opt(1118): This I/O statement inhibits optimization of loop.
  2482: vec( 103): Unvectorized loop.
  2482: vec( 180): I/O statement obstructs vectorization.
  2483: opt(1118): This I/O statement inhibits optimization of loop.
  2496: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2497: vec( 101): Vectorized loop.
  2500: opt(1019): Feedback of scalar value from one loop pass to another.: NNSTA3DDP
  2500: opt(3014): Moved reference within a conditional branch.
  2501: opt(3014): Moved reference within a conditional branch.
  2506: vec( 103): Unvectorized loop.
  2506: vec( 180): I/O statement obstructs vectorization.
  2508: opt(1118): This I/O statement inhibits optimization of loop.
  2522: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2523: vec( 101): Vectorized loop.
  2526: opt(1019): Feedback of scalar value from one loop pass to another.: NNSTA3DVP
  2526: opt(3014): Moved reference within a conditional branch.
  2527: opt(3014): Moved reference within a conditional branch.
  2532: vec( 103): Unvectorized loop.
  2532: vec( 180): I/O statement obstructs vectorization.
  2534: opt(1118): This I/O statement inhibits optimization of loop.
  2548: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2549: vec( 101): Vectorized loop.
  2552: opt(1019): Feedback of scalar value from one loop pass to another.: NNSTA3DTP
  2552: opt(3014): Moved reference within a conditional branch.
  2553: opt(3014): Moved reference within a conditional branch.
  2558: vec( 103): Unvectorized loop.
  2558: vec( 180): I/O statement obstructs vectorization.
  2560: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15_3DVS
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  2455:                 SUBROUTINE PREP15_3DVS(IPROC)
  2456:                 USE PRE_GLOBAL
  2457:                 USE GLOBAL_3DVS, ONLY : SIGMA
  2458:                 IMPLICIT NONE
  2459:                 INTEGER N          ! vertical grid layer counter
  2460:                 INTEGER IPROC      ! subdomain counter
  2461:                 INTEGER SDStation  ! subdomain station
  2462:                 INTEGER FDStation  ! full domain station
  2463:                 INTEGER SDEle      ! subdomain station element
  2464:                 INTEGER FDEle      ! full domain element
  2465:           
  2466:           c     jgf45.10 removed IDIAG
  2467:                 WRITE(15,80) IDENMSG
  2468:                 WRITE(15,80) SLIPMSG
  2469:                 WRITE(15,80) Z0MSG
  2470:                 WRITE(15,80) ALPMSG
  2471:                 WRITE(15,80) FEMSG
  2472:           C     jgf45.12 Added code to record thicknesses of vertical grid layers,
  2473:           C     if necessary.
  2474:                 IF(IGC.EQ.0) THEN
  2475: +------>           DO N=1,NFEN
  2476: |                     WRITE(15,*) Sigma(N)
  2477: +------            ENDDO
  2478:                 ENDIF
  2479:                 WRITE(15,80) EVCMSG
  2480:           C     jgf45.12 Add code to record vertical eddy viscosity profile.
  2481:                 IF(IEVC.EQ.0) THEN
  2482: +------>           DO N=1,NFEN
  2483: |                     WRITE(15,*) EVTot(N)
  2484: +------            ENDDO
  2485:                 ENDIF
  2486:                 IF((IEVC.EQ.50).OR.(IEVC.EQ.51)) WRITE(15,80) THETAMSG
  2487:           C     -------------------------------------------------------------
  2488:           C     jgf45.11 Create mapping from full domain 3D density station
  2489:           C     elements to corresponding elements in subdomains. Write out
  2490:           C     subdomain station locations to fort.15 file.
  2491:           C     -------------------------------------------------------------
  2492:                 WRITE(15,*) I3DSD,TO3DSDS,TO3DSDF,NSPO3DSD
  2493:           C   kmd48.33bc changed
  2494:                 IF(NSTA3DD.NE.0) THEN
  2495:                    NNSTA3DDP(IPROC) = 0
  2496: +------>           DO FDStation = 1, NSTA3DD
  2497: |V----->              DO SDEle = 1, NELP(IPROC)
  2498: ||                       FDEle = abs(IMAP_EL_LG(SDEle,IPROC))
  2499: ||                       IF ( FDEle .eq. NNS3DDG(FDStation) ) THEN
  2500: ||                          NNSTA3DDP(IPROC) = NNSTA3DDP(IPROC) + 1
  2501: ||                          IMAP_STA3DD_LG(NNSTA3DDP(IPROC),IPROC) = FDStation
  2502: ||                       ENDIF
  2503: |V-----               END DO
  2504: +------            END DO
  2505:                    WRITE(15,*) NNSTA3DDP(IPROC)
  2506: +------>           DO SDStation = 1, NNSTA3DDP(IPROC)
  2507: |                     FDStation = IMAP_STA3DD_LG(SDStation,IPROC)
  2508: |                     WRITE(15,80) STA3DDLOC(FDStation)
  2509: +------            ENDDO
  2510:                 ELSE
  2511:                    WRITE(15,80) NSTA3DDMSG
  2512:                 ENDIF
  2513:           C     -------------------------------------------------------------
  2514:           C     jgf45.11 Create mapping from full domain 3D velocity station
  2515:           C     elements to corresponding elements in subdomains. Write out
  2516:           C     velocity subdomain station locations to fort.15 file.
  2517:           C     -------------------------------------------------------------
  2518:                 WRITE(15,*) I3DSV,TO3DSVS,TO3DSVF,NSPO3DSV
  2519:           C   kmd48.33bc changed
  2520:                 IF(NSTA3DV.NE.0) THEN
  2521:                    NNSTA3DVP(IPROC) = 0
  2522: +------>           DO FDStation = 1, NSTA3DV
  2523: |V----->              DO SDEle = 1, NELP(IPROC)
  2524: ||                       FDEle = abs(IMAP_EL_LG(SDEle,IPROC))
  2525: ||                       IF ( FDEle .eq. NNS3DVG(FDStation) ) THEN
  2526: ||                          NNSTA3DVP(IPROC) = NNSTA3DVP(IPROC) + 1
  2527: ||                          IMAP_STA3DV_LG(NNSTA3DVP(IPROC),IPROC) = FDStation
  2528: ||                       ENDIF
  2529: |V-----               END DO
  2530: +------            END DO
  2531:                    WRITE(15,*) NNSTA3DVP(IPROC)
  2532: +------>           DO SDStation = 1, NNSTA3DVP(IPROC)
  2533: |                     FDStation = IMAP_STA3DV_LG(SDStation,IPROC)
  2534: |                     WRITE(15,80) STA3DVLOC(FDStation)
  2535: +------            ENDDO
  2536:                 ELSE
  2537:                    WRITE(15,80) NSTA3DVMSG
  2538:                 ENDIF
  2539:           C     -------------------------------------------------------------
  2540:           C     jgf45.11 Create mapping from full domain 3D turbulence station
  2541:           C     elements to corresponding elements in subdomains. Write out
  2542:           C     turbulence subdomain station locations to fort.15 file.
  2543:           C     -------------------------------------------------------------
  2544:                 WRITE(15,*) I3DST,TO3DSTS,TO3DSTF,NSPO3DST
  2545:           C   kmd48.33bc changed
  2546:                 IF(NSTA3DT.NE.0) THEN
  2547:                    NNSTA3DTP(IPROC) = 0
  2548: +------>           DO FDStation = 1, NSTA3DT
  2549: |V----->              DO SDEle = 1, NELP(IPROC)
  2550: ||                       FDEle = abs(IMAP_EL_LG(SDEle,IPROC))
  2551: ||                       IF ( FDEle .eq. NNS3DTG(FDStation) ) THEN
  2552: ||                          NNSTA3DTP(IPROC) = NNSTA3DTP(IPROC) + 1
  2553: ||                          IMAP_STA3DT_LG(NNSTA3DTP(IPROC),IPROC) = FDStation
  2554: ||                       ENDIF
  2555: |V-----               END DO
  2556: +------            END DO
  2557:                    WRITE(15,*) NNSTA3DTP(IPROC)
  2558: +------>           DO SDStation = 1, NNSTA3DTP(IPROC)
  2559: |                     FDStation = IMAP_STA3DT_LG(SDStation,IPROC)
  2560: |                     WRITE(15,80) STA3DTLOC(FDStation)
  2561: +------            ENDDO
  2562:                 ELSE
  2563:                    WRITE(15,80) NSTA3DTMSG
  2564:                 ENDIF
  2565:           
  2566:                 WRITE(15,80) DGDMSG
  2567:                 WRITE(15,80) DGVMSG
  2568:                 WRITE(15,80) DGTMSG
  2569:           
  2570:           C    kmd48.33bc add 3D boundary condition information
  2571:                 IF (CBAROCLINIC) THEN
  2572:                   WRITE(15,80) RESBCFLAGMSG
  2573:                   IF (RES_BC_FLAG.NE.0) THEN
  2574:                     IF (NOPEP(IPROC).GT.0) THEN
  2575:                        WRITE(15,80) BCTIMEMSG
  2576:                        WRITE(15,80) BCSTATMSG
  2577:                     END IF
  2578:                     IF (BCFLAG_TEMP.NE.0) THEN
  2579:                        WRITE(15,80) TBCTIMEMSG
  2580:                     END IF
  2581:                   END IF
  2582:                 END IF
  2583:           
  2584:                 IF (CBAROCLINIC) THEN
  2585:                   WRITE(15,80) SPONGEDISTMSG
  2586:                   WRITE(15,80) EqnstateMSG
  2587:                 END IF
  2588:           
  2589:           C
  2590:           C     jgf45.12: Write out the parameters for the transport equation, if
  2591:           C     necessary.
  2592:                 IF (C3D_BTrans) THEN
  2593:           C     Lateral and vertical diffusion coefficients.
  2594:                    WRITE(15,*) NLSD, NVSD
  2595:                    WRITE(15,*) NLTD, NVTD
  2596:           C     Time stepping coefficient for the transport equation terms.
  2597:                    WRITE(15,*) ALP4
  2598:           C   kmd48.33 took out as it is no longer needed with new heat flux boundary conditions
  2599:           C     Temperature boundary condition file type, if necessary
  2600:           !         IF ( IDEN .eq. 3 .or. IDEN .eq. 4 ) THEN
  2601:           !            WRITE(15,*) NTF
  2602:           !         ENDIF
  2603:                 ENDIF
  2604:           
  2605:                 RETURN
  2606:             80  FORMAT(A80)
  2607:             81  FORMAT(I8,2E15.8,2I8,A32)
  2608:             82  FORMAT(500I8)
  2609:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15_3DVS
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15_3DVS
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:2475)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2475)
  LOOP END

  LOOP BEGIN: (prep.F:2482)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2482)
  LOOP END

  LOOP BEGIN: (prep.F:2496)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:2497)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2497)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2497)
      *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2497)
      *** VCOMPRESS generated (prep.F:2501)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2506)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2506)
  LOOP END

  LOOP BEGIN: (prep.F:2522)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:2523)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2523)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2523)
      *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2523)
      *** VCOMPRESS generated (prep.F:2527)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2532)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2532)
  LOOP END

  LOOP BEGIN: (prep.F:2548)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:2549)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2549)
      *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2549)
      *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2549)
      *** VCOMPRESS generated (prep.F:2553)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2558)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2558)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP15_3DVS
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 52 [s0-s12 s15-s16 s18-s21 s23-s38 s47-s63]
      Vector registers         : 18 [v46-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 1328 bytes
      Register spill area      :   32 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1056 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:2475)
    *** Estimated execution cycle                       : 35
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:2482)
    *** Estimated execution cycle                       : 35
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:2496)
    *** Estimated execution cycle                       : 43
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:2497)
      *** Estimated execution cycle                     : 257
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2506)
    *** Estimated execution cycle                       : 59
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END

  LOOP BEGIN: (prep.F:2522)
    *** Estimated execution cycle                       : 43
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:2523)
      *** Estimated execution cycle                     : 257
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2532)
    *** Estimated execution cycle                       : 59
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END

  LOOP BEGIN: (prep.F:2548)
    *** Estimated execution cycle                       : 43
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:2549)
      *** Estimated execution cycle                     : 257
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2558)
    *** Estimated execution cycle                       : 59
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP18
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  2642: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  2646: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2649: inl(1212): Source for routine not found.: IWRITE
  2659: vec( 103): Unvectorized loop.
  2659: vec( 180): I/O statement obstructs vectorization.
  2661: opt(1118): This I/O statement inhibits optimization of loop.
  2670: vec( 103): Unvectorized loop.
  2670: vec( 180): I/O statement obstructs vectorization.
  2676: opt(1118): This I/O statement inhibits optimization of loop.
  2690: vec( 103): Unvectorized loop.
  2690: vec( 180): I/O statement obstructs vectorization.
  2692: opt(1118): This I/O statement inhibits optimization of loop.
  2700: vec( 103): Unvectorized loop.
  2700: vec( 180): I/O statement obstructs vectorization.
  2702: opt(1118): This I/O statement inhibits optimization of loop.
  2710: vec( 103): Unvectorized loop.
  2710: vec( 180): I/O statement obstructs vectorization.
  2712: opt(1118): This I/O statement inhibits optimization of loop.
  2720: vec( 103): Unvectorized loop.
  2720: vec( 180): I/O statement obstructs vectorization.
  2722: opt(1118): This I/O statement inhibits optimization of loop.
  2730: vec( 103): Unvectorized loop.
  2730: vec( 180): I/O statement obstructs vectorization.
  2732: opt(1118): This I/O statement inhibits optimization of loop.
  2751: vec( 180): I/O statement obstructs vectorization.
  2760: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2760: vec( 101): Vectorized loop.
  2768: opt(1019): Feedback of scalar value from one loop pass to another.: IRECV_TOT
  2768: opt(3014): Moved reference within a conditional branch.
  2771: opt(3014): Moved reference within a conditional branch.
  2776: opt(1118): This I/O statement inhibits optimization of loop.
  2783: vec( 180): I/O statement obstructs vectorization.
  2789: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2789: vec( 101): Vectorized loop.
  2796: opt(1019): Feedback of scalar value from one loop pass to another.: ISEND_TOT
  2796: opt(3014): Moved reference within a conditional branch.
  2799: opt(3014): Moved reference within a conditional branch.
  2804: opt(1118): This I/O statement inhibits optimization of loop.
  2815: opt(3014): Moved reference within a conditional branch.
  2815: vec( 101): Vectorized loop.
  2815: vec( 126): Idiom detected.: MAX/MIN
  2816: vec( 103): Unvectorized loop.
  2816: vec( 180): I/O statement obstructs vectorization.
  2817: opt(1118): This I/O statement inhibits optimization of loop.
  2820: opt(3014): Moved reference within a conditional branch.
  2820: vec( 101): Vectorized loop.
  2820: vec( 126): Idiom detected.: MAX/MIN
  2821: vec( 103): Unvectorized loop.
  2821: vec( 180): I/O statement obstructs vectorization.
  2822: opt(1118): This I/O statement inhibits optimization of loop.
  2825: opt(3014): Moved reference within a conditional branch.
  2825: vec( 101): Vectorized loop.
  2825: vec( 126): Idiom detected.: MAX/MIN
  2826: vec( 103): Unvectorized loop.
  2826: vec( 180): I/O statement obstructs vectorization.
  2827: opt(1118): This I/O statement inhibits optimization of loop.
  2837: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2837: vec( 101): Vectorized loop.
  2839: vec( 101): Vectorized loop.
  2840: vec( 126): Idiom detected.: SUM
  2850: vec( 103): Unvectorized loop.
  2850: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  2850: vec( 180): I/O statement obstructs vectorization.
  2852: opt(1025): Reference to this procedure inhibits optimization.: IWRITE
  2858: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  2859: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP18
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  2615:                 SUBROUTINE PREP18()
  2616:                 USE PRE_GLOBAL
  2617:                 use memory_usage
  2618:           C
  2619:           C---------------------------------------------------------------------------C
  2620:           C                     (  Serial Version  6/10/2011  )                       C
  2621:           C  This Routine writes a message-passing file "fort.18" for each subdomain  C
  2622:           C  of the domain decomposition created by DECOMP.                           C
  2623:           C                                                                           C
  2624:           C  The Decomposition Variables are defined in the include file adcprep.inc  C
  2625:           C  This version is compatible with ADCIRC version 50.21                     C
  2626:           C                                                                           C
  2627:           C  tcm V50.21 -- Changed all I8 formats to I12                              C
  2628:           C---------------------------------------------------------------------------C
  2629:           C
  2630:                 IMPLICIT NONE
  2631:                 integer(8) :: nbytes = 0
  2632:                 INTEGER N1, N2, N3, KMIN
  2633:                 INTEGER I,J,K,M,ITEMP,IPR,IPR1
  2634:                 INTEGER INDX,ITOT,IEL,IELG,ILNODE,IPROC,ITYPE
  2635:                 INTEGER,ALLOCATABLE :: RES_NODE(:)
  2636:                 CHARACTER LOCFN*14,PE*6
  2637:           C
  2638:           C  Allocate local arrays
  2639:           C
  2640:                 ALLOCATE ( RES_NODE(MNPP) )
  2641:                 nbytes = 4*mnpp
  2642:                 call memory_alloc(nbytes)
  2643:           C
  2644:           C--Write Message-Passing File for each PE
  2645:           C
  2646: +------>        DO 1000 I = 1,NPROC
  2647: |         C
  2648: |+=====>           LOCFN(1:14) = 'PE0000/fort.18'
  2649: |                  CALL IWRITE(LOCFN,3,6,I-1)
  2650: |                  OPEN (18,FILE=LOCFN)
  2651: |         
  2652: |                  write(18,3050) FileFmtVersion, 0, 0
  2653: |         
  2654: |         !vjp 9/17/06
  2655: |         C--Write the Global indexes of all local elements in local element order
  2656: |         
  2657: |         Casey 100209: Changed I8 to I12.
  2658: |                  WRITE(18,3000) NELG, MNEP, NELP(I)  ! number of Global elements
  2659: |+----->           DO J = 1,NELP(I)
  2660: ||                    INDX = IMAP_EL_LG(J,I)
  2661: ||                    WRITE(18,'(I12)') INDX        ! Global index of local element
  2662: |+-----            ENDDO
  2663: |         
  2664: |         C--Write the Global indexes of all local nodes in local node order
  2665: |         C  write global index as positive if a resident node and negative
  2666: |         C  if a ghost node
  2667: |         
  2668: |                  WRITE(18,3001) NNODG, MNPP, NNODP(I)   ! number of Global nodes
  2669: |                  ITOT = 0
  2670: |+----->           DO J = 1,NNODP(I)
  2671: ||                    INDX = IMAP_NOD_LG(J,I)
  2672: ||                    IPR = IMAP_NOD_GL(1,INDX)
  2673: ||                    IF (IPR.EQ.I)THEN
  2674: ||                       ITOT = ITOT + 1
  2675: ||                       RES_NODE(ITOT) = J
  2676: ||                       WRITE(18,'(I12)') INDX        ! Global index of resident node
  2677: ||                    ELSE
  2678: ||                       WRITE(18,'(I12)') -1*INDX     ! Global index of ghost node
  2679: ||                    ENDIF
  2680: |+-----            ENDDO
  2681: |                  IF (ITOT.NE.NOD_RES_TOT(I)) STOP 'ERROR IN # OF RES. NODES'
  2682: |         
  2683: |         C--Write local normal flow boundary flag
  2684: |         C--vjp This info is used only for relocalizing fort.15
  2685: |                  WRITE(18,3002) NFLUXFP(I) ! normal flow b.c. flag for subdomain
  2686: |         
  2687: |         C--Write global and local total number of elevation boundary nodes
  2688: |         C--vjp This info is used only for relocalizing fort.15
  2689: |                  WRITE(18,3003) NETA, NETA_MAX, NETAP(I) ! number of global elevation b.c. nodes
  2690: |+----->           DO J = 1,NETAP(I)
  2691: ||                    INDX = OBNODE_LG(J,I)
  2692: ||                    WRITE(18,'(I12)') INDX           ! Global open boundary node index
  2693: |+-----            ENDDO
  2694: |         
  2695: |         C--Write the Global indexes of all Elevation Stations in local node order
  2696: |         C  write global index as positive if a resident node and negative
  2697: |         C  if a ghost node
  2698: |         
  2699: |                  WRITE(18,3004) abs(NSTAE), NSTAE_MAX, NSTAEP(I) ! number of Global Elevation Stations
  2700: |+----->           DO J = 1,NSTAEP(I)
  2701: ||                    INDX = IMAP_STAE_LG(J,I)
  2702: ||                    WRITE(18,'(I12)') INDX           ! Global station number
  2703: |+-----            ENDDO
  2704: |         
  2705: |         C--Write the Global indexes of all Velocity Stations in local node order
  2706: |         C  write global index as positive if a resident node and negative
  2707: |         C  if a ghost node
  2708: |         
  2709: |                  WRITE(18,3005) abs(NSTAV), NSTAV_MAX, NSTAVP(I) ! number of Global Velocity Stations
  2710: |+----->           DO J = 1,NSTAVP(I)
  2711: ||                    INDX = IMAP_STAV_LG(J,I)
  2712: ||                    WRITE(18,'(I12)') INDX           ! Global station number
  2713: |+-----            ENDDO
  2714: |         
  2715: |         C--Write the Global indexes of all Elevation Stations in local node order
  2716: |         C  write global index as positive if a resident node and negative
  2717: |         C  if a ghost node
  2718: |         
  2719: |                  WRITE(18,3006) abs(NSTAM), NSTAM_MAX, NSTAMP(I) ! number of Global Meteorlogical Stations
  2720: |+----->           DO J = 1,NSTAMP(I)
  2721: ||                    INDX = IMAP_STAM_LG(J,I)
  2722: ||                    WRITE(18,'(I12)') INDX           ! Global station number
  2723: |+-----            ENDDO
  2724: |         
  2725: |         C--Write the Global indexes of all Concentration Stations in local node order
  2726: |         C  write global index as positive if a resident node and negative
  2727: |         C  if a ghost node
  2728: |         
  2729: |                  WRITE(18,3007) abs(NSTAC), NSTAC_MAX, NSTACP(I) ! number of Global Concentration Stations
  2730: |+----->           DO J = 1,NSTACP(I)
  2731: ||                    INDX = IMAP_STAC_LG(J,I)
  2732: ||                    WRITE(18,'(I12)') INDX           ! Global station number
  2733: |+-----            ENDDO
  2734: |         
  2735: |         C---------------------------------------------------------------------------------
  2736: |         C---------------------------------------------------------------------------------
  2737: |         C---------------------------------------------------------------------------------
  2738: |         C
  2739: |         C--Write the Resident Node List
  2740: |         C
  2741: |                  WRITE(18,3010) (I-1),NOD_RES_TOT(I)
  2742: |+----->           WRITE(18,1130) (RES_NODE(J),J=1,ITOT)
  2743: |         C
  2744: |         C--Write the Number of Communicating PEs
  2745: |         C
  2746: |                  WRITE(18,3020) NUM_COMM_PE(I)
  2747: |         C
  2748: |         C--Write the Receive List
  2749: |         C
  2750: |                  ! loop over this subdomain's neighbors
  2751: |+----->           DO J = 1,NUM_COMM_PE(I)
  2752: ||                    ! get the subdomain number of the Jth neighbor
  2753: ||                    ! of this subdomain
  2754: ||                    IPR = COMM_PE_NUM(J,I)
  2755: ||                    ! zero out the total number of ghost nodes on this
  2756: ||                    ! subdomain that are residents on the Jth neighbor
  2757: ||                    ! of this subdomain
  2758: ||                    IRECV_TOT(J,I) = 0
  2759: ||                    ! loop over nodes in this subdomain
  2760: ||V---->              DO K = 1,NNODP(I)
  2761: |||                      ! get corresponding fulldomain node number
  2762: |||                      INDX = IMAP_NOD_LG(K,I)
  2763: |||                      ! if the fulldomain node is a ghost and is a resident
  2764: |||                      ! of the Jth neighbor of this subdomain
  2765: |||     G                IF (IMAP_NOD_GL(1,INDX).EQ.IPR) THEN
  2766: |||                         ! increment the total number of ghost nodes that
  2767: |||                         ! are residents of the Jth neighbor subdomain
  2768: |||                         IRECV_TOT(J,I) = IRECV_TOT(J,I) + 1
  2769: |||                         ! record the local node number of this subdomain
  2770: |||                         ! that will receive data
  2771: |||                         IRECV(IRECV_TOT(J,I)) = K
  2772: |||       c uncomment next line and comment preceding line for debugging
  2773: |||       c                 IRECV(IRECV_TOT(J,I)) = INDX
  2774: |||                      ENDIF
  2775: ||V----               ENDDO
  2776: ||                    WRITE(18,3030) (IPR-1), IRECV_TOT(J,I)
  2777: ||+---->              WRITE(18,1130) (IRECV(K),K=1,IRECV_TOT(J,I))
  2778: |+-----            ENDDO
  2779: |         C
  2780: |         C--write the send list
  2781: |         C
  2782: |                 ! loop over this subdomain's neighbors
  2783: |+----->           DO J = 1,NUM_COMM_PE(I)
  2784: ||                    ! get the subdomain number of the Jth neighbor
  2785: ||                    ! of this subdomain
  2786: ||                    IPR = COMM_PE_NUM(J,I)
  2787: ||                    ISEND_TOT(J,I) = 0
  2788: ||                    ! loop over nodes in the Jth neighbor subdomain
  2789: ||V---->              DO K = 1,NNODP(IPR)
  2790: |||                      ! get the fulldomain node number in the Jth neighbor subdomain
  2791: |||                      INDX = IMAP_NOD_LG(K,IPR)
  2792: |||                      ! if the node is a resident of this subdomain
  2793: |||     G                IF (IMAP_NOD_GL(1,INDX).EQ.I) THEN
  2794: |||                         ! increment the total number of nodes on this subdomain
  2795: |||                         ! that are ghosts on the Jth neighbor
  2796: |||                         ISEND_TOT(J,I) = ISEND_TOT(J,I) + 1
  2797: |||                         ! record the local node number on this subdomain
  2798: |||                         ! that will send data
  2799: |||     G                   ISEND(ISEND_TOT(J,I)) = IMAP_NOD_GL(2,INDX)
  2800: |||       c uncomment next line and comment preceding line for debugging
  2801: |||       c                 ISEND(ISEND_TOT(J,I)) = INDX
  2802: |||                      ENDIF
  2803: ||V----               ENDDO
  2804: ||                    WRITE(18,3040)  IPR-1, ISEND_TOT(J,I)
  2805: ||+---->              WRITE(18,1130) (ISEND(K),K=1,ISEND_TOT(J,I))
  2806: |+-----            ENDDO
  2807: |         C
  2808: |                  IF (C3D.eqv..true.) THEN
  2809: |         C           jgf49.43.18: Add 3D station mappings from subdomain to fulldomain
  2810: |         C           to accomodate globalio.
  2811: |         C
  2812: |         C           Write the fulldomain station numbers of all 3D density stations
  2813: |         C           in local node order; write the fulldomain station number as positive
  2814: |         C           for resident stations and negative for ghost stations.
  2815: |V=====>              WRITE(18,3060) NSTA3DD, MAXVAL(NNSTA3DDP), NNSTA3DDP(I)
  2816: |+----->              DO J=1,NNSTA3DDP(I)
  2817: ||                       WRITE(18,1131) IMAP_STA3DD_LG(J,I)
  2818: |+-----               END DO
  2819: |         C           3D velocity stations
  2820: |V=====>              WRITE(18,3061) NSTA3DV, MAXVAL(NNSTA3DVP), NNSTA3DVP(I)
  2821: |+----->              DO J=1,NNSTA3DVP(I)
  2822: ||                       WRITE(18,'(I12)') IMAP_STA3DV_LG(J,I)
  2823: |+-----               END DO
  2824: |         C           3D turbulence stations
  2825: |V=====>              WRITE(18,3062) NSTA3DT, MAXVAL(NNSTA3DTP), NNSTA3DTP(I)
  2826: |+----->              DO J=1,NNSTA3DTP(I)
  2827: ||                       WRITE(18,'(I12)') IMAP_STA3DT_LG(J,I)
  2828: |+-----               ENDDO
  2829: |                  ENDIF
  2830: |         C
  2831: |                  CLOSE(18)
  2832: |         C
  2833: +------   1000  CONTINUE
  2834:           C
  2835:           C--Compute the surface to volume ratio (in %)
  2836:           C
  2837: V------>        DO I = 1,NPROC
  2838: |                  ITOT = 0
  2839: |V----->           DO J = 1,NUM_COMM_PE(I)
  2840: ||                    ITOT = ITOT + IRECV_TOT(J,I)
  2841: |V-----            ENDDO
  2842: |                  PROC_SV(I) = (ITOT/REAL(NOD_RES_TOT(I)))*100.0
  2843: |         c        WRITE(6,*) I-1,PROC_SV(I)
  2844: V------         ENDDO
  2845:           C
  2846:                 print *, " "
  2847:                 print *, "Communication Data"
  2848:                 print *, "DOMAIN  COMM_PE  %(SURF/VOL)"
  2849:                 print *, "------  -------  -----------"
  2850: +------>        DO I=1, NPROC
  2851: |                  PE(1:6) = 'PE0000'
  2852: |                  CALL IWRITE(PE,3,6,I-1)
  2853: |                  WRITE(6,92) PE, NUM_COMM_PE(I),PROC_SV(I)
  2854: +------         ENDDO
  2855:           
  2856:                 deallocate( res_node )
  2857:                 nbytes = 4*mnpp
  2858:                 call memory_dealloc(nbytes)
  2859:                 call memory_status()
  2860:                 RETURN
  2861:           C
  2862:             92  FORMAT(1X,A6,2X,I7,2X,F8.2)
  2863:           1130  FORMAT(8X,6I12) !(8X,9I8)
  2864:           1131  FORMAT(:,I12)
  2865:           Casey 100209: Changed I8 to I12 through this section.
  2866:           3000  FORMAT('NELG    ',3I12)
  2867:           3001  FORMAT('NNODG   ',3I12)
  2868:           3002  FORMAT('NFLUXF  ',I12)
  2869:           3003  FORMAT('NETA    ',3I12)
  2870:           3004  FORMAT('NSTAE   ',3I12)
  2871:           3005  FORMAT('NSTAV   ',3I12)
  2872:           3006  FORMAT('NSTAM   ',3I12)
  2873:           3007  FORMAT('NSTAC   ',3I12)
  2874:           3010  FORMAT('RES NODE',2I12)
  2875:           3020  FORMAT('COMM PE ',2I12)
  2876:           3030  FORMAT('RECV PE ',2I12)
  2877:           3040  FORMAT('SEND PE ',2I12)
  2878:           3050  FORMAT('FileFmt ',3I12)
  2879:           3060  FORMAT('NSTA3DD ',3I12)
  2880:           3061  FORMAT('NSTA3DV ',3I12)
  2881:           3062  FORMAT('NSTA3DT ',3I12)
  2882:                 END SUBROUTINE PREP18


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP18
INLINE LIST

  ROOT: PREP18 (prep.F:2615)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:2642)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2649)
     *** Source for routine not found.
  -> NOINLINE: IWRITE (prep.F:2852)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:2858)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:2859)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP18
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:2646)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:2648)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:2648)
    LOOP END

    LOOP BEGIN: (prep.F:2659)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2659)
    LOOP END

    LOOP BEGIN: (prep.F:2670)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2670)
    LOOP END

    LOOP BEGIN: (prep.F:2690)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2690)
    LOOP END

    LOOP BEGIN: (prep.F:2700)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2700)
    LOOP END

    LOOP BEGIN: (prep.F:2710)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2710)
    LOOP END

    LOOP BEGIN: (prep.F:2720)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2720)
    LOOP END

    LOOP BEGIN: (prep.F:2730)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2730)
    LOOP END

    LOOP BEGIN: (prep.F:2751)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2751)

      LOOP BEGIN: (prep.F:2760)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  1,  0. (prep.F:2760)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2760)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2760)
        *** VGT generated (prep.F:2765)
        *** VCOMPRESS generated (prep.F:2771)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2783)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2783)

      LOOP BEGIN: (prep.F:2789)
        <Vectorized loop.>
        *** The number of VGT,   VSC.    :  2,  0. (prep.F:2789)
        *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:2789)
        *** The number of VCOMPRESS, VEXPAND. :  1,  0. (prep.F:2789)
        *** VGT generated (prep.F:2793)
        *** VGT generated (prep.F:2799)
        *** VCOMPRESS generated (prep.F:2799)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2815)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2815)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2815)
      *** Idiom detected. : MAX/MIN (prep.F:2815)
    LOOP END

    LOOP BEGIN: (prep.F:2816)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2816)
    LOOP END

    LOOP BEGIN: (prep.F:2820)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2820)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2820)
      *** Idiom detected. : MAX/MIN (prep.F:2820)
    LOOP END

    LOOP BEGIN: (prep.F:2821)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2821)
    LOOP END

    LOOP BEGIN: (prep.F:2825)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2825)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2825)
      *** Idiom detected. : MAX/MIN (prep.F:2825)
    LOOP END

    LOOP BEGIN: (prep.F:2826)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2826)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2837)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:2837)
    *** The number of VLOAD, VSTORE. :  2,  1. (prep.F:2837)

    LOOP BEGIN: (prep.F:2839)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:2839)
      *** The number of VLOAD, VSTORE. :  1,  0. (prep.F:2839)
      *** Idiom detected. : SUM (prep.F:2840)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2850)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:2850)
    *** I/O statement obstructs vectorization. (prep.F:2850)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP18
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         : 42 [v22-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 3984 bytes
      Register spill area      : 1288 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2360 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:2646)
    *** Estimated execution cycle                       : 1994
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 123
            Across calls                                :  60
            Over basic blocks                           :  60
            Others                                      :   3
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 206
            Across calls                                :  69
            Over basic blocks                           : 129
            Others                                      :   8
    *** The number of SCALAR REGISTER TRANSFER          : 233

    LOOP BEGIN: (prep.F:2648)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:2659)
      *** Estimated execution cycle                     : 44
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 8
    LOOP END

    LOOP BEGIN: (prep.F:2670)
      *** Estimated execution cycle                     : 131
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER TRANSFER        : 35
    LOOP END

    LOOP BEGIN: (prep.F:2690)
      *** Estimated execution cycle                     : 48
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:2700)
      *** Estimated execution cycle                     : 51
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER TRANSFER        : 8
    LOOP END

    LOOP BEGIN: (prep.F:2710)
      *** Estimated execution cycle                     : 56
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 3
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 3
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:2720)
      *** Estimated execution cycle                     : 61
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2730)
      *** Estimated execution cycle                     : 61
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2751)
      *** Estimated execution cycle                     : 278
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 11
              Across calls                              : 11
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 21
              Across calls                              : 13
              Over basic blocks                         :  7
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 37

      LOOP BEGIN: (prep.F:2760)
        *** Estimated execution cycle                   : 379
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2783)
      *** Estimated execution cycle                     : 256
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 9
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 19
              Across calls                              : 11
              Over basic blocks                         :  7
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 37

      LOOP BEGIN: (prep.F:2789)
        *** Estimated execution cycle                   : 441
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:2815)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (prep.F:2816)
      *** Estimated execution cycle                     : 71
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 5
              Over basic blocks                         : 3
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2820)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (prep.F:2821)
      *** Estimated execution cycle                     : 65
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 4
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:2825)
      *** Estimated execution cycle                     : 96
    LOOP END

    LOOP BEGIN: (prep.F:2826)
      *** Estimated execution cycle                     : 65
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 4
              Over basic blocks                         : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2837)
    *** Estimated execution cycle                       : 108
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:2839)
      *** Estimated execution cycle                     : 96
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2837)
    *** Estimated execution cycle                       : 483
  LOOP END

  LOOP BEGIN: (prep.F:2850)
    *** Estimated execution cycle                       : 184
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 14
            Across calls                                : 10
            Over basic blocks                           :  4
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 26
            Across calls                                : 15
            Over basic blocks                           : 10
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 20
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP19
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  2926: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  2929: vec( 103): Unvectorized loop.
  2929: vec( 180): I/O statement obstructs vectorization.
  2930: opt(1118): This I/O statement inhibits optimization of loop.
  2935: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  2935: vec( 108): Unvectorizable loop structure.
  2936: vec( 103): Unvectorized loop.
  2936: vec( 180): I/O statement obstructs vectorization.
  2937: opt(1118): This I/O statement inhibits optimization of loop.
  2937: opt(3014): Moved reference within a conditional branch.
  2944: vec( 180): I/O statement obstructs vectorization.
  2946: opt(1118): This I/O statement inhibits optimization of loop.
  2955: vec( 103): Unvectorized loop.
  2955: vec( 180): I/O statement obstructs vectorization.
  2956: opt(1118): This I/O statement inhibits optimization of loop.
  2961: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  2962: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP19
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  2885:                 SUBROUTINE PREP19()
  2886:                 USE PRE_GLOBAL
  2887:                 use memory_usage
  2888:           C
  2889:           C---------------------------------------------------------------------------C
  2890:           C                     (  Serial Version  2/28/98  )                         C
  2891:           C  This routine writes a Local "Aperiodic Elevation Boundary Condtions"     C
  2892:           C  (fort.19) file for each subdomain using the domain decomposition of      C
  2893:           C  the ADCIRC grid created by the routine DECOMP.                           C
  2894:           C                                                                           C
  2895:           C  The Decomposition Variables are defined in the include file adcprep.inc  C
  2896:           C  This version is compatible with ADCIRC version 34.03                     C
  2897:           C
  2898:           C     jgf45.12 Added subroutine call to open files.
  2899:           C                                                                           C
  2900:           C---------------------------------------------------------------------------C
  2901:           C
  2902:                 IMPLICIT NONE
  2903:                 integer(8) :: nbytes = 0
  2904:                 INTEGER I,J,IPROC,EOF
  2905:                 INTEGER SDU(NPROC) ! subdomain unit numbers
  2906:                 LOGICAL Success    ! .true. if files opened without errors
  2907:                 CHARACTER*40  ETIMINC,ESBINP
  2908:                 CHARACTER*40,ALLOCATABLE :: ESBIN(:)
  2909:           
  2910:           C
  2911:           C--Enter, Locate, Open, and Read the ADCIRC UNIT 19
  2912:           C  Global Aperiodic Elevation Boundary Conditions file
  2913:           C
  2914:           C     Open full domain and subdomain fort.19 files
  2915:                 CALL OpenPrepFiles(19, 'aperiodic elevation boundary  ',
  2916:                &     1, nproc, SDU, Success)
  2917:                 IF (.not.Success) THEN
  2918:                    WRITE(*,*) 'WARNING: Unit 19 files not preprocessed.'
  2919:                    RETURN ! note early return
  2920:                 ENDIF
  2921:           C
  2922:           C--Allocate local arrays
  2923:           C
  2924:                 ALLOCATE ( ESBIN(MNETA) )
  2925:                 nbytes = 8*mneta
  2926:                 call memory_alloc(nbytes)
  2927:           C
  2928:                 READ(19,40) ETIMINC
  2929: +------>        DO IPROC = 1,NPROC
  2930: |                  WRITE(SDU(IPROC),40)  ETIMINC
  2931: +------         ENDDO
  2932:           C
  2933:           C--While ( NOT EOF ) Read NETA BCs from Global File
  2934:           C
  2935: +------>        DO WHILE(.true.)
  2936: |+----->           DO I=1, NETA
  2937: ||                    READ(19,40,iostat=eof)  ESBIN(I)
  2938: ||                    IF (eof.ne.0) EXIT
  2939: |+-----            ENDDO
  2940: |         C        EOF reached, lets exit
  2941: |                  IF (eof < 0) EXIT
  2942: |          
  2943: |+----->           DO IPROC= 1,NPROC
  2944: ||+---->              DO I=1, NETAP(IPROC)
  2945: |||+===>                 ESBINP = ESBIN(OBNODE_LG(I,IPROC))
  2946: |||                      WRITE(SDU(IPROC),40) ESBINP
  2947: ||+----               ENDDO
  2948: |+-----            ENDDO
  2949: |         C
  2950: +------         ENDDO
  2951:           C
  2952:           C--Close Global file and all the Local Files
  2953:           C
  2954:                 CLOSE (19)
  2955: +------>        DO IPROC=1, NPROC
  2956: |                  CLOSE (SDU(IPROC))
  2957: +------         ENDDO
  2958:           
  2959:                 deallocate( esbin )
  2960:                 nbytes = 8*mneta
  2961:                 call memory_dealloc(nbytes)
  2962:                 call memory_status()
  2963:                 RETURN
  2964:             40  FORMAT(A40)
  2965:                 END SUBROUTINE PREP19


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP19
INLINE LIST

  ROOT: PREP19 (prep.F:2885)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:2926)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:2961)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:2962)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP19
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:2929)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2929)
  LOOP END

  LOOP BEGIN: (prep.F:2935)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:2935)

    LOOP BEGIN: (prep.F:2936)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:2936)
    LOOP END

    LOOP BEGIN: (prep.F:2943)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:2944)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:2944)

        LOOP BEGIN: (prep.F:2945)
          <Unvectorized loop.>
          *** Unvectorizable data type. : ESBIN (prep.F:2945)
          *** Unvectorizable data type. : ESBINP (prep.F:2945)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2955)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:2955)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP19
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 44 [s0-s12 s15-s16 s18-s35 s53-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1744 bytes
      Register spill area      :  184 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1304 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:2929)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:2935)
    *** Estimated execution cycle                       : 68
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 8
            Over basic blocks                           : 8
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 8
            Over basic blocks                           : 8
    *** The number of SCALAR REGISTER TRANSFER          : 24

    LOOP BEGIN: (prep.F:2936)
      *** Estimated execution cycle                     : 42
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:2943)
      *** Estimated execution cycle                     : 26
      *** The number of SCALAR REGISTER TRANSFER        : 9

      LOOP BEGIN: (prep.F:2944)
        *** Estimated execution cycle                   : 67
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 1
                Across calls                            : 1
        *** The number of SCALAR REGISTER TRANSFER      : 16

        LOOP BEGIN: (prep.F:2945)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:2955)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP20
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3019: vec( 103): Unvectorized loop.
  3019: vec( 180): I/O statement obstructs vectorization.
  3020: opt(1118): This I/O statement inhibits optimization of loop.
  3028: vec( 108): Unvectorizable loop structure.
  3029: vec( 108): Unvectorizable loop structure.
  3039: vec( 180): I/O statement obstructs vectorization.
  3039: vec( 181): Allocation obstructs vectorization.
  3039: vec( 182): Deallocation obstructs vectorization.
  3042: opt(1082): Backward transfers inhibit loop optimization.
  3042: opt(1118): This I/O statement inhibits optimization of loop.
  3042: vec( 103): Unvectorized loop.
  3042: vec( 108): Unvectorizable loop structure.
  3049: vec( 103): Unvectorized loop.
  3049: vec( 180): I/O statement obstructs vectorization.
  3050: opt(1118): This I/O statement inhibits optimization of loop.
  3056: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  3058: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP20
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  2982:                 SUBROUTINE PREP20(sponge)
  2983:           C---------------------------------------------------------------------------
  2984:                 USE PRE_GLOBAL
  2985:                 use memory_usage
  2986:                 IMPLICIT NONE
  2987:                 integer(8) :: nbytes = 0
  2988:                 INTEGER IPROC
  2989:                 INTEGER INDEX14, I, FLUX_NUM
  2990:                 REAL(8)  FLUX_INC, FLUX_VAL
  2991:                 CHARACTER(80) :: FLUX_MSG
  2992:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  2993:                 LOGICAL Success     ! .true. if all files open without error
  2994:                 LOGICAL,optional :: sponge !.true. if want to prep fort.2001
  2995:                 INTEGER INDX ! full domain node number for a flow boundary node
  2996:                 INTEGER J     ! counter for subdomains that corrsp. to a single f.d. node
  2997:                 INTEGER IPROC2! PE of a subdomain that matches a single full domain node
  2998:                 INTEGER PROC_NO ! proc number is 20 unless specified
  2999:           
  3000:                 proc_no = 20;
  3001:                 FLUX_NUM = EXIST_FLUX
  3002:           C     Open full domain and subdomain fort.20 files
  3003:                 if (sponge) then
  3004:                    proc_no = 2001
  3005:                    FLUX_NUM = ubound(nodeNumSP,1)
  3006:                    write(*,*) 'FLUX_NUM = ',FLUX_NUM
  3007:                 endif
  3008:           
  3009:                 CALL OpenPrepFiles(proc_no, 'aperiodic flux boundary       ',
  3010:                &     1, nproc, SDU, Success)
  3011:                 IF (.not.Success) THEN
  3012:                    WRITE(*,*) 'WARNING: Unit 20 files not preprocessed.'
  3013:                    RETURN ! note early return
  3014:                 ENDIF
  3015:           c
  3016:           c     Write Increment into all flux files
  3017:           c
  3018:                 READ(proc_no,*) FLUX_INC
  3019: +------>        DO IPROC=1,NPROC
  3020: |                  WRITE(SDU(IPROC),*) FLUX_INC
  3021: +------         ENDDO
  3022:           C
  3023:           C     jgf45.12 Write each full domain nodal flux value into each of the
  3024:           C     subdomains that that full domain node maps to. The full domain
  3025:           C     node may map to more than one subdomain node if it falls on a
  3026:           C     boundary between subdomains (ghost nodes).
  3027:           C
  3028: +------>        DO WHILE(.TRUE.)
  3029: |+----->           DO I = 1, FLUX_NUM             ! loop through full domain flow nodes
  3030: ||        !            READ(20,*,END=40) FLUX_VAL ! get a flo val for this f.d. flow node
  3031: ||                    READ(proc_no,'(A80)',END=40) FLUX_MSG ! get a flo val for this f.d. flow node
  3032: ||                    if (sponge) then
  3033: ||                       INDX = nodeNumSP(I)
  3034: ||                    else
  3035: ||                       INDX = FLUX14_ARY(I)      ! get full domain flow node number
  3036: ||                    endif
  3037: ||+---->              DO J=1, ITOTPROC(INDX)    ! loop over subdomains for 1 f.d. node
  3038: |||                      IPROC2 = IMAP_NOD_GL2(2*(J-1)+1,INDX) ! find next subdomain
  3039: |||+--->                 DO IPROC=1, NPROC
  3040: ||||                        IF (IPROC.EQ.IPROC2) THEN ! full domain node maps to this s.d.
  3041: ||||                           !WRITE(SDU(IPROC),50) FLUX_VAL
  3042: ||||                           WRITE(SDU(IPROC),*) TRIM(FLUX_MSG)
  3043: ||||                        ENDIF
  3044: |||+---                  END DO
  3045: ||+----               END DO
  3046: |+-----            END DO
  3047: +------         ENDDO
  3048:            40   CLOSE (proc_no)
  3049: +------>        DO IPROC=1, NPROC
  3050: |                  CLOSE (SDU(IPROC))
  3051: +------         ENDDO
  3052:           
  3053:                 IF (allocated(FLUX14_ARY)) then
  3054:                   DEALLOCATE (FLUX14_ARY)
  3055:                   nbytes = 4*exist_flux
  3056:                   call memory_dealloc(nbytes)
  3057:                 ENDIF
  3058:                 call memory_status()
  3059:                 return
  3060:            50   FORMAT (F16.8,1x,I6,1x,I6,1x,I6)
  3061:           c----------------------------------------------------------------------------
  3062:                 END SUBROUTINE PREP20


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP20
INLINE LIST

  ROOT: PREP20 (prep.F:2982)
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:3056)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:3058)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP20
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:3019)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:3019)
  LOOP END

  LOOP BEGIN: (prep.F:3028)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3028)

    LOOP BEGIN: (prep.F:3029)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:3029)

      LOOP BEGIN: (prep.F:3037)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3039)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3039)
          *** Allocation obstructs vectorization. (prep.F:3039)
          *** Deallocation obstructs vectorization. (prep.F:3039)

          LOOP BEGIN: (prep.F:3042)
            <Unvectorized loop.>
            *** Unvectorizable loop structure. (prep.F:3042)
          LOOP END
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:3049)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:3049)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP20
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 39 [s0-s12 s15-s16 s18-s33 s56-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1632 bytes
      Register spill area      :  120 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1256 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3019)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:3028)
    *** Estimated execution cycle                       : 13
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 5

    LOOP BEGIN: (prep.F:3029)
      *** Estimated execution cycle                     : 136
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Over basic blocks                         : 8
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER TRANSFER        : 39

      LOOP BEGIN: (prep.F:3037)
        *** Estimated execution cycle                   : 34
        *** The number of SCALAR REGISTER TRANSFER      : 10

        LOOP BEGIN: (prep.F:3039)
          *** Estimated execution cycle                 : 54
          *** The number of SCALAR REGISTER TRANSFER    : 16

          LOOP BEGIN: (prep.F:3042)
            *** Estimated execution cycle               : 7
          LOOP END
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:3049)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP22
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3207: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  3217: vec( 108): Unvectorizable loop structure.
  3242: vec( 108): Unvectorizable loop structure.
  3243: opt(1118): This I/O statement inhibits optimization of loop.
  3243: vec( 103): Unvectorized loop.
  3243: vec( 180): I/O statement obstructs vectorization.
  3243: vec( 108): Unvectorizable loop structure.
  3246: vec( 101): Vectorized loop.
  3252: vec( 103): Unvectorized loop.
  3252: vec( 180): I/O statement obstructs vectorization.
  3253: opt(1118): This I/O statement inhibits optimization of loop.
  3268: vec( 108): Unvectorizable loop structure.
  3271: vec( 103): Unvectorized loop.
  3271: vec( 180): I/O statement obstructs vectorization.
  3272: opt(1118): This I/O statement inhibits optimization of loop.
  3280: vec( 103): Unvectorized loop.
  3280: vec( 180): I/O statement obstructs vectorization.
  3283: opt(1118): This I/O statement inhibits optimization of loop.
  3298: inl(1212): Source for routine not found.: NWS4GET
  3301: vec( 101): Vectorized loop.
  3307: vec( 103): Unvectorized loop.
  3307: vec( 180): I/O statement obstructs vectorization.
  3308: opt(1118): This I/O statement inhibits optimization of loop.
  3328: vec( 103): Unvectorized loop.
  3328: vec( 180): I/O statement obstructs vectorization.
  3329: opt(1118): This I/O statement inhibits optimization of loop.
  3338: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  3339: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP22
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3175:                 SUBROUTINE PREP22()
  3176:           C---------------------------------------------------------------------------
  3177:                 USE PRE_GLOBAL
  3178:                 use memory_usage
  3179:                 IMPLICIT NONE
  3180:                 integer(8) :: nbytes = 0
  3181:                 LOGICAL FOUND,DONE
  3182:                 INTEGER I,J,IPROC,IPROC2,ILNODE,INDX,NHG,LINDEX
  3183:                 CHARACTER*80 PBLJAGF
  3184:           C      CHARACTER FNAME*60,LOCFN*14,CMD1*63,CMD2*7,CMD*70,INLINE*80
  3185:                 CHARACTER FNAME*60,CMD1*63,CMD2*7,CMD*70
  3186:                 CHARACTER*170 Line ! line of data from NWS=8 (Holland) file
  3187:                 CHARACTER*270 Line19 ! line of data from NWS=19 (AsymmHollandv2.0) file
  3188:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  3189:                 LOGICAL Success     ! .true. if all files open without error
  3190:                 INTEGER,ALLOCATABLE  :: NG(:)
  3191:                 REAL(8),ALLOCATABLE :: WVNXG(:),WVNYG(:),PRG(:)
  3192:                 REAL(8),ALLOCATABLE :: WVNXL(:),WVNYL(:),PRL(:)
  3193:                 REAL(8) U,V,PR
  3194:                 REAL(8) RHOWAT     !jgfdebug46.02
  3195:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
  3196:           C     time ... some platforms/compilers limit the number of files that
  3197:           C     can be open at any one time.
  3198:                 INTEGER, PARAMETER :: maxOpenFiles = 256
  3199:                 INTEGER startProc
  3200:                 INTEGER endProc
  3201:                 INTEGER deltaProc
  3202:           C
  3203:           C     Allocate local work arrays
  3204:           C
  3205:                 ALLOCATE ( NG(MNWP) )
  3206:                 nbytes = 4*mnwp
  3207:                 call memory_alloc(nbytes)
  3208:                 ALLOCATE ( WVNXG(MNWP),WVNYG(MNWP),PRG(MNWP) )
  3209:                 nbytes = 24*mnwp
  3210:                 call memory_alloc(nbytes)
  3211:                 ALLOCATE ( WVNXL(MNWP),WVNYL(MNWP),PRL(MNWP) )
  3212:                 nbytes = 24*mnwp
  3213:                 call memory_alloc(nbytes)
  3214:           C
  3215:           C     Perform decomposition over a range of subdomains.
  3216:                 startProc = 1
  3217: +------>        DO WHILE ( startProc .lt. nproc )
  3218: |                  deltaProc = nproc - startProc
  3219: |                  IF ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
  3220: |                  endProc = startProc + deltaProc
  3221: |         
  3222: |         C        Open full domain and all subdomain fort.22 files
  3223: |                  CALL OpenPrepFiles(22, 'wind information              ',
  3224: |              &      startProc, endProc, sdu, success)
  3225: |         
  3226: |                  IF (.not.success) THEN
  3227: |                    WRITE(*,*) 'WARNING: Unit 22 files not preprocessed.'
  3228: |                    RETURN ! note early return
  3229: |                  ENDIF
  3230: |         C
  3231: |         C--Branch to Appropriate Code
  3232: |         C
  3233: |                  SELECT CASE(ABS(NWS))
  3234: |         C        -------------
  3235: |                  CASE(1,2,5,7)
  3236: |         C        -------------
  3237: |         C
  3238: |         C     MAIN LOOP FOR NWS = 1, +-2,+-5,+-7
  3239: |         C     (1)  Read a record from Global Wind Stress File
  3240: |         C     (2)  Use Decomp arrarys to Localize record to a subdomain
  3241: |         C     (3)  Write Local Wind Stress record in same format
  3242: |+----->             DO                     ! loop forever (or until file ends)
  3243: ||+---->                READ(22,*,END=9999)
  3244: ||             &           (NG(I),WVNXG(I),WVNYG(I),PRG(I),I=1,NNODG)
  3245: ||+---->                DO IPROC = STARTPROC, ENDPROC
  3246: |||V--->                   DO I=1, NNODP(IPROC)
  3247: ||||                          INDX = IMAP_NOD_LG(I,IPROC)
  3248: ||||    G                     WVNXL(I) = WVNXG(INDX)
  3249: ||||    G                     WVNYL(I) = WVNYG(INDX)
  3250: ||||    G                     PRL(I) = PRG(INDX)
  3251: |||V---                    ENDDO
  3252: |||+--->                   DO I=1, NNODP(IPROC)
  3253: ||||                          WRITE(SDU(IPROC),1100)  I,WVNXL(I),WVNYL(I),PRL(I)
  3254: |||+---                    ENDDO
  3255: ||+----                 ENDDO
  3256: |+-----              ENDDO
  3257: |         C
  3258: |         C        -------
  3259: |                  CASE(4)
  3260: |         C        -------
  3261: |         C        MAIN LOOP FOR NWS = +- 4  ( PBL Format )
  3262: |         C        (1)  Read a record from Global Wind Stress File
  3263: |         C        (2)  Use Decomp arrarys to Localize record to a subdomain
  3264: |         C        (3)  Write out in PBL Format on subdomain
  3265: |         C
  3266: |         C--Read a wind field record from the global input file
  3267: |         C
  3268: |+----->           DO
  3269: ||                    READ(22,'(A80)',END=9999) PBLJAGF
  3270: ||                    IF(PBLJAGF(2:2).EQ.'#') THEN
  3271: ||+---->                 DO IPROC =  STARTPROC,ENDPROC
  3272: |||                         WRITE(SDU(IPROC),1101)
  3273: |||                         WRITE(SDU(IPROC),1100) 1,0.0,0.0,0.0 !victor didn't like this line 27/11/03
  3274: ||+----                  ENDDO
  3275: ||                    ELSE
  3276: ||        !     vjp 27/11/03
  3277: ||        !     rewrote this section to handle ghost-nodes
  3278: ||        C              READ(PBLJAGF,'(I8,3E13.5)',END=9999) NHG,U,V,PR
  3279: ||                       READ(PBLJAGF,*,END=9999) NHG,U,V,PR
  3280: ||+---->                 DO J=1, ITOTPROC(NHG)
  3281: |||                         IPROC  = IMAP_NOD_GL2(2*(J-1)+1,NHG)
  3282: |||                         LINDEX = IMAP_NOD_GL2(2*(J-1)+2,NHG)
  3283: |||                         WRITE(SDU(IPROC),1100) LINDEX,U,V,PR
  3284: ||+----                  ENDDO
  3285: ||                    ENDIF
  3286: |+-----            END DO
  3287: |         C
  3288: |         C        --------
  3289: |                  CASE(45)
  3290: |         C        --------
  3291: |         C        jgf46.02 Convert NWS=4 winds to NWS=5 winds to imitate the Katrina
  3292: |         C        (IPET) version of the code.
  3293: |         C
  3294: |         C-- Read a wind field record from the global input file
  3295: |         C
  3296: |+----->           DO
  3297: ||                    RHOWAT=1000.0d0
  3298: ||                    CALL NWS4GET(WVNXG,WVNYG,PRG,G,RHOWAT,NNODG,DONE)
  3299: ||        C
  3300: ||+---->              DO IPROC = STARTPROC,ENDPROC
  3301: |||V--->                 DO I=1, NNODP(IPROC)
  3302: ||||                        INDX = IMAP_NOD_LG(I,IPROC)
  3303: ||||    G                   WVNXL(I) = WVNXG(INDX)
  3304: ||||    G                   WVNYL(I) = WVNYG(INDX)
  3305: ||||    G                   PRL(I) = PRG(INDX)
  3306: |||V---                  ENDDO
  3307: |||+--->                 DO I=1, NNODP(IPROC)
  3308: ||||                        WRITE(SDU(IPROC),1100)  I,WVNXL(I),WVNYL(I),PRL(I)
  3309: |||+---                  ENDDO
  3310: ||+----               ENDDO
  3311: ||        C--   If reached EOF in NWS4GET last time go close files and return
  3312: ||        C
  3313: ||                    IF (DONE) GOTO 9999
  3314: |+-----            ENDDO
  3315: |         
  3316: |         C        ------------
  3317: |                  CASE DEFAULT
  3318: |         C        ------------
  3319: |                  print *, "NWS=",NWS," has incorrect value in PREP22"
  3320: |                  RETURN
  3321: |         
  3322: |                  END SELECT
  3323: |         
  3324: |         C
  3325: |         C--Close Global file and all the Local Files
  3326: |         C
  3327: |          9999    CLOSE (22)
  3328: |+----->           DO IPROC=STARTPROC, ENDPROC
  3329: ||                    CLOSE (SDU(IPROC))
  3330: |+-----            ENDDO
  3331: |                  startProc=endProc+1
  3332: +------         ENDDO
  3333:           
  3334:           
  3335:                 DEALLOCATE ( NG,  WVNXG, WVNYG, PRG )
  3336:                 DEALLOCATE ( WVNXL, WVNYL, PRL )
  3337:                 nbytes = 52*mnwp
  3338:                 call memory_dealloc(nbytes)
  3339:                 call memory_status()
  3340:                 RETURN
  3341:             60  FORMAT(A60)
  3342:            170  FORMAT(A170)
  3343:            270  FORMAT(A270)
  3344:            1010 FORMAT(' File ',A60,/,' WAS NOT FOUND!  Try again',/)
  3345:            1011 FORMAT(' File ',A60,/,' WAS FOUND!  Opening & Processing file',/)
  3346:            1100 FORMAT(I8,3E13.5)
  3347:            1101 FORMAT(' #')
  3348:           c----------------------------------------------------------------------------
  3349:                 END SUBROUTINE PREP22


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP22
INLINE LIST

  ROOT: PREP22 (prep.F:3175)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3207)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3210)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3213)
     *** Source for routine not found.
  -> NOINLINE: NWS4GET (prep.F:3298)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:3338)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:3339)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP22
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:3217)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3217)

    LOOP BEGIN: (prep.F:3268)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:3268)

      LOOP BEGIN: (prep.F:3271)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3271)
      LOOP END

      LOOP BEGIN: (prep.F:3280)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3280)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3242)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:3242)

      LOOP BEGIN: (prep.F:3243)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3243)
        *** Unvectorizable loop structure. (prep.F:3243)
      LOOP END

      LOOP BEGIN: (prep.F:3245)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3246)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  3,  0. (prep.F:3246)
          *** The number of VLOAD, VSTORE. :  1,  3. (prep.F:3246)
          *** VGT generated (prep.F:3248)
          *** VGT generated (prep.F:3249)
          *** VGT generated (prep.F:3250)
        LOOP END

        LOOP BEGIN: (prep.F:3252)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3252)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3296)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3300)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3301)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  3,  0. (prep.F:3301)
          *** The number of VLOAD, VSTORE. :  1,  3. (prep.F:3301)
          *** VGT generated (prep.F:3303)
          *** VGT generated (prep.F:3304)
          *** VGT generated (prep.F:3305)
        LOOP END

        LOOP BEGIN: (prep.F:3307)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3307)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3328)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3328)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP22
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 54 [s0-s12 s15-s16 s18-s37 s45-s63]
      Vector registers         : 14 [v50-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3680 bytes
      Register spill area      :  616 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 2808 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3217)
    *** Estimated execution cycle                       : 254
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 35
            Over basic blocks                           : 35
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 40
            Over basic blocks                           : 40
    *** The number of SCALAR REGISTER TRANSFER          : 31

    LOOP BEGIN: (prep.F:3296)
      *** Estimated execution cycle                     : 94
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 12
              Across calls                              :  2
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 17
              Across calls                              :  2
              Over basic blocks                         : 14
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 27

      LOOP BEGIN: (prep.F:3300)
        *** Estimated execution cycle                   : 103
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER TRANSFER      : 25

        LOOP BEGIN: (prep.F:3301)
          *** Estimated execution cycle                 : 370
        LOOP END

        LOOP BEGIN: (prep.F:3307)
          *** Estimated execution cycle                 : 47
          *** The number of SCALAR REGISTER TRANSFER    : 10
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3268)
      *** Estimated execution cycle                     : 166
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Over basic blocks                         : 3
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Over basic blocks                         : 10
      *** The number of SCALAR REGISTER TRANSFER        : 43

      LOOP BEGIN: (prep.F:3280)
        *** Estimated execution cycle                   : 72
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 2
                Across calls                            : 2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 3
                Across calls                            : 2
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER TRANSFER      : 14
      LOOP END

      LOOP BEGIN: (prep.F:3271)
        *** Estimated execution cycle                   : 71
        *** The number of SCALAR REGISTER TRANSFER      : 14
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3242)
      *** Estimated execution cycle                     : 142
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 12
              Over basic blocks                         : 12
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 32
              Over basic blocks                         : 32
      *** The number of SCALAR REGISTER TRANSFER        : 30

      LOOP BEGIN: (prep.F:3243)
        *** Estimated execution cycle                   : 36
        *** The number of SCALAR REGISTER TRANSFER      : 9
      LOOP END

      LOOP BEGIN: (prep.F:3245)
        *** Estimated execution cycle                   : 107
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER TRANSFER      : 28

        LOOP BEGIN: (prep.F:3246)
          *** Estimated execution cycle                 : 370
        LOOP END

        LOOP BEGIN: (prep.F:3252)
          *** Estimated execution cycle                 : 47
          *** The number of SCALAR REGISTER TRANSFER    : 10
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3328)
      *** Estimated execution cycle                     : 15
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP23
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3394: vec( 108): Unvectorizable loop structure.
  3397: vec( 103): Unvectorized loop.
  3397: vec( 180): I/O statement obstructs vectorization.
  3398: opt(1118): This I/O statement inhibits optimization of loop.
  3407: vec( 103): Unvectorized loop.
  3407: vec( 180): I/O statement obstructs vectorization.
  3410: opt(1118): This I/O statement inhibits optimization of loop.
  3417: vec( 103): Unvectorized loop.
  3417: vec( 180): I/O statement obstructs vectorization.
  3418: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP23
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3354:                 SUBROUTINE PREP23()
  3355:                 USE PRE_GLOBAL
  3356:           C
  3357:           C---------------------------------------------------------------------------C
  3358:           C                           (  add MEB 03/04/03  )                          C
  3359:           C  This routine writes a Local Input file "fort.23" file for each subdomain C
  3360:           C  using the domain decomposition of the ADCIRC grid created by the routine C
  3361:           C  DECOMP.                                                                  C
  3362:           C                                                                           C
  3363:           C  The Decomposition Variables are defined in the include file adcprep.inc  C
  3364:           C  This version is compatible with ADCIRC version 34.03                     C
  3365:           C                                                                           C
  3366:           C---------------------------------------------------------------------------C
  3367:           C
  3368:                 IMPLICIT NONE
  3369:                 INTEGER IPROC, NHG, J, LINDEX
  3370:                 CHARACTER*80 PBLJAGF
  3371:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  3372:                 LOGICAL Success     ! .true. if all files open without error
  3373:                 REAL(8)                U,V
  3374:           C
  3375:           C--Open Global Wave Stress File ( UNIT 23 )
  3376:           C
  3377:           C     Open full domain and subdomain fort.23 files
  3378:                 CALL OpenPrepFiles(23, 'wave stress                   ',
  3379:                &     1, nproc, SDU, Success)
  3380:                 IF (.not.Success) THEN
  3381:                    WRITE(*,*) 'WARNING: Unit 23 files not preprocessed.'
  3382:                    RETURN ! note early return
  3383:                 ENDIF
  3384:           C--------------------------------------------------------------------------
  3385:           C--MAIN LOOP
  3386:           C   (1)  Read a record from Global Wave Stress File
  3387:           C   (2)  Use Decomp arrays to Localize record to a subdomain
  3388:           C   (3)  Write Local Wave Stress record in standard PBL format
  3389:           C--------------------------------------------------------------------------
  3390:           C
  3391:           C--Read a wave field record from the global input file
  3392:           C--and write out to respective local fort.23 file.
  3393:           C
  3394: +------>        DO WHILE(.TRUE.)
  3395: |         170      READ(23,'(A80)',END=9999) PBLJAGF
  3396: |                  IF(PBLJAGF(2:2).EQ.'#') THEN
  3397: |+----->              DO IPROC = 1,NPROC
  3398: ||                       WRITE(SDU(IPROC),1101)
  3399: ||                       WRITE(SDU(IPROC),1100) 1,0.0,0.0 !victor didn't like this line 27/11/03
  3400: |+-----               ENDDO
  3401: |                  ELSE
  3402: |         ! vjp 27/11/03
  3403: |         ! rewrote this section to handle ghost-nodes
  3404: |         ! and changed if test from "and" to "or"
  3405: |                     READ(PBLJAGF,'(I8,2E13.5)',END=9999) NHG,U,V
  3406: |                     IF ((U.NE.0.).OR.(V.NE.0.)) THEN
  3407: |+----->                 DO J=1, ITOTPROC(NHG)
  3408: ||                          IPROC  = IMAP_NOD_GL2(2*(J-1)+1,NHG)
  3409: ||                          LINDEX = IMAP_NOD_GL2(2*(J-1)+2,NHG)
  3410: ||                          WRITE(SDU(IPROC),1100) LINDEX,U,V
  3411: |+-----                  ENDDO
  3412: |                     ENDIF
  3413: |                  ENDIF
  3414: +------         ENDDO
  3415:           
  3416:            9999 CLOSE(23)
  3417: +------>        DO IPROC=1,NPROC
  3418: |                  CLOSE(SDU(IPROC))
  3419: +------         ENDDO
  3420:           
  3421:            1100 FORMAT(I8,2E13.5)
  3422:            1101 FORMAT (' #')
  3423:           
  3424:            99   RETURN
  3425:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP23
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP23
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:3394)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3394)

    LOOP BEGIN: (prep.F:3397)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3397)
    LOOP END

    LOOP BEGIN: (prep.F:3407)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3407)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:3417)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:3417)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP23
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 43 [s0-s12 s15-s16 s18-s41 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2672 bytes
      Register spill area      :  120 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 2296 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3394)
    *** Estimated execution cycle                       : 187
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 10
            Over basic blocks                           : 10
    *** The number of SCALAR REGISTER TRANSFER          : 48

    LOOP BEGIN: (prep.F:3407)
      *** Estimated execution cycle                     : 78
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 3
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Across calls                              : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END

    LOOP BEGIN: (prep.F:3397)
      *** Estimated execution cycle                     : 66
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:3417)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP24
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3474: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  3474: vec( 108): Unvectorizable loop structure.
  3491: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  3504: opt(3014): Moved reference within a conditional branch.
  3513: vec( 103): Unvectorized loop.
  3513: vec( 180): I/O statement obstructs vectorization.
  3514: opt(1118): This I/O statement inhibits optimization of loop.
  3521: vec( 103): Unvectorized loop.
  3521: vec( 180): I/O statement obstructs vectorization.
  3522: opt(1118): This I/O statement inhibits optimization of loop.
  3527: vec( 103): Unvectorized loop.
  3527: vec( 180): I/O statement obstructs vectorization.
  3529: opt(1118): This I/O statement inhibits optimization of loop.
  3537: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  3541: vec( 103): Unvectorized loop.
  3541: vec( 180): I/O statement obstructs vectorization.
  3542: opt(1118): This I/O statement inhibits optimization of loop.
  3547: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP24
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3437:                 SUBROUTINE PREP24()
  3438:           C---------------------------------------------------------------------------
  3439:                 USE PRE_GLOBAL
  3440:                 use memory_usage
  3441:                 IMPLICIT NONE
  3442:           C
  3443:                 integer(8) :: nbytes = 0
  3444:                 INTEGER i              ! node loop counter
  3445:                 INTEGER k              ! constituent loop counter
  3446:                 INTEGER ll             ! line loop counter
  3447:                 INTEGER iproc          ! subdomain loop counter
  3448:                 INTEGER sdu(nproc)     ! subdomain unit number for unit 24 files
  3449:                 INTEGER NoOfVals       ! NoOfVals for each constituent (always 1)
  3450:                 CHARACTER(len=80) header   ! header comments in unit 24 files
  3451:                 CHARACTER(len=80) ConstName ! label for constituent
  3452:                 LOGICAL success        ! .true. if all files opened successfully
  3453:                 LOGICAL netcdf_file_exists
  3454:                 REAL(8), ALLOCATABLE :: SALTAMP(:), SALTPHS(:)
  3455:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
  3456:           C     time ... some platforms/compilers limit the number of files that
  3457:           C     can be open at any one time.
  3458:                 INTEGER, PARAMETER :: maxOpenFiles = 256
  3459:                 INTEGER startProc
  3460:                 INTEGER endProc
  3461:                 INTEGER deltaProc
  3462:                 REAL(8) Frequency    ! Frequency of constituent
  3463:           
  3464:           
  3465:                 !...Check if we'll be using netcdf or ascii
  3466:                 inquire(file="fort.24.nc",exist=netcdf_file_exists)
  3467:                 if(netcdf_file_exists)then
  3468:                     return
  3469:                 endif
  3470:           
  3471:           C
  3472:           C     Perform decomposition over range of subdomains.
  3473:                 startProc = 1
  3474: +------>        DO WHILE ( startProc .lt. nproc )
  3475: |                  deltaProc = nproc - startProc
  3476: |                  IF ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
  3477: |                  endProc = startProc + deltaProc
  3478: |         C
  3479: |         C        Open full domain and subdomain fort.24 files.
  3480: |                  CALL OpenPrepFiles(24, 'self-attraction and loading   ',
  3481: |              &       startProc, endProc, sdu, success)
  3482: |         C
  3483: |                  IF (.not.success) THEN
  3484: |                     WRITE(*,*) 'WARNING: Unit 24 files not preprocessed.'
  3485: |                     RETURN ! note early return
  3486: |                  ENDIF
  3487: |         C
  3488: |         C        Allocate the global SAL amp and phases
  3489: |                  ALLOCATE(SALTAMP(NNODG),SALTPHS(NNODG))
  3490: |                  nbytes = 16*NNODG
  3491: |                  call memory_alloc(nbytes)
  3492: |         
  3493: |         C        Read info from fort.24 and write to subdomains
  3494: |         C        Loop over the number of constituents
  3495: |+----->           DO k=1, NTIF
  3496: ||        
  3497: ||        C           Read header information from full domain unit 24 file
  3498: ||                    READ(24,'(A80)') header
  3499: ||                    READ(24,*) Frequency
  3500: ||                    READ(24,*) NoOfVals
  3501: ||                    READ(24,'(A80)') ConstName
  3502: ||                    IF (ConstName(1:2) .ne. TIPOTAG(k)(1:2)) THEN
  3503: ||                        WRITE(6,*) 'CONST 24 =',ConstName,'CONST 15=',TIPOTAG(K)
  3504: ||                        WRITE(6,9924)
  3505: ||         9924           FORMAT(////,1X,'!!!!!!!!!!  FATAL ERROR  !!!!!!!!!',
  3506: ||             &          //,1X,'CONSTITUENT NAME AS ABOVE NOT RECOGNISED      '
  3507: ||             &          //,1X,'OR IN THE CORRECT ORDER.                      ',
  3508: ||             &          //,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
  3509: ||                        CALL EXIT(1)                   ! We're toast
  3510: ||                    ENDIF
  3511: ||        C
  3512: ||        C           Write header info to the local unit 24
  3513: ||+---->              DO iproc=startProc, endProc
  3514: |||                      WRITE(sdu(IPROC),'(A80)') header
  3515: |||                      WRITE(sdu(IPROC),*) Frequency
  3516: |||                      WRITE(sdu(IPROC),*) NoOfVals
  3517: |||                      WRITE(sdu(IPROC),'(A80)') ConstName
  3518: ||+----               END DO
  3519: ||        
  3520: ||        C           Read the amp and phase of the unit 24 file
  3521: ||+---->              DO i = 1,NNODG
  3522: |||                      READ(24,*) ll,SALTAMP(ll),SALTPHS(ll)
  3523: ||+----               ENDDO
  3524: ||        C
  3525: ||        C           Write out the info to the local unit 24
  3526: ||+---->              DO iproc=startProc, endProc
  3527: |||+--->                 DO i = 1,NNODP(IPROC)
  3528: ||||                        ll = IMAP_NOD_LG(i,IPROC)
  3529: ||||                        WRITE(sdu(IPROC),*) LABELS(ll),SALTAMP(ll),SALTPHS(ll)
  3530: |||+---                  ENDDO
  3531: ||+----               END DO
  3532: ||        
  3533: |+-----            END DO
  3534: |         C
  3535: |         C        Deallocate the arrays
  3536: |                  DEALLOCATE(SALTAMP,SALTPHS)
  3537: |                  call memory_dealloc(nbytes)
  3538: |         C
  3539: |         C        Close full domain and subdomain files
  3540: |                  CLOSE (24)
  3541: |+----->           DO iproc=startProc, endProc
  3542: ||                    CLOSE(sdu(iproc))
  3543: |+-----            ENDDO
  3544: |                  startProc = endProc + 1
  3545: +------         END DO
  3546:           C
  3547:                 call memory_status()
  3548:                 RETURN
  3549:           C---------------------------------------------------------------------------
  3550:                 END SUBROUTINE PREP24


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP24
INLINE LIST

  ROOT: PREP24 (prep.F:3437)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3491)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:3537)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:3547)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP24
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:3474)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3474)

    LOOP BEGIN: (prep.F:3495)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3513)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3513)
      LOOP END

      LOOP BEGIN: (prep.F:3521)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3521)
      LOOP END

      LOOP BEGIN: (prep.F:3526)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3527)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3527)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3541)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3541)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:26 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP24
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 56 [s0-s12 s15-s16 s18-s44 s50-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2896 bytes
      Register spill area      :  688 bytes
      Parameter area           :  104 bytes
      Register save area       :  176 bytes
      User data area           : 1920 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3437)
    *** Estimated execution cycle                       : 404
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 46
            Across calls                                :  1
            Over basic blocks                           : 40
            Others                                      :  5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 55
            Across calls                                :  1
            Over basic blocks                           : 54
    *** The number of SCALAR REGISTER TRANSFER          : 46

    LOOP BEGIN: (prep.F:3495)
      *** Estimated execution cycle                     : 504
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 51
              Across calls                              : 15
              Over basic blocks                         : 33
              Others                                    :  3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 82
              Across calls                              : 20
              Over basic blocks                         : 61
              Others                                    :  1
      *** The number of SCALAR REGISTER TRANSFER        : 72

      LOOP BEGIN: (prep.F:3513)
        *** Estimated execution cycle                   : 180
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 12
                Across calls                            : 12
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 23
                Across calls                            : 16
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 27
      LOOP END

      LOOP BEGIN: (prep.F:3521)
        *** Estimated execution cycle                   : 82
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Across calls                            : 6
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 12
                Across calls                            :  7
                Over basic blocks                       :  5
        *** The number of SCALAR REGISTER TRANSFER      : 13
      LOOP END

      LOOP BEGIN: (prep.F:3526)
        *** Estimated execution cycle                   : 24
        *** The number of SCALAR REGISTER TRANSFER      : 7

        LOOP BEGIN: (prep.F:3527)
          *** Estimated execution cycle                 : 67
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 3
                  Across calls                          : 3
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 3
                  Across calls                          : 3
          *** The number of SCALAR REGISTER TRANSFER    : 7
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3541)
      *** Estimated execution cycle                     : 17
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 1
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP5354
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3629: vec( 108): Unvectorizable loop structure.
  3652: vec( 103): Unvectorized loop.
  3652: vec( 180): I/O statement obstructs vectorization.
  3653: opt(1118): This I/O statement inhibits optimization of loop.
  3661: vec( 180): I/O statement obstructs vectorization.
  3661: vec( 181): Allocation obstructs vectorization.
  3661: vec( 182): Deallocation obstructs vectorization.
  3662: opt(1082): Backward transfers inhibit loop optimization.
  3662: opt(1118): This I/O statement inhibits optimization of loop.
  3662: vec( 103): Unvectorized loop.
  3662: vec( 108): Unvectorizable loop structure.
  3670: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  3671: vec( 101): Vectorized loop.
  3672: opt(1418): Constant-length loop is expanded.
  3680: inl(1222): Inlined: PROCESS5354
  3686: vec( 103): Unvectorized loop.
  3686: vec( 180): I/O statement obstructs vectorization.
  3687: opt(1118): This I/O statement inhibits optimization of loop.
  3692: inl(1222): Inlined: PROCESS5354
  3697: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  3701: vec( 103): Unvectorized loop.
  3701: vec( 180): I/O statement obstructs vectorization.
  3702: opt(1118): This I/O statement inhibits optimization of loop.
  3707: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP5354
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3565:                 SUBROUTINE PREP5354( FUNIT )
  3566:           C---------------------------------------------------------------------------
  3567:                 USE PRE_GLOBAL
  3568:                 use memory_usage
  3569:                 IMPLICIT NONE
  3570:           C
  3571:                 INTEGER:: FUNIT
  3572:                 INTEGER:: NCOMP
  3573:           
  3574:                 integer(8) :: nbytes = 0
  3575:                 INTEGER i                 ! node loop counter
  3576:                 INTEGER k                 ! attribute loop counter
  3577:                 INTEGER ll                ! line loop counter
  3578:                 INTEGER m                 ! attribute default value counter
  3579:                 INTEGER iproc             ! subdomain loop counter
  3580:                 INTEGER sdu(nproc)        ! subdomain unit number for unit 13 files
  3581:                 INTEGER NumOfNodes        ! must match the no. of nodes in grid (unit 14)
  3582:                 INTEGER NAttr             ! number of nodal attributes in the file
  3583:                 INTEGER NumNotDefault     ! number of nodes specified in the file
  3584:           
  3585:           C      CHARACTER(len=80) header  ! header comments in unit 13 files
  3586:           C      CHARACTER(len=80) AttrName ! label for attribute
  3587:           C      CHARACTER(len=80) Units   ! label for physical units
  3588:           
  3589:                 CHARACTER(len=80) Skipped ! data we want to skip over
  3590:                 REAL(8) DefaultVal(12)   ! default value of attribute
  3591:                 INTEGER NoOfVals          ! at each node for an attribute
  3592:                 INTEGER Mode              !=0 to count, =1 to write
  3593:                 LOGICAL success           ! .true. if all files opened successfully
  3594:                 INTEGER, ALLOCATABLE :: SDNumND(:,:) ! subdomain # of nodes not default
  3595:           
  3596:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
  3597:           C     time ... some platforms/compilers limit the number of files that
  3598:           C     can be open at any one time.
  3599:                 INTEGER, PARAMETER :: maxOpenFiles = 256
  3600:                 INTEGER startProc
  3601:                 INTEGER endProc
  3602:                 INTEGER deltaProc
  3603:            
  3604:                 INTEGER:: NBF
  3605:                 REAL(8), dimension(32):: AMIGv, FFv, FACEv ! Maximum 32 Consituent
  3606:                 CHARACTER (LEN=300):: IGNOREMSG
  3607:            
  3608:                 INTEGER:: KK
  3609:           
  3610:                 TYPE CARR
  3611:                    CHARACTER (LEN=32):: NAME
  3612:                 END TYPE CARR
  3613:                 TYPE (CARR):: CONSTINAME(maxOpenFiles)
  3614:           
  3615:           
  3616:                 SELECT CASE( FUNIT )
  3617:                 CASE (53001)
  3618:                    NCOMP = 2 ;
  3619:                 CASE (54001)
  3620:                    NCOMP = 4 ;
  3621:                 CASE DEFAULT
  3622:                    PRINT*, "Error in PREP5354(): ", FUNIT, " is not allowed." ;
  3623:                    CALL EXIT(1) ;
  3624:                 END SELECT
  3625:           C
  3626:           C
  3627:           C     Perform decomposition over range of subdomains.
  3628:                 startProc = 1
  3629: +------>        DO WHILE ( startProc .lt. nproc )
  3630: |                  deltaProc = nproc - startProc
  3631: |                  IF ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
  3632: |                  endProc = startProc + deltaProc
  3633: |         
  3634: |         C
  3635: |         C     Open full domain and subdomain fort.13 files.
  3636: |                 CALL OpenPrepFiles( FUNIT, 'harmonic forcing in sponge layer',
  3637: |              &        startProc, endProc, sdu, success)
  3638: |         C
  3639: |                  IF (.not.success) THEN
  3640: |                     WRITE(*,'(A,I5,A)') 'WARNING: Unit ', FUNIT,
  3641: |              &                                    'files not preprocessed.' ;
  3642: |                     RETURN              ! note early return
  3643: |                  ENDIF
  3644: |         C
  3645: |         C     Read header information from full domain unit 13 file
  3646: |         C
  3647: |                  READ(FUNIT,*) NBF
  3648: |                  IF ( NBF > 32 ) THEN
  3649: |                     PRINT*, "Error in PREP5354(): ", NBF, " is greater 32" ;
  3650: |                  END IF
  3651: |         
  3652: |+----->           DO KK = 1, NBF
  3653: ||                    READ(FUNIT,*) AMIGv(KK), FFv(KK),
  3654: ||             &           FACEv(KK), CONSTINAME(KK)%NAME
  3655: |+-----            END DO
  3656: |         
  3657: |         C     Transcribe header information into subdomain unit 13 files
  3658: |         
  3659: |+----->           DO iproc = startProc, endProc
  3660: ||                    WRITE(sdu(iproc),*) NBF
  3661: ||+---->              DO KK = 1, NBF
  3662: |||                       WRITE(sdu(iproc),'(3E15.8,A)') AMIGv(KK), FFv(KK),
  3663: |||            &                     FACEv(KK), ' '//TRIM(CONSTINAME(KK)%NAME) ;
  3664: ||+----               END DO
  3665: |+-----            ENDDO
  3666: |         
  3667: |                  NAttr = 1 ;
  3668: |                  ALLOCATE(SDNumND(nproc,NAttr))
  3669: |                  nbytes = 8*nproc*NAttr ;
  3670: |                  call memory_alloc(nbytes)
  3671: |V----->           DO iproc=startProc,endProc
  3672: ||*---->              DO k=1, NAttr
  3673: |||                      SDNumND(iproc,k)=0
  3674: ||*----               END DO
  3675: |V-----            END DO
  3676: |         
  3677: |         C     We need to figure out how many nodes go into each subdomain
  3678: |         C     for each attribute.
  3679: |         
  3680: |       I          CALL process5354( FUNIT, NBF, NCOMP, 0, sdu,
  3681: |              &        SDNumND, startProc, endProc )
  3682: |         C
  3683: |         C     Now rewind and advance to the beginning of the data again
  3684: |         
  3685: |                  REWIND(FUNIT)
  3686: |+----->           DO ll=1, NBF + 1
  3687: ||                    READ(FUNIT,*) skipped ! skip NBF + 1 lines (NBF, AMIG, ...)
  3688: |+-----            END DO
  3689: |         C
  3690: |         C     Now read each of the nodal attributes and transcribe them to the
  3691: |         C     appropriate subdomain.
  3692: |       I          CALL process5354( FUNIT, NBF, NCOMP, 1, sdu,
  3693: |              &        SDNumND, startProc, endProc)
  3694: |         
  3695: |                  DEALLOCATE(SDNumND)
  3696: |                  nbytes = 8*nproc*nattr ;
  3697: |                  call memory_dealloc(nbytes)
  3698: |         C
  3699: |         C     Close full domain and subdomain files
  3700: |                  CLOSE (FUNIT)
  3701: |+----->           DO iproc=startProc, endProc
  3702: ||                    CLOSE(sdu(iproc))
  3703: |+-----            ENDDO
  3704: |                  startProc = endProc + 1 ;
  3705: +------         END DO
  3706:           
  3707:                 call memory_status()
  3708:                 RETURN ;
  3709:           
  3710:                 END SUBROUTINE PREP5354


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP5354
INLINE LIST

  ROOT: PREP5354 (prep.F:3565)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3670)
     *** Source for routine not found.
  -> INLINE: PROCESS5354 (prep.F:3680)
  -> INLINE: PROCESS5354 (prep.F:3692)
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:3697)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:3707)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP5354
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:3629)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3629)

    LOOP BEGIN: (prep.F:3652)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3652)
    LOOP END

    LOOP BEGIN: (prep.F:3659)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3661)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3661)
        *** Allocation obstructs vectorization. (prep.F:3661)
        *** Deallocation obstructs vectorization. (prep.F:3661)

        LOOP BEGIN: (prep.F:3662)
          <Unvectorized loop.>
          *** Unvectorizable loop structure. (prep.F:3662)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3671)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:3671)
      *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:3671)
    LOOP END

    LOOP BEGIN: (prep.F:3744)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3754)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3757)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3757)

          LOOP BEGIN: (prep.F:3758)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:3758)
            *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:3758)
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          <Unvectorized loop.>
          **  Copied loop. : FOR UNROLLING (prep.F:3786)
          *** Overhead of loop division is too large. (prep.F:3786)

          LOOP BEGIN: (prep.F:3789)
            <Vectorized loop.>
            **  Copied loop. : FOR UNROLLING (prep.F:3789)
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:3789)
            *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:3789)
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          <Unvectorized loop.>
          **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:3786)
          *** Overhead of loop division is too large. (prep.F:3786)

          LOOP BEGIN: (prep.F:3789)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:3789)
            *** The number of VLOAD, VSTORE. :  4,  4. (prep.F:3789)
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3686)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3686)
    LOOP END

    LOOP BEGIN: (prep.F:3744)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3749)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3749)
      LOOP END

      LOOP BEGIN: (prep.F:3754)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3757)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3757)

          LOOP BEGIN: (prep.F:3758)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:3758)
            *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:3758)
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          <Unvectorized loop.>

          LOOP BEGIN: (prep.F:3789)
            <Unvectorized loop.>

            LOOP BEGIN: (prep.F:3798)
              <Unvectorized loop.>

              LOOP BEGIN: (prep.F:3799)
                <Unvectorized loop.>
                *** I/O statement obstructs vectorization. (prep.F:3799)
              LOOP END
            LOOP END
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3779)
          <Unvectorized loop.>

          LOOP BEGIN: (prep.F:3780)
            <Unvectorized loop.>
            *** I/O statement obstructs vectorization. (prep.F:3780)
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3701)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3701)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP5354
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 60 [s0-s12 s15-s16 s18-s44 s46-s63]
      Vector registers         : 23 [v41-v63]
      Vector mask registers    :  1 [vm15]
      VREG directive           :  0

  Routine stack
    Total size                 : 23024 bytes
      Register spill area      :  5264 bytes
      Parameter area           :    72 bytes
      Register save area       :   176 bytes
      User data area           : 17504 bytes
      Others                   :     8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3565)
    *** Estimated execution cycle                       : 680
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 77
            Across calls                                :  6
            Over basic blocks                           : 61
            Others                                      : 10
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 80
            Across calls                                :  7
            Over basic blocks                           : 73
    *** The number of SCALAR REGISTER TRANSFER          : 61

    LOOP BEGIN: (prep.F:3652)
      *** Estimated execution cycle                     : 78
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              : 11
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END

    LOOP BEGIN: (prep.F:3659)
      *** Estimated execution cycle                     : 67
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 2
              Others                                    : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 13
              Across calls                              :  5
              Over basic blocks                         :  8
      *** The number of SCALAR REGISTER TRANSFER        : 11

      LOOP BEGIN: (prep.F:3661)
        *** Estimated execution cycle                   : 195
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 18
                Across calls                            : 16
                Over basic blocks                       :  2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 39
                Across calls                            : 25
                Over basic blocks                       : 12
                Others                                  :  2
        *** The number of SCALAR REGISTER TRANSFER      : 18

        LOOP BEGIN: (prep.F:3662)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3671)
      *** Estimated execution cycle                     : 63
    LOOP END

    LOOP BEGIN: (prep.F:3744)
      *** Estimated execution cycle                     : 142
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 26
              Across calls                              :  2
              Over basic blocks                         : 24
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 23
              Across calls                              :  2
              Over basic blocks                         : 21
      *** The number of SCALAR REGISTER TRANSFER        : 12

      LOOP BEGIN: (prep.F:3754)
        *** Estimated execution cycle                   : 222
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 14
                Across calls                            :  3
                Over basic blocks                       : 11
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 33
                Across calls                            :  3
                Over basic blocks                       : 30
        *** The number of SCALAR REGISTER TRANSFER      : 33

        LOOP BEGIN: (prep.F:3757)
          *** Estimated execution cycle                 : 90
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 1
                  Across calls                          : 1
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 2
                  Across calls                          : 1
                  Over basic blocks                     : 1
          *** The number of SCALAR REGISTER TRANSFER    : 8

          LOOP BEGIN: (prep.F:3758)
            *** Estimated execution cycle               : 63
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          *** Estimated execution cycle                 : 68
          *** The number of SCALAR REGISTER TRANSFER    : 3

          LOOP BEGIN: (prep.F:3789)
            *** Estimated execution cycle               : 166
            *** The number of VECTOR REGISTER RESTORE
                  Total                                 : 1
                    Over basic blocks                   : 1
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          *** Estimated execution cycle                 : 169
          *** The number of SCALAR REGISTER TRANSFER    : 8

          LOOP BEGIN: (prep.F:3789)
            *** Estimated execution cycle               : 455
            *** The number of VECTOR REGISTER RESTORE
                  Total                                 : 1
                    Over basic blocks                   : 1
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3686)
      *** Estimated execution cycle                     : 38
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Across calls                              : 2
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:3744)
      *** Estimated execution cycle                     : 167
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 17
              Across calls                              :  5
              Over basic blocks                         : 12
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 32
              Across calls                              :  7
              Over basic blocks                         : 25
      *** The number of SCALAR REGISTER TRANSFER        : 20

      LOOP BEGIN: (prep.F:3749)
        *** Estimated execution cycle                   : 59
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 5
                Across calls                            : 4
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 10
                Across calls                            :  7
                Over basic blocks                       :  3
        *** The number of SCALAR REGISTER TRANSFER      : 7
      LOOP END

      LOOP BEGIN: (prep.F:3754)
        *** Estimated execution cycle                   : 321
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 37
                Across calls                            :  5
                Over basic blocks                       : 30
                Others                                  :  2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 65
                Across calls                            :  7
                Over basic blocks                       : 58
        *** The number of SCALAR REGISTER TRANSFER      : 32

        LOOP BEGIN: (prep.F:3757)
          *** Estimated execution cycle                 : 95
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 2
                  Across calls                          : 2
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 4
                  Across calls                          : 2
                  Over basic blocks                     : 2
          *** The number of SCALAR REGISTER TRANSFER    : 9

          LOOP BEGIN: (prep.F:3758)
            *** Estimated execution cycle               : 63
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3786)
          *** Estimated execution cycle                 : 66
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 8
                  Over basic blocks                     : 8
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 8
                  Over basic blocks                     : 8
          *** The number of SCALAR REGISTER TRANSFER    : 8

          LOOP BEGIN: (prep.F:3789)
            *** Estimated execution cycle               : 92
            *** The number of SCALAR REGISTER SPILL
                  Total                                 : 11
                    Across calls                        :  4
                    Over basic blocks                   :  7
            *** The number of SCALAR REGISTER RESTORE
                  Total                                 : 15
                    Across calls                        :  7
                    Over basic blocks                   :  8
            *** The number of SCALAR REGISTER TRANSFER  : 12

            LOOP BEGIN: (prep.F:3798)
              *** Estimated execution cycle             : 36
              *** The number of SCALAR REGISTER TRANSFER : 15

              LOOP BEGIN: (prep.F:3799)
                *** Estimated execution cycle           : 9
                *** The number of SCALAR REGISTER TRANSFER : 2
              LOOP END
            LOOP END
          LOOP END
        LOOP END

        LOOP BEGIN: (prep.F:3779)
          *** Estimated execution cycle                 : 53
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 5
                  Across calls                          : 1
                  Over basic blocks                     : 4
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 7
                  Across calls                          : 1
                  Over basic blocks                     : 6
          *** The number of SCALAR REGISTER TRANSFER    : 9

          LOOP BEGIN: (prep.F:3780)
            *** Estimated execution cycle               : 9
            *** The number of SCALAR REGISTER TRANSFER  : 2
          LOOP END
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3701)
      *** Estimated execution cycle                     : 15
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESS5354
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3749: vec( 103): Unvectorized loop.
  3749: vec( 180): I/O statement obstructs vectorization.
  3750: opt(1118): This I/O statement inhibits optimization of loop.
  3757: vec( 180): I/O statement obstructs vectorization.
  3758: opt(1118): This I/O statement inhibits optimization of loop.
  3758: vec( 101): Vectorized loop.
  3780: opt(1118): This I/O statement inhibits optimization of loop.
  3780: vec( 103): Unvectorized loop.
  3780: vec( 180): I/O statement obstructs vectorization.
  3799: opt(1118): This I/O statement inhibits optimization of loop.
  3799: vec( 103): Unvectorized loop.
  3799: vec( 180): I/O statement obstructs vectorization.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESS5354
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3713:                 SUBROUTINE Process5354( FUNIT, NBF, ncmp, mode, sdu, SDNumND,
  3714:                &     startProc, endProc)
  3715:           
  3716:                 USE PRE_GLOBAL
  3717:                 IMPLICIT NONE
  3718:           C
  3719:                 INTEGER,intent(in) :: FUNIT, NBF, ncmp ! number of attributes in the file
  3720:            
  3721:           
  3722:                 INTEGER,intent(in) :: Mode !=0 to count and return, =1 to write
  3723:                 INTEGER,intent(in),dimension(nproc) :: sdu !i/o unit number array
  3724:                 INTEGER,intent(inout),dimension(nproc,1) :: SDNumND
  3725:                 INTEGER,intent(in) :: startProc
  3726:                 INTEGER,intent(in) :: endProc
  3727:                 INTEGER NumNotDefault     ! number of nodes specified in the file
  3728:                 INTEGER NumCol            ! number of values per node for an attr
  3729:                 INTEGER NodeNum           ! full domain node number
  3730:                 INTEGER SDNode            ! subdomain node number
  3731:                 INTEGER i                 ! node loop counter
  3732:                 INTEGER j                 ! column loop counter
  3733:                 INTEGER k                 ! attribute loop counter
  3734:                 INTEGER m                 ! mapping loop counter
  3735:                 INTEGER iproc             ! subdomain loop counter
  3736:                 INTEGER iproc2              ! mapped subdomain
  3737:                 REAL(8):: AttrData(NBF, 4) ! attribute data
  3738:                 CHARACTER(len=80) Skipped   ! data we want to skip over
  3739:           C
  3740:                 CHARACTER (len=80):: FMT
  3741:                 INTEGER:: ifreq, NAttr
  3742:            
  3743:                 NAttr = 1 ;
  3744: +------>        DO k=1, NAttr
  3745: |          
  3746: |                  READ(FUNIT,*) NumNotDefault
  3747: |          
  3748: |                  IF (Mode.eq.1) THEN
  3749: |+----->              DO iproc=startProc,endProc
  3750: ||                       WRITE(sdu(iproc),*) SDNumND(iproc,k)
  3751: |+-----               END DO
  3752: |                  ENDIF
  3753: |         
  3754: |+----->           DO i=1, NumNotDefault
  3755: ||                    !
  3756: ||                    READ(FUNIT,'(I10)') NodeNum
  3757: ||+---->              DO ifreq = 1, NBF
  3758: |||V===>                 READ(FUNIT,*) AttrData(ifreq,1:ncmp) ;
  3759: ||+----               END DO
  3760: ||                    !
  3761: ||        
  3762: ||                    IF (ITOTPROC(NodeNum).eq.1) THEN
  3763: ||                       !
  3764: ||                       iproc = IMAP_NOD_GL(1,NodeNum)
  3765: ||                       IF ( (iproc.lt.startProc) .or. (iproc.gt.endProc) ) THEN
  3766: ||        
  3767: ||                          CYCLE         ! skip it if it does not map to our range of procs
  3768: ||                       ENDIF
  3769: ||        
  3770: ||                       IF (Mode.eq.0) THEN
  3771: ||                           SDNumND(iproc,k) = SDNumND(iproc,k)+1 ;
  3772: ||                           !
  3773: ||                       END IF
  3774: ||        
  3775: ||                       IF (Mode.eq.1) THEN
  3776: ||                          SDNode = IMAP_NOD_GL(2,NodeNum)
  3777: ||                          !
  3778: ||                          WRITE(sdu(iproc),*) SDNode ;
  3779: ||+---->                    DO ifreq = 1, NBF
  3780: |||+--->                       WRITE(sdu(iproc),1101) (AttrData(ifreq,j),j=1,ncmp)
  3781: ||+----                     END DO
  3782: ||                       ENDIF
  3783: ||                       !
  3784: ||                    ELSE
  3785: ||                       !
  3786: ||+---->                 DO m=1, ITOTPROC(NodeNum)
  3787: |||                         iproc2 = IMAP_NOD_GL2(2*(m-1)+1,NodeNum)
  3788: |||       
  3789: |||+--->                    DO iproc=startProc, endProc
  3790: ||||                           IF (iproc.EQ.iproc2) THEN !f.d. node maps to this s.d.
  3791: ||||                              IF (Mode.eq.0) THEN
  3792: ||||                                 SDNumND(iproc,k)=SDNumND(iproc,k)+1 ;
  3793: ||||                              ENDIF
  3794: ||||                              IF (Mode.eq.1) THEN
  3795: ||||                                 SDNode = IMAP_NOD_GL2(2*(m-1)+2,NodeNum) ;
  3796: ||||      
  3797: ||||                                 WRITE(sdu(iproc),*) SDNode ;
  3798: ||||+-->                             DO ifreq = 1, NBF
  3799: |||||+->                               WRITE(sdu(iproc),1101) (AttrData(ifreq,j),j=1,ncmp)
  3800: ||||+--                              END DO
  3801: ||||                              ENDIF
  3802: ||||                           ENDIF
  3803: |||+---                     END DO
  3804: ||+----                  END DO
  3805: ||                       !
  3806: ||                    END IF
  3807: |+-----            END DO
  3808: |         
  3809: |                  IF (Mode.eq.1) THEN
  3810: |                     WRITE(6,*) 'for processor range ',startProc,' to ',endProc
  3811: |                  ENDIF
  3812: +------         END DO
  3813:           C
  3814:            1101 FORMAT(32000(E16.8))
  3815:           C
  3816:                 RETURN
  3817:           C---------------------------------------------------------------------------
  3818:                 END SUBROUTINE Process5354


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESS5354
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESS5354
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:3744)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:3749)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3749)
    LOOP END

    LOOP BEGIN: (prep.F:3754)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:3757)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3757)

        LOOP BEGIN: (prep.F:3758)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:3758)
          *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:3758)
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:3786)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3789)
          <Unvectorized loop.>

          LOOP BEGIN: (prep.F:3798)
            <Unvectorized loop.>

            LOOP BEGIN: (prep.F:3799)
              <Unvectorized loop.>
              *** I/O statement obstructs vectorization. (prep.F:3799)
            LOOP END
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:3779)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3780)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3780)
        LOOP END
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PROCESS5354
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 51 [s0-s12 s15-s16 s18-s43 s54-s63]
      Vector registers         :  1 [v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2192 bytes
      Register spill area      :  440 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1512 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3744)
    *** Estimated execution cycle                       : 195
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 18
            Over basic blocks                           : 18
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 22
            Over basic blocks                           : 22
    *** The number of SCALAR REGISTER TRANSFER          : 39

    LOOP BEGIN: (prep.F:3749)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Across calls                              : 2
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:3754)
      *** Estimated execution cycle                     : 350
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 41
              Across calls                              :  6
              Over basic blocks                         : 32
              Others                                    :  3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 66
              Across calls                              :  6
              Over basic blocks                         : 60
      *** The number of SCALAR REGISTER TRANSFER        : 37

      LOOP BEGIN: (prep.F:3757)
        *** Estimated execution cycle                   : 101
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 3
                Across calls                            : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 6
                Across calls                            : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER TRANSFER      : 9

        LOOP BEGIN: (prep.F:3758)
          *** Estimated execution cycle                 : 63
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:3786)
        *** Estimated execution cycle                   : 58
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Over basic blocks                       : 6
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 6
                Over basic blocks                       : 6
        *** The number of SCALAR REGISTER TRANSFER      : 8

        LOOP BEGIN: (prep.F:3789)
          *** Estimated execution cycle                 : 120
          *** The number of SCALAR REGISTER SPILL
                Total                                   : 14
                  Across calls                          :  6
                  Over basic blocks                     :  8
          *** The number of SCALAR REGISTER RESTORE
                Total                                   : 20
                  Across calls                          :  9
                  Over basic blocks                     : 11
          *** The number of SCALAR REGISTER TRANSFER    : 14

          LOOP BEGIN: (prep.F:3798)
            *** Estimated execution cycle               : 50
            *** The number of SCALAR REGISTER SPILL
                  Total                                 : 1
                    Across calls                        : 1
            *** The number of SCALAR REGISTER RESTORE
                  Total                                 : 1
                    Across calls                        : 1
            *** The number of SCALAR REGISTER TRANSFER  : 25

            LOOP BEGIN: (prep.F:3799)
              *** Estimated execution cycle             : 9
              *** The number of SCALAR REGISTER TRANSFER : 2
            LOOP END
          LOOP END
        LOOP END
      LOOP END

      LOOP BEGIN: (prep.F:3779)
        *** Estimated execution cycle                   : 60
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Across calls                            : 3
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 7
                Across calls                            : 3
                Over basic blocks                       : 4
        *** The number of SCALAR REGISTER TRANSFER      : 18

        LOOP BEGIN: (prep.F:3780)
          *** Estimated execution cycle                 : 9
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP141
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  3866: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  3876: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  3876: vec( 108): Unvectorizable loop structure.
  3901: vec( 108): Unvectorizable loop structure.
  3902: opt(1118): This I/O statement inhibits optimization of loop.
  3902: vec( 103): Unvectorized loop.
  3902: vec( 180): I/O statement obstructs vectorization.
  3902: vec( 108): Unvectorizable loop structure.
  3905: vec( 101): Vectorized loop.
  3909: vec( 103): Unvectorized loop.
  3909: vec( 180): I/O statement obstructs vectorization.
  3910: opt(1118): This I/O statement inhibits optimization of loop.
  3930: vec( 108): Unvectorizable loop structure.
  3934: vec( 103): Unvectorized loop.
  3934: vec( 180): I/O statement obstructs vectorization.
  3935: opt(1118): This I/O statement inhibits optimization of loop.
  3942: vec( 103): Unvectorized loop.
  3942: vec( 180): I/O statement obstructs vectorization.
  3947: opt(1118): This I/O statement inhibits optimization of loop.
  3947: opt(3014): Moved reference within a conditional branch.
  3966: vec( 103): Unvectorized loop.
  3966: vec( 180): I/O statement obstructs vectorization.
  3967: opt(1118): This I/O statement inhibits optimization of loop.
  3978: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  3979: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP141
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  3839:                 SUBROUTINE PREP141()
  3840:           C---------------------------------------------------------------------------
  3841:                 USE PRE_GLOBAL
  3842:                 use memory_usage
  3843:                 IMPLICIT NONE
  3844:                 integer(8) :: nbytes = 0
  3845:                 LOGICAL FOUND,DONE
  3846:                 INTEGER I,J,IPROC,IPROC2,ILNODE,INDX,NHG,LINDEX
  3847:                 CHARACTER*80 PBLJAGF
  3848:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  3849:                 LOGICAL Success     ! .true. if all files open without error
  3850:                 INTEGER,ALLOCATABLE  :: NG(:)
  3851:                 REAL(8),ALLOCATABLE :: DPG(:)  !global array
  3852:                 REAL(8),ALLOCATABLE :: DPL(:)  !local array
  3853:                 REAL(8) DPTMP
  3854:           C     jgf48.47 Do the decomposition for a max of 256 subdomains at a
  3855:           C     time ... some platforms/compilers limit the number of files that
  3856:           C     can be open at any one time.
  3857:                 INTEGER, PARAMETER :: maxOpenFiles = 256
  3858:                 INTEGER startProc
  3859:                 INTEGER endProc
  3860:                 INTEGER deltaProc
  3861:           C
  3862:           C     Allocate local work arrays
  3863:           C
  3864:                 ALLOCATE ( NG(MNP) )
  3865:                 nbytes = 4*mnp
  3866:                 call memory_alloc(nbytes)
  3867:                 ALLOCATE ( DPG(MNP) )   !global
  3868:                 nbytes = 8*mnp
  3869:                 call memory_alloc(nbytes)
  3870:                 ALLOCATE ( DPL(MNP) )   !local
  3871:                 nbytes = 8*mnp
  3872:                 call memory_alloc(nbytes)
  3873:           C
  3874:           C     Perform decomposition over a range of subdomains.
  3875:                 startProc = 1
  3876: +------>        DO WHILE ( startProc .lt. nproc )
  3877: |                  deltaProc = nproc - startProc
  3878: |                  IF ( deltaProc .gt. maxOpenFiles ) deltaProc = maxOpenFiles
  3879: |                  endProc = startProc + deltaProc
  3880: |         
  3881: |         C        Open full domain and all subdomain fort.141 files
  3882: |                  CALL OpenPrepFiles(141, 'bathymetry information        ',
  3883: |              &      startProc, endProc, sdu, success)
  3884: |         
  3885: |                  IF (.not.success) THEN
  3886: |                    WRITE(*,*) 'WARNING: Unit 141 files not preprocessed.'
  3887: |                    RETURN ! note early return
  3888: |                  ENDIF
  3889: |         C
  3890: |         C--Branch to Appropriate Code
  3891: |         C
  3892: |                  SELECT CASE(ABS(NDDT))
  3893: |         C        -------------
  3894: |                  CASE(1)
  3895: |         C        -------------
  3896: |         C
  3897: |         C     MAIN LOOP FOR NWS = +-1
  3898: |         C     (1)  Read a record from Global Bathymetry File
  3899: |         C     (2)  Use Decomp arrarys to Localize record to a subdomain
  3900: |         C     (3)  Write Local Bathymetry record in same format
  3901: |+----->             DO                     ! loop forever (or until file ends)
  3902: ||+---->                READ(141,*,END=9999)
  3903: ||             &           (NG(I),DPG(I),I=1,NNODG)
  3904: ||+---->                DO IPROC = STARTPROC, ENDPROC
  3905: |||V--->                   DO I=1, NNODP(IPROC)
  3906: ||||                          INDX = IMAP_NOD_LG(I,IPROC)
  3907: ||||    G                     DPL(I) = DPG(INDX)
  3908: |||V---                    ENDDO
  3909: |||+--->                   DO I=1, NNODP(IPROC)
  3910: ||||                          WRITE(SDU(IPROC),*)  I,DPL(I)
  3911: |||+---                    ENDDO
  3912: ||+----                 ENDDO
  3913: |+-----              ENDDO
  3914: |         C
  3915: |         C        -------
  3916: |                  CASE(2)
  3917: |         C        -------
  3918: |         C        MAIN LOOP FOR NWS = +- 2  ( PBL Format )
  3919: |         C        (1)  Read a record from Global Bathymetry File
  3920: |         C        (2)  Use Decomp arrarys to Localize record to a subdomain
  3921: |         C        (3)  Write out in PBL Format on subdomain
  3922: |         C
  3923: |         C--Read a bathymetry field record from the global input file
  3924: |         C--- during the decomp phase, after each time record indicator is written (#)
  3925: |         C--- we write a single entry (1,-99999.d0) to ensure that there will be no
  3926: |         C--- empty records.  When this file is read by ADCIRC using nddt2get, the
  3927: |         C--- extra entry (1,-99999.d0) will be ignored, and if node 1 actually is
  3928: |         C--- changed then it will be read regardless if it appears twice.
  3929: |         C
  3930: |+----->           DO
  3931: ||+====>              PBLJAGF(:) = ' '
  3932: ||                    READ(141,'(A80)',END=9999) PBLJAGF
  3933: ||                    IF(PBLJAGF(2:2).EQ.'#') THEN
  3934: ||+---->                 DO IPROC =  STARTPROC,ENDPROC
  3935: |||                         WRITE(SDU(IPROC),1101)
  3936: |||       !  write a default value to ensure that no empty records
  3937: |||       !  are produced during the decomp phase (default values will be ignored by ADCIRC)
  3938: |||                         WRITE(SDU(IPROC),1100) 1,-99999.d0
  3939: ||+----                  ENDDO
  3940: ||                    ELSE
  3941: ||                       READ(PBLJAGF,*,END=9999) NHG,DPTMP
  3942: ||+---->                 DO J=1, ITOTPROC(NHG)
  3943: |||                         IPROC  = IMAP_NOD_GL2(2*(J-1)+1,NHG)
  3944: |||                         LINDEX = IMAP_NOD_GL2(2*(J-1)+2,NHG)
  3945: |||                         IF ( (IPROC.GE.STARTPROC).AND.
  3946: |||            &                 (IPROC.LE.ENDPROC) ) THEN
  3947: |||                            WRITE(SDU(IPROC),1100) LINDEX,DPTMP
  3948: |||                         endif
  3949: ||+----                  ENDDO
  3950: ||                    ENDIF
  3951: |+-----            END DO
  3952: |         C
  3953: |         
  3954: |         C        ------------
  3955: |                  CASE DEFAULT
  3956: |         C        ------------
  3957: |                  WRITE(*,*) "NDDT = ",NDDT," has incorrect value in PREP141"
  3958: |                  RETURN
  3959: |         
  3960: |                  END SELECT
  3961: |         
  3962: |         C
  3963: |         C--Close Global file and all the Local Files
  3964: |         C
  3965: |          9999    CLOSE (141)
  3966: |+----->           DO IPROC=STARTPROC, ENDPROC
  3967: ||                    CLOSE (SDU(IPROC))
  3968: |+-----            ENDDO
  3969: |                  write(*,*) "     Finished processing fort.141 file"
  3970: |                  write(*,*) "for processor range ",startproc," to ",endproc
  3971: |                  startProc=endProc+1
  3972: +------         ENDDO
  3973:           
  3974:           
  3975:                 DEALLOCATE ( NG,  DPG )
  3976:                 DEALLOCATE ( DPL )
  3977:                 nbytes = 20*mnp
  3978:                 call memory_dealloc(nbytes)
  3979:                 call memory_status()
  3980:                 RETURN
  3981:           !  60  FORMAT(A60)
  3982:           ! 170  FORMAT(A170)
  3983:            !270  FORMAT(A270)
  3984:            !1010 FORMAT(' File ',A60,/,' WAS NOT FOUND!  Try again',/)
  3985:            !1011 FORMAT(' File ',A60,/,' WAS FOUND!  Opening & Processing file',/)
  3986:            1100 FORMAT(I8,E13.5)
  3987:            1101 FORMAT(' #')
  3988:           c----------------------------------------------------------------------------
  3989:                 END SUBROUTINE PREP141


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP141
INLINE LIST

  ROOT: PREP141 (prep.F:3839)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3866)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3869)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:3872)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:3978)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:3979)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP141
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:3876)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:3876)

    LOOP BEGIN: (prep.F:3901)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:3901)

      LOOP BEGIN: (prep.F:3902)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3902)
        *** Unvectorizable loop structure. (prep.F:3902)
      LOOP END

      LOOP BEGIN: (prep.F:3904)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:3905)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  1,  0. (prep.F:3905)
          *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:3905)
          *** VGT generated (prep.F:3907)
        LOOP END

        LOOP BEGIN: (prep.F:3909)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:3909)
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3930)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:3930)

      LOOP BEGIN: (prep.F:3931)
        <Unvectorized loop.>
        *** Unvectorizable data type. : PBLJAGF (prep.F:3931)
      LOOP END

      LOOP BEGIN: (prep.F:3934)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3934)
      LOOP END

      LOOP BEGIN: (prep.F:3942)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:3942)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3966)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:3966)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP141
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 49 [s0-s12 s15-s16 s18-s37 s50-s63]
      Vector registers         :  3 [v61-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3264 bytes
      Register spill area      :  416 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 2592 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:3876)
    *** Estimated execution cycle                       : 357
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 46
            Across calls                                :  7
            Over basic blocks                           : 39
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 47
            Across calls                                :  8
            Over basic blocks                           : 39
    *** The number of SCALAR REGISTER TRANSFER          : 44

    LOOP BEGIN: (prep.F:3930)
      *** Estimated execution cycle                     : 162
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Over basic blocks                         : 7
      *** The number of SCALAR REGISTER TRANSFER        : 53

      LOOP BEGIN: (prep.F:3931)
        *** Estimated execution cycle                   : 5
      LOOP END

      LOOP BEGIN: (prep.F:3942)
        *** Estimated execution cycle                   : 83
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 2
                Across calls                            : 2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 2
                Across calls                            : 2
        *** The number of SCALAR REGISTER TRANSFER      : 22
      LOOP END

      LOOP BEGIN: (prep.F:3934)
        *** Estimated execution cycle                   : 60
        *** The number of SCALAR REGISTER TRANSFER      : 12
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3901)
      *** Estimated execution cycle                     : 71
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 34

      LOOP BEGIN: (prep.F:3902)
        *** Estimated execution cycle                   : 19
        *** The number of SCALAR REGISTER TRANSFER      : 5
      LOOP END

      LOOP BEGIN: (prep.F:3904)
        *** Estimated execution cycle                   : 86
        *** The number of SCALAR REGISTER TRANSFER      : 22

        LOOP BEGIN: (prep.F:3905)
          *** Estimated execution cycle                 : 153
        LOOP END

        LOOP BEGIN: (prep.F:3909)
          *** Estimated execution cycle                 : 33
          *** The number of SCALAR REGISTER TRANSFER    : 7
        LOOP END
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:3966)
      *** Estimated execution cycle                     : 15
      *** The number of SCALAR REGISTER TRANSFER        : 2
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP35
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4039: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  4044: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  4044: vec( 108): Unvectorizable loop structure.
  4045: opt(3014): Moved reference within a conditional branch.
  4046: vec( 103): Unvectorized loop.
  4046: vec( 180): I/O statement obstructs vectorization.
  4047: opt(1118): This I/O statement inhibits optimization of loop.
  4049: vec( 103): Unvectorized loop.
  4049: vec( 180): I/O statement obstructs vectorization.
  4050: opt(1118): This I/O statement inhibits optimization of loop.
  4050: opt(3014): Moved reference within a conditional branch.
  4054: vec( 180): I/O statement obstructs vectorization.
  4056: opt(1118): This I/O statement inhibits optimization of loop.
  4065: vec( 103): Unvectorized loop.
  4065: vec( 180): I/O statement obstructs vectorization.
  4066: opt(1118): This I/O statement inhibits optimization of loop.
  4071: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4072: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP35
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4000:                 SUBROUTINE PREP35()
  4001:                 USE PRE_GLOBAL
  4002:                 use memory_usage
  4003:           C
  4004:           C---------------------------------------------------------------------------C
  4005:           C                                                                           C
  4006:           C  This routine writes a Local "Residual Boundary Condtions Baroclinic"     C
  4007:           C  (fort.35) file for each subdomain using the domain decomposition of     C
  4008:           C  the ADCIRC grid created by the routine DECOMP.                           C
  4009:           C                                                                           C
  4010:           C                   Added by Kendra Dresback (Aug. 18, 2007)                C
  4011:           C---------------------------------------------------------------------------C
  4012:           C
  4013:                 IMPLICIT NONE
  4014:                 INTEGER(8) :: nbytes = 0
  4015:                 INTEGER I,J,IPROC
  4016:                 INTEGER SDU(NPROC) ! subdomain unit numbers
  4017:                 LOGICAL Success    ! .true. if files opened without errors
  4018:                 CHARACTER*40  ETIMINC,RESBCBINP,GRIDINC
  4019:                 CHARACTER*40,ALLOCATABLE :: RESBCBIN(:)
  4020:           
  4021:           C
  4022:           C--Enter, Locate, Open, and Read the ADCIRC UNIT 35
  4023:           C  Global Level of No Motion Boundary Conditions file for baroclinic
  4024:           C
  4025:           C     Open full domain and subdomain fort.35 files
  4026:           C      Print *, "Made it to prepping the files"
  4027:                 CALL OpenPrepFiles(35, 'level of no motion boundary  ',
  4028:                &     1, nproc, SDU, Success)
  4029:           C      Print *, "Made it out of prepping the files"
  4030:                 IF (.not.Success) THEN
  4031:                    WRITE(*,*) 'WARNING: Unit 35 files not preprocessed.'
  4032:                    RETURN ! note early return
  4033:                 ENDIF
  4034:           C
  4035:           C--Allocate local arrays
  4036:           C
  4037:                 ALLOCATE ( RESBCBIN(MNETA) )
  4038:                 nbytes = 8*mneta
  4039:                 call memory_alloc(nbytes)
  4040:           C
  4041:           C--While ( NOT EOF ) Read NETA BCs from Global File
  4042:           C
  4043:           C      PRINT *, "Made it to the reading in of the 35 file"
  4044: +------>        DO  ! loop until end of file
  4045: |               READ(35,40,END=9999) ETIMINC
  4046: |+----->        DO IPROC = 1,NPROC
  4047: ||                 WRITE(SDU(IPROC),40)  ETIMINC
  4048: |+-----         ENDDO
  4049: |+----->        DO I=1, NETA
  4050: ||                 READ(35,40,END=9999)  RESBCBIN(I)
  4051: |+-----         ENDDO
  4052: |         C
  4053: |+----->        DO IPROC= 1,NPROC
  4054: ||+---->           DO I=1, NETAP(IPROC)
  4055: |||+===>              RESBCBINP = RESBCBIN(OBNODE_LG(I,IPROC))
  4056: |||                   WRITE(SDU(IPROC),40) RESBCBINP
  4057: ||+----            ENDDO
  4058: |+-----         ENDDO
  4059: +------         END DO
  4060:           C
  4061:           C
  4062:           C--Close Global file and all the Local Files
  4063:           C
  4064:            9999 CLOSE (35)
  4065: +------>        DO IPROC=1, NPROC
  4066: |                  CLOSE (SDU(IPROC))
  4067: +------         ENDDO
  4068:           
  4069:                 deallocate(resbcbin)
  4070:                 nbytes = 8*mneta
  4071:                 call memory_dealloc(nbytes)
  4072:                 call memory_status()
  4073:           C
  4074:             40  FORMAT(A40)
  4075:           C
  4076:                 RETURN
  4077:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP35
INLINE LIST

  ROOT: PREP35 (prep.F:4000)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4039)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4071)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4072)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP35
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:4044)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:4044)

    LOOP BEGIN: (prep.F:4046)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4046)
    LOOP END

    LOOP BEGIN: (prep.F:4049)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4049)
    LOOP END

    LOOP BEGIN: (prep.F:4053)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:4054)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4054)

        LOOP BEGIN: (prep.F:4055)
          <Unvectorized loop.>
          *** Unvectorizable data type. : RESBCBIN (prep.F:4055)
          *** Unvectorizable data type. : RESBCBINP (prep.F:4055)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4065)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4065)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP35
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 42 [s0-s12 s15-s16 s18-s33 s53-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1568 bytes
      Register spill area      :   96 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1216 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4044)
    *** Estimated execution cycle                       : 99
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Over basic blocks                           : 5
    *** The number of SCALAR REGISTER TRANSFER          : 35

    LOOP BEGIN: (prep.F:4046)
      *** Estimated execution cycle                     : 31
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:4049)
      *** Estimated execution cycle                     : 42
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:4053)
      *** Estimated execution cycle                     : 26
      *** The number of SCALAR REGISTER TRANSFER        : 9

      LOOP BEGIN: (prep.F:4054)
        *** Estimated execution cycle                   : 64
        *** The number of SCALAR REGISTER TRANSFER      : 16

        LOOP BEGIN: (prep.F:4055)
          *** Estimated execution cycle                 : 7
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4065)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP36
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4122: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  4126: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  4126: vec( 108): Unvectorizable loop structure.
  4127: opt(3014): Moved reference within a conditional branch.
  4128: vec( 103): Unvectorized loop.
  4128: vec( 180): I/O statement obstructs vectorization.
  4129: opt(1118): This I/O statement inhibits optimization of loop.
  4132: vec( 108): Unvectorizable loop structure.
  4133: opt(1118): This I/O statement inhibits optimization of loop.
  4133: vec( 103): Unvectorized loop.
  4133: vec( 180): I/O statement obstructs vectorization.
  4137: vec( 180): I/O statement obstructs vectorization.
  4139: vec( 101): Vectorized loop.
  4142: opt(1118): This I/O statement inhibits optimization of loop.
  4151: vec( 103): Unvectorized loop.
  4151: vec( 180): I/O statement obstructs vectorization.
  4152: opt(1118): This I/O statement inhibits optimization of loop.
  4157: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4158: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP36
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4079:                 SUBROUTINE PREP36()
  4080:                 USE PRE_GLOBAL
  4081:                 use memory_usage
  4082:           C
  4083:           C---------------------------------------------------------------------------C
  4084:           C                                                                           C
  4085:           C  This routine writes a Local "Salinity Boundary Conditions Values"        C
  4086:           C  (fort.36) file for each subdomain using the domain decomposition of      C
  4087:           C  the ADCIRC grid created by the routine DECOMP.                           C
  4088:           C                                                                           C
  4089:           C                Added by Kendra Dresback (January 15, 2008)                C
  4090:           C---------------------------------------------------------------------------C
  4091:           C
  4092:                 IMPLICIT NONE
  4093:                 integer(8) :: nbytes = 0
  4094:                 INTEGER I,J,IPROC
  4095:                 INTEGER SDU(NPROC) ! subdomain unit numbers
  4096:                 LOGICAL Success    ! .true. if files opened without errors
  4097:                 CHARACTER*40  ETIMINC,GRIDINC
  4098:                 INTEGER :: NODP, M
  4099:                 INTEGER,ALLOCATABLE :: NOD(:)
  4100:                 REAL(8),ALLOCATABLE :: SalBC(:,:)
  4101:                 REAL(8),ALLOCATABLE :: RESBCBINP(:)
  4102:           
  4103:           
  4104:           C
  4105:           C--Enter, Locate, Open, and Read the ADCIRC UNIT 36
  4106:           C  Global Salinity Boundary Conditions file for baroclinic
  4107:           C
  4108:           C     Open full domain and subdomain fort.36 files
  4109:                 CALL OpenPrepFiles(36, 'salinity boundary             ',
  4110:                &     1, nproc, SDU, Success)
  4111:                 IF (.not.Success) THEN
  4112:                    WRITE(*,*) 'WARNING: Unit 36 files not preprocessed.'
  4113:                    RETURN ! note early return
  4114:                 ENDIF
  4115:           C
  4116:           C--Allocate local arrays
  4117:           C
  4118:                 ALLOCATE ( NOD(MNETA) )
  4119:                 ALLOCATE ( RESBCBINP(NFEN) )
  4120:                 ALLOCATE ( SalBC(MNETA,NFEN) )
  4121:                 nbytes = 8*mneta
  4122:                 call memory_alloc(nbytes)
  4123:           C
  4124:           C--While ( NOT EOF ) Read NETA BCs from Global File
  4125:           C
  4126: +------>        DO  ! loop until end of file
  4127: |               READ(36,40,END=9999) ETIMINC
  4128: |+----->        DO IPROC = 1,NPROC
  4129: ||                 WRITE(SDU(IPROC),40)  ETIMINC
  4130: |+-----         ENDDO
  4131: |         
  4132: |+----->        DO I=1, NETA
  4133: ||+---->           READ(36,*,END=9999)  NOD(I), (SalBC(I,M),M=1,NFEN)
  4134: |+-----         ENDDO
  4135: |         C
  4136: |+----->        DO IPROC= 1,NPROC
  4137: ||+---->           DO I=1, NETAP(IPROC)
  4138: |||                   NODP = NOD(OBNODE_LG(I,IPROC))
  4139: |||V--->              DO M=1,NFEN
  4140: ||||                    RESBCBINP(M) = SalBC(OBNODE_LG(I,IPROC),M)
  4141: |||V---               END DO
  4142: |||+--->                WRITE(SDU(IPROC),80) NODP, (RESBCBINP(M),M=1,NFEN)
  4143: ||+----            ENDDO
  4144: |+-----         ENDDO
  4145: +------         END DO
  4146:           C
  4147:           C
  4148:           C--Close Global file and all the Local Files
  4149:           C
  4150:            9999 CLOSE (36)
  4151: +------>        DO IPROC=1, NPROC
  4152: |                  CLOSE (SDU(IPROC))
  4153: +------         ENDDO
  4154:           C
  4155:                 deallocate(salbc)
  4156:                 nbytes = 8*mneta
  4157:                 call memory_dealloc(nbytes)
  4158:                 call memory_status()
  4159:             40  FORMAT(A40)
  4160:             80  FORMAT(1X,I6,1X,32000(F11.7,2X))
  4161:           C
  4162:                 RETURN
  4163:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP36
INLINE LIST

  ROOT: PREP36 (prep.F:4079)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4122)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4157)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4158)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP36
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:4126)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:4126)

    LOOP BEGIN: (prep.F:4128)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4128)
    LOOP END

    LOOP BEGIN: (prep.F:4132)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:4132)

      LOOP BEGIN: (prep.F:4133)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4133)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4136)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:4137)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4137)

        LOOP BEGIN: (prep.F:4139)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:4139)
          *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:4139)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4151)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4151)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP36
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 42 [s0-s12 s15-s16 s18-s33 s53-s63]
      Vector registers         :  1 [v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1872 bytes
      Register spill area      :  264 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1352 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4126)
    *** Estimated execution cycle                       : 154
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 20
            Over basic blocks                           : 20
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 20
            Over basic blocks                           : 20
    *** The number of SCALAR REGISTER TRANSFER          : 31

    LOOP BEGIN: (prep.F:4128)
      *** Estimated execution cycle                     : 31
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:4132)
      *** Estimated execution cycle                     : 57
      *** The number of SCALAR REGISTER TRANSFER        : 22

      LOOP BEGIN: (prep.F:4133)
        *** Estimated execution cycle                   : 11
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4136)
      *** Estimated execution cycle                     : 32
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:4137)
        *** Estimated execution cycle                   : 113
        *** The number of SCALAR REGISTER TRANSFER      : 26

        LOOP BEGIN: (prep.F:4139)
          *** Estimated execution cycle                 : 63
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4151)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP37
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4207: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  4212: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  4212: vec( 108): Unvectorizable loop structure.
  4213: opt(3014): Moved reference within a conditional branch.
  4214: vec( 103): Unvectorized loop.
  4214: vec( 180): I/O statement obstructs vectorization.
  4215: opt(1118): This I/O statement inhibits optimization of loop.
  4218: vec( 108): Unvectorizable loop structure.
  4219: opt(1118): This I/O statement inhibits optimization of loop.
  4219: vec( 103): Unvectorized loop.
  4219: vec( 180): I/O statement obstructs vectorization.
  4223: vec( 180): I/O statement obstructs vectorization.
  4225: vec( 101): Vectorized loop.
  4228: opt(1118): This I/O statement inhibits optimization of loop.
  4237: vec( 103): Unvectorized loop.
  4237: vec( 180): I/O statement obstructs vectorization.
  4238: opt(1118): This I/O statement inhibits optimization of loop.
  4243: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4244: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP37
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4165:                 SUBROUTINE PREP37()
  4166:                 USE PRE_GLOBAL
  4167:                 use memory_usage
  4168:           C
  4169:           C---------------------------------------------------------------------------C
  4170:           C                                                                           C
  4171:           C  This routine writes a Local "Temperature Boundary Conditions Values"     C
  4172:           C  (fort.37) file for each subdomain using the domain decomposition of      C
  4173:           C  the ADCIRC grid created by the routine DECOMP.                           C
  4174:           C                                                                           C
  4175:           C                Added by Kendra Dresback (January 15, 2008)                C
  4176:           C---------------------------------------------------------------------------C
  4177:           C
  4178:                 IMPLICIT NONE
  4179:                 integer(8) :: nbytes = 0
  4180:                 INTEGER I,J,IPROC
  4181:                 INTEGER SDU(NPROC) ! subdomain unit numbers
  4182:                 LOGICAL Success    ! .true. if files opened without errors
  4183:                 CHARACTER*40  ETIMINC
  4184:                 INTEGER :: NODP, M
  4185:                 INTEGER,ALLOCATABLE :: NOD(:)
  4186:                 REAL(8),ALLOCATABLE :: TempBC(:,:)
  4187:                 REAL(8),ALLOCATABLE :: RESBCBINP(:)
  4188:           
  4189:           C
  4190:           C--Enter, Locate, Open, and Read the ADCIRC UNIT 37
  4191:           C  Global Temperature Boundary Conditions file for baroclinic
  4192:           C
  4193:           C     Open full domain and subdomain fort.37 files
  4194:                 CALL OpenPrepFiles(37, 'temperature boundary          ',
  4195:                &     1, nproc, SDU, Success)
  4196:                 IF (.not.Success) THEN
  4197:                    WRITE(*,*) 'WARNING: Unit 37 files not preprocessed.'
  4198:                    RETURN ! note early return
  4199:                 ENDIF
  4200:           C
  4201:           C--Allocate local arrays
  4202:           C
  4203:                 ALLOCATE ( NOD(MNETA) )
  4204:                 ALLOCATE ( RESBCBINP(NFEN) )
  4205:                 ALLOCATE ( TempBC(MNETA,NFEN) )
  4206:                 nbytes = 8*mneta
  4207:                 call memory_alloc(nbytes)
  4208:           C
  4209:           C
  4210:           C--While ( NOT EOF ) Read NETA BCs from Global File
  4211:           C
  4212: +------>        DO  ! loop around until the end of the file
  4213: |               READ(37,40,END=9999) ETIMINC
  4214: |+----->        DO IPROC = 1,NPROC
  4215: ||                 WRITE(SDU(IPROC),40)  ETIMINC
  4216: |+-----         ENDDO
  4217: |         
  4218: |+----->        DO I=1, NETA
  4219: ||+---->           READ(37,*,END=9999)  NOD(I), (TempBC(I,M),M=1,NFEN)
  4220: |+-----         ENDDO
  4221: |         C
  4222: |+----->        DO IPROC= 1,NPROC
  4223: ||+---->           DO I=1, NETAP(IPROC)
  4224: |||                   NODP = NOD(OBNODE_LG(I,IPROC))
  4225: |||V--->              DO M=1,NFEN
  4226: ||||                    RESBCBINP(M) = TempBC(OBNODE_LG(I,IPROC),M)
  4227: |||V---               END DO
  4228: |||+--->                WRITE(SDU(IPROC),80) NODP, (RESBCBINP(M),M=1,NFEN)
  4229: ||+----            ENDDO
  4230: |+-----         ENDDO
  4231: +------         END DO
  4232:           C
  4233:           C
  4234:           C--Close Global file and all the Local Files
  4235:           C
  4236:            9999 CLOSE (37)
  4237: +------>        DO IPROC=1, NPROC
  4238: |                  CLOSE (SDU(IPROC))
  4239: +------         ENDDO
  4240:           C
  4241:                 deallocate(TempBC)
  4242:                 nbytes = 8*mneta
  4243:                 call memory_dealloc(nbytes)
  4244:                 call memory_status()
  4245:             40  FORMAT(A40)
  4246:             80  FORMAT(1X,I6,1X,32000(F11.7,2X))
  4247:           C
  4248:                 RETURN
  4249:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP37
INLINE LIST

  ROOT: PREP37 (prep.F:4165)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4207)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4243)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4244)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP37
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:4212)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:4212)

    LOOP BEGIN: (prep.F:4214)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4214)
    LOOP END

    LOOP BEGIN: (prep.F:4218)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:4218)

      LOOP BEGIN: (prep.F:4219)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4219)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4222)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:4223)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4223)

        LOOP BEGIN: (prep.F:4225)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:4225)
          *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:4225)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4237)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4237)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP37
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 42 [s0-s12 s15-s16 s18-s33 s53-s63]
      Vector registers         :  1 [v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1872 bytes
      Register spill area      :  264 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1352 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4212)
    *** Estimated execution cycle                       : 154
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 20
            Over basic blocks                           : 20
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 20
            Over basic blocks                           : 20
    *** The number of SCALAR REGISTER TRANSFER          : 31

    LOOP BEGIN: (prep.F:4214)
      *** Estimated execution cycle                     : 31
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:4218)
      *** Estimated execution cycle                     : 57
      *** The number of SCALAR REGISTER TRANSFER        : 22

      LOOP BEGIN: (prep.F:4219)
        *** Estimated execution cycle                   : 11
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4222)
      *** Estimated execution cycle                     : 32
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:4223)
        *** Estimated execution cycle                   : 113
        *** The number of SCALAR REGISTER TRANSFER      : 26

        LOOP BEGIN: (prep.F:4225)
          *** Estimated execution cycle                 : 63
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4237)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP38
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4307: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  4311: vec( 108): Unvectorizable loop structure.
  4313: opt(1118): This I/O statement inhibits optimization of loop.
  4313: vec( 103): Unvectorized loop.
  4313: vec( 108): Unvectorizable loop structure.
  4313: vec( 180): I/O statement obstructs vectorization.
  4318: vec( 101): Vectorized loop.
  4321: opt(1118): This I/O statement inhibits optimization of loop.
  4321: vec( 103): Unvectorized loop.
  4321: vec( 180): I/O statement obstructs vectorization.
  4330: vec( 103): Unvectorized loop.
  4330: vec( 180): I/O statement obstructs vectorization.
  4331: opt(1118): This I/O statement inhibits optimization of loop.
  4336: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4337: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP38
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4251:                 SUBROUTINE PREP38()
  4252:                 USE PRE_GLOBAL
  4253:                 use memory_usage
  4254:           C
  4255:           C---------------------------------------------------------------------------C
  4256:           C                                                                           C
  4257:           C  This routine writes a Local "Temperature Boundary Conditions Values      C
  4258:           C  for the surface" (fort.38) file for each subdomain using the domain     C
  4259:           C  decomposition of the ADCIRC grid created by the routine DECOMP.          C
  4260:           C                                                                           C
  4261:           C                Added by Kendra Dresback (October 15, 2008)                C
  4262:           C---------------------------------------------------------------------------C
  4263:           C
  4264:                 IMPLICIT NONE
  4265:                 integer(8) :: nbytes = 0
  4266:                 INTEGER I,J,IPROC
  4267:                 INTEGER SDU(NPROC) ! subdomain unit numbers
  4268:                 LOGICAL Success    ! .true. if files opened without errors
  4269:                 CHARACTER*40  ETIMINC,GRIDINC
  4270:                 INTEGER :: NODP, M, NFLUX
  4271:                 INTEGER,ALLOCATABLE :: NOD(:)
  4272:                 REAL(8),ALLOCATABLE :: TopTempBC(:,:)
  4273:                 REAL(8),ALLOCATABLE :: RESBCBINP(:,:)
  4274:           
  4275:           
  4276:           C
  4277:           C--Enter, Locate, Open, and Read the ADCIRC UNIT 38
  4278:           C  Global Salinity Boundary Conditions file for baroclinic
  4279:           C
  4280:           C     Open full domain and subdomain fort.38 files
  4281:                 CALL OpenPrepFiles(38, 'top temperature boundary      ',
  4282:                &     1, nproc, SDU, Success)
  4283:                 IF (.not.Success) THEN
  4284:                    WRITE(*,*) 'WARNING: Unit 38 files not preprocessed.'
  4285:                    RETURN ! note early return
  4286:                 ENDIF
  4287:           C
  4288:           C  Determine how many values are in the top temperature boundary
  4289:           C  condition
  4290:           
  4291:                 IF (BCFLAG_TEMP.EQ.1) THEN
  4292:                    NFLUX = 1
  4293:                 ELSE IF (BCFLAG_TEMP.EQ.2) THEN
  4294:                    NFLUX = 6
  4295:                 ELSE IF (BCFLAG_TEMP.EQ.3) THEN
  4296:                    NFLUX = 4
  4297:                 END IF
  4298:           
  4299:                 MNP=nnodg
  4300:           C
  4301:           C--Allocate local arrays
  4302:           C
  4303:                 ALLOCATE ( NOD(MNP) )
  4304:                 ALLOCATE ( RESBCBINP(MNP,NFLUX) )
  4305:                 ALLOCATE ( TopTempBC(MNP,NFLUX) )
  4306:                 nbytes = 24*mnp
  4307:                 call memory_alloc(nbytes)
  4308:           C
  4309:           C--While ( NOT EOF ) Read NETA BCs from Global File
  4310:           C
  4311: +------>        DO  ! loop until end of file
  4312: |         
  4313: |+----->         READ(38,*,END=9999) (NOD(I),(TopTempBC(I,M),M=1,NFLUX),I=1,NNODG)
  4314: |         C
  4315: |+----->        DO IPROC= 1,NPROC
  4316: ||+---->           DO I=1, NNODP(IPROC)
  4317: |||                   NODP = IMAP_NOD_LG(I,IPROC)
  4318: |||V--->              DO M=1,NFLUX
  4319: ||||                    RESBCBINP(I,M) = TopTempBC(NODP,M)
  4320: |||V---               END DO
  4321: |||+--->                WRITE(SDU(IPROC),80) I, (RESBCBINP(I,M),M=1,NFLUX)
  4322: ||+----            ENDDO
  4323: |+-----         ENDDO
  4324: +------         END DO
  4325:           C
  4326:           C
  4327:           C--Close Global file and all the Local Files
  4328:           C
  4329:            9999 CLOSE (38)
  4330: +------>        DO IPROC=1, NPROC
  4331: |                  CLOSE (SDU(IPROC))
  4332: +------         ENDDO
  4333:           C
  4334:                 deallocate(toptempbc)
  4335:                 nbytes = 24*mnp
  4336:                 call memory_dealloc(nbytes)
  4337:                 call memory_status()
  4338:             40  FORMAT(A40)
  4339:             80  FORMAT(1X,I8,1X,32(F12.6,2X))
  4340:           C
  4341:                 RETURN
  4342:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP38
INLINE LIST

  ROOT: PREP38 (prep.F:4251)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4307)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4336)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4337)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP38
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:4311)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:4311)

    LOOP BEGIN: (prep.F:4313)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:4313)

      LOOP BEGIN: (prep.F:4313)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4313)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4315)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:4316)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:4318)
          <Vectorized loop.>
          *** The number of VGT,   VSC.    :  0,  0. (prep.F:4318)
          *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:4318)
        LOOP END

        LOOP BEGIN: (prep.F:4321)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:4321)
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4330)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4330)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP38
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 45 [s0-s12 s15-s16 s18-s36 s53-s63]
      Vector registers         :  1 [v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1760 bytes
      Register spill area      :  232 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1272 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4311)
    *** Estimated execution cycle                       : 94
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Over basic blocks                           : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 16
            Over basic blocks                           : 16
    *** The number of SCALAR REGISTER TRANSFER          : 23

    LOOP BEGIN: (prep.F:4313)
      *** Estimated execution cycle                     : 23
      *** The number of SCALAR REGISTER TRANSFER        : 13

      LOOP BEGIN: (prep.F:4313)
        *** Estimated execution cycle                   : 11
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4315)
      *** Estimated execution cycle                     : 37
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 5

      LOOP BEGIN: (prep.F:4316)
        *** Estimated execution cycle                   : 112
        *** The number of SCALAR REGISTER TRANSFER      : 41

        LOOP BEGIN: (prep.F:4318)
          *** Estimated execution cycle                 : 63
        LOOP END

        LOOP BEGIN: (prep.F:4321)
          *** Estimated execution cycle                 : 9
          *** The number of SCALAR REGISTER TRANSFER    : 2
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4330)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP39
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4403: opt(1592): Outer loop unrolled inside inner loop.
  4403: vec( 101): Vectorized loop.
  4404: vec( 101): Vectorized loop.
  4412: vec( 103): Unvectorized loop.
  4412: vec( 180): I/O statement obstructs vectorization.
  4414: opt(1118): This I/O statement inhibits optimization of loop.
  4423: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  4423: vec( 108): Unvectorizable loop structure.
  4425: vec( 108): Unvectorizable loop structure.
  4432: opt(1118): This I/O statement inhibits optimization of loop.
  4432: vec( 103): Unvectorized loop.
  4432: vec( 180): I/O statement obstructs vectorization.
  4434: opt(1118): This I/O statement inhibits optimization of loop.
  4434: vec( 103): Unvectorized loop.
  4434: vec( 180): I/O statement obstructs vectorization.
  4443: opt(1135): Outer loop conditionally executes inner loop.
  4443: vec( 180): I/O statement obstructs vectorization.
  4448: vec( 101): Vectorized loop.
  4451: opt(3014): Moved reference within a conditional branch.
  4453: vec( 101): Vectorized loop.
  4456: opt(3014): Moved reference within a conditional branch.
  4467: vec( 103): Unvectorized loop.
  4467: vec( 180): I/O statement obstructs vectorization.
  4468: opt(1118): This I/O statement inhibits optimization of loop.
  4474: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4476: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP39
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4344:                 SUBROUTINE PREP39()
  4345:           C---------------------------------------------------------------------------
  4346:           C                                                                           C
  4347:           C  This routine writes a Local river boundary file for the baroclnic        C
  4348:           C  simulation (fort.39) for each subdomain using the domain                 C
  4349:           C  decomposition of the ADCIRC grid created by the routine DECOMP.          C
  4350:           C                                                                           C
  4351:           C                Added by Kendra Dresback (January 14, 2010)                C
  4352:           !
  4353:           ! arash June 23 2016: RIVBCSTATIM was missing
  4354:           ! arash July 7: FLUX_VAL(:,:) should support both salinity and temperature if IDEN == 4, which requires an array of size 2 * NFEN
  4355:           C---------------------------------------------------------------------------C
  4356:           C
  4357:                 USE PRE_GLOBAL
  4358:                 use memory_usage
  4359:                 IMPLICIT NONE
  4360:                 integer(8) :: nbytes = 0
  4361:                 INTEGER IPROC
  4362:                 INTEGER INDEX14, I
  4363:                 REAL(8) :: FLUX_INC
  4364:           ! arash June 23 2016 added RIVBCSTATIM
  4365:                 REAL(8) :: RIVBCSTATIM
  4366:                 REAL(8),ALLOCATABLE ::  FLUX_VAL(:,:)
  4367:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  4368:                 LOGICAL Success     ! .true. if all files open without error
  4369:                 INTEGER INDX ! full domain node number for a flow boundary node
  4370:                 INTEGER J,M     ! counter for subdomains that corrsp. to a single f.d. node
  4371:                 INTEGER IPROC2! PE of a subdomain that matches a single full domain node
  4372:                 INTEGER, ALLOCATABLE :: NOD(:)
  4373:                 REAL(8),ALLOCATABLE ::  RESBCBINP(:)
  4374:           
  4375:           C     Open full domain and subdomain fort.20 files
  4376:                 CALL OpenPrepFiles(39, 'aperiodic river temp and salinity   ',
  4377:                &     1, nproc, SDU, Success)
  4378:                 IF (.not.Success) THEN
  4379:                    WRITE(*,*) 'WARNING: Unit 39 files not preprocessed.'
  4380:                    RETURN ! note early return
  4381:                 ENDIF
  4382:           
  4383:           ! arash debug
  4384:           !      write(*,*) '--------------------'
  4385:           !      write(*,*) 'arash: iden =', iden
  4386:           !      write(*,*) '--------------------'
  4387:           
  4388:                 ALLOCATE ( NOD(MNVEL) )
  4389:                 ALLOCATE ( RESBCBINP(NFEN) )
  4390:           ! arash:
  4391:           !      ALLOCATE ( FLUX_VAL(MNVEL,NFEN) )
  4392:                 ALLOCATE ( FLUX_VAL(MNP,NFEN) )
  4393:           
  4394:           ! arash July 7 2016: account for both salinity and temperature
  4395:                 If ( IDEN == 4 ) Then
  4396:                    If ( Allocated(FLUX_VAL) ) Deallocate(FLUX_VAL)
  4397:                    If ( Allocated(RESBCBINP) ) Deallocate(RESBCBINP)
  4398:           ! arash
  4399:           !         Allocate ( FLUX_VAL(MNVEL, 2*NFEN) )
  4400:                    Allocate ( FLUX_VAL(MNP, 2*NFEN) )
  4401:                    Allocate ( RESBCBINP(2*NFEN) )
  4402:                 End If
  4403: U======>        FLUX_VAL  ( : , : ) = 0.0d0
  4404: V======>        RESBCBINP ( : )     = 0.0d0
  4405:           
  4406:                 Write(*,*) 'MNVEL =', MNVEL
  4407:                 Write(*,*) 'MNP =', MNP
  4408:           c
  4409:           c     Write Increment into all flux files
  4410:           c
  4411:                 READ(39,*) FLUX_INC, RIVBCSTATIM
  4412: +------>        DO IPROC=1,NPROC
  4413: |         ! arash June 23 2016 added RIVBCSTATIM
  4414: |                  WRITE(SDU(IPROC),*) FLUX_INC, RIVBCSTATIM
  4415: +------         ENDDO
  4416:           C
  4417:           C     jgf45.12 Write each full domain nodal flux value into each of the
  4418:           C     subdomains that that full domain node maps to. The full domain
  4419:           C     node may map to more than one subdomain node if it falls on a
  4420:           C     boundary between subdomains (ghost nodes).
  4421:           C
  4422:           
  4423: +------>        DO  ! continue to loop over file until you reach the end of the file
  4424: |         
  4425: |+----->        DO I=1, EXIST_BC_TS      ! loop through full domain flow nodes
  4426: ||                 INDX=BCTS14_ARY(I)
  4427: ||        
  4428: ||                 !write(*,*) indx
  4429: ||        
  4430: ||        ! arash July 7 2016:
  4431: ||                 If ( IDEN == 4 ) Then
  4432: ||+---->              READ(39,*,END=40)  (FLUX_VAL(INDX,M),M=1,2*NFEN)
  4433: ||                 Else
  4434: ||+---->              READ(39,*,END=40)  (FLUX_VAL(INDX,M),M=1,NFEN)
  4435: ||                 End If
  4436: ||        
  4437: |+-----         END DO
  4438: |         
  4439: |+----->        DO I=1, EXIST_BC_TS
  4440: ||                 INDX = BCTS14_ARY(I)      ! get full domain flow node number
  4441: ||+---->           DO J=1, ITOTPROC(INDX)    ! loop over subdomains for 1 f.d. node
  4442: |||                   IPROC2 = IMAP_NOD_GL2(2*(J-1)+1,INDX) ! find next subdomain
  4443: |||+--->              DO IPROC=1, NPROC
  4444: ||||                     IF (IPROC.EQ.IPROC2) THEN ! full domain node maps to this s.d.
  4445: ||||      
  4446: ||||      ! arash July 7 2016: ----------------------------
  4447: ||||                        If ( IDEN == 4 ) Then
  4448: ||||V-->                       DO M=1,2*NFEN
  4449: |||||                             RESBCBINP(M) = FLUX_VAL(INDX,M)
  4450: ||||V--                        END DO
  4451: ||||+-->                       WRITE(SDU(IPROC),80) (RESBCBINP(M),M=1,2*NFEN)
  4452: ||||                        Else
  4453: ||||V-->                       DO M=1,NFEN
  4454: |||||                             RESBCBINP(M) = FLUX_VAL(INDX,M)
  4455: ||||V--                        END DO
  4456: ||||+-->                       WRITE(SDU(IPROC),80) (RESBCBINP(M),M=1,NFEN)
  4457: ||||                       End If
  4458: ||||      ! -----------------------------------------------
  4459: ||||      
  4460: ||||                     ENDIF
  4461: |||+---               END DO
  4462: ||+----            END DO
  4463: |+-----         END DO
  4464: +------         END DO
  4465:           
  4466:            40   CLOSE (39)
  4467: +------>        DO IPROC=1, NPROC
  4468: |                  CLOSE (SDU(IPROC))
  4469: +------         ENDDO
  4470:           
  4471:                 IF (allocated(BCTS14_ARY)) then
  4472:                   DEALLOCATE (BCTS14_ARY)
  4473:                   nbytes = 4*exist_bc_ts
  4474:                   call memory_dealloc(nbytes)
  4475:                 ENDIF
  4476:                 call memory_status()
  4477:                 return
  4478:            80   FORMAT(1X,32000(F11.7,2X))
  4479:           c----------------------------------------------------------------------------
  4480:                 END SUBROUTINE PREP39


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP39
INLINE LIST

  ROOT: PREP39 (prep.F:4344)
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4474)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4476)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP39
VECTORIZATION LIST

  NOTE: The number of operation does not include the instruction
        for register spill and restore.

  LOOP BEGIN: (prep.F:4403)
    <Unvectorized loop.>
    **  Copied loop. : FOR UNROLLING (prep.F:4403)

    LOOP BEGIN: (prep.F:4403)
      <Vectorized loop.>
      **  Copied loop. : FOR UNROLLING (prep.F:4403)
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:4403)
      *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:4403)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4403)
    <Unvectorized loop.>
    **  Outer loop unrolled loop. : THE UNROLL TIME IS 4. (prep.F:4403)

    LOOP BEGIN: (prep.F:4403)
      <Vectorized loop.>
      *** The number of VGT,   VSC.    :  0,  0. (prep.F:4403)
      *** The number of VLOAD, VSTORE. :  0,  4. (prep.F:4403)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4404)
    <Vectorized loop.>
    *** The number of VGT,   VSC.    :  0,  0. (prep.F:4404)
    *** The number of VLOAD, VSTORE. :  0,  1. (prep.F:4404)
  LOOP END

  LOOP BEGIN: (prep.F:4412)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4412)
  LOOP END

  LOOP BEGIN: (prep.F:4423)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:4423)

    LOOP BEGIN: (prep.F:4425)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:4425)

      LOOP BEGIN: (prep.F:4432)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4432)
      LOOP END

      LOOP BEGIN: (prep.F:4434)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:4434)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4439)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:4441)
        <Unvectorized loop.>

        LOOP BEGIN: (prep.F:4443)
          <Unvectorized loop.>
          *** I/O statement obstructs vectorization. (prep.F:4443)

          LOOP BEGIN: (prep.F:4448)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:4448)
            *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:4448)
          LOOP END

          LOOP BEGIN: (prep.F:4453)
            <Vectorized loop.>
            *** The number of VGT,   VSC.    :  0,  0. (prep.F:4453)
            *** The number of VLOAD, VSTORE. :  1,  1. (prep.F:4453)
          LOOP END
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4467)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4467)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:27 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP39
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 56 [s0-s12 s15-s16 s18-s37 s43-s63]
      Vector registers         :  5 [v59-v63]
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2080 bytes
      Register spill area      :  328 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1496 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4403)
    *** Estimated execution cycle                       : 40
    *** The number of SCALAR REGISTER TRANSFER          : 8

    LOOP BEGIN: (prep.F:4403)
      *** Estimated execution cycle                     : 65
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4403)
    *** Estimated execution cycle                       : 52
    *** The number of SCALAR REGISTER TRANSFER          : 17

    LOOP BEGIN: (prep.F:4403)
      *** Estimated execution cycle                     : 162
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4404)
    *** Estimated execution cycle                       : 65
  LOOP END

  LOOP BEGIN: (prep.F:4412)
    *** Estimated execution cycle                       : 33
    *** The number of SCALAR REGISTER TRANSFER          : 8
  LOOP END

  LOOP BEGIN: (prep.F:4423)
    *** Estimated execution cycle                       : 81
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 15
            Over basic blocks                           : 15
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 15
            Over basic blocks                           : 15
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:4425)
      *** Estimated execution cycle                     : 153
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER TRANSFER        : 63

      LOOP BEGIN: (prep.F:4434)
        *** Estimated execution cycle                   : 11
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END

      LOOP BEGIN: (prep.F:4432)
        *** Estimated execution cycle                   : 11
        *** The number of SCALAR REGISTER TRANSFER      : 3
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:4439)
      *** Estimated execution cycle                     : 53
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (prep.F:4441)
        *** Estimated execution cycle                   : 50
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 5
                Over basic blocks                       : 5
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 5
                Over basic blocks                       : 5
        *** The number of SCALAR REGISTER TRANSFER      : 8

        LOOP BEGIN: (prep.F:4443)
          *** Estimated execution cycle                 : 174
          *** The number of SCALAR REGISTER TRANSFER    : 41

          LOOP BEGIN: (prep.F:4453)
            *** Estimated execution cycle               : 63
          LOOP END

          LOOP BEGIN: (prep.F:4448)
            *** Estimated execution cycle               : 63
          LOOP END
        LOOP END
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4467)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:28 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTINITCOND
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  4583: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  4627: vec( 103): Unvectorized loop.
  4627: vec( 180): I/O statement obstructs vectorization.
  4628: opt(1118): This I/O statement inhibits optimization of loop.
  4630: vec( 103): Unvectorized loop.
  4630: vec( 180): I/O statement obstructs vectorization.
  4631: opt(1118): This I/O statement inhibits optimization of loop.
  4633: vec( 103): Unvectorized loop.
  4633: vec( 180): I/O statement obstructs vectorization.
  4634: opt(1118): This I/O statement inhibits optimization of loop.
  4636: vec( 103): Unvectorized loop.
  4636: vec( 180): I/O statement obstructs vectorization.
  4637: opt(1118): This I/O statement inhibits optimization of loop.
  4640: vec( 103): Unvectorized loop.
  4640: vec( 180): I/O statement obstructs vectorization.
  4642: opt(1118): This I/O statement inhibits optimization of loop.
  4645: vec( 103): Unvectorized loop.
  4645: vec( 180): I/O statement obstructs vectorization.
  4646: opt(1118): This I/O statement inhibits optimization of loop.
  4648: vec( 103): Unvectorized loop.
  4648: vec( 180): I/O statement obstructs vectorization.
  4649: opt(1118): This I/O statement inhibits optimization of loop.
  4659: inl(1214): Expansion routine is too big for automatic expansion.: READINITCOND3D
  4791: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  4791: vec( 180): I/O statement obstructs vectorization.
  4794: inl(1212): Source for routine not found.: IWRITE
  4810: vec( 103): Unvectorized loop.
  4810: vec( 180): I/O statement obstructs vectorization.
  4812: opt(1118): This I/O statement inhibits optimization of loop.
  4815: vec( 103): Unvectorized loop.
  4815: vec( 180): I/O statement obstructs vectorization.
  4817: opt(1118): This I/O statement inhibits optimization of loop.
  4820: vec( 103): Unvectorized loop.
  4820: vec( 180): I/O statement obstructs vectorization.
  4822: opt(1118): This I/O statement inhibits optimization of loop.
  4825: vec( 103): Unvectorized loop.
  4825: vec( 180): I/O statement obstructs vectorization.
  4827: opt(1118): This I/O statement inhibits optimization of loop.
  4831: vec( 103): Unvectorized loop.
  4831: vec( 180): I/O statement obstructs vectorization.
  4833: opt(1118): This I/O statement inhibits optimization of loop.
  4837: vec( 103): Unvectorized loop.
  4837: vec( 180): I/O statement obstructs vectorization.
  4839: opt(1118): This I/O statement inhibits optimization of loop.
  4842: vec( 103): Unvectorized loop.
  4842: vec( 180): I/O statement obstructs vectorization.
  4844: opt(1118): This I/O statement inhibits optimization of loop.
  4850: inl(1222): Inlined: WRITEINITCOND3D
  4899: vec( 103): Unvectorized loop.
  4899: vec( 180): I/O statement obstructs vectorization.
  4900: opt(1118): This I/O statement inhibits optimization of loop.
  4905: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  4912: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTINITCOND
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4485:                 SUBROUTINE HOTINITCOND()
  4486:                 USE PRE_GLOBAL
  4487:                 use presizes; use memory_usage
  4488:           C
  4489:           C---------------------------------------------------------------------------C
  4490:           C                     written 10/11/01 by RL                                C
  4491:           C             started mods for harmonic analysis and 3D RL 5/22/03          C
  4492:           C         jgf Updated for v45.06 09/07/2005 not incl. harmonic or 3D        C
  4493:           C         kmd Updated for v48.33 07/07/2008 to bring in initial conditions  C
  4494:           C                                                                           C
  4495:           C  This routine reads the global initial condition file (fort.17)           C
  4496:           C  and writes local hot start files of the same format.                     C
  4497:           C                                                                           C
  4498:           C---------------------------------------------------------------------------C
  4499:           C
  4500:                 IMPLICIT NONE
  4501:                 integer(8) :: nbytes = 0
  4502:                 LOGICAL FOUND
  4503:                 INTEGER I,J,IPROC,IINDX,IHOTSTP, not_active
  4504:                 INTEGER IMHSF,ITHSF
  4505:                 CHARACTER FNAME*60,LOCFN*14
  4506:                 CHARACTER*16 FNAME1
  4507:                 CHARACTER*8 FNAM8(2)
  4508:                 EQUIVALENCE (FNAM8(1),FNAME1)
  4509:           
  4510:                 INTEGER,ALLOCATABLE  :: LOC2(:),NOFF(:), domA(:)
  4511:                 REAL(8),ALLOCATABLE :: ETA1(:),ETA2(:),EtaDisc(:),
  4512:                &    UU2(:),VV2(:),CH1(:)
  4513:                 REAL(8) TIMEHSF
  4514:                 integer :: InputFileFmtVn, NP_G_IN, NE_G_IN, NP_A_IN, NE_A_IN
  4515:                 CHARACTER*60 FileFmtVn
  4516:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  4517:                 LOGICAL Success     ! .true. if all files open without error
  4518:           
  4519:           #if 0
  4520:                 ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  4521:                 INTEGER INZ,INF,IMM,INP,INSTAE,INSTAV,IISTAE,IISTAV,IIGLOE,IIGLOV,
  4522:                &                                       IICALL,INFREQ,ITUD,NTSTEPS
  4523:                 INTEGER ITHAS,ITHAF,ITMV,IHABEG,ICHA
  4524:                 CHARACTER*10,ALLOCATABLE     ::  INAMEFR(:)
  4525:                 REAL(8)  TIMEUD
  4526:                 REAL(8),ALLOCATABLE ::  HA(:,:)
  4527:                 REAL(8),ALLOCATABLE ::  ELAV(:),ELVA(:),XVELAV(:),XVELVA(:),
  4528:                &                                         YVELAV(:),YVELVA(:)
  4529:                 REAL(8),ALLOCATABLE ::  IFREQ(:),IFF(:),IFACE(:)
  4530:                 REAL(8),ALLOCATABLE ::  GLOELV(:,:)
  4531:                 REAL(8),ALLOCATABLE ::  GLOULV(:,:),GLOVLV(:,:)
  4532:                 REAL(8),ALLOCATABLE ::  STAELV(:,:)
  4533:                 REAL(8),ALLOCATABLE ::  STAULV(:,:),STAVLV(:,:)
  4534:           #endif
  4535:           C
  4536:           C--   Open the Initial Condition Start File based on the value of IHOT from
  4537:           C--   the fort.15 file
  4538:           C
  4539:           C     Open full domain and subdomain fort.17 files
  4540:                 Print *, "Made it to prepping the files"
  4541:                 CALL OpenPrepFiles(17, 'initial condition file  ',
  4542:                &     1, nproc, SDU, Success)
  4543:                 Print *, "Made it out of prepping the files"
  4544:                 IF (.not.Success) THEN
  4545:                    WRITE(*,*) 'WARNING: Unit 17 files not preprocessed.'
  4546:                    RETURN ! note early return
  4547:                 ENDIF
  4548:                 IHOT=17
  4549:           
  4550:           C--   Read in info from global initial condition file
  4551:           
  4552:                 READ(IHOT,*) FileFmtVn
  4553:           
  4554:                 READ(IHOT,*) IMHSF
  4555:                 READ(IHOT,*) TIMEHSF
  4556:                 READ(IHOT,*) ITHSF
  4557:                 READ(IHOT,*) NP_G_IN
  4558:                 READ(IHOT,*) NE_G_IN
  4559:                 READ(IHOT,*) NP_A_IN
  4560:                 READ(IHOT,*) NE_A_IN
  4561:                 if (nnodg == np_g_in) then
  4562:                   MNP = nnodg
  4563:                 else
  4564:                   print *, "number global nodes does not match hotstart file"
  4565:                   write(*,'(A,I8)') "expected value   = ", nnodg
  4566:                   write(*,'(A,I8)') "hotstart value = ", np_g_in
  4567:                   CALL EXIT(1)
  4568:                 endif
  4569:                 if (nelg ==  ne_g_in) then
  4570:                   MNE = nelg
  4571:                 else
  4572:                   print *, "number global elements does not match hotstart file"
  4573:                   write(*,'(A,I8)') "expected value   = ", nelg
  4574:                   write(*,'(A,I8)') "hotstart value = ", ne_g_in
  4575:                   CALL EXIT(1)
  4576:                 endif
  4577:           C
  4578:           C Allocate local work arrays
  4579:           C
  4580:                 MNP = nnodg
  4581:                 MNE = nelg
  4582:                 nbytes = 4*nproc
  4583:                 call memory_alloc(nbytes)
  4584:                 ALLOCATE ( ETA1(MNP),ETA2(MNP),EtaDisc(MNP),UU2(MNP),
  4585:                &           VV2(MNP),NODECODE(MNP),CH1(MNP) )
  4586:                 nbytes = 7*mnp
  4587:                 call memory_alloc(nbytes)
  4588:                 ALLOCATE ( NOFF(MNE) )
  4589:                 nbytes = 4*mne
  4590:                 call memory_alloc(nbytes)
  4591:           
  4592:           #if 0
  4593:                 ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  4594:                 ALLOCATE ( HA(2*MNHARF,2*MNHARF) )
  4595:                 nbytes = 32*mnharf
  4596:                 call memory_alloc(nbytes)
  4597:                 ALLOCATE ( GLOELV(2*MNHARF,MNP) )
  4598:                 nbytes = 16*mnharf*mnp
  4599:                 call memory_alloc(nbytes)
  4600:                 ALLOCATE ( GLOULV(2*MNHARF,MNP),GLOVLV(2*MNHARF,MNP) )
  4601:                 nbytes = 32*mnharf*mnp
  4602:                 call memory_alloc(nbytes)
  4603:                 ALLOCATE ( STAELV(2*MNHARF,MNSTAE) )
  4604:                 nbytes = 16*mnharf*mnstae
  4605:                 call memory_alloc(nbytes)
  4606:                 ALLOCATE ( STAULV(2*MNHARF,MNSTAV),STAVLV(2*MNHARF,MNSTAV) )
  4607:                 nbytes = 16*mnharf*mnstav
  4608:                 call memory_alloc(nbytes)
  4609:                 ALLOCATE ( ELAV(MNP),ELVA(MNP) )
  4610:                 nbytes = 16*mnp
  4611:                 call memory_alloc(nbytes)
  4612:                 ALLOCATE ( XVELAV(MNP),XVELVA(MNP),YVELAV(MNP),YVELVA(MNP) )
  4613:                 nbytes = 32*mnp
  4614:                 call memory_alloc(nbytes)
  4615:                 ALLOCATE ( IFREQ(MNHARF),IFF(MNHARF),IFACE(MNHARF) )
  4616:                 nbytes = 12*mnharf
  4617:                 call memory_alloc(nbytes)
  4618:                 ALLOCATE ( INAMEFR(MNHARF) )
  4619:                 nbytes = 4*mnharf
  4620:                 call memory_alloc(nbytes)
  4621:           #endif
  4622:           !  Continue reading global initial condition file
  4623:                 print *, "continuing to read global initial condition file"
  4624:                 write(*,*) "enter number of layers: "
  4625:                 read(*,*) NFEN
  4626:           
  4627: +------>        DO I=1,MNP
  4628: |                  READ(IHOT,*) ETA1(I)
  4629: +------         END DO
  4630: +------>        DO I=1,MNP
  4631: |                  READ(IHOT,*) ETA2(I)
  4632: +------         END DO
  4633: +------>        DO I=1,MNP
  4634: |                  READ(IHOT,*) UU2(I)
  4635: +------         END DO
  4636: +------>        DO I=1,MNP
  4637: |                  READ(IHOT,*) VV2(I)
  4638: +------         END DO
  4639:                 IF(IM.EQ.10) THEN
  4640: +------>          DO I=1,MNP
  4641: |                    IHOTSTP=IHOTSTP+1
  4642: |                    READ(IHOT,REC=IHOTSTP) CH1(I)
  4643: +------           END DO
  4644:                 ENDIF
  4645: +------>        DO I=1,MNP
  4646: |                  READ(IHOT,*) NODECODE(I)
  4647: +------         END DO
  4648: +------>        DO I=1,MNE
  4649: |                  READ(IHOT,*) NOFF(I)
  4650: +------         END DO
  4651:           
  4652:                 PRINT *, "Made it through the 2D values"
  4653:           
  4654:                  ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  4655:           C     jgf46.02 Read in 3D hotstart data if appropriate
  4656:                 IF (IMHSF.GT.10) THEN
  4657:                    PRINT *, "set to go into 3D read"
  4658:                    PRINT *, "NFEN = ", NFEN
  4659:                    CALL ReadInitCond3D(IHOT)
  4660:                 ENDIF
  4661:           #if 0
  4662:           C
  4663:           C.....DETERMINE HARMONIC ANALYSIS PARAMETERS
  4664:           
  4665:                 IHARIND=NHARFR*(NHASE+NHASV+NHAGE+NHAGV)
  4666:                 IF(IHARIND.GT.0) IHARIND=1
  4667:           
  4668:           C.....IF HARMONIC ANALYSIS IS INCLUDED IN THE RUN, PROCESS HOT START INFORMATION FOR
  4669:           C.....IN PROGRESS HARMONIC ANALYSIS
  4670:           
  4671:                 IF(IHARIND.EQ.1) THEN
  4672:                    ITHAS=INT((THAS-STATIM)*(86400.D0/DT) + 0.5d0)
  4673:                    ITHAF=INT((THAF-STATIM)*(86400.D0/DT) + 0.5d0)
  4674:                    ITMV = ITHAF - (ITHAF-ITHAS)*FMV
  4675:                    IHABEG=ITHAS+NHAINC
  4676:           
  4677:           C.......IF HARMONIC ANALYSIS HAS ALREADY BEGUN, READ IN HOT START
  4678:           C........HARMONIC ANALYSIS, MEAN AND SQUARE INFO
  4679:           
  4680:                    IF(ITHSF.GT.ITHAS) THEN
  4681:                       IHOTSTP=IHOTSTP+1
  4682:                       READ(IHOT,REC=IHOTSTP) ICHA
  4683:                    ENDIF
  4684:           
  4685:                    IF(ITHSF.GE.IHABEG) THEN
  4686:                       READ(IHOT,REC=IHOTSTP+1) INZ
  4687:                       READ(IHOT,REC=IHOTSTP+2) INF
  4688:                       READ(IHOT,REC=IHOTSTP+3) IMM
  4689:                       READ(IHOT,REC=IHOTSTP+4) INP
  4690:                       READ(IHOT,REC=IHOTSTP+5) INSTAE
  4691:                       READ(IHOT,REC=IHOTSTP+6) INSTAV
  4692:                       READ(IHOT,REC=IHOTSTP+7) IISTAE
  4693:                       READ(IHOT,REC=IHOTSTP+8) IISTAV
  4694:                       READ(IHOT,REC=IHOTSTP+9) IIGLOE
  4695:                       READ(IHOT,REC=IHOTSTP+10) IIGLOV
  4696:                       READ(IHOT,REC=IHOTSTP+11) IICALL
  4697:                       READ(IHOT,REC=IHOTSTP+12) INFREQ
  4698:                       IHOTSTP = IHOTSTP+12
  4699:           
  4700:                       DO I=1,INFREQ+INF
  4701:                          READ(IHOT,REC=IHOTSTP+1) FNAM8(1)
  4702:                          READ(IHOT,REC=IHOTSTP+2) FNAM8(2)
  4703:                          IHOTSTP = IHOTSTP + 2
  4704:                          INAMEFR(I) = FNAME1
  4705:                          READ(IHOT,REC=IHOTSTP+1) IFREQ(I)
  4706:                          READ(IHOT,REC=IHOTSTP+2) IFF(I)
  4707:                          READ(IHOT,REC=IHOTSTP+3) IFACE(I)
  4708:                          IHOTSTP = IHOTSTP + 3
  4709:                       ENDDO
  4710:           
  4711:                       READ(IHOT,REC=IHOTSTP+1) TIMEUD
  4712:                       READ(IHOT,REC=IHOTSTP+2) ITUD
  4713:                       IHOTSTP = IHOTSTP + 2
  4714:           
  4715:                       DO I=1,IMM
  4716:                          DO J=1,IMM
  4717:                             IHOTSTP = IHOTSTP + 1
  4718:                             READ(IHOT,REC=IHOTSTP) HA(I,J)
  4719:                          ENDDO
  4720:                       ENDDO
  4721:           
  4722:                       IF(NHASE.ne.0) THEN
  4723:                          DO J=1,INSTAE
  4724:                             DO I=1,IMM
  4725:                                IHOTSTP=IHOTSTP+1
  4726:                                READ(IHOT,REC=IHOTSTP) STAELV(I,J)
  4727:                             ENDDO
  4728:                          ENDDO
  4729:                       ENDIF
  4730:           
  4731:                       IF(NHASV.ne.0) THEN
  4732:                          DO J=1,INSTAV
  4733:                             DO I=1,IMM
  4734:                                READ(IHOT,REC=IHOTSTP+1) STAULV(I,J)
  4735:                                READ(IHOT,REC=IHOTSTP+2) STAVLV(I,J)
  4736:                                IHOTSTP = IHOTSTP + 2
  4737:                             ENDDO
  4738:                          ENDDO
  4739:                       ENDIF
  4740:           
  4741:                       IF(NHAGE.ne.0) THEN
  4742:                          DO J=1,INP
  4743:                             DO I=1,IMM
  4744:                                IHOTSTP=IHOTSTP+1
  4745:                                READ(IHOT,REC=IHOTSTP) GLOELV(I,J)
  4746:                             ENDDO
  4747:                          ENDDO
  4748:                       ENDIF
  4749:           
  4750:                       IF(NHAGV.ne.0) THEN
  4751:                          DO J=1,INP
  4752:                             DO I=1,IMM
  4753:                                READ(IHOT,REC=IHOTSTP+1) GLOULV(I,J)
  4754:                                READ(IHOT,REC=IHOTSTP+2) GLOVLV(I,J)
  4755:                                IHOTSTP = IHOTSTP + 2
  4756:                             ENDDO
  4757:                          ENDDO
  4758:                       ENDIF
  4759:           
  4760:                    ENDIF
  4761:           
  4762:                    IF((FMV.GT.0.).AND.(INFREQ.GT.0).AND.(IM.EQ.0)) THEN !include means and variances
  4763:                       IF(ITHSF.GT.ITMV) THEN
  4764:                          IHOTSTP=IHOTSTP+1
  4765:                          READ(IHOT,REC=IHOTSTP) NTSTEPS
  4766:                          IF(NHAGE.EQ.1) THEN
  4767:                             DO I=1,INP
  4768:                                READ(IHOT,REC=IHOTSTP+1) ELAV(I)
  4769:                                READ(IHOT,REC=IHOTSTP+2) ELVA(I)
  4770:                                IHOTSTP=IHOTSTP+2
  4771:                             ENDDO
  4772:                          ENDIF
  4773:                          IF(NHAGV.EQ.1) THEN
  4774:                             DO I=1,INP
  4775:                                READ(IHOT,REC=IHOTSTP+1) XVELAV(I)
  4776:                                READ(IHOT,REC=IHOTSTP+2) YVELAV(I)
  4777:                                READ(IHOT,REC=IHOTSTP+3) XVELVA(I)
  4778:                                READ(IHOT,REC=IHOTSTP+4) YVELVA(I)
  4779:                                IHOTSTP=IHOTSTP+4
  4780:                             ENDDO
  4781:                          ENDIF
  4782:                       ENDIF
  4783:                    ENDIF    ! charmv
  4784:                 ENDIF     ! HARIND
  4785:           #endif
  4786:           
  4787:           C
  4788:           C--Open All Local Hot Start files
  4789:           C
  4790:                 ALLOCATE ( LOC2(NPROC) )
  4791: +------>        DO IPROC = 1,NPROC
  4792: |                  LOC2(IPROC) = 105 + (IPROC-1)
  4793: |+=====>           LOCFN(1:14) = 'PE0000/'//FNAME(1:7)
  4794: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
  4795: |                  OPEN (LOC2(IPROC),FILE=LOCFN)
  4796: +------         ENDDO
  4797:           C
  4798:           C--Write out info to local hot start files
  4799:           C
  4800: +------>        DO IPROC = 1,NPROC
  4801: |                  WRITE(LOC2(IPROC),*) FileFmtVn
  4802: |                  WRITE(LOC2(IPROC),*) IMHSF
  4803: |                  WRITE(LOC2(IPROC),*) TIMEHSF
  4804: |                  WRITE(LOC2(IPROC),*) ITHSF
  4805: |                  WRITE(LOC2(IPROC),*) NNODP(IPROC)
  4806: |                  WRITE(LOC2(IPROC),*) NELP(IPROC)
  4807: |                  WRITE(LOC2(IPROC),*) NNODP(IPROC)
  4808: |                  WRITE(LOC2(IPROC),*) NELP(IPROC)
  4809: |         
  4810: |+----->           DO I=1, NNODP(IPROC)
  4811: ||                    IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4812: ||                    WRITE(LOC2(IPROC),*) ETA1(IINDX)
  4813: |+-----            END DO
  4814: |         
  4815: |+----->           DO I=1, NNODP(IPROC)
  4816: ||                    IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4817: ||                    WRITE(LOC2(IPROC),*) ETA2(IINDX)
  4818: |+-----            END DO
  4819: |         
  4820: |+----->           DO I=1, NNODP(IPROC)
  4821: ||                    IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4822: ||                    WRITE(LOC2(IPROC),*) UU2(IINDX)
  4823: |+-----            END DO
  4824: |         
  4825: |+----->           DO I=1, NNODP(IPROC)
  4826: ||                    IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4827: ||                    WRITE(LOC2(IPROC),*) VV2(IINDX)
  4828: |+-----            END DO
  4829: |         
  4830: |                  IF(IM.EQ.10) THEN
  4831: |+----->              DO I=1, NNODP(IPROC)
  4832: ||                       IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4833: ||                       WRITE(LOC2(IPROC),*) CH1(IINDX)
  4834: |+-----               END DO
  4835: |                  ENDIF
  4836: |         
  4837: |+----->           DO I=1, NNODP(IPROC)
  4838: ||                    IINDX = ABS(IMAP_NOD_LG(I,IPROC))
  4839: ||                    WRITE(LOC2(IPROC),*) NODECODE(IINDX)
  4840: |+-----            END DO
  4841: |         
  4842: |+----->           DO I=1,NELP(IPROC)
  4843: ||                    IINDX=ABS(IMAP_EL_LG(I,IPROC))
  4844: ||                    WRITE(LOC2(IPROC),*) NOFF(IINDX)
  4845: |+-----            END DO
  4846: |         
  4847: |         C
  4848: |         C     jgf46.02 Write out 3D hotstart data if appropriate
  4849: |                  IF (IMHSF.GT.10) THEN
  4850: |       I             CALL WriteInitCond3D(LOC2(IPROC),IPROC)
  4851: |                  ENDIF
  4852: |         #if 0
  4853: |         C
  4854: |         C....IF APPROPRIATE, WRITE OUT HOT START INFORMATION FOR IN PROGRESS HARMONIC ANALYSIS
  4855: |         
  4856: |         c       IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITHAS)) THEN
  4857: |         c         WRITE(LOC2(IPROC),REC=IHOTSTP+1) ICHA
  4858: |         c         IHOTSTP = IHOTSTP + 1
  4859: |         c         CALL HAHOUT(NP,NSTAE,NSTAV,NHASE,NHASV,NHAGE,NHAGV,
  4860: |         c    &                LOC2(IPROC),IHOTSTP)
  4861: |         c
  4862: |         c         IF(NHASE.EQ.1) CALL HAHOUTES(NSTAE,LOC2(IPROC),IHOTSTP)
  4863: |         c         IF(NHASV.EQ.1) CALL HAHOUTVS(NSTAV,LOC2(IPROC),IHOTSTP)
  4864: |         c         IF(NHAGE.EQ.1) CALL HAHOUTEG(MNP,LOC2(IPROC),IHOTSTP)
  4865: |         c         IF(NHAGV.EQ.1) CALL HAHOUTVG(MNP,LOC2(IPROC),IHOTSTP)
  4866: |         c         ENDIF
  4867: |         c
  4868: |         c       if(CHARMV) then
  4869: |         c         IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITMV)) THEN
  4870: |         c           IHOTSTP=IHOTSTP+1
  4871: |         c           WRITE(LOC2(IPROC),REC=IHOTSTP) NTSTEPS
  4872: |         c           IF(NHAGE.EQ.1) THEN
  4873: |         c             DO I=1, NNODP(IPROC)
  4874: |         c               IINDX = IMAP_NOD_LG(I,IPROC)
  4875: |         c               DO I=1,MNP
  4876: |         c                 WRITE(LOC2(IPROC),REC=IHOTSTP+1) ELAV(IINDX)
  4877: |         c                 WRITE(LOC2(IPROC),REC=IHOTSTP+2) ELVA(IINDX)
  4878: |         c                 IHOTSTP=IHOTSTP+2
  4879: |         c                 END DO
  4880: |         c             ENDIF
  4881: |         c           IF(NHAGV.EQ.1) THEN
  4882: |         c             DO I=1,NNODP(IPROC)
  4883: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+1) XVELAV(IINDX)
  4884: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+2) YVELAV(IINDX)
  4885: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+3) XVELVA(IINDX)
  4886: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+4) YVELVA(IINDX)
  4887: |         c               IHOTSTP=IHOTSTP+4
  4888: |         c               END DO
  4889: |         c             ENDIF
  4890: |         c           ENDIF
  4891: |         c         ENDIF
  4892: |         #endif
  4893: |         
  4894: +------         ENDDO
  4895:           C
  4896:           C--Close Global file and all the Local Files
  4897:           C
  4898:                 CLOSE (IHOT)
  4899: +------>        DO IPROC=1, NPROC
  4900: |                  CLOSE (LOC2(IPROC))
  4901: +------         ENDDO
  4902:           C
  4903:                 DEALLOCATE ( LOC2 )
  4904:                 nbytes = 4*nproc
  4905:                 call memory_dealloc(nbytes)
  4906:                 DEALLOCATE ( ETA1, ETA2, EtaDisc, UU2, VV2, NODECODE, CH1 )
  4907:                 nbytes = 7*mnp
  4908:                 call memory_dealloc(nbytes)
  4909:                 DEALLOCATE ( NOFF )
  4910:                 nbytes = 6*mne
  4911:                 call memory_dealloc(nbytes)
  4912:                 call memory_status()
  4913:           C
  4914:                 RETURN
  4915:            1001 FORMAT('ERROR: The hot start file')
  4916:            1010 FORMAT(' File ',A60,/,' WAS NOT FOUND!  ADCPrep Terminated!!!',/)
  4917:            1011 FORMAT(' File ',A60,/,' WAS FOUND!  Opening & Processing file',/)
  4918:            1012 FORMAT('was a nonmatching version')
  4919:            1005 FORMAT('exists but cannot be opened.')
  4920:            9973 FORMAT(/,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
  4921:                 END SUBROUTINE HOTINITCOND


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:28 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTINITCOND
INLINE LIST

  ROOT: HOTINITCOND (prep.F:4485)
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4583)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4587)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:4590)
     *** Source for routine not found.
  -> NOINLINE: READINITCOND3D (prep.F:4659)
     *** Expansion routine is too big for automatic expansion.
  -> NOINLINE: IWRITE (prep.F:4794)
     *** Source for routine not found.
  -> INLINE: WRITEINITCOND3D (prep.F:4850)
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4905)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4908)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:4911)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:4912)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:28 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTINITCOND
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:4627)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4627)
  LOOP END

  LOOP BEGIN: (prep.F:4630)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4630)
  LOOP END

  LOOP BEGIN: (prep.F:4633)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4633)
  LOOP END

  LOOP BEGIN: (prep.F:4636)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4636)
  LOOP END

  LOOP BEGIN: (prep.F:4640)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4640)
  LOOP END

  LOOP BEGIN: (prep.F:4645)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4645)
  LOOP END

  LOOP BEGIN: (prep.F:4648)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4648)
  LOOP END

  LOOP BEGIN: (prep.F:4791)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:4791)
    *** I/O statement obstructs vectorization. (prep.F:4791)

    LOOP BEGIN: (prep.F:4793)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:4793)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4800)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:4810)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4810)
    LOOP END

    LOOP BEGIN: (prep.F:4815)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4815)
    LOOP END

    LOOP BEGIN: (prep.F:4820)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4820)
    LOOP END

    LOOP BEGIN: (prep.F:4825)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4825)
    LOOP END

    LOOP BEGIN: (prep.F:4831)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4831)
    LOOP END

    LOOP BEGIN: (prep.F:4837)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4837)
    LOOP END

    LOOP BEGIN: (prep.F:4842)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:4842)
    LOOP END

    LOOP BEGIN: (prep.F:6809)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6809)
    LOOP END

    LOOP BEGIN: (prep.F:6814)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6814)
    LOOP END

    LOOP BEGIN: (prep.F:6819)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6820)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6820)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6825)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6826)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6826)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6831)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6832)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6832)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6837)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6838)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6838)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6843)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6844)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6844)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6850)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6851)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6851)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6858)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6859)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6859)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6866)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6867)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6867)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6874)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6875)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6875)
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6880)
      <Unvectorized loop.>

      LOOP BEGIN: (prep.F:6881)
        <Unvectorized loop.>
        *** I/O statement obstructs vectorization. (prep.F:6881)
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4899)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:4899)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:28 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTINITCOND
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 6304 bytes
      Register spill area      : 1832 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 4136 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4627)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:4630)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:4633)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:4636)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:4640)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:4645)
    *** Estimated execution cycle                       : 34
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:4648)
    *** Estimated execution cycle                       : 27
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:4791)
    *** Estimated execution cycle                       : 287
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 28
            Across calls                                :  2
            Over basic blocks                           : 26
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 29
            Across calls                                :  3
            Over basic blocks                           : 26
    *** The number of SCALAR REGISTER TRANSFER          : 35

    LOOP BEGIN: (prep.F:4793)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4800)
    *** Estimated execution cycle                       : 1326
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 120
            Across calls                                :  13
            Over basic blocks                           : 105
            Others                                      :   2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 277
            Across calls                                :  63
            Over basic blocks                           : 214
    *** The number of SCALAR REGISTER TRANSFER          : 163

    LOOP BEGIN: (prep.F:4810)
      *** Estimated execution cycle                     : 96
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 6
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  8
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END

    LOOP BEGIN: (prep.F:4815)
      *** Estimated execution cycle                     : 96
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 6
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 15
              Across calls                              :  8
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END

    LOOP BEGIN: (prep.F:4820)
      *** Estimated execution cycle                     : 93
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 6
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 14
              Across calls                              :  8
              Over basic blocks                         :  6
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END

    LOOP BEGIN: (prep.F:4825)
      *** Estimated execution cycle                     : 80
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 4
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  6
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:4831)
      *** Estimated execution cycle                     : 82
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 5
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  5
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END

    LOOP BEGIN: (prep.F:4837)
      *** Estimated execution cycle                     : 74
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 2
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 8
              Across calls                              : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:4842)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 2
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 2
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:6809)
      *** Estimated execution cycle                     : 75
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 3
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END

    LOOP BEGIN: (prep.F:6814)
      *** Estimated execution cycle                     : 83
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 4
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 4
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END

    LOOP BEGIN: (prep.F:6819)
      *** Estimated execution cycle                     : 27
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:6820)
        *** Estimated execution cycle                   : 67
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 2
                Across calls                            : 2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 3
                Across calls                            : 2
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER TRANSFER      : 10
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6825)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10

      LOOP BEGIN: (prep.F:6826)
        *** Estimated execution cycle                   : 79
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 4
                Across calls                            : 4
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 7
                Across calls                            : 4
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER TRANSFER      : 12
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6831)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 8

      LOOP BEGIN: (prep.F:6832)
        *** Estimated execution cycle                   : 84
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 5
                Across calls                            : 5
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 9
                Across calls                            : 5
                Over basic blocks                       : 4
        *** The number of SCALAR REGISTER TRANSFER      : 11
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6837)
      *** Estimated execution cycle                     : 30
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (prep.F:6838)
        *** Estimated execution cycle                   : 89
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 6
                Across calls                            : 5
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 10
                Across calls                            :  5
                Over basic blocks                       :  5
        *** The number of SCALAR REGISTER TRANSFER      : 12
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6843)
      *** Estimated execution cycle                     : 29
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:6844)
        *** Estimated execution cycle                   : 93
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 7
                Across calls                            : 6
                Over basic blocks                       : 1
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 11
                Across calls                            :  6
                Over basic blocks                       :  5
        *** The number of SCALAR REGISTER TRANSFER      : 13
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6850)
      *** Estimated execution cycle                     : 33
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Over basic blocks                         : 5
      *** The number of SCALAR REGISTER TRANSFER        : 8

      LOOP BEGIN: (prep.F:6851)
        *** Estimated execution cycle                   : 98
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 8
                Across calls                            : 6
                Over basic blocks                       : 2
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 12
                Across calls                            :  6
                Over basic blocks                       :  6
        *** The number of SCALAR REGISTER TRANSFER      : 14
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6858)
      *** Estimated execution cycle                     : 34
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (prep.F:6859)
        *** Estimated execution cycle                   : 103
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 6
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 13
                Across calls                            :  6
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 15
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6866)
      *** Estimated execution cycle                     : 34
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER TRANSFER        : 7

      LOOP BEGIN: (prep.F:6867)
        *** Estimated execution cycle                   : 103
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 6
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 13
                Across calls                            :  6
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 15
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6874)
      *** Estimated execution cycle                     : 32
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER TRANSFER        : 4

      LOOP BEGIN: (prep.F:6875)
        *** Estimated execution cycle                   : 103
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 6
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 13
                Across calls                            :  6
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 15
      LOOP END
    LOOP END

    LOOP BEGIN: (prep.F:6880)
      *** Estimated execution cycle                     : 33
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Over basic blocks                         : 6
      *** The number of SCALAR REGISTER TRANSFER        : 6

      LOOP BEGIN: (prep.F:6881)
        *** Estimated execution cycle                   : 103
        *** The number of SCALAR REGISTER SPILL
              Total                                     : 9
                Across calls                            : 6
                Over basic blocks                       : 3
        *** The number of SCALAR REGISTER RESTORE
              Total                                     : 13
                Across calls                            :  6
                Over basic blocks                       :  7
        *** The number of SCALAR REGISTER TRANSFER      : 15
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:4899)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTLOCALIZE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5014: inl(1212): Source for routine not found.: PRE_GLOBAL::CMP_VERSION_NUMBERS
  5050: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  5062: vec( 103): Unvectorized loop.
  5062: vec( 180): I/O statement obstructs vectorization.
  5063: opt(1118): This I/O statement inhibits optimization of loop.
  5065: vec( 103): Unvectorized loop.
  5065: vec( 180): I/O statement obstructs vectorization.
  5066: opt(1118): This I/O statement inhibits optimization of loop.
  5068: vec( 103): Unvectorized loop.
  5068: vec( 180): I/O statement obstructs vectorization.
  5069: opt(1118): This I/O statement inhibits optimization of loop.
  5071: vec( 103): Unvectorized loop.
  5071: vec( 180): I/O statement obstructs vectorization.
  5072: opt(1118): This I/O statement inhibits optimization of loop.
  5074: vec( 103): Unvectorized loop.
  5074: vec( 180): I/O statement obstructs vectorization.
  5075: opt(1118): This I/O statement inhibits optimization of loop.
  5078: vec( 103): Unvectorized loop.
  5078: vec( 180): I/O statement obstructs vectorization.
  5079: opt(1118): This I/O statement inhibits optimization of loop.
  5082: vec( 103): Unvectorized loop.
  5082: vec( 180): I/O statement obstructs vectorization.
  5083: opt(1118): This I/O statement inhibits optimization of loop.
  5086: vec( 103): Unvectorized loop.
  5086: vec( 180): I/O statement obstructs vectorization.
  5087: opt(1118): This I/O statement inhibits optimization of loop.
  5125: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: READHOTSTART3D
  5261: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  5261: vec( 180): I/O statement obstructs vectorization.
  5264: inl(1212): Source for routine not found.: IWRITE
  5289: vec( 103): Unvectorized loop.
  5289: vec( 180): I/O statement obstructs vectorization.
  5291: opt(1118): This I/O statement inhibits optimization of loop.
  5295: vec( 103): Unvectorized loop.
  5295: vec( 180): I/O statement obstructs vectorization.
  5297: opt(1118): This I/O statement inhibits optimization of loop.
  5301: vec( 103): Unvectorized loop.
  5301: vec( 180): I/O statement obstructs vectorization.
  5303: opt(1118): This I/O statement inhibits optimization of loop.
  5307: vec( 103): Unvectorized loop.
  5307: vec( 180): I/O statement obstructs vectorization.
  5309: opt(1118): This I/O statement inhibits optimization of loop.
  5313: vec( 103): Unvectorized loop.
  5313: vec( 180): I/O statement obstructs vectorization.
  5315: opt(1118): This I/O statement inhibits optimization of loop.
  5320: vec( 103): Unvectorized loop.
  5320: vec( 180): I/O statement obstructs vectorization.
  5322: opt(1118): This I/O statement inhibits optimization of loop.
  5327: vec( 103): Unvectorized loop.
  5327: vec( 180): I/O statement obstructs vectorization.
  5329: opt(1118): This I/O statement inhibits optimization of loop.
  5333: vec( 103): Unvectorized loop.
  5333: vec( 180): I/O statement obstructs vectorization.
  5335: opt(1118): This I/O statement inhibits optimization of loop.
  5373: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WRITEHOTSTART3D
  5423: vec( 103): Unvectorized loop.
  5423: vec( 180): I/O statement obstructs vectorization.
  5424: opt(1118): This I/O statement inhibits optimization of loop.
  5429: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  5471: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTLOCALIZE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  4924:                 SUBROUTINE HOTLOCALIZE()
  4925:                 USE VERSION
  4926:                 USE PRE_GLOBAL
  4927:                 use presizes; use memory_usage
  4928:           C
  4929:           C---------------------------------------------------------------------------C
  4930:           C                     written 10/11/01 by RL                                C
  4931:           C             started mods for harmonic analysis and 3D RL 5/22/03          C
  4932:           C         jgf Updated for v45.06 09/07/2005 not incl. harmonic or 3D        C
  4933:           C         kmd48.33bc updated with 3D information                            C
  4934:           C                                                                           C
  4935:           C  This routine reads the global hot start file (either fort.67 or fort.68) C
  4936:           C  and writes local hot start files of the same format.                     C
  4937:           C                                                                           C
  4938:           C---------------------------------------------------------------------------C
  4939:           C
  4940:                 IMPLICIT NONE
  4941:                 integer(8) :: nbytes = 0
  4942:                 LOGICAL FOUND
  4943:                 INTEGER I,J,IPROC,INDX,IHOTSTP, not_active
  4944:                 INTEGER IMHSF,ITHSF, NH, N
  4945:                 CHARACTER FNAME*60,LOCFN*14
  4946:                 CHARACTER*16 FNAME1
  4947:                 CHARACTER*8 FNAM8(2)
  4948:                 EQUIVALENCE (FNAM8(1),FNAME1)
  4949:           
  4950:                 INTEGER,ALLOCATABLE  :: LOC2(:),NOFF(:), domA(:)
  4951:                 REAL(8),ALLOCATABLE :: ETA1(:),ETA2(:),EtaDisc(:),
  4952:                &    UU2(:),VV2(:),CH1(:)
  4953:                 REAL(8) TIMEHSF
  4954:                 integer :: InputFileFmtVn, NP_G_IN, NE_G_IN, NP_A_IN, NE_A_IN
  4955:           
  4956:                 INTEGER INZ,INF,IMM,INP,INSTAE,INSTAV,IISTAE,IISTAV,IIGLOE,IIGLOV,
  4957:                &                                       IICALL,INFREQ,ITUD,NTSTEPS
  4958:                 INTEGER IHARIND,ITHAS,ITHAF,ITMV,IHABEG,ICHA
  4959:                 CHARACTER*10,ALLOCATABLE     ::  INAMEFR(:)
  4960:                 REAL(8)  TIMEUD
  4961:                 REAL(8),ALLOCATABLE ::  HA(:,:)
  4962:                 REAL(8),ALLOCATABLE ::  ELAV(:),ELVA(:),XVELAV(:),XVELVA(:),
  4963:                &                                         YVELAV(:),YVELVA(:)
  4964:                 REAL(8),ALLOCATABLE ::  IFREQ(:),IFF(:),IFACE(:)
  4965:                 REAL(8),ALLOCATABLE ::  GLOELV(:,:)
  4966:                 REAL(8),ALLOCATABLE ::  GLOULV(:,:),GLOVLV(:,:)
  4967:                 REAL(8),ALLOCATABLE ::  STAELV(:,:)
  4968:                 REAL(8),ALLOCATABLE ::  STAULV(:,:),STAVLV(:,:)
  4969:                 REAL(8) TIME
  4970:           
  4971:                 REAL(8) DUMMY
  4972:                 INTEGER IDUMMY
  4973:                 INTEGER LUN
  4974:                 INTEGER NHS
  4975:           C
  4976:           C--   Open Appropriate Hot Start File based on the value of IHOT from
  4977:           C--   the fort.15 file
  4978:           C
  4979:                 write(*,*) "enter IHOT: "
  4980:                 read(*,*) IHOT
  4981:                 SELECT CASE (IHOT)
  4982:                 CASE(67)
  4983: +======>           FNAME='fort.67'
  4984:                 CASE(68)
  4985: +======>           FNAME='fort.68'
  4986:                 CASE(367,368)
  4987:                    write(*,*) "INFO: IHOT=",IHOT,
  4988:                &      " means parallel ADCIRC should read a NetCDF hotstart file."
  4989:                    write(*,*)
  4990:                &      "INFO: NetCDF hotstart files do not require decomposition."
  4991:                    RETURN
  4992:                 CASE DEFAULT
  4993:                    write(*,*) "ERROR: The IHOT value ",IHOT,
  4994:                &      " is not a valid option."
  4995:                    write(*,*) "INFO: 67 and 68 are the only valid options."
  4996:                    RETURN
  4997:                 END SELECT
  4998:           C
  4999:                 INQUIRE(FILE=FNAME,EXIST=FOUND)
  5000:                 IF (FOUND) THEN
  5001:                    WRITE(*,1011) FNAME
  5002:                    IF(IHOT.EQ.67.OR.IHOT.EQ.68)
  5003:                &      OPEN(IHOT,FILE=FNAME,ACCESS='DIRECT',RECL=8)
  5004:                 ELSE
  5005:                    WRITE(*,1010) FNAME
  5006:                    CALL EXIT(1)
  5007:                 ENDIF
  5008:           
  5009:           C--   Read in info from global hot start files
  5010:           
  5011:                 IHOTSTP=1
  5012:                 READ(IHOT,REC=IHOTSTP) InputFileFmtVn ; IHOTSTP = IHOTSTP + 1
  5013:           
  5014:                 if (.not. CMP_VERSION_NUMBERS(InputFileFmtVn, FileFmtVersion))then
  5015:                   write(*, 1001)
  5016:                   write(*, 1012)
  5017:                   write(*, 9973)
  5018:                   !stop
  5019:                 endif
  5020:           
  5021:                 READ(IHOT,REC=IHOTSTP) IMHSF        ; IHOTSTP = IHOTSTP + 1
  5022:                 READ(IHOT,REC=IHOTSTP) TIMEHSF      ; IHOTSTP = IHOTSTP + 1
  5023:                 READ(IHOT,REC=IHOTSTP) ITHSF        ; IHOTSTP = IHOTSTP + 1
  5024:                 READ(IHOT,REC=IHOTSTP) NP_G_IN      ; IHOTSTP = IHOTSTP + 1
  5025:                 READ(IHOT,REC=IHOTSTP) NE_G_IN      ; IHOTSTP = IHOTSTP + 1
  5026:                 READ(IHOT,REC=IHOTSTP) NP_A_IN      ; IHOTSTP = IHOTSTP + 1
  5027:                 READ(IHOT,REC=IHOTSTP) NE_A_IN      ; IHOTSTP = IHOTSTP + 1
  5028:                 if (nnodg == np_g_in) then
  5029:                   MNP = nnodg
  5030:                   print *, "MNP = ", MNP
  5031:                 else
  5032:                   print *, "number global nodes does not match hotstart file"
  5033:                   write(*,'(A,I8)') "expected value   = ", nnodg
  5034:                   write(*,'(A,I8)') "hotstart value = ", np_g_in
  5035:                   CALL EXIT(1)
  5036:                 endif
  5037:                 if (nelg ==  ne_g_in) then
  5038:                   MNE = nelg
  5039:                 else
  5040:                   print *, "number global elements does not match hotstart file"
  5041:                   write(*,'(A,I8)') "expected value   = ", nelg
  5042:                   write(*,'(A,I8)') "hotstart value = ", ne_g_in
  5043:                   CALL EXIT(1)
  5044:                 endif
  5045:                 PRINT *, "IMHSF ", IMHSF
  5046:           C
  5047:           C Allocate local work arrays
  5048:           C
  5049:                 nbytes = 4*nproc
  5050:                 call memory_alloc(nbytes)
  5051:                 ALLOCATE ( ETA1(MNP),ETA2(MNP),EtaDisc(MNP),UU2(MNP),
  5052:                &           VV2(MNP),NODECODE(MNP),CH1(MNP) )
  5053:                 nbytes = 7*mnp*8
  5054:                 call memory_alloc(nbytes)
  5055:                 ALLOCATE ( NOFF(MNE) )
  5056:                 nbytes = 4*mne
  5057:                 call memory_alloc(nbytes)
  5058:           
  5059:           !  Continue reading global hot start file
  5060:                 print *, "continuing to read global hotstart file"
  5061:           
  5062: +------>        DO I=1,MNP
  5063: |                  READ(IHOT,REC=IHOTSTP) ETA1(I) ; IHOTSTP = IHOTSTP + 1
  5064: +------         END DO
  5065: +------>        DO I=1,MNP
  5066: |                  READ(IHOT,REC=IHOTSTP) ETA2(I) ; IHOTSTP = IHOTSTP + 1
  5067: +------         END DO
  5068: +------>        DO I=1,MNP
  5069: |                  READ(IHOT,REC=IHOTSTP) EtaDisc(I) ; IHOTSTP = IHOTSTP + 1
  5070: +------         END DO
  5071: +------>        DO I=1,MNP
  5072: |                  READ(IHOT,REC=IHOTSTP) UU2(I) ; IHOTSTP = IHOTSTP + 1
  5073: +------         END DO
  5074: +------>        DO I=1,MNP
  5075: |                  READ(IHOT,REC=IHOTSTP) VV2(I) ; IHOTSTP = IHOTSTP + 1
  5076: +------         END DO
  5077:                 IF(IMHSF.EQ.10) THEN
  5078: +------>          DO I=1,MNP
  5079: |                    READ(IHOT,REC=IHOTSTP) CH1(I) ; IHOTSTP = IHOTSTP + 1
  5080: +------           END DO
  5081:                 ENDIF
  5082: +------>        DO I=1,MNP
  5083: |                  READ(IHOT,REC=IHOTSTP) NODECODE(I) ; IHOTSTP = IHOTSTP + 1
  5084: +------         END DO
  5085:           
  5086: +------>        DO I=1,MNE
  5087: |                  READ(IHOT,REC=IHOTSTP) NOFF(I)  ; IHOTSTP = IHOTSTP + 1
  5088: +------         END DO
  5089:           
  5090:                 READ(IHOT,REC=IHOTSTP) IESTP ; IHOTSTP = IHOTSTP + 1
  5091:                 READ(IHOT,REC=IHOTSTP) NSCOUE ; IHOTSTP = IHOTSTP + 1
  5092:           
  5093:                 READ(IHOT,REC=IHOTSTP) IVSTP ; IHOTSTP = IHOTSTP + 1
  5094:                 READ(IHOT,REC=IHOTSTP) NSCOUV ; IHOTSTP = IHOTSTP + 1
  5095:           
  5096:                 READ(IHOT,REC=IHOTSTP) ICSTP ; IHOTSTP = IHOTSTP + 1
  5097:                 READ(IHOT,REC=IHOTSTP) NSCOUC ; IHOTSTP = IHOTSTP + 1
  5098:           
  5099:                 READ(IHOT,REC=IHOTSTP) IPSTP ; IHOTSTP = IHOTSTP + 1
  5100:                 READ(IHOT,REC=IHOTSTP) IWSTP ; IHOTSTP = IHOTSTP + 1
  5101:                 READ(IHOT,REC=IHOTSTP) NSCOUM ; IHOTSTP = IHOTSTP + 1
  5102:           
  5103:                 READ(IHOT,REC=IHOTSTP) IGEP ; IHOTSTP = IHOTSTP + 1
  5104:                 READ(IHOT,REC=IHOTSTP) NSCOUGE ; IHOTSTP = IHOTSTP + 1
  5105:           
  5106:                 READ(IHOT,REC=IHOTSTP) IGVP ; IHOTSTP = IHOTSTP + 1
  5107:                 READ(IHOT,REC=IHOTSTP) NSCOUGV ; IHOTSTP = IHOTSTP + 1
  5108:           
  5109:                 READ(IHOT,REC=IHOTSTP) IGCP ; IHOTSTP = IHOTSTP + 1
  5110:                 READ(IHOT,REC=IHOTSTP) NSCOUGC ; IHOTSTP = IHOTSTP + 1
  5111:           
  5112:                 READ(IHOT,REC=IHOTSTP) IGPP ; IHOTSTP = IHOTSTP + 1
  5113:                 READ(IHOT,REC=IHOTSTP) IGWP ; IHOTSTP = IHOTSTP + 1
  5114:                 READ(IHOT,REC=IHOTSTP) NSCOUGW ; IHOTSTP = IHOTSTP + 1
  5115:           
  5116:           C kmd48.33 moved 3D hot start information to subroutine
  5117:           C          and took out other lines
  5118:           C jgf49.17 refined check of IMHSF so that it picks up only
  5119:           C     IM values that indicate 3D (and so we can use six integer IM values).
  5120:           Casey 140701: Added for 611112 and 711112.
  5121:                 IF ((IMHSF.EQ.1).OR.(IMHSF.EQ.11).OR.
  5122:           C    &    (IMHSF.EQ.21).OR.(IMHSF.EQ.31)) THEN
  5123:                &    (IMHSF.EQ.21).OR.(IMHSF.EQ.31).OR.
  5124:                &    (IMHSF.EQ.611112).OR.(IMHSF.EQ.711112))THEN
  5125:                    CALL ReadHotStart3D(IHOT,IHOTSTP)
  5126:                 ENDIF
  5127:           
  5128:           C     jgf48.03 harmonic analysis not supported yet
  5129:           #if 0
  5130:           C
  5131:           C....DETERMINE HARMONIC ANALYSIS PARAMETERS
  5132:           
  5133:                 IHARIND=NHARFR*(NHASE+NHASV+NHAGE+NHAGV)
  5134:                 IF(IHARIND.GT.0) IHARIND=1
  5135:           
  5136:           C.....IF HARMONIC ANALYSIS IS INCLUDED IN THE RUN, PROCESS HOT START
  5137:           C     INFORMATION FOR IN PROGRESS HARMONIC ANALYSIS
  5138:           
  5139:                 IF(IHARIND.EQ.1) THEN
  5140:                    ITHAS=INT((THAS-STATIM)*(86400.D0/DT) + 0.5d0)
  5141:                    ITHAF=INT((THAF-STATIM)*(86400.D0/DT) + 0.5d0)
  5142:                    ITMV = ITHAF - (ITHAF-ITHAS)*FMV
  5143:                    IHABEG=ITHAS+NHAINC
  5144:           
  5145:           C.......IF HARMONIC ANALYSIS HAS ALREADY BEGUN, READ IN HOT START
  5146:           C........HARMONIC ANALYSIS, MEAN AND SQUARE INFO
  5147:           
  5148:                    IF(ITHSF.GT.ITHAS) THEN
  5149:                       READ(IHOT,REC=IHOTSTP) ICHA
  5150:                       IHOTSTP=IHOTSTP+1
  5151:                    ENDIF
  5152:           
  5153:                    IF(ITHSF.GE.IHABEG) THEN
  5154:                       READ(IHOT,REC=IHOTSTP) INZ ; IHOTSTP = IHOTSTP + 1
  5155:                       READ(IHOT,REC=IHOTSTP) INF ; IHOTSTP = IHOTSTP + 1
  5156:                       READ(IHOT,REC=IHOTSTP) IMM ; IHOTSTP = IHOTSTP + 1
  5157:                       READ(IHOT,REC=IHOTSTP) INP ; IHOTSTP = IHOTSTP + 1
  5158:                       READ(IHOT,REC=IHOTSTP) INSTAE ; IHOTSTP = IHOTSTP + 1
  5159:                       READ(IHOT,REC=IHOTSTP) INSTAV ; IHOTSTP = IHOTSTP + 1
  5160:                       READ(IHOT,REC=IHOTSTP) IISTAE ; IHOTSTP = IHOTSTP + 1
  5161:                       READ(IHOT,REC=IHOTSTP) IISTAV ; IHOTSTP = IHOTSTP + 1
  5162:                       READ(IHOT,REC=IHOTSTP) IIGLOE ; IHOTSTP = IHOTSTP + 1
  5163:                       READ(IHOT,REC=IHOTSTP) IIGLOV ; IHOTSTP = IHOTSTP + 1
  5164:                       READ(IHOT,REC=IHOTSTP) IICALL ; IHOTSTP = IHOTSTP + 1
  5165:                       READ(IHOT,REC=IHOTSTP) INFREQ ; IHOTSTP = IHOTSTP + 1
  5166:           
  5167:                       DO I=1,INFREQ+INF
  5168:                          READ(IHOT,REC=IHOTSTP) FNAM8(1) ; IHOTSTP = IHOTSTP + 1
  5169:                          READ(IHOT,REC=IHOTSTP) FNAM8(2) ; IHOTSTP = IHOTSTP + 1
  5170:           
  5171:                          INAMEFR(I) = FNAME1
  5172:                          READ(IHOT,REC=IHOTSTP) IFREQ(I) ; IHOTSTP = IHOTSTP + 1
  5173:                          READ(IHOT,REC=IHOTSTP) IFF(I) ; IHOTSTP = IHOTSTP + 1
  5174:                          READ(IHOT,REC=IHOTSTP) IFACE(I) ; IHOTSTP = IHOTSTP + 1
  5175:                       ENDDO
  5176:           
  5177:                       READ(IHOT,REC=IHOTSTP) TIMEUD ; IHOTSTP = IHOTSTP + 1
  5178:                       READ(IHOT,REC=IHOTSTP) ITUD ; IHOTSTP = IHOTSTP + 1
  5179:           
  5180:                       DO I=1,IMM
  5181:                          DO J=1,IMM
  5182:                             READ(IHOT,REC=IHOTSTP) HA(I,J) ; IHOTSTP = IHOTSTP + 1
  5183:                          ENDDO
  5184:                       ENDDO
  5185:           
  5186:                       IF(NHASE.ne.0) THEN
  5187:                          DO J=1,INSTAE
  5188:                             DO I=1,IMM
  5189:                                READ(IHOT,REC=IHOTSTP) STAELV(I,J)
  5190:                                IHOTSTP=IHOTSTP+1
  5191:                             ENDDO
  5192:                          ENDDO
  5193:                       ENDIF
  5194:           
  5195:                       IF(NHASV.ne.0) THEN
  5196:                          DO J=1,INSTAV
  5197:                             DO I=1,IMM
  5198:                                READ(IHOT,REC=IHOTSTP) STAULV(I,J)
  5199:                                IHOTSTP = IHOTSTP + 1
  5200:                                READ(IHOT,REC=IHOTSTP) STAVLV(I,J)
  5201:                                IHOTSTP = IHOTSTP + 1
  5202:                             ENDDO
  5203:                          ENDDO
  5204:                       ENDIF
  5205:           
  5206:                       IF(NHAGE.ne.0) THEN
  5207:                          DO J=1,INP
  5208:                             DO I=1,IMM
  5209:                                READ(IHOT,REC=IHOTSTP) GLOELV(I,J)
  5210:                                IHOTSTP=IHOTSTP+1
  5211:                             ENDDO
  5212:                          ENDDO
  5213:                       ENDIF
  5214:           
  5215:                       IF(NHAGV.ne.0) THEN
  5216:                          DO J=1,INP
  5217:                             DO I=1,IMM
  5218:                                READ(IHOT,REC=IHOTSTP) GLOULV(I,J)
  5219:                                IHOTSTP = IHOTSTP + 1
  5220:                                READ(IHOT,REC=IHOTSTP) GLOVLV(I,J)
  5221:                                IHOTSTP = IHOTSTP + 1
  5222:                             ENDDO
  5223:                          ENDDO
  5224:                       ENDIF
  5225:           
  5226:                    ENDIF
  5227:           
  5228:                    IF((FMV.GT.0.).AND.(INFREQ.GT.0).AND.(IM.EQ.0)) THEN !include means and variances
  5229:                       IF(ITHSF.GT.ITMV) THEN
  5230:                          READ(IHOT,REC=IHOTSTP) NTSTEPS
  5231:                          IHOTSTP=IHOTSTP+1
  5232:                          IF(NHAGE.EQ.1) THEN
  5233:                             DO I=1,INP
  5234:                                READ(IHOT,REC=IHOTSTP) ELAV(I)
  5235:                                IHOTSTP=IHOTSTP+1
  5236:                                READ(IHOT,REC=IHOTSTP) ELVA(I)
  5237:                                IHOTSTP=IHOTSTP+1
  5238:                             ENDDO
  5239:                          ENDIF
  5240:                          IF(NHAGV.EQ.1) THEN
  5241:                             DO I=1,INP
  5242:                                READ(IHOT,REC=IHOTSTP) XVELAV(I)
  5243:                                IHOTSTP=IHOTSTP+1
  5244:                                READ(IHOT,REC=IHOTSTP) YVELAV(I)
  5245:                                IHOTSTP=IHOTSTP+1
  5246:                                READ(IHOT,REC=IHOTSTP) XVELVA(I)
  5247:                                IHOTSTP=IHOTSTP+1
  5248:                                READ(IHOT,REC=IHOTSTP) YVELVA(I)
  5249:                                IHOTSTP=IHOTSTP+1
  5250:                             ENDDO
  5251:                          ENDIF
  5252:                       ENDIF
  5253:                    ENDIF    ! charmv
  5254:                 ENDIF     ! HARIND
  5255:           #endif
  5256:           C
  5257:           C--Open All Local Hot Start files
  5258:           C
  5259:           
  5260:                 ALLOCATE ( LOC2(NPROC) )
  5261: +------>        DO IPROC = 1,NPROC
  5262: |                  LOC2(IPROC) = 105 + (IPROC-1)
  5263: |+=====>           LOCFN(1:14) = 'PE0000/'//FNAME(1:7)
  5264: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
  5265: |                  OPEN (LOC2(IPROC),FILE=LOCFN,ACCESS='DIRECT',RECL=8)
  5266: +------         ENDDO
  5267:           C
  5268:           C--Write out info to local hot start files
  5269:           C
  5270: +------>        DO IPROC = 1,NPROC
  5271: |                  IHOTSTP=1
  5272: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) InputFileFmtVn ;
  5273: |                                                            IHOTSTP = IHOTSTP + 1
  5274: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IMHSF          ;
  5275: |                                                            IHOTSTP = IHOTSTP + 1
  5276: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) TIMEHSF        ;
  5277: |                                                            IHOTSTP = IHOTSTP + 1
  5278: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) ITHSF          ;
  5279: |                                                            IHOTSTP = IHOTSTP + 1
  5280: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NNODP(IPROC)   ;
  5281: |                                                            IHOTSTP = IHOTSTP + 1
  5282: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NELP(IPROC)    ;
  5283: |                                                            IHOTSTP = IHOTSTP + 1
  5284: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NNODP(IPROC)   ;
  5285: |                                                            IHOTSTP = IHOTSTP + 1
  5286: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NELP(IPROC)    ;
  5287: |                                                            IHOTSTP = IHOTSTP + 1
  5288: |         
  5289: |+----->           DO I=1, NNODP(IPROC)
  5290: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5291: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) ETA1(INDX)
  5292: ||                    IHOTSTP=IHOTSTP+1
  5293: |+-----            END DO
  5294: |         
  5295: |+----->           DO I=1, NNODP(IPROC)
  5296: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5297: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) ETA2(INDX)
  5298: ||                    IHOTSTP=IHOTSTP+1
  5299: |+-----            END DO
  5300: |         
  5301: |+----->           DO I=1, NNODP(IPROC)
  5302: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5303: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) EtaDisc(INDX)
  5304: ||                    IHOTSTP=IHOTSTP+1
  5305: |+-----            END DO
  5306: |         
  5307: |+----->           DO I=1, NNODP(IPROC)
  5308: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5309: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) UU2(INDX)
  5310: ||                    IHOTSTP=IHOTSTP+1
  5311: |+-----            END DO
  5312: |         
  5313: |+----->           DO I=1, NNODP(IPROC)
  5314: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5315: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) VV2(INDX)
  5316: ||                    IHOTSTP=IHOTSTP+1
  5317: |+-----            END DO
  5318: |         
  5319: |                  IF(IM.EQ.10) THEN
  5320: |+----->              DO I=1, NNODP(IPROC)
  5321: ||                       INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5322: ||                       WRITE(LOC2(IPROC),REC=IHOTSTP) CH1(INDX)
  5323: ||                       IHOTSTP=IHOTSTP+1
  5324: |+-----               END DO
  5325: |                  ENDIF
  5326: |         
  5327: |+----->           DO I=1, NNODP(IPROC)
  5328: ||                    INDX = ABS(IMAP_NOD_LG(I,IPROC))
  5329: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) NODECODE(INDX)
  5330: ||                    IHOTSTP=IHOTSTP+1
  5331: |+-----            END DO
  5332: |         
  5333: |+----->           DO I=1,NELP(IPROC)
  5334: ||                    INDX=ABS(IMAP_EL_LG(I,IPROC))
  5335: ||                    WRITE(LOC2(IPROC),REC=IHOTSTP) NOFF(INDX)
  5336: ||                    IHOTSTP=IHOTSTP+1
  5337: |+-----            END DO
  5338: |         
  5339: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IESTP  ; IHOTSTP = IHOTSTP + 1
  5340: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUE  ; IHOTSTP = IHOTSTP + 1
  5341: |         
  5342: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IVSTP  ; IHOTSTP = IHOTSTP + 1
  5343: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUV  ; IHOTSTP = IHOTSTP + 1
  5344: |         
  5345: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) ICSTP  ; IHOTSTP = IHOTSTP + 1
  5346: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUC  ; IHOTSTP = IHOTSTP + 1
  5347: |         
  5348: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IPSTP  ; IHOTSTP = IHOTSTP + 1
  5349: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IWSTP  ; IHOTSTP = IHOTSTP + 1
  5350: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUM  ; IHOTSTP = IHOTSTP + 1
  5351: |         
  5352: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IGEP  ; IHOTSTP = IHOTSTP + 1
  5353: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUGE  ; IHOTSTP = IHOTSTP + 1
  5354: |         
  5355: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IGVP  ; IHOTSTP = IHOTSTP + 1
  5356: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUGV  ; IHOTSTP = IHOTSTP + 1
  5357: |         
  5358: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IGCP  ; IHOTSTP = IHOTSTP + 1
  5359: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUGC  ; IHOTSTP = IHOTSTP + 1
  5360: |         
  5361: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IGPP  ; IHOTSTP = IHOTSTP + 1
  5362: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) IGWP  ; IHOTSTP = IHOTSTP + 1
  5363: |                  WRITE(LOC2(IPROC),REC=IHOTSTP) NSCOUGW  ; IHOTSTP = IHOTSTP + 1
  5364: |         
  5365: |         C  kmd48.33bc moved 3D hot start information to subroutine
  5366: |         C jgf49.43 refined check of IMHSF so that it picks up only
  5367: |         C     IM values that indicate 3D (and so we can use six integer IM values).
  5368: |         Casey 140701: Added for 611112 and 711112.
  5369: |               IF ((IMHSF.EQ.1).OR.(IMHSF.EQ.11).OR.
  5370: |         C    &    (IMHSF.EQ.21).OR.(IMHSF.EQ.31)) THEN
  5371: |              &    (IMHSF.EQ.21).OR.(IMHSF.EQ.31).OR.
  5372: |              &    (IMHSF.EQ.611112).OR.(IMHSF.EQ.711112))THEN
  5373: |                     CALL WriteHotStart3D(LOC2(IPROC),IHOTSTP,IPROC)
  5374: |               ENDIF
  5375: |         
  5376: |         #if 0
  5377: |         C
  5378: |         C....IF APPROPRIATE, WRITE OUT HOT START INFORMATION FOR IN PROGRESS HARMONIC ANALYSIS
  5379: |         
  5380: |         c       IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITHAS)) THEN
  5381: |         c         WRITE(LOC2(IPROC),REC=IHOTSTP+1) ICHA
  5382: |         c         IHOTSTP = IHOTSTP + 1
  5383: |         c         CALL HAHOUT(NP,NSTAE,NSTAV,NHASE,NHASV,NHAGE,NHAGV,
  5384: |         c    &                LOC2(IPROC),IHOTSTP)
  5385: |         c
  5386: |         c         IF(NHASE.EQ.1) CALL HAHOUTES(NSTAE,LOC2(IPROC),IHOTSTP)
  5387: |         c         IF(NHASV.EQ.1) CALL HAHOUTVS(NSTAV,LOC2(IPROC),IHOTSTP)
  5388: |         c         IF(NHAGE.EQ.1) CALL HAHOUTEG(MNP,LOC2(IPROC),IHOTSTP)
  5389: |         c         IF(NHAGV.EQ.1) CALL HAHOUTVG(MNP,LOC2(IPROC),IHOTSTP)
  5390: |         c         ENDIF
  5391: |         c
  5392: |         c       if(CHARMV) then
  5393: |         c         IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITMV)) THEN
  5394: |         c           IHOTSTP=IHOTSTP+1
  5395: |         c           WRITE(LOC2(IPROC),REC=IHOTSTP) NTSTEPS
  5396: |         c           IF(NHAGE.EQ.1) THEN
  5397: |         c             DO I=1, NNODP(IPROC)
  5398: |         c               INDX = IMAP_NOD_LG(I,IPROC)
  5399: |         c               DO I=1,MNP
  5400: |         c                 WRITE(LOC2(IPROC),REC=IHOTSTP+1) ELAV(INDX)
  5401: |         c                 WRITE(LOC2(IPROC),REC=IHOTSTP+2) ELVA(INDX)
  5402: |         c                 IHOTSTP=IHOTSTP+2
  5403: |         c                 END DO
  5404: |         c             ENDIF
  5405: |         c           IF(NHAGV.EQ.1) THEN
  5406: |         c             DO I=1,NNODP(IPROC)
  5407: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+1) XVELAV(INDX)
  5408: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+2) YVELAV(INDX)
  5409: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+3) XVELVA(INDX)
  5410: |         c               WRITE(LOC2(IPROC),REC=IHOTSTP+4) YVELVA(INDX)
  5411: |         c               IHOTSTP=IHOTSTP+4
  5412: |         c               END DO
  5413: |         c             ENDIF
  5414: |         c           ENDIF
  5415: |         c         ENDIF
  5416: |         #endif
  5417: |         
  5418: +------         ENDDO
  5419:           C
  5420:           C--Close Global file and all the Local Files
  5421:           C
  5422:                 CLOSE (IHOT)
  5423: +------>        DO IPROC=1, NPROC
  5424: |                  CLOSE (LOC2(IPROC))
  5425: +------         ENDDO
  5426:           C
  5427:                 IF(ALLOCATED(LOC2)) DEALLOCATE ( LOC2 )
  5428:                 nbytes = 4*nproc
  5429:                 call memory_dealloc(nbytes)
  5430:                 IF(ALLOCATED( ETA1 ))DEALLOCATE ( ETA1  )
  5431:                 IF(ALLOCATED( ETA2 ))DEALLOCATE ( ETA2  )
  5432:                 IF(ALLOCATED( EtaDisc ))DEALLOCATE ( EtaDisc )
  5433:                 IF(ALLOCATED( UU2 ))DEALLOCATE ( UU2 )
  5434:                 IF(ALLOCATED( VV2 ))DEALLOCATE ( VV2 )
  5435:                 IF(ALLOCATED( NODECODE ))DEALLOCATE ( NODECODE )
  5436:                 IF(ALLOCATED( CH1 ))DEALLOCATE ( CH1 )
  5437:                 nbytes = 7*mnp*8
  5438:                 call memory_dealloc(nbytes)
  5439:                 IF(ALLOCATED(NOFF))DEALLOCATE ( NOFF )
  5440:                 nbytes = 6*mne
  5441:                 call memory_dealloc(nbytes)
  5442:                 IF(ALLOCATED( DUU ))DEALLOCATE ( DUU  )
  5443:                 IF(ALLOCATED( DUV ))DEALLOCATE ( DUV  )
  5444:                 IF(ALLOCATED( DVV ))DEALLOCATE ( DVV )
  5445:                 nbytes = 3*mnp*8
  5446:                 call memory_dealloc(nbytes)
  5447:                 IF(ALLOCATED( UU )) DEALLOCATE ( UU )
  5448:                 IF(ALLOCATED( VV )) DEALLOCATE ( VV )
  5449:                 nbytes = 2*mnp*8
  5450:                 call memory_dealloc(nbytes)
  5451:                 IF(ALLOCATED  ( BSX )) DEALLOCATE ( BSX )
  5452:                 IF(ALLOCATED  ( BSY )) DEALLOCATE ( BSY )
  5453:                 nbytes = 2*mnp*8
  5454:                 call memory_dealloc(nbytes)
  5455:                 IF(ALLOCATED  ( WZ )) DEALLOCATE ( WZ )
  5456:                 IF(ALLOCATED  ( q20 )) DEALLOCATE (q20 )
  5457:                 nbytes = (mnp*nfen*8) + (mnp*nfen*8)
  5458:                 call memory_dealloc(nbytes)
  5459:                 IF(ALLOCATED  ( RealQ ))  DEALLOCATE ( RealQ)
  5460:                 IF(ALLOCATED  ( ImagQ ))  DEALLOCATE ( ImagQ)
  5461:                 nbytes = (mnp*nfen*8) + (mnp*nfen*8)
  5462:                 call memory_dealloc(nbytes)
  5463:                 IF(ALLOCATED  ( l )) DEALLOCATE ( l )
  5464:                 IF(ALLOCATED  ( SigT )) DEALLOCATE ( SigT )
  5465:                 nbytes = (mnp*nfen*8) + (mnp*nfen*8)
  5466:                 call memory_dealloc(nbytes)
  5467:                 IF(ALLOCATED ( Sal)) DEALLOCATE ( Sal  )
  5468:                 IF(ALLOCATED ( Temp )) DEALLOCATE (  Temp )
  5469:                 nbytes = (mnp*nfen*8) + (mnp*nfen*8)
  5470:                 call memory_dealloc(nbytes)
  5471:                 call memory_status()
  5472:           C
  5473:                 RETURN
  5474:            1001 FORMAT('ERROR: The hot start file')
  5475:            1010 FORMAT(' File ',A60,/,' WAS NOT FOUND!  ADCPrep Terminated!!!',/)
  5476:            1011 FORMAT(' File ',A60,/,' WAS FOUND!  Opening & Processing file',/)
  5477:            1012 FORMAT('was a nonmatching version')
  5478:            1005 FORMAT('exists but cannot be opened.')
  5479:            9973 FORMAT(/,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
  5480:                 END SUBROUTINE HOTLOCALIZE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTLOCALIZE
INLINE LIST

  ROOT: HOTLOCALIZE (prep.F:4924)
  -> NOINLINE: PRE_GLOBAL::CMP_VERSION_NUMBERS (prep.F:5014)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5050)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5054)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5057)
     *** Source for routine not found.
  -> NOINLINE: READHOTSTART3D (prep.F:5125)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: IWRITE (prep.F:5264)
     *** Source for routine not found.
  -> NOINLINE: WRITEHOTSTART3D (prep.F:5373)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5429)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5438)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5441)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5446)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5450)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5454)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5458)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5462)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5466)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5470)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:5471)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTLOCALIZE
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:4985)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FNAME (prep.F:4985)
  LOOP END

  LOOP BEGIN: (prep.F:4983)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FNAME (prep.F:4983)
  LOOP END

  LOOP BEGIN: (prep.F:5062)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5062)
  LOOP END

  LOOP BEGIN: (prep.F:5065)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5065)
  LOOP END

  LOOP BEGIN: (prep.F:5068)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5068)
  LOOP END

  LOOP BEGIN: (prep.F:5071)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5071)
  LOOP END

  LOOP BEGIN: (prep.F:5074)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5074)
  LOOP END

  LOOP BEGIN: (prep.F:5078)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5078)
  LOOP END

  LOOP BEGIN: (prep.F:5082)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5082)
  LOOP END

  LOOP BEGIN: (prep.F:5086)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5086)
  LOOP END

  LOOP BEGIN: (prep.F:5261)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:5261)
    *** I/O statement obstructs vectorization. (prep.F:5261)

    LOOP BEGIN: (prep.F:5263)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:5263)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5270)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:5289)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5289)
    LOOP END

    LOOP BEGIN: (prep.F:5295)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5295)
    LOOP END

    LOOP BEGIN: (prep.F:5301)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5301)
    LOOP END

    LOOP BEGIN: (prep.F:5307)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5307)
    LOOP END

    LOOP BEGIN: (prep.F:5313)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5313)
    LOOP END

    LOOP BEGIN: (prep.F:5320)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5320)
    LOOP END

    LOOP BEGIN: (prep.F:5327)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5327)
    LOOP END

    LOOP BEGIN: (prep.F:5333)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5333)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5423)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5423)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTLOCALIZE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 5824 bytes
      Register spill area      : 1696 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 3792 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:4985)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:4983)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:5062)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5065)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5068)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5071)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5074)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5078)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5082)
    *** Estimated execution cycle                       : 36
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5086)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5261)
    *** Estimated execution cycle                       : 305
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 31
            Across calls                                :  5
            Over basic blocks                           : 26
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 33
            Across calls                                :  6
            Over basic blocks                           : 27
    *** The number of SCALAR REGISTER TRANSFER          : 37

    LOOP BEGIN: (prep.F:5263)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5270)
    *** Estimated execution cycle                       : 1432
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 48
            Across calls                                : 26
            Over basic blocks                           : 22
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 179
            Across calls                                :  98
            Over basic blocks                           :  81
    *** The number of SCALAR REGISTER TRANSFER          : 159

    LOOP BEGIN: (prep.F:5289)
      *** Estimated execution cycle                     : 61
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:5295)
      *** Estimated execution cycle                     : 73
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 5
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:5301)
      *** Estimated execution cycle                     : 75
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 6
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  6
              Over basic blocks                         :  4
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:5307)
      *** Estimated execution cycle                     : 80
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 6
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  6
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END

    LOOP BEGIN: (prep.F:5313)
      *** Estimated execution cycle                     : 85
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 7
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 12
              Across calls                              :  7
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END

    LOOP BEGIN: (prep.F:5320)
      *** Estimated execution cycle                     : 95
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 10
              Across calls                              :  7
              Over basic blocks                         :  3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 14
              Across calls                              :  7
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 14
    LOOP END

    LOOP BEGIN: (prep.F:5327)
      *** Estimated execution cycle                     : 92
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 9
              Across calls                              : 7
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 13
              Across calls                              :  7
              Over basic blocks                         :  6
      *** The number of SCALAR REGISTER TRANSFER        : 13
    LOOP END

    LOOP BEGIN: (prep.F:5333)
      *** Estimated execution cycle                     : 95
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 10
              Across calls                              :  7
              Over basic blocks                         :  3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 14
              Across calls                              :  7
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 14
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5423)
    *** Estimated execution cycle                       : 16
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTGLOBALIZE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  5543: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  5543: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  5543: vec( 180): I/O statement obstructs vectorization.
  5543: vec( 109): Vectorization obstructive statement.
  5546: inl(1212): Source for routine not found.: IWRITE
  5549: opt(3014): Moved reference within a conditional branch.
  5552: opt(3014): Moved reference within a conditional branch.
  5563: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_ALLOC
  5629: vec( 103): Unvectorized loop.
  5629: vec( 180): I/O statement obstructs vectorization.
  5631: opt(1118): This I/O statement inhibits optimization of loop.
  5636: vec( 103): Unvectorized loop.
  5636: vec( 180): I/O statement obstructs vectorization.
  5638: opt(1118): This I/O statement inhibits optimization of loop.
  5643: vec( 103): Unvectorized loop.
  5643: vec( 180): I/O statement obstructs vectorization.
  5645: opt(1118): This I/O statement inhibits optimization of loop.
  5650: vec( 103): Unvectorized loop.
  5650: vec( 180): I/O statement obstructs vectorization.
  5652: opt(1118): This I/O statement inhibits optimization of loop.
  5657: vec( 103): Unvectorized loop.
  5657: vec( 180): I/O statement obstructs vectorization.
  5659: opt(1118): This I/O statement inhibits optimization of loop.
  5665: vec( 103): Unvectorized loop.
  5665: vec( 180): I/O statement obstructs vectorization.
  5667: opt(1118): This I/O statement inhibits optimization of loop.
  5673: vec( 103): Unvectorized loop.
  5673: vec( 180): I/O statement obstructs vectorization.
  5675: opt(1118): This I/O statement inhibits optimization of loop.
  5680: vec( 103): Unvectorized loop.
  5680: vec( 180): I/O statement obstructs vectorization.
  5682: opt(1118): This I/O statement inhibits optimization of loop.
  5716: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: READHOTSTART3DGLOBAL
  5767: vec( 103): Unvectorized loop.
  5767: vec( 108): Unvectorizable loop structure.
  5780: vec( 103): Unvectorized loop.
  5780: vec( 180): I/O statement obstructs vectorization.
  5781: opt(1118): This I/O statement inhibits optimization of loop.
  5784: vec( 103): Unvectorized loop.
  5784: vec( 180): I/O statement obstructs vectorization.
  5785: opt(1118): This I/O statement inhibits optimization of loop.
  5788: vec( 103): Unvectorized loop.
  5788: vec( 180): I/O statement obstructs vectorization.
  5789: opt(1118): This I/O statement inhibits optimization of loop.
  5792: vec( 103): Unvectorized loop.
  5792: vec( 180): I/O statement obstructs vectorization.
  5793: opt(1118): This I/O statement inhibits optimization of loop.
  5796: vec( 103): Unvectorized loop.
  5796: vec( 180): I/O statement obstructs vectorization.
  5797: opt(1118): This I/O statement inhibits optimization of loop.
  5801: vec( 103): Unvectorized loop.
  5801: vec( 180): I/O statement obstructs vectorization.
  5802: opt(1118): This I/O statement inhibits optimization of loop.
  5806: vec( 103): Unvectorized loop.
  5806: vec( 180): I/O statement obstructs vectorization.
  5807: opt(1118): This I/O statement inhibits optimization of loop.
  5810: vec( 103): Unvectorized loop.
  5810: vec( 180): I/O statement obstructs vectorization.
  5811: opt(1118): This I/O statement inhibits optimization of loop.
  5846: inl(2238): Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.: WRITEHOTSTART3DGLOBAL
  5983: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_DEALLOC
  5990: inl(1212): Source for routine not found.: MEMORY_USAGE::MEMORY_STATUS


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTGLOBALIZE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  5483:                 SUBROUTINE HOTGLOBALIZE()
  5484:                 USE PRE_GLOBAL
  5485:                 use presizes; use memory_usage
  5486:           C
  5487:           C---------------------------------------------------------------------------C
  5488:           C                     written 10/11/01 by RL                                C
  5489:           C             started mods for harmonic analysis and 3D RL 5/22/03          C
  5490:           C         jgf Updated for v45.06 09/07/2005 not incl. harmonic or 3D        C
  5491:           C         kmd48.33bc updated with 3D hot start                              C
  5492:           C                                                                           C
  5493:           C  This routine reads the global hot start file (either fort.67 or fort.68) C
  5494:           C  and writes local hot start files of the same format.                     C
  5495:           C                                                                           C
  5496:           C---------------------------------------------------------------------------C
  5497:           C
  5498:                 IMPLICIT NONE
  5499:                 integer(8) :: nbytes = 0
  5500:                 LOGICAL FOUND
  5501:                 INTEGER I,J,IPROC,INDX,IHOTSTP, not_active
  5502:                 INTEGER IMHSF,ITHSF,IVALUE,IDUMY, NH, N
  5503:                 CHARACTER FNAME*60,LOCFN*14
  5504:                 CHARACTER*16 FNAME1
  5505:                 CHARACTER*8 FNAM8(2)
  5506:                 EQUIVALENCE (FNAM8(1),FNAME1)
  5507:           
  5508:                 INTEGER,ALLOCATABLE  :: LOC2(:),NOFF(:), domA(:)
  5509:                 REAL(8),ALLOCATABLE :: ETA1(:),ETA2(:),EtaDisc(:),
  5510:                &    UU2(:),VV2(:),CH1(:)
  5511:                 REAL(8) TIMEHSF, RVALUE
  5512:                 integer :: InputFileFmtVn, NP_G_IN, NE_G_IN, NP_A_IN, NE_A_IN
  5513:           
  5514:           #if 0
  5515:                 ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  5516:                 INTEGER INZ,INF,IMM,INP,INSTAE,INSTAV,IISTAE,IISTAV,IIGLOE,IIGLOV,
  5517:                &                                       IICALL,INFREQ,ITUD,NTSTEPS
  5518:                 INTEGER IHARIND,ITHAS,ITHAF,ITMV,IHABEG,ICHA
  5519:                 CHARACTER*10,ALLOCATABLE     ::  INAMEFR(:)
  5520:                 REAL(8)  TIMEUD
  5521:                 REAL(8),ALLOCATABLE ::  HA(:,:)
  5522:                 REAL(8),ALLOCATABLE ::  ELAV(:),ELVA(:),XVELAV(:),XVELVA(:),
  5523:                &                                         YVELAV(:),YVELVA(:)
  5524:                 REAL(8),ALLOCATABLE ::  IFREQ(:),IFF(:),IFACE(:)
  5525:                 REAL(8),ALLOCATABLE ::  GLOELV(:,:)
  5526:                 REAL(8),ALLOCATABLE ::  GLOULV(:,:),GLOVLV(:,:)
  5527:                 REAL(8),ALLOCATABLE ::  STAELV(:,:)
  5528:                 REAL(8),ALLOCATABLE ::  STAULV(:,:),STAVLV(:,:)
  5529:           #endif
  5530:           C
  5531:           C--   Open Appropriate Hot Start File based on the value of IHOT from
  5532:           C--   the fort.15 file
  5533:           C
  5534:                 write(*,*) "enter IHOT: "
  5535:                 read(*,*) IHOT
  5536: +======>        IF(IHOT.EQ.67) FNAME='fort.67'
  5537: +======>        IF(IHOT.EQ.68) FNAME='fort.68'
  5538:           
  5539:           C
  5540:           C--Open All Local Hot Start files
  5541:           C
  5542:                 ALLOCATE ( LOC2(NPROC) )
  5543: +------>        DO IPROC = 1,NPROC
  5544: |                  LOC2(IPROC) = 105 + (IPROC-1)
  5545: |+=====>           LOCFN(1:14) = 'PE0000/'//FNAME(1:7)
  5546: |                  CALL IWRITE(LOCFN,3,6,IPROC-1)
  5547: |                  INQUIRE(FILE=LOCFN,EXIST=FOUND)
  5548: |                  IF (FOUND) THEN
  5549: |                    WRITE(*,1011) LOCFN
  5550: |                    OPEN (LOC2(IPROC),FILE=LOCFN,ACCESS='DIRECT',RECL=8)
  5551: |                  ELSE
  5552: |                   WRITE(*,1010) FNAME
  5553: |                   CALL EXIT(1)
  5554: |                  ENDIF
  5555: +------         ENDDO
  5556:           C
  5557:           C Allocate local work arrays
  5558:           C
  5559:                 MNP  =  nnodg    !  global number of nodes    ( read from fort.18 )
  5560:                 print *, "MNP =", MNP
  5561:           
  5562:                 nbytes = 4*nproc
  5563:                 call memory_alloc(nbytes)
  5564:                 ALLOCATE ( ETA1(MNP),ETA2(MNP),EtaDisc(MNP),UU2(MNP),
  5565:                &           VV2(MNP),NODECODE(MNP),CH1(MNP) )
  5566:                 nbytes = 7*mnp
  5567:           
  5568:                 MNE  =  nelg     !  global number of elements ( read from fort.18 )
  5569:                 print *, "MNE =", MNE
  5570:           
  5571:                 call memory_alloc(nbytes)
  5572:                 ALLOCATE ( NOFF(MNE) )
  5573:                 nbytes = 4*mne
  5574:                 call memory_alloc(nbytes)
  5575:           
  5576:           #if HA
  5577:                 ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  5578:                 ALLOCATE ( HA(2*MNHARF,2*MNHARF) )
  5579:                 nbytes = 32*mnharf
  5580:                 call memory_alloc(nbytes)
  5581:                 ALLOCATE ( GLOELV(2*MNHARF,MNP) )
  5582:                 nbytes = 16*mnharf*mnp
  5583:                 call memory_alloc(nbytes)
  5584:                 ALLOCATE ( GLOULV(2*MNHARF,MNP),GLOVLV(2*MNHARF,MNP) )
  5585:                 nbytes = 32*mnharf*mnp
  5586:                 call memory_alloc(nbytes)
  5587:                 ALLOCATE ( STAELV(2*MNHARF,MNSTAE) )
  5588:                 nbytes = 16*mnharf*mnstae
  5589:                 call memory_alloc(nbytes)
  5590:                 ALLOCATE ( STAULV(2*MNHARF,MNSTAV),STAVLV(2*MNHARF,MNSTAV) )
  5591:                 nbytes = 16*mnharf*mnstav
  5592:                 call memory_alloc(nbytes)
  5593:                 ALLOCATE ( ELAV(MNP),ELVA(MNP) )
  5594:                 nbytes = 16*mnp
  5595:                 call memory_alloc(nbytes)
  5596:                 ALLOCATE ( XVELAV(MNP),XVELVA(MNP),YVELAV(MNP),YVELVA(MNP) )
  5597:                 nbytes = 32*mnp
  5598:                 call memory_alloc(nbytes)
  5599:                 ALLOCATE ( IFREQ(MNHARF),IFF(MNHARF),IFACE(MNHARF) )
  5600:                 nbytes = 12*mnharf
  5601:                 call memory_alloc(nbytes)
  5602:                 ALLOCATE ( INAMEFR(MNHARF) )
  5603:                 nbytes = 4*mnharf
  5604:                 call memory_alloc(nbytes)
  5605:           #endif
  5606:           
  5607:           C
  5608:           C--Read info from local hot start files
  5609:           C
  5610: +------>        DO IPROC = 1,NPROC
  5611: |                  IHOTSTP=1
  5612: |                  READ(LOC2(IPROC),REC=IHOTSTP) InputFileFmtVn ;
  5613: |                                                            IHOTSTP = IHOTSTP + 1
  5614: |                  READ(LOC2(IPROC),REC=IHOTSTP) IMHSF          ;
  5615: |                                                            IHOTSTP = IHOTSTP + 1
  5616: |                  READ(LOC2(IPROC),REC=IHOTSTP) TIMEHSF        ;
  5617: |                                                            IHOTSTP = IHOTSTP + 1
  5618: |                  READ(LOC2(IPROC),REC=IHOTSTP) ITHSF          ;
  5619: |                                                            IHOTSTP = IHOTSTP + 1
  5620: |                  READ(LOC2(IPROC),REC=IHOTSTP) IDUMY          ;
  5621: |                                                            IHOTSTP = IHOTSTP + 1
  5622: |                  READ(LOC2(IPROC),REC=IHOTSTP) IDUMY          ;
  5623: |                                                            IHOTSTP = IHOTSTP + 1
  5624: |                  READ(LOC2(IPROC),REC=IHOTSTP) IDUMY          ;
  5625: |                                                            IHOTSTP = IHOTSTP + 1
  5626: |                  READ(LOC2(IPROC),REC=IHOTSTP) IDUMY          ;
  5627: |                                                            IHOTSTP = IHOTSTP + 1
  5628: |         
  5629: |+----->           DO I=1, NNODP(IPROC)
  5630: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5631: ||                    READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5632: ||                    IHOTSTP=IHOTSTP+1
  5633: ||                    IF (INDX > 0) ETA1(INDX) = RVALUE
  5634: |+-----            END DO
  5635: |         
  5636: |+----->           DO I=1, NNODP(IPROC)
  5637: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5638: ||                    READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5639: ||                    IHOTSTP=IHOTSTP+1
  5640: ||                    IF (INDX > 0) ETA2(INDX) = RVALUE
  5641: |+-----            END DO
  5642: |         
  5643: |+----->           DO I=1, NNODP(IPROC)
  5644: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5645: ||                    READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5646: ||                    IHOTSTP=IHOTSTP+1
  5647: ||                    IF (INDX > 0) EtaDisc(INDX) = RVALUE
  5648: |+-----            END DO
  5649: |         
  5650: |+----->           DO I=1, NNODP(IPROC)
  5651: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5652: ||                    READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5653: ||                    IHOTSTP=IHOTSTP+1
  5654: ||                    IF (INDX > 0) UU2(INDX) = RVALUE
  5655: |+-----            END DO
  5656: |         
  5657: |+----->           DO I=1, NNODP(IPROC)
  5658: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5659: ||                    READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5660: ||                    IHOTSTP=IHOTSTP+1
  5661: ||                    IF (INDX > 0) VV2(INDX) = RVALUE
  5662: |+-----            END DO
  5663: |         
  5664: |                  IF(IM.EQ.10) THEN
  5665: |+----->              DO I=1, NNODP(IPROC)
  5666: ||                       INDX = IMAP_NOD_LG(I,IPROC)
  5667: ||                       READ(LOC2(IPROC),REC=IHOTSTP) RVALUE
  5668: ||                       IHOTSTP=IHOTSTP+1
  5669: ||                       IF (INDX > 0) CH1(INDX) = RVALUE
  5670: |+-----               END DO
  5671: |                  ENDIF
  5672: |         
  5673: |+----->           DO I=1, NNODP(IPROC)
  5674: ||                    INDX = IMAP_NOD_LG(I,IPROC)
  5675: ||                    READ(LOC2(IPROC),REC=IHOTSTP) IVALUE
  5676: ||                    IHOTSTP=IHOTSTP+1
  5677: ||                    IF (INDX > 0) NODECODE(INDX) = IVALUE
  5678: |+-----            END DO
  5679: |         
  5680: |+----->           DO I=1,NELP(IPROC)
  5681: ||                    INDX = IMAP_EL_LG(I,IPROC)
  5682: ||                    READ(LOC2(IPROC),REC=IHOTSTP) IVALUE
  5683: ||                    IHOTSTP=IHOTSTP+1
  5684: ||                    IF (INDX > 0) NOFF(INDX) = IVALUE
  5685: |+-----            END DO
  5686: |         
  5687: |                  READ(LOC2(IPROC),REC=IHOTSTP) IESTP ; IHOTSTP = IHOTSTP + 1
  5688: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUE ; IHOTSTP = IHOTSTP + 1
  5689: |         
  5690: |                  READ(LOC2(IPROC),REC=IHOTSTP) IVSTP ; IHOTSTP = IHOTSTP + 1
  5691: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUV ; IHOTSTP = IHOTSTP + 1
  5692: |         
  5693: |                  READ(LOC2(IPROC),REC=IHOTSTP) ICSTP ; IHOTSTP = IHOTSTP + 1
  5694: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUC ; IHOTSTP = IHOTSTP + 1
  5695: |         
  5696: |                  READ(LOC2(IPROC),REC=IHOTSTP) IPSTP ; IHOTSTP = IHOTSTP + 1
  5697: |                  READ(LOC2(IPROC),REC=IHOTSTP) IWSTP ; IHOTSTP = IHOTSTP + 1
  5698: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUM ; IHOTSTP = IHOTSTP + 1
  5699: |         
  5700: |                  READ(LOC2(IPROC),REC=IHOTSTP) IGEP ; IHOTSTP = IHOTSTP + 1
  5701: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUGE ; IHOTSTP = IHOTSTP + 1
  5702: |         
  5703: |                  READ(LOC2(IPROC),REC=IHOTSTP) IGVP ; IHOTSTP = IHOTSTP + 1
  5704: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUGV ; IHOTSTP = IHOTSTP + 1
  5705: |         
  5706: |                  READ(LOC2(IPROC),REC=IHOTSTP) IGCP ; IHOTSTP = IHOTSTP + 1
  5707: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUGC ; IHOTSTP = IHOTSTP + 1
  5708: |         
  5709: |                  READ(LOC2(IPROC),REC=IHOTSTP) IGPP ; IHOTSTP = IHOTSTP + 1
  5710: |                  READ(LOC2(IPROC),REC=IHOTSTP) IGWP ; IHOTSTP = IHOTSTP + 1
  5711: |                  READ(LOC2(IPROC),REC=IHOTSTP) NSCOUGW ; IHOTSTP = IHOTSTP + 1
  5712: |         C
  5713: |         C   kmd48.33bc add information for 3D hot start
  5714: |         C     jgf46.02 read in 3D hotstart data if appropriate
  5715: |                  IF (C3D) THEN
  5716: |                     CALL ReadHotStart3DGlobal(LOC2(IPROC),IHOTSTP,IPROC)
  5717: |                  ENDIF
  5718: |         #if HA
  5719: |         C
  5720: |         C....IF APPROPRIATE, WRITE OUT HOT START INFORMATION FOR IN PROGRESS HARMONIC ANALYSIS
  5721: |         
  5722: |         c       IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITHAS)) THEN
  5723: |         c         READ(LOC2(IPROC),REC=IHOTSTP+1) ICHA
  5724: |         c         IHOTSTP = IHOTSTP + 1
  5725: |         c         CALL HAHOUT(NP,NSTAE,NSTAV,NHASE,NHASV,NHAGE,NHAGV,
  5726: |         c    &                LOC2(IPROC),IHOTSTP)
  5727: |         c
  5728: |         c         IF(NHASE.EQ.1) CALL HAHOUTES(NSTAE,LOC2(IPROC),IHOTSTP)
  5729: |         c         IF(NHASV.EQ.1) CALL HAHOUTVS(NSTAV,LOC2(IPROC),IHOTSTP)
  5730: |         c         IF(NHAGE.EQ.1) CALL HAHOUTEG(MNP,LOC2(IPROC),IHOTSTP)
  5731: |         c         IF(NHAGV.EQ.1) CALL HAHOUTVG(MNP,LOC2(IPROC),IHOTSTP)
  5732: |         c         ENDIF
  5733: |         c
  5734: |         c       if(CHARMV) then
  5735: |         c         IF((IHARIND.EQ.1).AND.(ITHSF.GT.ITMV)) THEN
  5736: |         c           IHOTSTP=IHOTSTP+1
  5737: |         c           READ(LOC2(IPROC),REC=IHOTSTP) NTSTEPS
  5738: |         c           IF(NHAGE.EQ.1) THEN
  5739: |         c             DO I=1, NNODP(IPROC)
  5740: |         c               INDX = IMAP_NOD_LG(I,IPROC)
  5741: |         c               DO I=1,MNP
  5742: |         c                 READ(LOC2(IPROC),REC=IHOTSTP+1) ELAV(INDX)
  5743: |         c                 READ(LOC2(IPROC),REC=IHOTSTP+2) ELVA(INDX)
  5744: |         c                 IHOTSTP=IHOTSTP+2
  5745: |         c                 END DO
  5746: |         c             ENDIF
  5747: |         c           IF(NHAGV.EQ.1) THEN
  5748: |         c             DO I=1,NNODP(IPROC)
  5749: |         c               READ(LOC2(IPROC),REC=IHOTSTP+1) XVELAV(INDX)
  5750: |         c               READ(LOC2(IPROC),REC=IHOTSTP+2) YVELAV(INDX)
  5751: |         c               READ(LOC2(IPROC),REC=IHOTSTP+3) XVELVA(INDX)
  5752: |         c               READ(LOC2(IPROC),REC=IHOTSTP+4) YVELVA(INDX)
  5753: |         c               IHOTSTP=IHOTSTP+4
  5754: |         c               END DO
  5755: |         c             ENDIF
  5756: |         c           ENDIF
  5757: |         c         ENDIF
  5758: |         #endif
  5759: |                   CLOSE (LOC2(IPROC))
  5760: |         
  5761: +------         ENDDO
  5762:           
  5763:           C-----------------------------------------------------------------------
  5764:           C--   Write info to global hot start files
  5765:           C-----------------------------------------------------------------------
  5766:           
  5767:                 OPEN(IHOT,FILE=trim(FNAME),ACCESS='DIRECT',RECL=8)
  5768:                 print *, "opening global hotstart file"
  5769:           
  5770:                 IHOTSTP=1
  5771:                 WRITE(IHOT,REC=IHOTSTP) InputFileFmtVn ; IHOTSTP = IHOTSTP + 1
  5772:                 WRITE(IHOT,REC=IHOTSTP) IMHSF        ; IHOTSTP = IHOTSTP + 1
  5773:                 WRITE(IHOT,REC=IHOTSTP) TIMEHSF      ; IHOTSTP = IHOTSTP + 1
  5774:                 WRITE(IHOT,REC=IHOTSTP) ITHSF        ; IHOTSTP = IHOTSTP + 1
  5775:                 WRITE(IHOT,REC=IHOTSTP) MNP          ; IHOTSTP = IHOTSTP + 1
  5776:                 WRITE(IHOT,REC=IHOTSTP) MNE          ; IHOTSTP = IHOTSTP + 1
  5777:                 WRITE(IHOT,REC=IHOTSTP) MNP          ; IHOTSTP = IHOTSTP + 1
  5778:                 WRITE(IHOT,REC=IHOTSTP) MNE          ; IHOTSTP = IHOTSTP + 1
  5779:           
  5780: +------>        DO I=1,MNP
  5781: |                  WRITE(IHOT,REC=IHOTSTP) ETA1(I)
  5782: |                  IHOTSTP = IHOTSTP + 1
  5783: +------         END DO
  5784: +------>        DO I=1,MNP
  5785: |                  WRITE(IHOT,REC=IHOTSTP) ETA2(I)
  5786: |                  IHOTSTP = IHOTSTP + 1
  5787: +------         END DO
  5788: +------>        DO I=1,MNP
  5789: |                  WRITE(IHOT,REC=IHOTSTP) EtaDisc(I)
  5790: |                  IHOTSTP = IHOTSTP + 1
  5791: +------         END DO
  5792: +------>        DO I=1,MNP
  5793: |                  WRITE(IHOT,REC=IHOTSTP) UU2(I)
  5794: |                  IHOTSTP = IHOTSTP + 1
  5795: +------         END DO
  5796: +------>        DO I=1,MNP
  5797: |                  WRITE(IHOT,REC=IHOTSTP) VV2(I)
  5798: |                  IHOTSTP = IHOTSTP + 1
  5799: +------         END DO
  5800:                 IF(IM.EQ.10) THEN
  5801: +------>          DO I=1,MNP
  5802: |                    WRITE(IHOT,REC=IHOTSTP) CH1(I)
  5803: |                    IHOTSTP=IHOTSTP+1
  5804: +------           END DO
  5805:                 ENDIF
  5806: +------>        DO I=1,MNP
  5807: |                  WRITE(IHOT,REC=IHOTSTP) NODECODE(I)
  5808: |                  IHOTSTP=IHOTSTP+1
  5809: +------         END DO
  5810: +------>        DO I=1,MNE
  5811: |                  WRITE(IHOT,REC=IHOTSTP) NOFF(I)
  5812: |                  IHOTSTP=IHOTSTP+1
  5813: +------         END DO
  5814:           
  5815:                 WRITE(IHOT,REC=IHOTSTP) IESTP ; IHOTSTP = IHOTSTP + 1
  5816:                 WRITE(IHOT,REC=IHOTSTP) NSCOUE ; IHOTSTP = IHOTSTP + 1
  5817:           
  5818:                 WRITE(IHOT,REC=IHOTSTP) IVSTP ; IHOTSTP = IHOTSTP + 1
  5819:                 WRITE(IHOT,REC=IHOTSTP) NSCOUV ; IHOTSTP = IHOTSTP + 1
  5820:           
  5821:                 WRITE(IHOT,REC=IHOTSTP) ICSTP ; IHOTSTP = IHOTSTP + 1
  5822:                 WRITE(IHOT,REC=IHOTSTP) NSCOUC ; IHOTSTP = IHOTSTP + 1
  5823:           
  5824:                 WRITE(IHOT,REC=IHOTSTP) IPSTP ; IHOTSTP = IHOTSTP + 1
  5825:                 WRITE(IHOT,REC=IHOTSTP) IWSTP ; IHOTSTP = IHOTSTP + 1
  5826:                 WRITE(IHOT,REC=IHOTSTP) NSCOUM ; IHOTSTP = IHOTSTP + 1
  5827:           
  5828:                 WRITE(IHOT,REC=IHOTSTP) IGEP ; IHOTSTP = IHOTSTP + 1
  5829:                 WRITE(IHOT,REC=IHOTSTP) NSCOUGE ; IHOTSTP = IHOTSTP + 1
  5830:           
  5831:                 WRITE(IHOT,REC=IHOTSTP) IGVP ; IHOTSTP = IHOTSTP + 1
  5832:                 WRITE(IHOT,REC=IHOTSTP) NSCOUGV ; IHOTSTP = IHOTSTP + 1
  5833:           
  5834:                 WRITE(IHOT,REC=IHOTSTP) IGCP ; IHOTSTP = IHOTSTP + 1
  5835:                 WRITE(IHOT,REC=IHOTSTP) NSCOUGC ; IHOTSTP = IHOTSTP + 1
  5836:           
  5837:                 WRITE(IHOT,REC=IHOTSTP) IGPP ; IHOTSTP = IHOTSTP + 1
  5838:                 WRITE(IHOT,REC=IHOTSTP) IGWP ; IHOTSTP = IHOTSTP + 1
  5839:                 WRITE(IHOT,REC=IHOTSTP) NSCOUGW ; IHOTSTP = IHOTSTP + 1
  5840:           C
  5841:           
  5842:                  ! vjp 2006/9/30 not supporting harmonic analysis or C3D yet
  5843:           C   kmd48.33bc add information for 3D hot start
  5844:           C     jgf46.02 Write in 3D hotstart data if appropriate
  5845:                 IF (C3D) THEN
  5846:                    CALL WriteHotStart3DGlobal(IHOT,IHOTSTP,IPROC)
  5847:                 ENDIF
  5848:           C
  5849:           #if 0
  5850:           C.....DETERMINE HARMONIC ANALYSIS PARAMETERS
  5851:           
  5852:                 IHARIND=NHARFR*(NHASE+NHASV+NHAGE+NHAGV)
  5853:                 IF(IHARIND.GT.0) IHARIND=1
  5854:           
  5855:           C.....IF HARMONIC ANALYSIS IS INCLUDED IN THE RUN, PROCESS HOT START INFORMATION FOR
  5856:           C.....IN PROGRESS HARMONIC ANALYSIS
  5857:           
  5858:                 IF(IHARIND.EQ.1) THEN
  5859:                    ITHAS=INT((THAS-STATIM)*(86400.D0/DT) + 0.5d0)
  5860:                    ITHAF=INT((THAF-STATIM)*(86400.D0/DT) + 0.5d0)
  5861:                    ITMV = ITHAF - (ITHAF-ITHAS)*FMV
  5862:                    IHABEG=ITHAS+NHAINC
  5863:           
  5864:           C.......IF HARMONIC ANALYSIS HAS ALREADY BEGUN, READ IN HOT START
  5865:           C........HARMONIC ANALYSIS, MEAN AND SQUARE INFO
  5866:           
  5867:                    IF(ITHSF.GT.ITHAS) THEN
  5868:                       WRITE(IHOT,REC=IHOTSTP) ICHA
  5869:                       IHOTSTP=IHOTSTP+1
  5870:                    ENDIF
  5871:           
  5872:                    IF(ITHSF.GE.IHABEG) THEN
  5873:                       WRITE(IHOT,REC=IHOTSTP) INZ ; IHOTSTP = IHOTSTP + 1
  5874:                       WRITE(IHOT,REC=IHOTSTP) INF ;  IHOTSTP = IHOTSTP + 1
  5875:                       WRITE(IHOT,REC=IHOTSTP) IMM ;  IHOTSTP = IHOTSTP + 1
  5876:                       WRITE(IHOT,REC=IHOTSTP) INP ;  IHOTSTP = IHOTSTP + 1
  5877:                       WRITE(IHOT,REC=IHOTSTP) INSTAE ;  IHOTSTP = IHOTSTP + 1
  5878:                       WRITE(IHOT,REC=IHOTSTP) INSTAV ;  IHOTSTP = IHOTSTP + 1
  5879:                       WRITE(IHOT,REC=IHOTSTP) IISTAE ;  IHOTSTP = IHOTSTP + 1
  5880:                       WRITE(IHOT,REC=IHOTSTP) IISTAV ;  IHOTSTP = IHOTSTP + 1
  5881:                       WRITE(IHOT,REC=IHOTSTP) IIGLOE ;  IHOTSTP = IHOTSTP + 1
  5882:                       WRITE(IHOT,REC=IHOTSTP) IIGLOV ;  IHOTSTP = IHOTSTP + 1
  5883:                       WRITE(IHOT,REC=IHOTSTP) IICALL ;  IHOTSTP = IHOTSTP + 1
  5884:                       WRITE(IHOT,REC=IHOTSTP) INFREQ ;  IHOTSTP = IHOTSTP + 1
  5885:           
  5886:                       DO I=1,INFREQ+INF
  5887:                          WRITE(IHOT,REC=IHOTSTP) FNAM8(1) ;  IHOTSTP = IHOTSTP + 1
  5888:                          WRITE(IHOT,REC=IHOTSTP) FNAM8(2) ;  IHOTSTP = IHOTSTP + 1
  5889:                          INAMEFR(I) = FNAME1
  5890:                          WRITE(IHOT,REC=IHOTSTP) IFREQ(I) ;  IHOTSTP = IHOTSTP + 1
  5891:                          WRITE(IHOT,REC=IHOTSTP) IFF(I) ;  IHOTSTP = IHOTSTP + 1
  5892:                          WRITE(IHOT,REC=IHOTSTP) IFACE(I) ;  IHOTSTP = IHOTSTP + 1
  5893:                       ENDDO
  5894:           
  5895:                       WRITE(IHOT,REC=IHOTSTP) TIMEUD ;  IHOTSTP = IHOTSTP + 1
  5896:                       WRITE(IHOT,REC=IHOTSTP) ITUD ;  IHOTSTP = IHOTSTP + 1
  5897:           
  5898:                       DO I=1,IMM
  5899:                          DO J=1,IMM
  5900:                             WRITE(IHOT,REC=IHOTSTP) HA(I,J)
  5901:                             IHOTSTP = IHOTSTP + 1
  5902:                          ENDDO
  5903:                       ENDDO
  5904:           
  5905:                       IF(NHASE.ne.0) THEN
  5906:                          DO J=1,INSTAE
  5907:                             DO I=1,IMM
  5908:                                WRITE(IHOT,REC=IHOTSTP) STAELV(I,J)
  5909:                                IHOTSTP=IHOTSTP+1
  5910:                             ENDDO
  5911:                          ENDDO
  5912:                       ENDIF
  5913:           
  5914:                       IF(NHASV.ne.0) THEN
  5915:                          DO J=1,INSTAV
  5916:                             DO I=1,IMM
  5917:                                WRITE(IHOT,REC=IHOTSTP) STAULV(I,J)
  5918:                                IHOTSTP=IHOTSTP+1
  5919:                                WRITE(IHOT,REC=IHOTSTP) STAVLV(I,J)
  5920:                                IHOTSTP=IHOTSTP+1
  5921:                             ENDDO
  5922:                          ENDDO
  5923:                       ENDIF
  5924:           
  5925:                       IF(NHAGE.ne.0) THEN
  5926:                          DO J=1,INP
  5927:                             DO I=1,IMM
  5928:                                WRITE(IHOT,REC=IHOTSTP) GLOELV(I,J)
  5929:                                IHOTSTP=IHOTSTP+1
  5930:                             ENDDO
  5931:                          ENDDO
  5932:                       ENDIF
  5933:           
  5934:                       IF(NHAGV.ne.0) THEN
  5935:                          DO J=1,INP
  5936:                             DO I=1,IMM
  5937:                                WRITE(IHOT,REC=IHOTSTP) GLOULV(I,J)
  5938:                                IHOTSTP = IHOTSTP + 1
  5939:                                WRITE(IHOT,REC=IHOTSTP) GLOVLV(I,J)
  5940:                                IHOTSTP = IHOTSTP + 1
  5941:                             ENDDO
  5942:                          ENDDO
  5943:                       ENDIF
  5944:           
  5945:                    ENDIF
  5946:           
  5947:                    IF((FMV.GT.0.).AND.(INFREQ.GT.0).AND.(IM.EQ.0)) THEN !include means and variances
  5948:                       IF(ITHSF.GT.ITMV) THEN
  5949:                          WRITE(IHOT,REC=IHOTSTP) NTSTEPS
  5950:                          IHOTSTP=IHOTSTP+1
  5951:                          IF(NHAGE.EQ.1) THEN
  5952:                             DO I=1,INP
  5953:                                WRITE(IHOT,REC=IHOTSTP) ELAV(I)
  5954:                                IHOTSTP=IHOTSTP+1
  5955:                                WRITE(IHOT,REC=IHOTSTP) ELVA(I)
  5956:                                IHOTSTP=IHOTSTP+1
  5957:                             ENDDO
  5958:                          ENDIF
  5959:                          IF(NHAGV.EQ.1) THEN
  5960:                             DO I=1,INP
  5961:                                WRITE(IHOT,REC=IHOTSTP) XVELAV(I)
  5962:                                IHOTSTP=IHOTSTP+1
  5963:                                WRITE(IHOT,REC=IHOTSTP) YVELAV(I)
  5964:                                IHOTSTP=IHOTSTP+1
  5965:                                WRITE(IHOT,REC=IHOTSTP) XVELVA(I)
  5966:                                IHOTSTP=IHOTSTP+1
  5967:                                WRITE(IHOT,REC=IHOTSTP) YVELVA(I)
  5968:                                IHOTSTP=IHOTSTP+1
  5969:                             ENDDO
  5970:                          ENDIF
  5971:                       ENDIF
  5972:                    ENDIF    ! charmv
  5973:                 ENDIF     ! HARIND
  5974:           #endif
  5975:           
  5976:           C
  5977:           C--Close Global file and all the Local Files
  5978:           C
  5979:                 CLOSE (IHOT)
  5980:           C
  5981:                 DEALLOCATE ( LOC2 )
  5982:                 nbytes = 4*nproc
  5983:                 call memory_dealloc(nbytes)
  5984:                 DEALLOCATE ( ETA1, ETA2, EtaDisc, UU2, VV2, NODECODE, CH1 )
  5985:                 nbytes = 7*mnp
  5986:                 call memory_dealloc(nbytes)
  5987:                 DEALLOCATE ( NOFF )
  5988:                 nbytes = 6*mne
  5989:                 call memory_dealloc(nbytes)
  5990:                 call memory_status()
  5991:           C
  5992:                 RETURN
  5993:            1001 FORMAT('ERROR: The hot start file')
  5994:            1010 FORMAT(' File ',A60,/,' WAS NOT FOUND!  ADCPrep Terminated!!!',/)
  5995:            1011 FORMAT(' File ',A60,/,' WAS FOUND!  Opening & Processing file',/)
  5996:            1012 FORMAT('was a nonmatching version')
  5997:            1005 FORMAT('exists but cannot be opened.')
  5998:            9973 FORMAT(/,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
  5999:                 END SUBROUTINE HOTGLOBALIZE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTGLOBALIZE
INLINE LIST

  ROOT: HOTGLOBALIZE (prep.F:5483)
  -> NOINLINE: IWRITE (prep.F:5546)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5563)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5571)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_ALLOC (prep.F:5574)
     *** Source for routine not found.
  -> NOINLINE: READHOTSTART3DGLOBAL (prep.F:5716)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: WRITEHOTSTART3DGLOBAL (prep.F:5846)
     *** Inlining inhibited: SAVEed variables and/or not-inlinable data in routine.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5983)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5986)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_DEALLOC (prep.F:5989)
     *** Source for routine not found.
  -> NOINLINE: MEMORY_USAGE::MEMORY_STATUS (prep.F:5990)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTGLOBALIZE
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:5536)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FNAME (prep.F:5536)
  LOOP END

  LOOP BEGIN: (prep.F:5537)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FNAME (prep.F:5537)
  LOOP END

  LOOP BEGIN: (prep.F:5543)
    <Unvectorized loop.>
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:5543)
    *** I/O statement obstructs vectorization. (prep.F:5543)
    *** Vectorization obstructive statement. (prep.F:5543)

    LOOP BEGIN: (prep.F:5545)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:5545)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5610)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:5629)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5629)
    LOOP END

    LOOP BEGIN: (prep.F:5636)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5636)
    LOOP END

    LOOP BEGIN: (prep.F:5643)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5643)
    LOOP END

    LOOP BEGIN: (prep.F:5650)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5650)
    LOOP END

    LOOP BEGIN: (prep.F:5657)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5657)
    LOOP END

    LOOP BEGIN: (prep.F:5665)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5665)
    LOOP END

    LOOP BEGIN: (prep.F:5673)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5673)
    LOOP END

    LOOP BEGIN: (prep.F:5680)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:5680)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5767)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:5767)
  LOOP END

  LOOP BEGIN: (prep.F:5780)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5780)
  LOOP END

  LOOP BEGIN: (prep.F:5784)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5784)
  LOOP END

  LOOP BEGIN: (prep.F:5788)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5788)
  LOOP END

  LOOP BEGIN: (prep.F:5792)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5792)
  LOOP END

  LOOP BEGIN: (prep.F:5796)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5796)
  LOOP END

  LOOP BEGIN: (prep.F:5801)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5801)
  LOOP END

  LOOP BEGIN: (prep.F:5806)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5806)
  LOOP END

  LOOP BEGIN: (prep.F:5810)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:5810)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: HOTGLOBALIZE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 4272 bytes
      Register spill area      : 1352 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2584 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:5536)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:5537)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:5543)
    *** Estimated execution cycle                       : 457
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 28
            Across calls                                :  1
            Over basic blocks                           : 27
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 62
            Across calls                                :  1
            Over basic blocks                           : 61
    *** The number of SCALAR REGISTER TRANSFER          : 58

    LOOP BEGIN: (prep.F:5545)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5610)
    *** Estimated execution cycle                       : 1361
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 55
            Across calls                                : 26
            Over basic blocks                           : 29
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 158
            Across calls                                :  75
            Over basic blocks                           :  83
    *** The number of SCALAR REGISTER TRANSFER          : 158

    LOOP BEGIN: (prep.F:5629)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 6
              Across calls                              : 3
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END

    LOOP BEGIN: (prep.F:5636)
      *** Estimated execution cycle                     : 66
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 4
              Across calls                              : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 7
              Across calls                              : 4
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER TRANSFER        : 8
    LOOP END

    LOOP BEGIN: (prep.F:5643)
      *** Estimated execution cycle                     : 72
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 5
              Across calls                              : 5
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 9
              Across calls                              : 5
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER TRANSFER        : 8
    LOOP END

    LOOP BEGIN: (prep.F:5650)
      *** Estimated execution cycle                     : 77
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 6
              Across calls                              : 5
              Over basic blocks                         : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 10
              Across calls                              :  5
              Over basic blocks                         :  5
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END

    LOOP BEGIN: (prep.F:5657)
      *** Estimated execution cycle                     : 81
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 7
              Across calls                              : 5
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  5
              Over basic blocks                         :  6
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END

    LOOP BEGIN: (prep.F:5665)
      *** Estimated execution cycle                     : 85
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  4
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END

    LOOP BEGIN: (prep.F:5673)
      *** Estimated execution cycle                     : 88
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 5
              Over basic blocks                         : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 12
              Across calls                              :  5
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 11
    LOOP END

    LOOP BEGIN: (prep.F:5680)
      *** Estimated execution cycle                     : 85
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 8
              Across calls                              : 4
              Over basic blocks                         : 4
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 11
              Across calls                              :  4
              Over basic blocks                         :  7
      *** The number of SCALAR REGISTER TRANSFER        : 12
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:5767)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:5780)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5784)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5788)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5792)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5796)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5801)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END

  LOOP BEGIN: (prep.F:5806)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:5810)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER TRANSFER          : 6
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3D
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6063: vec( 103): Unvectorized loop.
  6063: vec( 180): I/O statement obstructs vectorization.
  6064: opt(1118): This I/O statement inhibits optimization of loop.
  6067: vec( 103): Unvectorized loop.
  6067: vec( 180): I/O statement obstructs vectorization.
  6068: opt(1118): This I/O statement inhibits optimization of loop.
  6071: vec( 103): Unvectorized loop.
  6071: vec( 180): I/O statement obstructs vectorization.
  6072: opt(1118): This I/O statement inhibits optimization of loop.
  6075: vec( 103): Unvectorized loop.
  6075: vec( 180): I/O statement obstructs vectorization.
  6076: opt(1118): This I/O statement inhibits optimization of loop.
  6079: vec( 103): Unvectorized loop.
  6079: vec( 180): I/O statement obstructs vectorization.
  6080: opt(1118): This I/O statement inhibits optimization of loop.
  6083: vec( 103): Unvectorized loop.
  6083: vec( 180): I/O statement obstructs vectorization.
  6084: opt(1118): This I/O statement inhibits optimization of loop.
  6087: vec( 103): Unvectorized loop.
  6087: vec( 180): I/O statement obstructs vectorization.
  6088: opt(1118): This I/O statement inhibits optimization of loop.
  6093: vec( 103): Unvectorized loop.
  6093: vec( 180): I/O statement obstructs vectorization.
  6094: opt(1118): This I/O statement inhibits optimization of loop.
  6099: vec( 103): Unvectorized loop.
  6099: vec( 180): I/O statement obstructs vectorization.
  6100: opt(1118): This I/O statement inhibits optimization of loop.
  6105: vec( 103): Unvectorized loop.
  6105: vec( 180): I/O statement obstructs vectorization.
  6106: opt(1118): This I/O statement inhibits optimization of loop.
  6111: vec( 103): Unvectorized loop.
  6111: vec( 180): I/O statement obstructs vectorization.
  6112: opt(1118): This I/O statement inhibits optimization of loop.
  6117: vec( 103): Unvectorized loop.
  6117: vec( 180): I/O statement obstructs vectorization.
  6118: opt(1118): This I/O statement inhibits optimization of loop.
  6124: vec( 103): Unvectorized loop.
  6124: vec( 180): I/O statement obstructs vectorization.
  6125: opt(1118): This I/O statement inhibits optimization of loop.
  6132: vec( 103): Unvectorized loop.
  6132: vec( 180): I/O statement obstructs vectorization.
  6133: opt(1118): This I/O statement inhibits optimization of loop.
  6140: vec( 103): Unvectorized loop.
  6140: vec( 180): I/O statement obstructs vectorization.
  6141: opt(1118): This I/O statement inhibits optimization of loop.
  6148: vec( 103): Unvectorized loop.
  6148: vec( 180): I/O statement obstructs vectorization.
  6149: opt(1118): This I/O statement inhibits optimization of loop.
  6154: vec( 103): Unvectorized loop.
  6154: vec( 180): I/O statement obstructs vectorization.
  6155: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3D
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6014:                 SUBROUTINE ReadHotStart3D(UnitNumber,FilePosition)
  6015:           C     ----------------------------------------------------------------------
  6016:                 USE PRE_GLOBAL
  6017:                 IMPLICIT NONE
  6018:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of full domain file
  6019:                 INTEGER, intent(inout) :: FilePosition ! position in binary file
  6020:                 INTEGER IHOTSTP,NH,K
  6021:           C
  6022:           C     Start reading in the data
  6023:           
  6024:           !kmd Added information for 3D hotstart
  6025:                 ALLOCATE ( DUU(MNP),DUV(MNP),DVV(MNP))
  6026:                 ALLOCATE ( UU(MNP),VV(MNP))
  6027:                 ALLOCATE ( BSX(MNP),BSY(MNP))
  6028:           !kmd end of additions
  6029:           
  6030:                   PRINT *, "NFEN = ", NFEN
  6031:                   IHOT=UnitNumber
  6032:                   IHOTSTP=FilePosition
  6033:           
  6034:                   PRINT *, "How many layers need to be evaluated:"
  6035:                   READ *, NFEN
  6036:           
  6037:                   PRINT *, "made it to 3D portion of code"
  6038:                   PRINT *, "MNP = ", MNP
  6039:                   PRINT *, "NFEN = ", NFEN
  6040:                   PRINT *, "IHOTSTP = ", IHOTSTP
  6041:           
  6042:           !kmd Added information for 3D hotstart
  6043:                 ALLOCATE ( WZ(MNP,NFEN), q20(MNP,NFEN))
  6044:                 ALLOCATE ( RealQ(MNP,NFEN), ImagQ(MNP,NFEN))
  6045:                 ALLOCATE ( l(MNP,NFEN), SigT(MNP,NFEN))
  6046:                 ALLOCATE ( Sal(MNP,NFEN), Temp(MNP,NFEN))
  6047:           !kmd end of additions
  6048:           
  6049:                   READ(IHOT,REC=IHOTSTP) IDEN  ;  IHOTSTP = IHOTSTP + 1
  6050:                   READ(IHOT,REC=IHOTSTP) N3DSD ;  IHOTSTP = IHOTSTP + 1
  6051:                   READ(IHOT,REC=IHOTSTP) I3DSDRec ;  IHOTSTP = IHOTSTP + 1
  6052:                   READ(IHOT,REC=IHOTSTP) N3DSV ;  IHOTSTP = IHOTSTP + 1
  6053:                   READ(IHOT,REC=IHOTSTP) I3DSVRec ;  IHOTSTP = IHOTSTP + 1
  6054:                   READ(IHOT,REC=IHOTSTP) N3DST ;  IHOTSTP = IHOTSTP + 1
  6055:                   READ(IHOT,REC=IHOTSTP) I3DSTRec ;  IHOTSTP = IHOTSTP + 1
  6056:                   READ(IHOT,REC=IHOTSTP) N3DGD ;  IHOTSTP = IHOTSTP + 1
  6057:                   READ(IHOT,REC=IHOTSTP) I3DGDRec ;  IHOTSTP = IHOTSTP + 1
  6058:                   READ(IHOT,REC=IHOTSTP) N3DGV ;  IHOTSTP = IHOTSTP + 1
  6059:                   READ(IHOT,REC=IHOTSTP) I3DGVRec ;  IHOTSTP = IHOTSTP + 1
  6060:                   READ(IHOT,REC=IHOTSTP) N3DGT ;  IHOTSTP = IHOTSTP + 1
  6061:                   READ(IHOT,REC=IHOTSTP) I3DGTRec ;  IHOTSTP = IHOTSTP + 1
  6062:           
  6063: +------>          DO NH=1,MNP
  6064: |                   READ(IHOT,REC=IHOTSTP) DUU(NH)
  6065: |                   IHOTSTP=IHOTSTP+1
  6066: +------           END DO
  6067: +------>          DO NH=1,MNP
  6068: |                   READ(IHOT,REC=IHOTSTP) DUV(NH)
  6069: |                   IHOTSTP=IHOTSTP+1
  6070: +------           END DO
  6071: +------>          DO NH=1,MNP
  6072: |                   READ(IHOT,REC=IHOTSTP) DVV(NH)
  6073: |                   IHOTSTP=IHOTSTP+1
  6074: +------           END DO
  6075: +------>          DO NH=1,MNP
  6076: |                   READ(IHOT,REC=IHOTSTP) UU(NH)
  6077: |                   IHOTSTP=IHOTSTP+1
  6078: +------           END DO
  6079: +------>          DO NH=1,MNP
  6080: |                   READ(IHOT,REC=IHOTSTP) VV(NH)
  6081: |                   IHOTSTP=IHOTSTP+1
  6082: +------           END DO
  6083: +------>          DO NH=1,MNP
  6084: |                   READ(IHOT,REC=IHOTSTP) BSX(NH)
  6085: |                   IHOTSTP=IHOTSTP+1
  6086: +------           END DO
  6087: +------>          DO NH=1,MNP
  6088: |                   READ(IHOT,REC=IHOTSTP) BSY(NH)
  6089: |                   IHOTSTP=IHOTSTP+1
  6090: +------           ENDDO
  6091:           
  6092: +------>          DO K=1,NFEN
  6093: |+----->            DO NH=1,MNP
  6094: ||                    READ(IHOT,REC=IHOTSTP) RealQ(NH,K)
  6095: ||                    IHOTSTP=IHOTSTP+1
  6096: |+-----             END DO
  6097: +------           END DO
  6098: +------>          DO K=1,NFEN
  6099: |+----->            DO NH=1,MNP
  6100: ||                    READ(IHOT,REC=IHOTSTP) ImagQ(NH,K)
  6101: ||                    IHOTSTP=IHOTSTP+1
  6102: |+-----             END DO
  6103: +------           END DO
  6104: +------>          DO K=1,NFEN
  6105: |+----->            DO NH=1,MNP
  6106: ||                    READ(IHOT,REC=IHOTSTP) WZ(NH,K)
  6107: ||                    IHOTSTP=IHOTSTP+1
  6108: |+-----             END DO
  6109: +------           END DO
  6110: +------>          DO K=1,NFEN
  6111: |+----->            DO NH=1,MNP
  6112: ||                    READ(IHOT,REC=IHOTSTP) q20(NH,K)
  6113: ||                    IHOTSTP=IHOTSTP+1
  6114: |+-----             END DO
  6115: +------           END DO
  6116: +------>          DO K=1,NFEN
  6117: |+----->            DO NH=1,MNP
  6118: ||                    READ(IHOT,REC=IHOTSTP) l(NH,K)
  6119: ||                    IHOTSTP=IHOTSTP+1
  6120: |+-----             END DO
  6121: +------           END DO
  6122:                   IF (ABS(IDEN).EQ.1) THEN
  6123: +------>            DO K=1,NFEN
  6124: |+----->              DO NH=1,MNP
  6125: ||                      READ(IHOT,REC=IHOTSTP) SigT(NH,K)
  6126: ||                      IHOTSTP=IHOTSTP+1
  6127: |+-----               END DO
  6128: +------             END DO
  6129:                   END IF
  6130:                   IF(ABS(IDen).EQ.2) THEN
  6131: +------>            DO K=1,NFEN
  6132: |+----->              DO NH=1,MNP
  6133: ||                      READ(IHOT,REC=IHOTSTP) Sal(NH,K)
  6134: ||                      IHOTSTP=IHOTSTP+1
  6135: |+-----               END DO
  6136: +------             END DO
  6137:                   ENDIF
  6138:                   IF(ABS(IDen).EQ.3) THEN
  6139: +------>            DO K=1,NFEN
  6140: |+----->              DO NH=1,MNP
  6141: ||                      READ(IHOT,REC=IHOTSTP) Temp(NH,K)
  6142: ||                      IHOTSTP=IHOTSTP+1
  6143: |+-----               END DO
  6144: +------             END DO
  6145:                   ENDIF
  6146:                   IF(ABS(IDen).EQ.4) THEN
  6147: +------>            DO K=1,NFEN
  6148: |+----->              DO NH=1,MNP
  6149: ||                      READ(IHOT,REC=IHOTSTP) Sal(NH,K)
  6150: ||                      IHOTSTP=IHOTSTP+1
  6151: |+-----               END DO
  6152: +------             END DO
  6153: +------>            DO K=1,NFEN
  6154: |+----->              DO NH=1,MNP
  6155: ||                      READ(IHOT,REC=IHOTSTP) Temp(NH,K)
  6156: ||                      IHOTSTP=IHOTSTP+1
  6157: |+-----               ENDDO
  6158: +------             ENDDO
  6159:                   END IF
  6160:           
  6161:                 RETURN
  6162:           C     ----------------------------------------------------------------------
  6163:                 END SUBROUTINE ReadHotStart3D


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3D
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3D
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6063)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6063)
  LOOP END

  LOOP BEGIN: (prep.F:6067)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6067)
  LOOP END

  LOOP BEGIN: (prep.F:6071)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6071)
  LOOP END

  LOOP BEGIN: (prep.F:6075)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6075)
  LOOP END

  LOOP BEGIN: (prep.F:6079)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6079)
  LOOP END

  LOOP BEGIN: (prep.F:6083)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6083)
  LOOP END

  LOOP BEGIN: (prep.F:6087)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6087)
  LOOP END

  LOOP BEGIN: (prep.F:6092)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6093)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6093)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6098)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6099)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6099)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6104)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6105)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6105)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6110)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6111)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6111)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6116)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6117)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6117)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6123)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6124)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6124)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6131)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6132)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6132)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6139)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6140)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6140)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6147)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6148)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6148)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6153)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6154)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6154)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3D
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 46 [s0-s12 s15-s16 s18-s44 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2032 bytes
      Register spill area      :  376 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1400 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6063)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6067)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6071)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6075)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6079)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6083)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6087)
    *** Estimated execution cycle                       : 31
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6092)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6093)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6098)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6099)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6104)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6105)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6110)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6111)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6116)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6117)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6123)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6124)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6131)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6132)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6139)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6140)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6147)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6148)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6153)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6154)
      *** Estimated execution cycle                     : 41
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 6
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3D
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6203: vec( 103): Unvectorized loop.
  6203: vec( 180): I/O statement obstructs vectorization.
  6205: opt(1118): This I/O statement inhibits optimization of loop.
  6208: vec( 103): Unvectorized loop.
  6208: vec( 180): I/O statement obstructs vectorization.
  6210: opt(1118): This I/O statement inhibits optimization of loop.
  6213: vec( 103): Unvectorized loop.
  6213: vec( 180): I/O statement obstructs vectorization.
  6215: opt(1118): This I/O statement inhibits optimization of loop.
  6218: vec( 103): Unvectorized loop.
  6218: vec( 180): I/O statement obstructs vectorization.
  6220: opt(1118): This I/O statement inhibits optimization of loop.
  6223: vec( 103): Unvectorized loop.
  6223: vec( 180): I/O statement obstructs vectorization.
  6225: opt(1118): This I/O statement inhibits optimization of loop.
  6228: vec( 103): Unvectorized loop.
  6228: vec( 180): I/O statement obstructs vectorization.
  6230: opt(1118): This I/O statement inhibits optimization of loop.
  6233: vec( 103): Unvectorized loop.
  6233: vec( 180): I/O statement obstructs vectorization.
  6235: opt(1118): This I/O statement inhibits optimization of loop.
  6240: vec( 103): Unvectorized loop.
  6240: vec( 180): I/O statement obstructs vectorization.
  6242: opt(1118): This I/O statement inhibits optimization of loop.
  6248: vec( 103): Unvectorized loop.
  6248: vec( 180): I/O statement obstructs vectorization.
  6250: opt(1118): This I/O statement inhibits optimization of loop.
  6256: vec( 103): Unvectorized loop.
  6256: vec( 180): I/O statement obstructs vectorization.
  6258: opt(1118): This I/O statement inhibits optimization of loop.
  6264: vec( 103): Unvectorized loop.
  6264: vec( 180): I/O statement obstructs vectorization.
  6266: opt(1118): This I/O statement inhibits optimization of loop.
  6272: vec( 103): Unvectorized loop.
  6272: vec( 180): I/O statement obstructs vectorization.
  6274: opt(1118): This I/O statement inhibits optimization of loop.
  6281: vec( 103): Unvectorized loop.
  6281: vec( 180): I/O statement obstructs vectorization.
  6283: opt(1118): This I/O statement inhibits optimization of loop.
  6290: vec( 103): Unvectorized loop.
  6290: vec( 180): I/O statement obstructs vectorization.
  6292: opt(1118): This I/O statement inhibits optimization of loop.
  6299: vec( 103): Unvectorized loop.
  6299: vec( 180): I/O statement obstructs vectorization.
  6301: opt(1118): This I/O statement inhibits optimization of loop.
  6308: vec( 103): Unvectorized loop.
  6308: vec( 180): I/O statement obstructs vectorization.
  6310: opt(1118): This I/O statement inhibits optimization of loop.
  6315: vec( 103): Unvectorized loop.
  6315: vec( 180): I/O statement obstructs vectorization.
  6317: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3D
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6175:                 SUBROUTINE WriteHotStart3D(UnitNumber,FilePosition,IPROC)
  6176:           C     ----------------------------------------------------------------------
  6177:                 USE PRE_GLOBAL
  6178:                 IMPLICIT NONE
  6179:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of subdomain file
  6180:                 INTEGER, intent(inout) :: FilePosition ! position in binary file
  6181:                 INTEGER IHOTSTP, LOCHSF, I, N, IINDX
  6182:                 INTEGER, intent(in) :: IPROC
  6183:           
  6184:           C     Start writing out the 3D hotstart information
  6185:           
  6186:                       LOCHSF=UnitNumber
  6187:                       IHOTSTP=FilePosition
  6188:           
  6189:                       WRITE(LOCHSF,REC=IHOTSTP) IDEN ; IHOTSTP = IHOTSTP + 1
  6190:                       WRITE(LOCHSF,REC=IHOTSTP) N3DSD ; IHOTSTP = IHOTSTP + 1
  6191:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSDRec ; IHOTSTP = IHOTSTP + 1
  6192:                       WRITE(LOCHSF,REC=IHOTSTP) N3DSV ; IHOTSTP = IHOTSTP + 1
  6193:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSVRec ; IHOTSTP = IHOTSTP + 1
  6194:                       WRITE(LOCHSF,REC=IHOTSTP) N3DST ; IHOTSTP = IHOTSTP + 1
  6195:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSTRec ; IHOTSTP = IHOTSTP + 1
  6196:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGD ; IHOTSTP = IHOTSTP + 1
  6197:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGDRec ; IHOTSTP = IHOTSTP + 1
  6198:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGV ; IHOTSTP = IHOTSTP + 1
  6199:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGVRec ; IHOTSTP = IHOTSTP + 1
  6200:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGT ; IHOTSTP = IHOTSTP + 1
  6201:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGTRec ; IHOTSTP = IHOTSTP + 1
  6202:           
  6203: +------>              DO I=1,NNODP(IPROC)
  6204: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6205: |                        WRITE(LOCHSF,REC=IHOTSTP) DUU(IINDX)
  6206: |                        IHOTSTP=IHOTSTP+1
  6207: +------               END DO
  6208: +------>              DO I=1,NNODP(IPROC)
  6209: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6210: |                        WRITE(LOCHSF,REC=IHOTSTP) DUV(IINDX)
  6211: |                        IHOTSTP=IHOTSTP+1
  6212: +------               END DO
  6213: +------>              DO I=1,NNODP(IPROC)
  6214: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6215: |                        WRITE(LOCHSF,REC=IHOTSTP) DVV(IINDX)
  6216: |                        IHOTSTP=IHOTSTP+1
  6217: +------               END DO
  6218: +------>              DO I=1,NNODP(IPROC)
  6219: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6220: |                        WRITE(LOCHSF,REC=IHOTSTP) UU(IINDX)
  6221: |                        IHOTSTP=IHOTSTP+1
  6222: +------               END DO
  6223: +------>              DO I=1,NNODP(IPROC)
  6224: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6225: |                        WRITE(LOCHSF,REC=IHOTSTP) VV(IINDX)
  6226: |                        IHOTSTP=IHOTSTP+1
  6227: +------               END DO
  6228: +------>              DO I=1,NNODP(IPROC)
  6229: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6230: |                        WRITE(LOCHSF,REC=IHOTSTP) BSX(IINDX)
  6231: |                        IHOTSTP=IHOTSTP+1
  6232: +------               END DO
  6233: +------>              DO I=1,NNODP(IPROC)
  6234: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6235: |                        WRITE(LOCHSF,REC=IHOTSTP) BSY(IINDX)
  6236: |                        IHOTSTP=IHOTSTP+1
  6237: +------                ENDDO
  6238:           
  6239: +------>              DO N=1,NFEN
  6240: |+----->                DO I=1,NNODP(IPROC)
  6241: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6242: ||                        WRITE(LOCHSF,REC=IHOTSTP) RealQ(IINDX,N)
  6243: ||                        IHOTSTP=IHOTSTP+1
  6244: |+-----                 END DO
  6245: +------               END DO
  6246:           
  6247: +------>              DO N=1,NFEN
  6248: |+----->                DO I=1,NNODP(IPROC)
  6249: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6250: ||                        WRITE(LOCHSF,REC=IHOTSTP) ImagQ(IINDX,N)
  6251: ||                        IHOTSTP=IHOTSTP+1
  6252: |+-----                 END DO
  6253: +------               END DO
  6254:           
  6255: +------>              DO N=1,NFEN
  6256: |+----->                DO I=1,NNODP(IPROC)
  6257: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6258: ||                        WRITE(LOCHSF,REC=IHOTSTP) WZ(IINDX,N)
  6259: ||                        IHOTSTP=IHOTSTP+1
  6260: |+-----                 END DO
  6261: +------               END DO
  6262:           
  6263: +------>              DO N=1,NFEN
  6264: |+----->                DO I=1,NNODP(IPROC)
  6265: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6266: ||                        WRITE(LOCHSF,REC=IHOTSTP) q20(IINDX,N)
  6267: ||                        IHOTSTP=IHOTSTP+1
  6268: |+-----                 END DO
  6269: +------               END DO
  6270:           
  6271: +------>              DO N=1,NFEN
  6272: |+----->                DO I=1,NNODP(IPROC)
  6273: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6274: ||                        WRITE(LOCHSF,REC=IHOTSTP) l(IINDX,N)
  6275: ||                        IHOTSTP=IHOTSTP+1
  6276: |+-----                 END DO
  6277: +------               END DO
  6278:           
  6279:                       IF (ABS(IDEN).EQ.1) THEN
  6280: +------>                DO N=1,NFEN
  6281: |+----->                  DO I=1,NNODP(IPROC)
  6282: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6283: ||                          WRITE(LOCHSF,REC=IHOTSTP) SigT(IINDX,N)
  6284: ||                          IHOTSTP=IHOTSTP+1
  6285: |+-----                   END DO
  6286: +------                 END DO
  6287:                       ENDIF
  6288:                       IF(ABS(IDen).EQ.2) THEN
  6289: +------>                DO N=1,NFEN
  6290: |+----->                  DO I=1,NNODP(IPROC)
  6291: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6292: ||                          WRITE(LOCHSF,REC=IHOTSTP) Sal(IINDX,N)
  6293: ||                          IHOTSTP=IHOTSTP+1
  6294: |+-----                   END DO
  6295: +------                 END DO
  6296:                       ENDIF
  6297:                       IF(ABS(IDen).EQ.3) THEN
  6298: +------>                DO N=1,NFEN
  6299: |+----->                  DO I=1,NNODP(IPROC)
  6300: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6301: ||                          WRITE(LOCHSF,REC=IHOTSTP) Temp(IINDX,N)
  6302: ||                          IHOTSTP=IHOTSTP+1
  6303: |+-----                   END DO
  6304: +------                 END DO
  6305:                       ENDIF
  6306:                       IF(ABS(IDen).EQ.4) THEN
  6307: +------>                DO N=1,NFEN
  6308: |+----->                  DO I=1,NNODP(IPROC)
  6309: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6310: ||                          WRITE(LOCHSF,REC=IHOTSTP) Sal(IINDX,N)
  6311: ||                          IHOTSTP=IHOTSTP+1
  6312: |+-----                   END DO
  6313: +------                 END DO
  6314: +------>                DO N=1,NFEN
  6315: |+----->                  DO I=1,NNODP(IPROC)
  6316: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6317: ||                          WRITE(LOCHSF,REC=IHOTSTP) Temp(IINDX,N)
  6318: ||                          IHOTSTP=IHOTSTP+1
  6319: |+-----                   END DO
  6320: +------                 END DO
  6321:                       END IF
  6322:           
  6323:                 RETURN
  6324:           C     ----------------------------------------------------------------------
  6325:                 END SUBROUTINE WriteHotStart3D


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3D
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3D
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6203)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6203)
  LOOP END

  LOOP BEGIN: (prep.F:6208)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6208)
  LOOP END

  LOOP BEGIN: (prep.F:6213)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6213)
  LOOP END

  LOOP BEGIN: (prep.F:6218)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6218)
  LOOP END

  LOOP BEGIN: (prep.F:6223)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6223)
  LOOP END

  LOOP BEGIN: (prep.F:6228)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6228)
  LOOP END

  LOOP BEGIN: (prep.F:6233)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6233)
  LOOP END

  LOOP BEGIN: (prep.F:6239)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6240)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6240)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6247)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6248)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6248)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6255)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6256)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6256)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6263)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6264)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6264)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6271)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6272)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6272)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6280)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6281)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6281)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6289)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6290)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6290)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6298)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6299)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6299)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6307)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6308)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6308)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6314)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6315)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6315)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3D
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 44 [s0-s12 s15-s16 s18-s42 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1968 bytes
      Register spill area      :  352 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1376 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6203)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6208)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6213)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6218)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6223)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6228)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6233)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6239)
    *** Estimated execution cycle                       : 28
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6240)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6247)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6248)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6255)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6256)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6263)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6264)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6271)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6272)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6280)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6281)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6289)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6290)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6298)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6299)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6307)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6308)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6314)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6315)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3DGLOBAL
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6387: vec( 103): Unvectorized loop.
  6387: vec( 180): I/O statement obstructs vectorization.
  6389: opt(1118): This I/O statement inhibits optimization of loop.
  6393: vec( 103): Unvectorized loop.
  6393: vec( 180): I/O statement obstructs vectorization.
  6395: opt(1118): This I/O statement inhibits optimization of loop.
  6399: vec( 103): Unvectorized loop.
  6399: vec( 180): I/O statement obstructs vectorization.
  6401: opt(1118): This I/O statement inhibits optimization of loop.
  6405: vec( 103): Unvectorized loop.
  6405: vec( 180): I/O statement obstructs vectorization.
  6407: opt(1118): This I/O statement inhibits optimization of loop.
  6411: vec( 103): Unvectorized loop.
  6411: vec( 180): I/O statement obstructs vectorization.
  6413: opt(1118): This I/O statement inhibits optimization of loop.
  6417: vec( 103): Unvectorized loop.
  6417: vec( 180): I/O statement obstructs vectorization.
  6419: opt(1118): This I/O statement inhibits optimization of loop.
  6423: vec( 103): Unvectorized loop.
  6423: vec( 180): I/O statement obstructs vectorization.
  6425: opt(1118): This I/O statement inhibits optimization of loop.
  6431: vec( 103): Unvectorized loop.
  6431: vec( 180): I/O statement obstructs vectorization.
  6433: opt(1118): This I/O statement inhibits optimization of loop.
  6439: vec( 103): Unvectorized loop.
  6439: vec( 180): I/O statement obstructs vectorization.
  6441: opt(1118): This I/O statement inhibits optimization of loop.
  6447: vec( 103): Unvectorized loop.
  6447: vec( 180): I/O statement obstructs vectorization.
  6449: opt(1118): This I/O statement inhibits optimization of loop.
  6455: vec( 103): Unvectorized loop.
  6455: vec( 180): I/O statement obstructs vectorization.
  6457: opt(1118): This I/O statement inhibits optimization of loop.
  6463: vec( 103): Unvectorized loop.
  6463: vec( 180): I/O statement obstructs vectorization.
  6465: opt(1118): This I/O statement inhibits optimization of loop.
  6472: vec( 103): Unvectorized loop.
  6472: vec( 180): I/O statement obstructs vectorization.
  6474: opt(1118): This I/O statement inhibits optimization of loop.
  6482: vec( 103): Unvectorized loop.
  6482: vec( 180): I/O statement obstructs vectorization.
  6484: opt(1118): This I/O statement inhibits optimization of loop.
  6492: vec( 103): Unvectorized loop.
  6492: vec( 180): I/O statement obstructs vectorization.
  6494: opt(1118): This I/O statement inhibits optimization of loop.
  6502: vec( 103): Unvectorized loop.
  6502: vec( 180): I/O statement obstructs vectorization.
  6504: opt(1118): This I/O statement inhibits optimization of loop.
  6510: vec( 103): Unvectorized loop.
  6510: vec( 180): I/O statement obstructs vectorization.
  6512: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3DGLOBAL
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6337:                 SUBROUTINE ReadHotStart3DGlobal(UnitNumber,FilePosition,ProcessNo)
  6338:           C     ----------------------------------------------------------------------
  6339:                 USE PRE_GLOBAL
  6340:                 IMPLICIT NONE
  6341:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of full domain file
  6342:                 INTEGER, intent(inout) :: FilePosition ! position in binary file
  6343:                 INTEGER, intent(in) :: ProcessNo ! i/o unit of full domain file
  6344:                 INTEGER IHOTSTP,NH,K,I,IPROC
  6345:                 INTEGER IINDX
  6346:                 REAL(8) RVALUE
  6347:           C
  6348:           C     Start reading in the data
  6349:           
  6350:           !kmd Added information for 3D hotstart
  6351:                 ALLOCATE ( DUU(MNP),DUV(MNP),DVV(MNP))
  6352:                 ALLOCATE ( UU(MNP),VV(MNP))
  6353:                 ALLOCATE ( BSX(MNP),BSY(MNP))
  6354:           !kmd end of additions
  6355:           
  6356:                   IHOT=UnitNumber
  6357:                   IHOTSTP=FilePosition
  6358:                   IPROC=ProcessNo
  6359:           
  6360:                   PRINT*, "How many layers need to be evaluated:"
  6361:                   READ *, NFEN
  6362:           
  6363:           C        PRINT *, "Made it to the 3d portion of this"
  6364:                   PRINT *, "NFEN = ", NFEN
  6365:           
  6366:           !kmd Added information for 3D hotstart
  6367:                 ALLOCATE ( WZ(MNP,NFEN), q20(MNP,NFEN))
  6368:                 ALLOCATE ( RealQ(MNP,NFEN), ImagQ(MNP,NFEN))
  6369:                 ALLOCATE ( l(MNP,NFEN), SigT(MNP,NFEN))
  6370:                 ALLOCATE ( Sal(MNP,NFEN), Temp(MNP,NFEN))
  6371:           !kmd end of additions
  6372:           
  6373:                   READ(IHOT,REC=IHOTSTP) IDEN ; IHOTSTP = IHOTSTP + 1
  6374:                   READ(IHOT,REC=IHOTSTP) N3DSD ; IHOTSTP = IHOTSTP + 1
  6375:                   READ(IHOT,REC=IHOTSTP) I3DSDRec ; IHOTSTP = IHOTSTP + 1
  6376:                   READ(IHOT,REC=IHOTSTP) N3DSV ; IHOTSTP = IHOTSTP + 1
  6377:                   READ(IHOT,REC=IHOTSTP) I3DSVRec ; IHOTSTP = IHOTSTP + 1
  6378:                   READ(IHOT,REC=IHOTSTP) N3DST ; IHOTSTP = IHOTSTP + 1
  6379:                   READ(IHOT,REC=IHOTSTP) I3DSTRec ; IHOTSTP = IHOTSTP + 1
  6380:                   READ(IHOT,REC=IHOTSTP) N3DGD ; IHOTSTP = IHOTSTP + 1
  6381:                   READ(IHOT,REC=IHOTSTP) I3DGDRec ; IHOTSTP = IHOTSTP + 1
  6382:                   READ(IHOT,REC=IHOTSTP) N3DGV ; IHOTSTP = IHOTSTP + 1
  6383:                   READ(IHOT,REC=IHOTSTP) I3DGVRec ; IHOTSTP = IHOTSTP + 1
  6384:                   READ(IHOT,REC=IHOTSTP) N3DGT ; IHOTSTP = IHOTSTP + 1
  6385:                   READ(IHOT,REC=IHOTSTP) I3DGTRec ; IHOTSTP = IHOTSTP + 1
  6386:           
  6387: +------>          DO I=1,NNODP(IPROC)
  6388: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6389: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6390: |                   IF (IINDX.GT.0) DUU(IINDX) = RVALUE
  6391: |                   IHOTSTP=IHOTSTP+1
  6392: +------           END DO
  6393: +------>          DO I=1,NNODP(IPROC)
  6394: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6395: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6396: |                   IF (IINDX.GT.0) DUV(IINDX) = RVALUE
  6397: |                   IHOTSTP=IHOTSTP+1
  6398: +------           END DO
  6399: +------>          DO I=1,NNODP(IPROC)
  6400: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6401: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6402: |                   IF (IINDX.GT.0) DVV(IINDX) = RVALUE
  6403: |                   IHOTSTP=IHOTSTP+1
  6404: +------           END DO
  6405: +------>          DO I=1,NNODP(IPROC)
  6406: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6407: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6408: |                   IF (IINDX.GT.0) UU(IINDX) = RVALUE
  6409: |                   IHOTSTP=IHOTSTP+1
  6410: +------           END DO
  6411: +------>          DO I=1,NNODP(IPROC)
  6412: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6413: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6414: |                   IF (IINDX.GT.0) VV(IINDX) = RVALUE
  6415: |                   IHOTSTP=IHOTSTP+1
  6416: +------           END DO
  6417: +------>          DO I=1,NNODP(IPROC)
  6418: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6419: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6420: |                   IF (IINDX.GT.0) BSX(IINDX) = RVALUE
  6421: |                   IHOTSTP=IHOTSTP+1
  6422: +------           END DO
  6423: +------>          DO I=1,NNODP(IPROC)
  6424: |                   IINDX=IMAP_NOD_LG(I,IPROC)
  6425: |                   READ(IHOT,REC=IHOTSTP) RVALUE
  6426: |                   IF (IINDX.GT.0) BSY(IINDX) = RVALUE
  6427: |                   IHOTSTP=IHOTSTP+1
  6428: +------           END DO
  6429:           
  6430: +------>          DO K=1,NFEN
  6431: |+----->            DO I=1,NNODP(IPROC)
  6432: ||                    IINDX=IMAP_NOD_LG(I,IPROC)
  6433: ||                    READ(IHOT,REC=IHOTSTP) RVALUE
  6434: ||                    IF (IINDX.GT.0) REALQ(IINDX,K) = RVALUE
  6435: ||                    IHOTSTP=IHOTSTP+1
  6436: |+-----             END DO
  6437: +------           END DO
  6438: +------>          DO K=1,NFEN
  6439: |+----->            DO I=1,NNODP(IPROC)
  6440: ||                    IINDX=IMAP_NOD_LG(I,IPROC)
  6441: ||                    READ(IHOT,REC=IHOTSTP) RVALUE
  6442: ||                    IF (IINDX.GT.0) ImagQ(IINDX,K) = RVALUE
  6443: ||                    IHOTSTP=IHOTSTP+1
  6444: |+-----             END DO
  6445: +------           END DO
  6446: +------>          DO K=1,NFEN
  6447: |+----->            DO I=1,NNODP(IPROC)
  6448: ||                    IINDX=IMAP_NOD_LG(I,IPROC)
  6449: ||                    READ(IHOT,REC=IHOTSTP) RVALUE
  6450: ||                    IF (IINDX.GT.0) WZ(IINDX,K) = RVALUE
  6451: ||                    IHOTSTP=IHOTSTP+1
  6452: |+-----             END DO
  6453: +------           END DO
  6454: +------>          DO K=1,NFEN
  6455: |+----->            DO I=1,NNODP(IPROC)
  6456: ||                    IINDX=IMAP_NOD_LG(I,IPROC)
  6457: ||                    READ(IHOT,REC=IHOTSTP) RVALUE
  6458: ||                    IF (IINDX.GT.0) q20(IINDX,K) = RVALUE
  6459: ||                    IHOTSTP=IHOTSTP+1
  6460: |+-----             END DO
  6461: +------           END DO
  6462: +------>          DO K=1,NFEN
  6463: |+----->            DO I=1,NNODP(IPROC)
  6464: ||                    IINDX=IMAP_NOD_LG(I,IPROC)
  6465: ||                    READ(IHOT,REC=IHOTSTP) RVALUE
  6466: ||                    IF (IINDX.GT.0) l(IINDX,K) = RVALUE
  6467: ||                    IHOTSTP=IHOTSTP+1
  6468: |+-----             END DO
  6469: +------           END DO
  6470:                   IF (ABS(IDEN).EQ.1) THEN
  6471: +------>            DO K=1,NFEN
  6472: |+----->              DO I=1,NNODP(IPROC)
  6473: ||                      IINDX=IMAP_NOD_LG(I,IPROC)
  6474: ||                      READ(IHOT,REC=IHOTSTP) RVALUE
  6475: ||                      IF (IINDX.GT.0) SigT(IINDX,K) = RVALUE
  6476: ||                      IHOTSTP=IHOTSTP+1
  6477: |+-----               END DO
  6478: +------             END DO
  6479:                   END IF
  6480:                   IF(ABS(IDen).EQ.2) THEN
  6481: +------>            DO K=1,NFEN
  6482: |+----->              DO I=1,NNODP(IPROC)
  6483: ||                      IINDX=IMAP_NOD_LG(I,IPROC)
  6484: ||                      READ(IHOT,REC=IHOTSTP) RVALUE
  6485: ||                      IF (IINDX.GT.0) Sal(IINDX,K) = RVALUE
  6486: ||                      IHOTSTP=IHOTSTP+1
  6487: |+-----               END DO
  6488: +------             END DO
  6489:                   ENDIF
  6490:                   IF(ABS(IDen).EQ.3) THEN
  6491: +------>            DO K=1,NFEN
  6492: |+----->              DO I=1,NNODP(IPROC)
  6493: ||                      IINDX=IMAP_NOD_LG(I,IPROC)
  6494: ||                      READ(IHOT,REC=IHOTSTP) RVALUE
  6495: ||                      IF (IINDX.GT.0) Temp(IINDX,K) = RVALUE
  6496: ||                      IHOTSTP=IHOTSTP+1
  6497: |+-----               END DO
  6498: +------             END DO
  6499:                   ENDIF
  6500:                   IF(ABS(IDen).EQ.4) THEN
  6501: +------>            DO K=1,NFEN
  6502: |+----->              DO I=1,NNODP(IPROC)
  6503: ||                      IINDX=IMAP_NOD_LG(I,IPROC)
  6504: ||                      READ(IHOT,REC=IHOTSTP) RVALUE
  6505: ||                      IF (IINDX.GT.0) Sal(IINDX,K) = RVALUE
  6506: ||                      IHOTSTP=IHOTSTP+1
  6507: |+-----               END DO
  6508: +------             END DO
  6509: +------>            DO K=1,NFEN
  6510: |+----->              DO I=1,NNODP(IPROC)
  6511: ||                      IINDX=IMAP_NOD_LG(I,IPROC)
  6512: ||                      READ(IHOT,REC=IHOTSTP) RVALUE
  6513: ||                      IF (IINDX.GT.0) TEMP(IINDX,K) = RVALUE
  6514: ||                      IHOTSTP=IHOTSTP+1
  6515: |+-----               END DO
  6516: +------             ENDDO
  6517:                   END IF
  6518:           
  6519:                 RETURN
  6520:           C     ----------------------------------------------------------------------
  6521:                 END SUBROUTINE ReadHotStart3DGlobal


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3DGLOBAL
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3DGLOBAL
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6387)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6387)
  LOOP END

  LOOP BEGIN: (prep.F:6393)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6393)
  LOOP END

  LOOP BEGIN: (prep.F:6399)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6399)
  LOOP END

  LOOP BEGIN: (prep.F:6405)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6405)
  LOOP END

  LOOP BEGIN: (prep.F:6411)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6411)
  LOOP END

  LOOP BEGIN: (prep.F:6417)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6417)
  LOOP END

  LOOP BEGIN: (prep.F:6423)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6423)
  LOOP END

  LOOP BEGIN: (prep.F:6430)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6431)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6431)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6438)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6439)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6439)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6446)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6447)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6447)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6454)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6455)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6455)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6462)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6463)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6463)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6471)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6472)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6472)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6481)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6482)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6482)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6491)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6492)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6492)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6501)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6502)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6502)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6509)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6510)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6510)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READHOTSTART3DGLOBAL
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 46 [s0-s12 s15-s16 s18-s44 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2320 bytes
      Register spill area      :  512 bytes
      Parameter area           :   72 bytes
      Register save area       :  176 bytes
      User data area           : 1552 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6387)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6393)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6399)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6405)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6411)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6417)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6423)
    *** Estimated execution cycle                       : 57
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 4
            Across calls                                : 2
            Over basic blocks                           : 2
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6430)
    *** Estimated execution cycle                       : 28
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 5

    LOOP BEGIN: (prep.F:6431)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6438)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6439)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6446)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6447)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6454)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6455)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6462)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6463)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6471)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6472)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6481)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6482)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6491)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6492)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6501)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6502)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6509)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6510)
      *** Estimated execution cycle                     : 62
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 2
              Across calls                              : 2
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 4
              Across calls                              : 2
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 7
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3DGLOBAL
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6561: vec( 103): Unvectorized loop.
  6561: vec( 180): I/O statement obstructs vectorization.
  6563: opt(1118): This I/O statement inhibits optimization of loop.
  6566: vec( 103): Unvectorized loop.
  6566: vec( 180): I/O statement obstructs vectorization.
  6568: opt(1118): This I/O statement inhibits optimization of loop.
  6571: vec( 103): Unvectorized loop.
  6571: vec( 180): I/O statement obstructs vectorization.
  6573: opt(1118): This I/O statement inhibits optimization of loop.
  6576: vec( 103): Unvectorized loop.
  6576: vec( 180): I/O statement obstructs vectorization.
  6578: opt(1118): This I/O statement inhibits optimization of loop.
  6581: vec( 103): Unvectorized loop.
  6581: vec( 180): I/O statement obstructs vectorization.
  6583: opt(1118): This I/O statement inhibits optimization of loop.
  6586: vec( 103): Unvectorized loop.
  6586: vec( 180): I/O statement obstructs vectorization.
  6588: opt(1118): This I/O statement inhibits optimization of loop.
  6591: vec( 103): Unvectorized loop.
  6591: vec( 180): I/O statement obstructs vectorization.
  6593: opt(1118): This I/O statement inhibits optimization of loop.
  6598: vec( 103): Unvectorized loop.
  6598: vec( 180): I/O statement obstructs vectorization.
  6600: opt(1118): This I/O statement inhibits optimization of loop.
  6605: vec( 103): Unvectorized loop.
  6605: vec( 180): I/O statement obstructs vectorization.
  6607: opt(1118): This I/O statement inhibits optimization of loop.
  6612: vec( 103): Unvectorized loop.
  6612: vec( 180): I/O statement obstructs vectorization.
  6614: opt(1118): This I/O statement inhibits optimization of loop.
  6619: vec( 103): Unvectorized loop.
  6619: vec( 180): I/O statement obstructs vectorization.
  6621: opt(1118): This I/O statement inhibits optimization of loop.
  6626: vec( 103): Unvectorized loop.
  6626: vec( 180): I/O statement obstructs vectorization.
  6628: opt(1118): This I/O statement inhibits optimization of loop.
  6634: vec( 103): Unvectorized loop.
  6634: vec( 180): I/O statement obstructs vectorization.
  6636: opt(1118): This I/O statement inhibits optimization of loop.
  6643: vec( 103): Unvectorized loop.
  6643: vec( 180): I/O statement obstructs vectorization.
  6645: opt(1118): This I/O statement inhibits optimization of loop.
  6652: vec( 103): Unvectorized loop.
  6652: vec( 180): I/O statement obstructs vectorization.
  6654: opt(1118): This I/O statement inhibits optimization of loop.
  6661: vec( 103): Unvectorized loop.
  6661: vec( 180): I/O statement obstructs vectorization.
  6663: opt(1118): This I/O statement inhibits optimization of loop.
  6668: vec( 103): Unvectorized loop.
  6668: vec( 180): I/O statement obstructs vectorization.
  6670: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3DGLOBAL
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6533:                 SUBROUTINE WriteHotStart3DGlobal(UnitNumber,FilePosition,IPROC)
  6534:           C     ----------------------------------------------------------------------
  6535:                 USE PRE_GLOBAL
  6536:                 IMPLICIT NONE
  6537:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of subdomain file
  6538:                 INTEGER, intent(inout) :: FilePosition ! position in binary file
  6539:                 INTEGER, intent(in) :: IPROC
  6540:                 INTEGER IHOTSTP, LOCHSF, I, N, IINDX
  6541:           
  6542:           C     Start writing out the 3D hotstart information
  6543:           
  6544:                       LOCHSF=UnitNumber
  6545:                       IHOTSTP=FilePosition
  6546:           
  6547:                       WRITE(LOCHSF,REC=IHOTSTP) IDEN ; IHOTSTP = IHOTSTP + 1
  6548:                       WRITE(LOCHSF,REC=IHOTSTP) N3DSD ; IHOTSTP = IHOTSTP + 1
  6549:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSDRec ; IHOTSTP = IHOTSTP + 1
  6550:                       WRITE(LOCHSF,REC=IHOTSTP) N3DSV ; IHOTSTP = IHOTSTP + 1
  6551:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSVRec ; IHOTSTP = IHOTSTP + 1
  6552:                       WRITE(LOCHSF,REC=IHOTSTP) N3DST ; IHOTSTP = IHOTSTP + 1
  6553:                       WRITE(LOCHSF,REC=IHOTSTP) I3DSTRec ; IHOTSTP = IHOTSTP + 1
  6554:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGD ; IHOTSTP = IHOTSTP + 1
  6555:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGDRec ; IHOTSTP = IHOTSTP + 1
  6556:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGV ; IHOTSTP = IHOTSTP + 1
  6557:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGVRec ; IHOTSTP = IHOTSTP + 1
  6558:                       WRITE(LOCHSF,REC=IHOTSTP) N3DGT ; IHOTSTP = IHOTSTP + 1
  6559:                       WRITE(LOCHSF,REC=IHOTSTP) I3DGTRec ; IHOTSTP = IHOTSTP + 1
  6560:           
  6561: +------>              DO I=1,MNP
  6562: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6563: |                        WRITE(LOCHSF,REC=IHOTSTP) DUU(IINDX)
  6564: |                        IHOTSTP=IHOTSTP+1
  6565: +------               END DO
  6566: +------>              DO I=1,NNODP(IPROC)
  6567: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6568: |                        WRITE(LOCHSF,REC=IHOTSTP) DUV(IINDX)
  6569: |                        IHOTSTP=IHOTSTP+1
  6570: +------               END DO
  6571: +------>              DO I=1,NNODP(IPROC)
  6572: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6573: |                        WRITE(LOCHSF,REC=IHOTSTP) DVV(IINDX)
  6574: |                        IHOTSTP=IHOTSTP+1
  6575: +------               END DO
  6576: +------>              DO I=1,NNODP(IPROC)
  6577: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6578: |                        WRITE(LOCHSF,REC=IHOTSTP) UU(IINDX)
  6579: |                        IHOTSTP=IHOTSTP+1
  6580: +------               END DO
  6581: +------>              DO I=1,NNODP(IPROC)
  6582: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6583: |                        WRITE(LOCHSF,REC=IHOTSTP) VV(IINDX)
  6584: |                        IHOTSTP=IHOTSTP+1
  6585: +------               END DO
  6586: +------>              DO I=1,NNODP(IPROC)
  6587: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6588: |                        WRITE(LOCHSF,REC=IHOTSTP) BSX(IINDX)
  6589: |                        IHOTSTP=IHOTSTP+1
  6590: +------               END DO
  6591: +------>              DO I=1,NNODP(IPROC)
  6592: |                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6593: |                        WRITE(LOCHSF,REC=IHOTSTP) BSY(IINDX)
  6594: |                        IHOTSTP=IHOTSTP+1
  6595: +------                ENDDO
  6596:           
  6597: +------>              DO N=1,NFEN
  6598: |+----->                DO I=1,NNODP(IPROC)
  6599: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6600: ||                        WRITE(LOCHSF,REC=IHOTSTP) RealQ(IINDX,N)
  6601: ||                        IHOTSTP=IHOTSTP+1
  6602: |+-----                 END DO
  6603: +------               END DO
  6604: +------>              DO N=1,NFEN
  6605: |+----->                DO I=1,NNODP(IPROC)
  6606: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6607: ||                        WRITE(LOCHSF,REC=IHOTSTP) ImagQ(IINDX,N)
  6608: ||                        IHOTSTP=IHOTSTP+1
  6609: |+-----                 END DO
  6610: +------               END DO
  6611: +------>              DO N=1,NFEN
  6612: |+----->                DO I=1,NNODP(IPROC)
  6613: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6614: ||                        WRITE(LOCHSF,REC=IHOTSTP) WZ(IINDX,N)
  6615: ||                        IHOTSTP=IHOTSTP+1
  6616: |+-----                 END DO
  6617: +------               END DO
  6618: +------>              DO N=1,NFEN
  6619: |+----->                DO I=1,NNODP(IPROC)
  6620: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6621: ||                        WRITE(LOCHSF,REC=IHOTSTP) q20(IINDX,N)
  6622: ||                        IHOTSTP=IHOTSTP+1
  6623: |+-----                 END DO
  6624: +------               END DO
  6625: +------>              DO N=1,NFEN
  6626: |+----->                DO I=1,NNODP(IPROC)
  6627: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6628: ||                        WRITE(LOCHSF,REC=IHOTSTP) l(IINDX,N)
  6629: ||                        IHOTSTP=IHOTSTP+1
  6630: |+-----                 END DO
  6631: +------               END DO
  6632:                       IF (ABS(IDEN).EQ.1) THEN
  6633: +------>                DO N=1,NFEN
  6634: |+----->                  DO I=1,NNODP(IPROC)
  6635: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6636: ||                          WRITE(LOCHSF,REC=IHOTSTP) SigT(IINDX,N)
  6637: ||                          IHOTSTP=IHOTSTP+1
  6638: |+-----                   END DO
  6639: +------                 END DO
  6640:                       ENDIF
  6641:                       IF(ABS(IDen).EQ.2) THEN
  6642: +------>                DO N=1,NFEN
  6643: |+----->                  DO I=1,NNODP(IPROC)
  6644: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6645: ||                          WRITE(LOCHSF,REC=IHOTSTP) Sal(IINDX,N)
  6646: ||                          IHOTSTP=IHOTSTP+1
  6647: |+-----                   END DO
  6648: +------                 END DO
  6649:                       ENDIF
  6650:                       IF(ABS(IDen).EQ.3) THEN
  6651: +------>                DO N=1,NFEN
  6652: |+----->                  DO I=1,NNODP(IPROC)
  6653: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6654: ||                          WRITE(LOCHSF,REC=IHOTSTP) Temp(IINDX,N)
  6655: ||                          IHOTSTP=IHOTSTP+1
  6656: |+-----                   END DO
  6657: +------                 END DO
  6658:                       ENDIF
  6659:                       IF(ABS(IDen).EQ.4) THEN
  6660: +------>                DO N=1,NFEN
  6661: |+----->                  DO I=1,NNODP(IPROC)
  6662: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6663: ||                          WRITE(LOCHSF,REC=IHOTSTP) Sal(IINDX,N)
  6664: ||                          IHOTSTP=IHOTSTP+1
  6665: |+-----                   END DO
  6666: +------                 END DO
  6667: +------>                DO N=1,NFEN
  6668: |+----->                  DO I=1,NNODP(IPROC)
  6669: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6670: ||                          WRITE(LOCHSF,REC=IHOTSTP) Temp(IINDX,N)
  6671: ||                          IHOTSTP=IHOTSTP+1
  6672: |+-----                   END DO
  6673: +------                 END DO
  6674:                       END IF
  6675:           
  6676:           C
  6677:                 RETURN
  6678:           C     ----------------------------------------------------------------------
  6679:                 END SUBROUTINE WriteHotStart3DGLOBAL


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3DGLOBAL
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3DGLOBAL
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6561)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6561)
  LOOP END

  LOOP BEGIN: (prep.F:6566)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6566)
  LOOP END

  LOOP BEGIN: (prep.F:6571)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6571)
  LOOP END

  LOOP BEGIN: (prep.F:6576)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6576)
  LOOP END

  LOOP BEGIN: (prep.F:6581)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6581)
  LOOP END

  LOOP BEGIN: (prep.F:6586)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6586)
  LOOP END

  LOOP BEGIN: (prep.F:6591)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6591)
  LOOP END

  LOOP BEGIN: (prep.F:6597)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6598)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6598)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6604)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6605)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6605)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6611)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6612)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6612)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6618)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6619)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6619)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6625)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6626)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6626)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6633)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6634)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6634)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6642)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6643)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6643)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6651)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6652)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6652)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6660)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6661)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6661)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6667)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6668)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6668)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:29 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEHOTSTART3DGLOBAL
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 44 [s0-s12 s15-s16 s18-s42 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1968 bytes
      Register spill area      :  352 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1376 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6561)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6566)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6571)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6576)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6581)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6586)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6591)
    *** Estimated execution cycle                       : 58
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 10
  LOOP END

  LOOP BEGIN: (prep.F:6597)
    *** Estimated execution cycle                       : 28
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6598)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6604)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6605)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6611)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6612)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6618)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6619)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6625)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6626)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6633)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6634)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6642)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6643)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6651)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6652)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6660)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6661)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6667)
    *** Estimated execution cycle                       : 29
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Over basic blocks                           : 3
    *** The number of SCALAR REGISTER TRANSFER          : 7

    LOOP BEGIN: (prep.F:6668)
      *** Estimated execution cycle                     : 68
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 3
              Across calls                              : 3
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 5
              Across calls                              : 3
              Over basic blocks                         : 2
      *** The number of SCALAR REGISTER TRANSFER        : 10
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READINITCOND3D
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6714: vec( 103): Unvectorized loop.
  6714: vec( 180): I/O statement obstructs vectorization.
  6715: opt(1118): This I/O statement inhibits optimization of loop.
  6718: vec( 103): Unvectorized loop.
  6718: vec( 180): I/O statement obstructs vectorization.
  6719: opt(1118): This I/O statement inhibits optimization of loop.
  6723: vec( 103): Unvectorized loop.
  6723: vec( 180): I/O statement obstructs vectorization.
  6724: opt(1118): This I/O statement inhibits optimization of loop.
  6728: vec( 103): Unvectorized loop.
  6728: vec( 180): I/O statement obstructs vectorization.
  6729: opt(1118): This I/O statement inhibits optimization of loop.
  6733: vec( 103): Unvectorized loop.
  6733: vec( 180): I/O statement obstructs vectorization.
  6734: opt(1118): This I/O statement inhibits optimization of loop.
  6738: vec( 103): Unvectorized loop.
  6738: vec( 180): I/O statement obstructs vectorization.
  6739: opt(1118): This I/O statement inhibits optimization of loop.
  6743: vec( 103): Unvectorized loop.
  6743: vec( 180): I/O statement obstructs vectorization.
  6744: opt(1118): This I/O statement inhibits optimization of loop.
  6749: vec( 103): Unvectorized loop.
  6749: vec( 180): I/O statement obstructs vectorization.
  6750: opt(1118): This I/O statement inhibits optimization of loop.
  6756: vec( 103): Unvectorized loop.
  6756: vec( 180): I/O statement obstructs vectorization.
  6757: opt(1118): This I/O statement inhibits optimization of loop.
  6763: vec( 103): Unvectorized loop.
  6763: vec( 180): I/O statement obstructs vectorization.
  6764: opt(1118): This I/O statement inhibits optimization of loop.
  6770: vec( 103): Unvectorized loop.
  6770: vec( 180): I/O statement obstructs vectorization.
  6771: opt(1118): This I/O statement inhibits optimization of loop.
  6775: vec( 103): Unvectorized loop.
  6775: vec( 180): I/O statement obstructs vectorization.
  6776: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READINITCOND3D
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6691:                 SUBROUTINE ReadInitCond3D(UnitNumber)
  6692:           C     ----------------------------------------------------------------------
  6693:                 USE PRE_GLOBAL
  6694:                 IMPLICIT NONE
  6695:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of full domain file
  6696:                 INTEGER NH,K
  6697:           C
  6698:           C     Start reading in the data
  6699:           
  6700:           !kmd Added information for 3D hotstart
  6701:                 ALLOCATE ( DUU(MNP),DUV(MNP),DVV(MNP))
  6702:                 ALLOCATE ( UU(MNP),VV(MNP))
  6703:                 ALLOCATE ( BSX(MNP),BSY(MNP))
  6704:                 ALLOCATE ( WZ(MNP,NFEN), q20(MNP,NFEN))
  6705:                 ALLOCATE ( RealQ(MNP,NFEN), ImagQ(MNP,NFEN))
  6706:                 ALLOCATE ( l(MNP,NFEN), SigT(MNP,NFEN))
  6707:                 ALLOCATE ( Sal(MNP,NFEN), Temp(MNP,NFEN))
  6708:           !kmd end of additions
  6709:           
  6710:                   IHOT=UnitNumber
  6711:           
  6712:                   READ(IHOT,*) IDEN
  6713:           
  6714: +------>          DO NH=1,MNP
  6715: |                   READ(IHOT,*) BSX(NH)
  6716: +------           END DO
  6717:           
  6718: +------>          DO NH=1,MNP
  6719: |                   READ(IHOT,*) BSY(NH)
  6720: +------           END DO
  6721:           
  6722: +------>          DO K=1,NFEN
  6723: |+----->            DO NH=1,MNP
  6724: ||                    READ(IHOT,*) RealQ(NH,K)
  6725: |+-----             END DO
  6726: +------           END DO
  6727: +------>          DO K=1,NFEN
  6728: |+----->            DO NH=1,MNP
  6729: ||                    READ(IHOT,*) ImagQ(NH,K)
  6730: |+-----             END DO
  6731: +------           END DO
  6732: +------>          DO K=1,NFEN
  6733: |+----->            DO NH=1,MNP
  6734: ||                    READ(IHOT,*) WZ(NH,K)
  6735: |+-----             END DO
  6736: +------           END DO
  6737: +------>          DO K=1,NFEN
  6738: |+----->            DO NH=1,MNP
  6739: ||                    READ(IHOT,*) q20(NH,K)
  6740: |+-----             END DO
  6741: +------           END DO
  6742: +------>          DO K=1,NFEN
  6743: |+----->            DO NH=1,MNP
  6744: ||                    READ(IHOT,*) l(NH,K)
  6745: |+-----             END DO
  6746: +------           END DO
  6747:                   IF (ABS(IDEN).EQ.1) THEN
  6748: +------>            DO K=1,NFEN
  6749: |+----->              DO NH=1,MNP
  6750: ||                      READ(IHOT,*) SigT(NH,K)
  6751: |+-----               END DO
  6752: +------             END DO
  6753:                   END IF
  6754:                   IF(ABS(IDen).EQ.2) THEN
  6755: +------>            DO K=1,NFEN
  6756: |+----->              DO NH=1,MNP
  6757: ||                      READ(IHOT,*) Sal(NH,K)
  6758: |+-----               END DO
  6759: +------             END DO
  6760:                   ENDIF
  6761:                   IF(ABS(IDen).EQ.3) THEN
  6762: +------>            DO K=1,NFEN
  6763: |+----->              DO NH=1,MNP
  6764: ||                      READ(IHOT,*) Temp(NH,K)
  6765: |+-----               END DO
  6766: +------             END DO
  6767:                   ENDIF
  6768:                   IF(ABS(IDen).EQ.4) THEN
  6769: +------>            DO K=1,NFEN
  6770: |+----->              DO NH=1,MNP
  6771: ||                      READ(IHOT,*) Sal(NH,K)
  6772: |+-----               END DO
  6773: +------             END DO
  6774: +------>            DO K=1,NFEN
  6775: |+----->              DO NH=1,MNP
  6776: ||                      READ(IHOT,*) Temp(NH,K)
  6777: |+-----               ENDDO
  6778: +------             ENDDO
  6779:                   END IF
  6780:                 RETURN
  6781:           
  6782:           C     ----------------------------------------------------------------------
  6783:                 END SUBROUTINE ReadInitCond3D


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READINITCOND3D
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READINITCOND3D
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6714)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6714)
  LOOP END

  LOOP BEGIN: (prep.F:6718)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6718)
  LOOP END

  LOOP BEGIN: (prep.F:6722)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6723)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6723)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6727)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6728)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6728)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6732)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6733)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6733)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6737)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6738)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6738)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6742)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6743)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6743)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6748)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6749)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6749)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6755)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6756)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6756)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6762)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6763)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6763)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6769)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6770)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6770)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6774)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6775)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6775)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: READINITCOND3D
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 42 [s0-s12 s15-s16 s18-s40 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1552 bytes
      Register spill area      :  144 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1168 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6714)
    *** Estimated execution cycle                       : 34
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6718)
    *** Estimated execution cycle                       : 34
    *** The number of SCALAR REGISTER TRANSFER          : 5
  LOOP END

  LOOP BEGIN: (prep.F:6722)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6723)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6727)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6728)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6732)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6733)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6737)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6738)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6742)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6743)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6748)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6749)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6755)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6756)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6762)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6763)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6769)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6770)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6774)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6775)
      *** Estimated execution cycle                     : 39
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEINITCOND3D
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6809: vec( 103): Unvectorized loop.
  6809: vec( 180): I/O statement obstructs vectorization.
  6811: opt(1118): This I/O statement inhibits optimization of loop.
  6814: vec( 103): Unvectorized loop.
  6814: vec( 180): I/O statement obstructs vectorization.
  6816: opt(1118): This I/O statement inhibits optimization of loop.
  6820: vec( 103): Unvectorized loop.
  6820: vec( 180): I/O statement obstructs vectorization.
  6822: opt(1118): This I/O statement inhibits optimization of loop.
  6826: vec( 103): Unvectorized loop.
  6826: vec( 180): I/O statement obstructs vectorization.
  6828: opt(1118): This I/O statement inhibits optimization of loop.
  6832: vec( 103): Unvectorized loop.
  6832: vec( 180): I/O statement obstructs vectorization.
  6834: opt(1118): This I/O statement inhibits optimization of loop.
  6838: vec( 103): Unvectorized loop.
  6838: vec( 180): I/O statement obstructs vectorization.
  6840: opt(1118): This I/O statement inhibits optimization of loop.
  6844: vec( 103): Unvectorized loop.
  6844: vec( 180): I/O statement obstructs vectorization.
  6846: opt(1118): This I/O statement inhibits optimization of loop.
  6851: vec( 103): Unvectorized loop.
  6851: vec( 180): I/O statement obstructs vectorization.
  6853: opt(1118): This I/O statement inhibits optimization of loop.
  6859: vec( 103): Unvectorized loop.
  6859: vec( 180): I/O statement obstructs vectorization.
  6861: opt(1118): This I/O statement inhibits optimization of loop.
  6867: vec( 103): Unvectorized loop.
  6867: vec( 180): I/O statement obstructs vectorization.
  6869: opt(1118): This I/O statement inhibits optimization of loop.
  6875: vec( 103): Unvectorized loop.
  6875: vec( 180): I/O statement obstructs vectorization.
  6877: opt(1118): This I/O statement inhibits optimization of loop.
  6881: vec( 103): Unvectorized loop.
  6881: vec( 180): I/O statement obstructs vectorization.
  6883: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEINITCOND3D
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6795:                 SUBROUTINE WriteInitCond3D(UnitNumber,IPROC)
  6796:           C     ----------------------------------------------------------------------
  6797:                 USE PRE_GLOBAL
  6798:                 IMPLICIT NONE
  6799:                 INTEGER, intent(in) :: UnitNumber ! i/o unit of subdomain file
  6800:                 INTEGER LOCHSF, I, N, IINDX
  6801:                 INTEGER, intent(in) :: IPROC
  6802:           
  6803:           C     Start writing out the 3D initial condition information
  6804:           
  6805:                       LOCHSF=UnitNumber
  6806:           
  6807:                       WRITE(LOCHSF,*) IDEN
  6808:           
  6809: +------>              DO I=1,NNODP(IPROC)
  6810: |                       IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6811: |                       WRITE(LOCHSF,*) BSX(IINDX)
  6812: +------               END DO
  6813:           
  6814: +------>              DO I=1,NNODP(IPROC)
  6815: |                       IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6816: |                       WRITE(LOCHSF,*) BSY(IINDX)
  6817: +------               END DO
  6818:           
  6819: +------>              DO N=1,NFEN
  6820: |+----->                DO I=1,NNODP(IPROC)
  6821: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6822: ||                        WRITE(LOCHSF,*) RealQ(IINDX,N)
  6823: |+-----                 END DO
  6824: +------               END DO
  6825: +------>              DO N=1,NFEN
  6826: |+----->                DO I=1,NNODP(IPROC)
  6827: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6828: ||                        WRITE(LOCHSF,*) ImagQ(IINDX,N)
  6829: |+-----                 END DO
  6830: +------               END DO
  6831: +------>              DO N=1,NFEN
  6832: |+----->                DO I=1,NNODP(IPROC)
  6833: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6834: ||                        WRITE(LOCHSF,*) WZ(IINDX,N)
  6835: |+-----                 END DO
  6836: +------               END DO
  6837: +------>              DO N=1,NFEN
  6838: |+----->                DO I=1,NNODP(IPROC)
  6839: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6840: ||                        WRITE(LOCHSF,*) q20(IINDX,N)
  6841: |+-----                 END DO
  6842: +------               END DO
  6843: +------>              DO N=1,NFEN
  6844: |+----->                DO I=1,NNODP(IPROC)
  6845: ||                        IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6846: ||                        WRITE(LOCHSF,*) l(IINDX,N)
  6847: |+-----                 END DO
  6848: +------               END DO
  6849:                       IF (ABS(IDEN).EQ.1) THEN
  6850: +------>                DO N=1,NFEN
  6851: |+----->                  DO I=1,NNODP(IPROC)
  6852: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6853: ||                          WRITE(LOCHSF,*) SigT(IINDX,N)
  6854: |+-----                   END DO
  6855: +------                 END DO
  6856:                       ENDIF
  6857:                       IF(ABS(IDen).EQ.2) THEN
  6858: +------>                DO N=1,NFEN
  6859: |+----->                  DO I=1,NNODP(IPROC)
  6860: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6861: ||                          WRITE(LOCHSF,*) Sal(IINDX,N)
  6862: |+-----                   END DO
  6863: +------                 END DO
  6864:                       ENDIF
  6865:                       IF(ABS(IDen).EQ.3) THEN
  6866: +------>                DO N=1,NFEN
  6867: |+----->                  DO I=1,NNODP(IPROC)
  6868: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6869: ||                          WRITE(LOCHSF,*) Temp(IINDX,N)
  6870: |+-----                   END DO
  6871: +------                 END DO
  6872:                       ENDIF
  6873:                       IF(ABS(IDen).EQ.4) THEN
  6874: +------>                DO N=1,NFEN
  6875: |+----->                  DO I=1,NNODP(IPROC)
  6876: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6877: ||                          WRITE(LOCHSF,*) Sal(IINDX,N)
  6878: |+-----                   END DO
  6879: +------                 END DO
  6880: +------>                DO N=1,NFEN
  6881: |+----->                  DO I=1,NNODP(IPROC)
  6882: ||                          IINDX=ABS(IMAP_NOD_LG(I,IPROC))
  6883: ||                          WRITE(LOCHSF,*) Temp(IINDX,N)
  6884: |+-----                   END DO
  6885: +------                 END DO
  6886:                       END IF
  6887:           C
  6888:                 RETURN
  6889:           C     ----------------------------------------------------------------------
  6890:                 END SUBROUTINE WriteInitCond3D


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEINITCOND3D
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEINITCOND3D
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6809)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6809)
  LOOP END

  LOOP BEGIN: (prep.F:6814)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6814)
  LOOP END

  LOOP BEGIN: (prep.F:6819)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6820)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6820)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6825)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6826)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6826)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6831)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6832)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6832)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6837)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6838)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6838)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6843)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6844)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6844)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6850)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6851)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6851)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6858)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6859)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6859)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6866)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6867)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6867)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6874)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6875)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6875)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6880)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:6881)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:6881)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: WRITEINITCOND3D
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 41 [s0-s12 s15-s16 s18-s39 s60-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1664 bytes
      Register spill area      :  200 bytes
      Parameter area           :   64 bytes
      Register save area       :  176 bytes
      User data area           : 1224 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6809)
    *** Estimated execution cycle                       : 49
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6814)
    *** Estimated execution cycle                       : 49
    *** The number of SCALAR REGISTER TRANSFER          : 7
  LOOP END

  LOOP BEGIN: (prep.F:6819)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6820)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6825)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6826)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6831)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6832)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6837)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6838)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6843)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6844)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6850)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6851)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6858)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6859)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6866)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6867)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6874)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6875)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:6880)
    *** Estimated execution cycle                       : 26
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 1
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 6

    LOOP BEGIN: (prep.F:6881)
      *** Estimated execution cycle                     : 60
      *** The number of SCALAR REGISTER SPILL
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER RESTORE
            Total                                       : 1
              Across calls                              : 1
      *** The number of SCALAR REGISTER TRANSFER        : 9
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENFULLDOMAINFILE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  6922: opt(3008): Reference within a conditional branch moved outside loop - use "move" directive to suppress this optimization.
  6922: vec( 180): I/O statement obstructs vectorization.
  6922: vec( 181): Allocation obstructs vectorization.
  6922: vec( 182): Deallocation obstructs vectorization.
  6922: vec( 118): Unvectorizable data type.
  6922: vec( 108): Unvectorizable loop structure.
  6928: opt(3014): Moved reference within a conditional branch.
  6929: opt(3014): Moved reference within a conditional branch.
  6930: opt(3014): Moved reference within a conditional branch.
  6932: vec( 103): Unvectorized loop.
  6932: vec( 108): Unvectorizable loop structure.
  6932: vec( 118): Unvectorizable data type.: FILENAME
  6940: opt(3014): Moved reference within a conditional branch.
  6940: vec( 103): Unvectorized loop.
  6940: vec( 108): Unvectorizable loop structure.
  6953: opt(3014): Moved reference within a conditional branch.
  6953: vec( 103): Unvectorized loop.
  6953: vec( 108): Unvectorizable loop structure.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENFULLDOMAINFILE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6901:                 SUBROUTINE OpenFullDomainFile(UnitNumber, Description, Success)
  6902:           C---------------------------------------------------------------------------
  6903:                 USE PRE_GLOBAL
  6904:                 IMPLICIT NONE
  6905:                 INTEGER, intent(in) :: UnitNumber     ! i/o unit number to open
  6906:                 CHARACTER(len=30), intent(in) :: Description ! description of file
  6907:                 LOGICAL, intent(out):: Success     ! .true. if file opened w/o errors
  6908:                 LOGICAL Found               !.true. if the full domain file exists
  6909:                 CHARACTER(len=80) FileName   ! name of full domain file
  6910:                 CHARACTER(len=7) DefaultName! default name of full domain file
  6911:                 INTEGER ErrorIO             ! zero if file opened successfully
  6912:                 CHARACTER(len=4) skipstring ! indicates user wants to skip this file
  6913:           
  6914:                 Found = .false.
  6915:                 Success = .false.
  6916:                 ErrorIO = 1
  6917:                 skipstring = 'skip'
  6918:           
  6919:                 DefaultName(1:5) = 'fort.'
  6920:                 WRITE(DefaultName(6:7),2) UnitNumber
  6921:           C
  6922: +------>        DO WHILE(.not.Found)
  6923: |         C
  6924: |         C     Determine the name of the file; if found, open it
  6925: |                  IF (USE_DEFAULT) THEN
  6926: |+=====>              FileName = DefaultName
  6927: |                  ELSE
  6928: |                     WRITE(*,850) ! type skip to bypass
  6929: |                     WRITE(*,900) Description
  6930: |                     WRITE(*,910) UnitNumber
  6931: |                     READ(*,'(A)') FileName
  6932: |+=====>              FileName = trim(FILENAME)
  6933: |                  ENDIF
  6934: |         C
  6935: |         C     Determine if full domain file exists
  6936: |                  INQUIRE(FILE=FileName,EXIST=FOUND)
  6937: |         C
  6938: |         C     If it does exist, open it
  6939: |                  IF ( FOUND ) THEN
  6940: |                     WRITE(*,1011) trim(FileName) !found
  6941: |                     OPEN(UNIT=UnitNumber, FILE=FileName, IOSTAT=ErrorIO)
  6942: |                     Success = .true.
  6943: |                     IF ( ErrorIO .GT. 0 ) THEN
  6944: |                        WRITE(*,*) "ERROR: Full domain file exists but"
  6945: |                        WRITE(*,*) "cannot be opened."
  6946: |                        Success = .false.
  6947: |                     ELSE
  6948: |                        WRITE(*,*) "Successfully opened full domain file."
  6949: |                     ENDIF
  6950: |                  ELSE
  6951: |         C     Give the user a chance to opt out of prepping this file.
  6952: |                     IF (FileName .eq. skipstring) RETURN ! note the early RETURN
  6953: |                     WRITE(*,1010) trim(FileName) !not found
  6954: |                  ENDIF
  6955: +------         ENDDO
  6956:           
  6957:            2    FORMAT(I2)
  6958:            30   FORMAT(A30)
  6959:            850  FORMAT(/,'Type ''skip'' to bypass preprocessing or')
  6960:            900  FORMAT('Enter the name of the ',A30)
  6961:            910  FORMAT('file (unit ',I3,'): ')
  6962:            1010 FORMAT('WARNING: File ',A,' WAS NOT FOUND! Try again or type "skip"',/)
  6963:            1011 FORMAT('INFO: File ',A,' WAS FOUND!  Opening & Processing file.',/)
  6964:                 RETURN
  6965:           C---------------------------------------------------------------------------
  6966:                 END SUBROUTINE OpenFullDomainFile


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENFULLDOMAINFILE
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENFULLDOMAINFILE
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:6922)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:6922)
    *** Allocation obstructs vectorization. (prep.F:6922)
    *** Deallocation obstructs vectorization. (prep.F:6922)
    *** Unvectorizable data type. (prep.F:6922)
    *** Unvectorizable loop structure. (prep.F:6922)

    LOOP BEGIN: (prep.F:6932)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:6932)
    LOOP END

    LOOP BEGIN: (prep.F:6932)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:6932)
    LOOP END

    LOOP BEGIN: (prep.F:6932)
      <Unvectorized loop.>
      *** Unvectorizable data type. : FILENAME (prep.F:6932)
    LOOP END

    LOOP BEGIN: (prep.F:6926)
      <Unvectorized loop.>
      *** Unvectorizable data type. : FILENAME (prep.F:6926)
    LOOP END

    LOOP BEGIN: (prep.F:6953)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:6953)
    LOOP END

    LOOP BEGIN: (prep.F:6940)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:6940)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENFULLDOMAINFILE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 40 [s0-s12 s15-s16 s18-s37 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3088 bytes
      Register spill area      :  296 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2456 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:6922)
    *** Estimated execution cycle                       : 613
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 18
            Across calls                                : 10
            Over basic blocks                           :  6
            Others                                      :  2
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 51
            Across calls                                : 14
            Over basic blocks                           : 34
            Others                                      :  3
    *** The number of SCALAR REGISTER TRANSFER          : 97

    LOOP BEGIN: (prep.F:6932)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:6932)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:6932)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:6926)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:6953)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:6940)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENSUBDOMAINFILE
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7005: inl(1212): Source for routine not found.: IWRITE


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENSUBDOMAINFILE
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  6978:                 SUBROUTINE OpenSubDomainFile(UnitNumber, IProc, sdu, Success)
  6979:           C---------------------------------------------------------------------------
  6980:                 USE PRE_GLOBAL
  6981:                 IMPLICIT NONE
  6982:                 INTEGER, intent(in) :: UnitNumber     ! i/o unit number of full dom file
  6983:                 INTEGER, intent(in) :: iproc          ! subdomain number
  6984:                 INTEGER, intent(out) :: sdu  ! i/o unit nunber that was opened
  6985:                 LOGICAL, intent(out):: Success     ! .true. if files opened w/o errors
  6986:                 LOGICAL Found               !.true. if the full domain file exists
  6987:                 CHARACTER(len=80) FileName   ! name of full domain file
  6988:                 CHARACTER(len=7) DefaultName! default name of full domain file
  6989:                 INTEGER ErrorIO             ! zero if file opened successfully
  6990:                 CHARACTER*14 sdFileName     ! subdomain file name
  6991:                 CHARACTER(len=4) skipstring ! indicates user wants to skip this file
  6992:           
  6993:                 Found = .false.
  6994:                 Success = .false.
  6995:                 ErrorIO = 1
  6996:                 skipstring = 'skip'
  6997:           
  6998:                 DefaultName(1:5) = 'fort.'
  6999:                 WRITE(DefaultName(6:7),2) UnitNumber
  7000:           
  7001:           C     Open subdomain file
  7002:                 sdu = 105 + (iproc-1)
  7003:                 sdFileName(1:7) = 'PE0000/'
  7004:                 sdFileName(8:14) = DefaultName
  7005:                 CALL IWRITE(sdFileName, 3, 6, iproc-1)
  7006:                 OPEN (UNIT=sdu, FILE=sdFileName, IOSTAT=ErrorIO)
  7007:                 Success = .true.
  7008:                 IF ( ErrorIO .GT. 0 ) THEN
  7009:                    WRITE(*,*) "ERROR: Subdomain file cannot be opened."
  7010:                    print *,sdu
  7011:                    print *,sdFileName
  7012:                    Success = .false.
  7013:                 ENDIF
  7014:            2    FORMAT(I2)
  7015:                 RETURN
  7016:           
  7017:           C---------------------------------------------------------------------------
  7018:                 END SUBROUTINE OpenSubDomainFile


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENSUBDOMAINFILE
INLINE LIST

  ROOT: OPENSUBDOMAINFILE (prep.F:6978)
  -> NOINLINE: IWRITE (prep.F:7005)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENSUBDOMAINFILE
VECTORIZATION LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENSUBDOMAINFILE
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 35 [s0-s12 s15-s16 s23-s39 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2480 bytes
      Register spill area      :   24 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2120 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENPREPFILES
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7066: vec( 103): Unvectorized loop.
  7066: vec( 108): Unvectorizable loop structure.
  7066: vec( 118): Unvectorizable data type.: DEFAULTNAME
  7066: vec( 118): Unvectorizable data type.: UNITNUMBERSTR
  7071: vec( 103): Unvectorized loop.
  7071: vec( 108): Unvectorizable loop structure.
  7071: vec( 118): Unvectorizable data type.: FILENAME
  7082: vec( 103): Unvectorized loop.
  7082: vec( 108): Unvectorizable loop structure.
  7082: vec( 118): Unvectorizable data type.: FILENAME
  7088: vec( 180): I/O statement obstructs vectorization.
  7088: vec( 181): Allocation obstructs vectorization.
  7088: vec( 182): Deallocation obstructs vectorization.
  7088: vec( 118): Unvectorizable data type.
  7088: vec( 108): Unvectorizable loop structure.
  7113: vec( 181): Allocation obstructs vectorization.
  7113: vec( 182): Deallocation obstructs vectorization.
  7113: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  7113: vec( 180): I/O statement obstructs vectorization.
  7113: vec( 108): Unvectorizable loop structure.
  7118: vec( 103): Unvectorized loop.
  7118: vec( 108): Unvectorizable loop structure.
  7118: vec( 118): Unvectorizable data type.
  7122: inl(1212): Source for routine not found.: IWRITE
  7123: vec( 103): Unvectorized loop.
  7123: vec( 108): Unvectorizable loop structure.
  7128: opt(1084): Branch out of the loop inhibits optimization.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENPREPFILES
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7033:                 SUBROUTINE OpenPrepFiles(UnitNumber, Description,
  7034:                &     startProc, endProc, SDU, Success)
  7035:           C---------------------------------------------------------------------------
  7036:                 USE PRE_GLOBAL
  7037:                 IMPLICIT NONE
  7038:                 INTEGER, intent(in) :: UnitNumber     ! i/o unit number to open
  7039:                 CHARACTER(*), intent(in) :: Description ! description of file
  7040:                 INTEGER, intent(in) :: startProc        ! subdomains to start with
  7041:                 INTEGER, intent(in) :: endProc          ! subdomain to end on
  7042:                 INTEGER, intent(out), dimension(nproc) :: SDU ! Subdomain unit numbers
  7043:                 LOGICAL, intent(out):: Success     ! .true. if files opened w/o errors
  7044:                 LOGICAL Found               !.true. if the full domain file exists
  7045:                 CHARACTER(len=80) FileName   ! name of full domain file
  7046:                 CHARACTER(len=80) DefaultName! default name of full domain file
  7047:                 INTEGER :: dnlen  !length of defaultname (7 or 8)
  7048:                 INTEGER ErrorIO             ! zero if file opened successfully
  7049:                 INTEGER iproc               ! subdomain index
  7050:                 CHARACTER(len=20) sdFileName     ! subdomain file name   !increased from 14 to 15 tcm v50.66.03
  7051:                 CHARACTER(len=4) skipstring ! indicates user wants to skip this file
  7052:                 INTEGER:: unitwidth
  7053:                 CHARACTER (len=20):: unitnumberstr
  7054:           
  7055:                 Found = .false.
  7056:                 Success = .false.
  7057:                 ErrorIO = 1
  7058:                 skipstring = 'skip'
  7059: +======>        DefaultName(:) = ' '  !initialize to all blanks !tcm v50.77
  7060:           
  7061:                 DefaultName(1:5) = 'fort.'
  7062:           
  7063:                 unitwidth = ceiling(log(dble(UnitNumber))/log(10.0)) ;
  7064:                 dnlen = 5 + unitwidth ;
  7065:                 WRITE(unitnumberstr,'(I0)') UnitNumber ;
  7066: +======>        DefaultName = TRIM(ADJUSTL(DefaultName))//TRIM(ADJUSTL(unitNumberStr))
  7067:           
  7068:           C
  7069:           C     Determine the name of the file; if found, open it
  7070:            31   IF (USE_DEFAULT) THEN
  7071: +======>           FileName = trim(DefaultName(1:dnlen))   !tcm v50.66.03 added trim !tcm v50.77 added 1:dnlen
  7072:           Casey 120402: Avoid an endless loop.  If the default file does not exist,
  7073:           C             then give the user a chance to specify the file name or skip.a
  7074:           C     ELSE
  7075:                    GOTO 33
  7076:                 ENDIF
  7077:            32   CONTINUE
  7078:                    WRITE(*,850) ! type skip to bypass
  7079:                    WRITE(*,900) Description
  7080:                    WRITE(*,910) UnitNumber
  7081:                    READ(*,'(A)') FileName
  7082: +======>           FileName = trim(FILENAME)
  7083:           C     ENDIF
  7084:            33   CONTINUE
  7085:           
  7086:           C
  7087:           C     Determine if full domain file exists
  7088:                 INQUIRE(FILE=FileName,EXIST=FOUND)
  7089:           C
  7090:           C     If it does exist, open it
  7091:                 IF ( FOUND ) THEN
  7092:                    WRITE(*,1011) FileName !found
  7093:                    OPEN(UNIT=UnitNumber, FILE=FileName, IOSTAT=ErrorIO)
  7094:                    Success = .true.
  7095:                    IF ( ErrorIO .GT. 0 ) THEN
  7096:                       WRITE(*,*) "ERROR: Full domain file exists but"
  7097:                       WRITE(*,*) "cannot be opened."
  7098:                       Success = .false.
  7099:                    ENDIF
  7100:                 ELSE
  7101:           C     Give the user a chance to opt out of prepping this file.
  7102:                    IF (FileName .eq. skipstring) RETURN ! note the early RETURN
  7103:                    WRITE(*,1010) FileName !not found
  7104:           Casey 120402: Avoid an endless loop.  If the default file does not exist,
  7105:           C             then give the user a chance to specify the file name or skip.
  7106:           C        GOTO 31
  7107:                    GOTO 32
  7108:                 ENDIF
  7109:           C
  7110:                 If (.not.Success) RETURN ! failed to open full domain file
  7111:           C
  7112:           C     Open each of the subdomain files
  7113: +------>        DO iproc = startProc, endProc
  7114: |+=====>           sdFileName(:) = ' '
  7115: |                  sdu(iproc) = 505 + (iproc-1)  !tcm v51.31 changed 105 to 505 to avoid conflicts with fort.141 file
  7116: |                  sdFileName(1:7) = 'PE0000/'
  7117: |         c........tcm v50.66.03 increased unit number to 100's places
  7118: |+=====>           sdFileName(8:) = trim(DefaultName)
  7119: |         #ifdef ADCSWAN
  7120: |+=====>           sdFileName = 'PE0000/'//FileName
  7121: |         #endif
  7122: |                  CALL IWRITE(sdFileName, 3, 6, iproc-1)
  7123: |                  OPEN (UNIT=SDU(iproc), FILE=trim(sdFileName), IOSTAT=ErrorIO)
  7124: |                  Success = .true.
  7125: |                  IF ( ErrorIO .GT. 0 ) THEN
  7126: |                     WRITE(*,*) "ERROR: Subdomain file cannot be opened."
  7127: |                     Success = .false.
  7128: |                     RETURN ! failed to open at least one subdomain file
  7129: |                  ENDIF
  7130: +------         ENDDO
  7131:           
  7132:            2    FORMAT(I2)
  7133:            3    FORMAT(I3)
  7134:            30   FORMAT(A30)
  7135:            850  FORMAT(/,'Type ''skip'' to bypass preprocessing or')
  7136:            900  FORMAT('Enter the name of the ',A30)
  7137:            910  FORMAT('file (unit ',I3,'): ')
  7138:            1010 FORMAT('File ',A8,/,' WAS NOT FOUND! Try again or type "skip"',/)  !increased A7 to A8  tcm v50.66.03
  7139:            1011 FORMAT('File ',A8,/,' WAS FOUND!  Opening & Processing file.',/)   !increased A7 to A8
  7140:                 RETURN
  7141:           C---------------------------------------------------------------------------
  7142:                 END SUBROUTINE OpenPrepFiles


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENPREPFILES
INLINE LIST

  ROOT: OPENPREPFILES (prep.F:7033)
  -> NOINLINE: IWRITE (prep.F:7122)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENPREPFILES
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:7059)
    <Unvectorized loop.>
    *** Unvectorizable data type. : DEFAULTNAME (prep.F:7059)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. : DEFAULTNAME (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. : UNITNUMBERSTR (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    <Unvectorized loop.>
    *** Unvectorizable data type. : DEFAULTNAME (prep.F:7066)
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7071)
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:7071)
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILENAME (prep.F:7071)
  LOOP END

  LOOP BEGIN: (Unknown Position)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:7088)
    *** Allocation obstructs vectorization. (prep.F:7088)
    *** Deallocation obstructs vectorization. (prep.F:7088)
    *** Unvectorizable data type. (prep.F:7088)
    *** Unvectorizable loop structure. (prep.F:7088)

    LOOP BEGIN: (prep.F:7082)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:7082)
    LOOP END

    LOOP BEGIN: (prep.F:7082)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:7082)
    LOOP END

    LOOP BEGIN: (prep.F:7082)
      <Unvectorized loop.>
      *** Unvectorizable data type. : FILENAME (prep.F:7082)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7113)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (prep.F:7113)
    *** Deallocation obstructs vectorization. (prep.F:7113)
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:7113)
    *** I/O statement obstructs vectorization. (prep.F:7113)
    *** Unvectorizable loop structure. (prep.F:7113)

    LOOP BEGIN: (prep.F:7114)
      <Unvectorized loop.>
      *** Unvectorizable data type. : SDFILENAME (prep.F:7114)
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:7118)
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:7118)
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:7118)
    LOOP END

    LOOP BEGIN: (prep.F:7120)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:7120)
    LOOP END

    LOOP BEGIN: (prep.F:7123)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:7123)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: OPENPREPFILES
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 58 [s0-s12 s15-s16 s18-s39 s43-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 3408 bytes
      Register spill area      :  392 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 2680 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:7059)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 8
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 8
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:7066)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:7071)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7078)
    *** Estimated execution cycle                       : 270
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 2
            Across calls                                : 1
            Others                                      : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 5
            Across calls                                : 3
            Over basic blocks                           : 1
            Others                                      : 1
    *** The number of SCALAR REGISTER TRANSFER          : 47

    LOOP BEGIN: (prep.F:7082)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:7082)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:7082)
      *** Estimated execution cycle                     : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7113)
    *** Estimated execution cycle                       : 393
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 32
            Across calls                                :  3
            Over basic blocks                           : 29
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 38
            Across calls                                :  4
            Over basic blocks                           : 33
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 69

    LOOP BEGIN: (prep.F:7114)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      *** Estimated execution cycle                     : 6
    LOOP END

    LOOP BEGIN: (prep.F:7118)
      *** Estimated execution cycle                     : 5
    LOOP END

    LOOP BEGIN: (prep.F:7120)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:7123)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP80
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7353: vec( 103): Unvectorized loop.
  7353: vec( 180): I/O statement obstructs vectorization.
  7354: opt(1118): This I/O statement inhibits optimization of loop.
  7360: vec( 103): Unvectorized loop.
  7360: vec( 180): I/O statement obstructs vectorization.
  7361: opt(1118): This I/O statement inhibits optimization of loop.
  7367: vec( 103): Unvectorized loop.
  7367: vec( 180): I/O statement obstructs vectorization.
  7368: opt(1118): This I/O statement inhibits optimization of loop.
  7377: vec( 103): Unvectorized loop.
  7377: vec( 180): I/O statement obstructs vectorization.
  7378: opt(1118): This I/O statement inhibits optimization of loop.
  7387: vec( 103): Unvectorized loop.
  7387: vec( 180): I/O statement obstructs vectorization.
  7388: opt(1118): This I/O statement inhibits optimization of loop.
  7397: vec( 103): Unvectorized loop.
  7397: vec( 180): I/O statement obstructs vectorization.
  7398: opt(1118): This I/O statement inhibits optimization of loop.
  7408: vec( 103): Unvectorized loop.
  7408: vec( 180): I/O statement obstructs vectorization.
  7409: opt(1118): This I/O statement inhibits optimization of loop.
  7445: vec( 103): Unvectorized loop.
  7445: vec( 180): I/O statement obstructs vectorization.
  7446: opt(1118): This I/O statement inhibits optimization of loop.
  7458: vec( 103): Unvectorized loop.
  7458: vec( 180): I/O statement obstructs vectorization.
  7459: opt(1118): This I/O statement inhibits optimization of loop.
  7471: vec( 103): Unvectorized loop.
  7471: vec( 180): I/O statement obstructs vectorization.
  7472: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP80
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7320:                 SUBROUTINE PREP80()
  7321:                 USE PRE_GLOBAL
  7322:                 USE SIZES, ONLY : MNHARF
  7323:                 USE HARM, ONLY : NHASE, NHASV, NHAGE, NHAGV
  7324:                 IMPLICIT NONE
  7325:                 INTEGER I,K
  7326:           C
  7327:                 OPEN(UNIT=80,FILE='fort.80')              ! output for ADCPOST
  7328:           C
  7329:           C--Write out the domain decomposition information into a file
  7330:           C  which will later be used in post-processing the results
  7331:           C
  7332:                 WRITE(80,80) RUNDES
  7333:                 WRITE(80,80) RUNID
  7334:                 WRITE(80,80) AGRID
  7335:                 WRITE(80,'(2I8,16x,A)') NELG,NNODG,'! Total # elements & nodes'
  7336:                 WRITE(80,'(I8,24x,A)') NPROC,' ! Number of processors'
  7337:                 WRITE(80,'(I8,24x,A)') MNPP,'! Max nodes on any processor'
  7338:                 WRITE(80,'(I8,24x,A)') MNEP,'! Max elements on any processor'!jgf45.07
  7339:                 WRITE(80,'(I8,24x,A)') IM,'! IM, run type'         !jgf46.02
  7340:                 WRITE(80,'(I8,24x,A)') NWS,'! NWS, wind data type' !jgf46.02
  7341:                 WRITE(80,'(I8,24x,A)') abs(NSTAE),'! NSTAE'
  7342:                 WRITE(80,'(I8,24x,A)') abs(NSTAV),'! NSTAV'
  7343:                 IF (IM.EQ.10) THEN
  7344:                    WRITE(80,'(I8,24x,A)') abs(NSTAC),' ! NSTAC' !jgf46.02
  7345:                 ENDIF
  7346:                 IF (NWS.NE.0) THEN
  7347:                    WRITE(80,'(I8,24x,A)') abs(NSTAM),'! NSTAM' !jgf46.02
  7348:                 ENDIF
  7349:                 WRITE(80,'(I8,24x,A)') MNHARF,'! MNHARF'
  7350:                 WRITE(80,'(2I8,16x,A)') MNWLAT,MNWLON,'! NWLON, NWLAT'
  7351:           C
  7352:           Casey 100301: Changed I8 to I12.
  7353: +------>        DO I = 1,NPROC
  7354: |                  WRITE(80,'(3I8,A33)') I-1, NNODP(I), NOD_RES_TOT(I),
  7355: |              &        '  ! PE, NNODP(PE), NOD_RES_TOT(PE)'
  7356: |+----->           WRITE(80,'(9I12)') (IMAP_NOD_LG(K,I),K=1,NNODP(I))
  7357: +------         ENDDO
  7358:           C
  7359:                 WRITE(80,*) "GLOBAL   PE     LOCAL   ( Global-to-Local Nodes )"
  7360: +------>        DO I = 1,NNODG
  7361: |                  WRITE(80,1140) I, IMAP_NOD_GL(1,I)-1, IMAP_NOD_GL(2,I)
  7362: +------         ENDDO
  7363:           C
  7364:           C     jgf45.07 Add subdomain->fulldomain mapping to handle NOFF processing
  7365:           C     IMAP_EL_LG(I,PE) = Global Element Number of Local Element I on PE
  7366:           Casey 100301: Changed I8 to I12.
  7367: +------>        DO I = 1,NPROC
  7368: |                  WRITE(80,'(2I8,A33)') I-1, NELP(I), '  ! PE, NELP(PE)'
  7369: |+----->           WRITE(80,'(9I12)') (IMAP_EL_LG(K,I),K=1,NELP(I))
  7370: +------         ENDDO
  7371:           C
  7372:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTE,TOUTSE,TOUTFE,NSPOOLE,
  7373:                &    '   ! NOUTE,TOUTSE,TOUTFE,NSPOOLE'
  7374:           C
  7375: +------>        DO I = 1,NPROC
  7376: |                  WRITE(80,*) I,NSTAEP(I)
  7377: |+----->           DO K = 1,NSTAEP(I)
  7378: ||                    WRITE(80,*) IMAP_STAE_LG(K,I)
  7379: |+-----            ENDDO
  7380: +------         ENDDO
  7381:           C
  7382:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTV,TOUTSV,TOUTFV,NSPOOLV,
  7383:                &    '   ! NOUTV,TOUTSV,TOUTFV,NSPOOLV'
  7384:           C
  7385: +------>        DO I = 1,NPROC
  7386: |                  WRITE(80,*) I,NSTAVP(I)
  7387: |+----->           DO K = 1,NSTAVP(I)
  7388: ||                    WRITE(80,*) IMAP_STAV_LG(K,I)
  7389: |+-----            ENDDO
  7390: +------         ENDDO
  7391:           C
  7392:                 IF (IM.EQ.10) THEN ! jgf46.02
  7393:                    WRITE(80,'(I8,2E15.8,I8,A32)') NOUTC,TOUTSC,TOUTFC,NSPOOLC,
  7394:                &        '   ! NOUTC,TOUTSC,TOUTFC,NSPOOLC'
  7395: +------>           DO I = 1,NPROC
  7396: |                     WRITE(80,*) I,NSTACP(I)
  7397: |+----->              DO K = 1,NSTACP(I)
  7398: ||                       WRITE(80,*) IMAP_STAC_LG(K,I)
  7399: |+-----               ENDDO
  7400: +------            ENDDO
  7401:                 ENDIF
  7402:           C
  7403:                 IF (NWS.NE.0) THEN ! jgf46.02
  7404:                    WRITE(80,'(I8,2E15.8,I8,A32)') NOUTM,TOUTSM,TOUTFM,NSPOOLM,
  7405:                &        '   ! NOUTM,TOUTSM,TOUTFM,NSPOOLM'
  7406: +------>           DO I = 1,NPROC
  7407: |                     WRITE(80,*) I,NSTAMP(I)
  7408: |+----->              DO K = 1,NSTAMP(I)
  7409: ||                       WRITE(80,*) IMAP_STAM_LG(K,I)
  7410: |+-----               ENDDO
  7411: +------            ENDDO
  7412:                 ENDIF
  7413:           C
  7414:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTGE, TOUTSGE,TOUTFGE,NSPOOLGE,
  7415:                &    '   ! NOUTGE, TOUTSGE, TOUTFGE, NSPOOLGE'
  7416:           C
  7417:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTGV, TOUTSGV,TOUTFGV,NSPOOLGV,
  7418:                &    '   ! NOUTGV, TOUTSGV, TOUTFGV, NSPOOLGV'
  7419:           C
  7420:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTGC, TOUTSGC,TOUTFGC,NSPOOLGC,
  7421:                &    '   ! NOUTGC, TOUTSGC, TOUTFGC, NSPOOLGC'
  7422:           C
  7423:                 WRITE(80,'(I8,2E15.8,I8,A32)') NOUTGW, TOUTSGW,TOUTFGW,NSPOOLGW,
  7424:                &    '   ! NOUTGW, TOUTSGW, TOUTFGW, NSPOOLGW'
  7425:           C
  7426:                 WRITE(80,'(4I4,A32)') NHASE,NHASV,NHAGE,NHAGV,
  7427:                &    '   ! NHASE, NHASV, NHAGE, NHAGV'
  7428:           
  7429:           C     -------------------------------------------------------------
  7430:           C
  7431:           C     S T A R T   3 D   D A T A
  7432:           C
  7433:           C     -------------------------------------------------------------
  7434:           
  7435:                 WRITE(80,*) IDEN !jgf45.11 needed to post process the fort.44 file
  7436:           
  7437:           C     -------------------------------------------------------------
  7438:           C     jgf45.11 Write mappings for 3D density stations.
  7439:           C     -------------------------------------------------------------
  7440:                 WRITE(80,81) I3DSD, TO3DSDS, TO3DSDF, NSPO3DSD, NSTA3DD,
  7441:                &       '   ! I3DSD, TO3DSDS, TO3DSDF, NSPO3DSD, NSTA3DD'
  7442:                 IF(I3DSD.NE.0) THEN
  7443: +------>           DO I = 1, NPROC
  7444: |                     WRITE(80,*) I, NNSTA3DDP(I)
  7445: |+----->              DO K = 1, NNSTA3DDP(I)
  7446: ||                       WRITE(80,*) IMAP_STA3DD_LG(K,I)
  7447: |+-----               ENDDO
  7448: +------            ENDDO
  7449:                 ENDIF
  7450:           C     -------------------------------------------------------------
  7451:           C     jgf45.11 Write mappings for 3D velocity stations.
  7452:           C     -------------------------------------------------------------
  7453:                 WRITE(80,81) I3DSV, TO3DSVS, TO3DSVF, NSPO3DSV, NSTA3DV,
  7454:                &       '   ! I3DSV, TO3DSVS, TO3DSVF, NSPO3DSV, NSTA3DV'
  7455:                 IF(I3DSV.NE.0) THEN
  7456: +------>           DO I = 1, NPROC
  7457: |                     WRITE(80,*) I, NNSTA3DVP(I)
  7458: |+----->              DO K = 1, NNSTA3DVP(I)
  7459: ||                       WRITE(80,*) IMAP_STA3DV_LG(K,I)
  7460: |+-----               ENDDO
  7461: +------            ENDDO
  7462:                 ENDIF
  7463:           C     -------------------------------------------------------------
  7464:           C     jgf45.11 Write mappings for 3D turbulence stations.
  7465:           C     -------------------------------------------------------------
  7466:                 WRITE(80,81) I3DST, TO3DSTS, TO3DSTF, NSPO3DST, NSTA3DT,
  7467:                &       '   ! I3DST, TO3DSST, TO3DFST, NSPO3DST, NSTA3DT'
  7468:                 IF(I3DST.NE.0) THEN
  7469: +------>           DO I = 1, NPROC
  7470: |                     WRITE(80,*) I, NNSTA3DTP(I)
  7471: |+----->              DO K = 1, NNSTA3DTP(I)
  7472: ||                       WRITE(80,*) IMAP_STA3DT_LG(K,I)
  7473: |+-----               ENDDO
  7474: +------            ENDDO
  7475:                 ENDIF
  7476:                 WRITE(80,82) I3DGD, TO3DGDS, TO3DGDF, NSPO3DGD,
  7477:                &       '   ! I3DGD, TO3DGDS, TO3DGDF, NSPO3DGD'
  7478:                 WRITE(80,82) I3DGV, TO3DGVS, TO3DGVF, NSPO3DGV,
  7479:                &       '   ! I3DGV, TO3DGVS, TO3DGVF, NSPO3DGV'
  7480:                 WRITE(80,82) I3DGT, TO3DGTS, TO3DGTF, NSPO3DGT,
  7481:                &       '   ! I3DGT, TO3DGTS, TO3DGTF, NSPO3DGT'
  7482:           C
  7483:           C     End 3D data
  7484:           C
  7485:                 WRITE(80,*) NBYTE
  7486:           C
  7487:                 CLOSE(80)
  7488:           C
  7489:             80  FORMAT(A80)
  7490:             81  FORMAT(I8,2E15.8,2I8,A32)
  7491:             82  FORMAT(I8,2E15.8,I8,A32)
  7492:           1130  FORMAT(8X,9I8)
  7493:           1140  FORMAT(8X,3I8)
  7494:           C
  7495:                 RETURN
  7496:                 END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP80
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP80
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:7353)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:7353)
  LOOP END

  LOOP BEGIN: (prep.F:7360)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:7360)
  LOOP END

  LOOP BEGIN: (prep.F:7367)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:7367)
  LOOP END

  LOOP BEGIN: (prep.F:7375)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7377)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7377)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7385)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7387)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7387)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7395)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7397)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7397)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7406)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7408)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7408)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7443)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7445)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7445)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7456)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7458)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7458)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7469)
    <Unvectorized loop.>

    LOOP BEGIN: (prep.F:7471)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7471)
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREP80
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 41 [s0-s12 s15-s16 s18-s40 s61-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 1808 bytes
      Register spill area      :  224 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 1248 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:7353)
    *** Estimated execution cycle                       : 161
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 7
            Across calls                                : 7
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 14
            Across calls                                :  9
            Over basic blocks                           :  5
    *** The number of SCALAR REGISTER TRANSFER          : 21
  LOOP END

  LOOP BEGIN: (prep.F:7360)
    *** Estimated execution cycle                       : 68
    *** The number of SCALAR REGISTER TRANSFER          : 9
  LOOP END

  LOOP BEGIN: (prep.F:7367)
    *** Estimated execution cycle                       : 139
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 6
            Across calls                                : 6
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 11
            Across calls                                :  7
            Over basic blocks                           :  4
    *** The number of SCALAR REGISTER TRANSFER          : 19
  LOOP END

  LOOP BEGIN: (prep.F:7375)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7377)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7385)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7387)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7395)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7397)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7406)
    *** Estimated execution cycle                       : 69
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7408)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7443)
    *** Estimated execution cycle                       : 68
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7445)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7456)
    *** Estimated execution cycle                       : 68
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7458)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7469)
    *** Estimated execution cycle                       : 68
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 1
            Across calls                                : 1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 3
            Across calls                                : 2
            Over basic blocks                           : 1
    *** The number of SCALAR REGISTER TRANSFER          : 14

    LOOP BEGIN: (prep.F:7471)
      *** Estimated execution cycle                     : 40
      *** The number of SCALAR REGISTER TRANSFER        : 5
    LOOP END
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPUNSWAN
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7557: opt(1418): Constant-length loop is expanded.
  7563: vec( 103): Unvectorized loop.
  7563: vec( 108): Unvectorizable loop structure.
  7574: vec( 103): Unvectorized loop.
  7574: vec( 108): Unvectorizable loop structure.
  7576: vec( 103): Unvectorized loop.
  7576: vec( 108): Unvectorizable loop structure.
  7578: vec( 103): Unvectorized loop.
  7578: vec( 108): Unvectorizable loop structure.
  7581: vec( 103): Unvectorized loop.
  7581: vec( 108): Unvectorizable loop structure.
  7585: vec( 103): Unvectorized loop.
  7585: vec( 108): Unvectorizable loop structure.
  7599: vec( 103): Unvectorized loop.
  7599: vec( 108): Unvectorizable loop structure.
  7602: vec( 103): Unvectorized loop.
  7602: vec( 108): Unvectorizable loop structure.
  7614: vec( 181): Allocation obstructs vectorization.
  7614: vec( 182): Deallocation obstructs vectorization.
  7614: vec( 110): Vectorization obstructive procedure reference.: IWRITE
  7614: vec( 180): I/O statement obstructs vectorization.
  7614: vec( 108): Unvectorizable loop structure.
  7616: opt(1097): This statement prevents loop optimization.
  7617: inl(1212): Source for routine not found.: IWRITE
  7618: opt(1082): Backward transfers inhibit loop optimization.
  7618: vec( 103): Unvectorized loop.
  7618: vec( 108): Unvectorizable loop structure.
  7620: opt(1082): Backward transfers inhibit loop optimization.
  7620: vec( 103): Unvectorized loop.
  7620: vec( 108): Unvectorizable loop structure.
  7628: vec( 108): Unvectorizable loop structure.
  7630: vec( 180): I/O statement obstructs vectorization.
  7630: vec( 181): Allocation obstructs vectorization.
  7630: vec( 182): Deallocation obstructs vectorization.
  7631: opt(1082): Backward transfers inhibit loop optimization.
  7631: opt(1118): This I/O statement inhibits optimization of loop.
  7631: vec( 103): Unvectorized loop.
  7631: vec( 108): Unvectorizable loop structure.
  7638: vec( 103): Unvectorized loop.
  7638: vec( 180): I/O statement obstructs vectorization.
  7639: opt(1118): This I/O statement inhibits optimization of loop.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPUNSWAN
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7513:                 SUBROUTINE  prepUnSWAN
  7514:           C---------------------------------------------------------------------------
  7515:                 USE PRE_GLOBAL
  7516:                 use memory_usage
  7517:                 IMPLICIT NONE
  7518:                 INTEGER I,J,IPROC,IPROC2,ILNODE,INDX,NHG,LINDEX
  7519:                 CHARACTER*170 Line ! line of data from UnSWAN file
  7520:                 INTEGER SDU(NPROC)  ! subdomain unit numbers
  7521:                 LOGICAL Success     ! .true. if all files open without error
  7522:                 LOGICAL swanInitFound !.true. if the swaninit file was found
  7523:                 LOGICAL origUseDefault ! there is no default UnSWAN input file name
  7524:                 INTEGER swiLUN ! logical unit number of swaninit file
  7525:                 INTEGER ErrorIO ! zero if the file was opened successfully
  7526:                 LOGICAL readError ! .true. if there was an error reading a file
  7527:                 CHARACTER(36) swanComFile ! name of swan command file
  7528:                 LOGICAL swanComFound ! .true. if swan command file was found
  7529:                 CHARACTER(len=43) sdFileName     ! subdomain file name
  7530:           C
  7531:           C
  7532:           Casey 110627: Set the unit number.
  7533:                 swiLUN = 26
  7534:           
  7535:           Casey 120402: Changes through this section.  The procedure here is:
  7536:           C             1. Check for the swaninit file.  If it exists, then read the name
  7537:           C                of the SWAN control file from the fourth line of swaninit.
  7538:           C             2. If the swaninit file does not exist, then the user may be using
  7539:           C                the default control file of INPUT.  Check for the INPUT file.
  7540:           C                If it exists, then use it as the SWAN control file.
  7541:           C             3. Otherwise, notify the user of the error.
  7542:           
  7543:                 swanInitFound = .false.
  7544:                 swanComFound = .false.
  7545:                 readError = .true.
  7546:                 INQUIRE(FILE='swaninit',EXIST=swanInitFound)
  7547:                 IF (swanInitFound.eqv..true.) THEN
  7548:                    WRITE(*,*) "INFO: The swaninit file was found."
  7549:                    OPEN(swiLUN,FILE='swaninit',ACTION='READ',
  7550:                &       ACCESS='SEQUENTIAL',IOSTAT=ErrorIO,STATUS='OLD')
  7551:                    IF (ErrorIO.ne.0) THEN
  7552:                       WRITE(*,*) "ERROR: The swaninit file could not be opened."
  7553:                    ELSE
  7554:                       WRITE(*,*)
  7555:                &      "INFO: Parsing swaninit file for swan command file name."
  7556:                       ! skip down to the 4th line
  7557: *------>              DO I=1,4
  7558: |                        READ(swiLUN,*,ERR=4321,END=4321,IOSTAT=ErrorIO) Line
  7559: *------               ENDDO
  7560:                       READ(Line,*,ERR=4321,END=4321,IOSTAT=ErrorIO) swanComFile
  7561:           Casey 110627: Close the swaninit file.
  7562:                       CLOSE(UNIT=swiLUN,STATUS='KEEP')
  7563:                       WRITE(*,*) "INFO: The swan command file is '",
  7564:                &         trim(swanComFile),"'."
  7565:                       readError = .false.
  7566:           Casey 120402: Changes to handle the default INPUT control file.
  7567:                       ! If swan was started without a swaninit file, it will create
  7568:                       ! its own swaninit, and it will use the string INPUT to
  7569:                       ! represent the name of the swan command file.
  7570:           C           IF (TRIM(swanComFile).eq.'INPUT') THEN
  7571:           C              WRITE(*,*) "ERROR: 'INPUT' is an invalid name."
  7572:           C           ELSE
  7573:                          ! check to see if the swan command file is present
  7574:                          INQUIRE(FILE=trim(swanComFile),EXIST=swanComFound)
  7575:                          IF (swanComFound.eqv..true.) THEN
  7576:                             WRITE(*,*) "INFO: The swan command file '",
  7577:                &               trim(swanComFile),"' was found."
  7578:                             OPEN(26,FILE=trim(swanComFile),ACTION='READ',
  7579:                &            ACCESS='SEQUENTIAL',IOSTAT=ErrorIO,STATUS='OLD')
  7580:                             IF (ErrorIO.ne.0) THEN
  7581:                                WRITE(*,*) "ERROR: The swan command file '",
  7582:                &                  trim(swanComFile),"' could not be opened."
  7583:                             ENDIF
  7584:                          ELSE
  7585:                              WRITE(*,*) "ERROR: The swan command file '",
  7586:                &               trim(swanComFile),"' was not found."
  7587:                          ENDIF
  7588:           C           ENDIF
  7589:                    ENDIF
  7590:           Casey 120402: Changes to handle the default INPUT control file.
  7591:                 ELSE
  7592:                    INQUIRE(FILE='INPUT',EXIST=swanComFound)
  7593:                    IF(swanComFound.eqv..true.)THEN
  7594:                       WRITE(swanComFile,'(A)') "INPUT"
  7595:                       readError = .false.
  7596:                       ErrorIO = 0
  7597:                       swanInitFound = .true.
  7598:                       swanComFound = .true.
  7599:                       WRITE(*,*) "INFO: The swan command file is '",
  7600:                &         trim(swanComFile),"'."
  7601:                       ! Casey 120402: Changes to handle the default INPUT control file.
  7602:                       OPEN(UNIT=26,FILE=TRIM(swanComFile),ACTION='READ')
  7603:                    ENDIF
  7604:                 ENDIF
  7605:           4321  IF ((readError.eqv..true.).or.(ErrorIO.ne.0).or.
  7606:                &     (swanInitFound.eqv..false.).or.
  7607:                &     (swanComFound.eqv..false.)) THEN
  7608:                    WRITE(*,*) 'ERROR: There was an error reading swan files.'
  7609:                    WRITE(*,*) 'WARNING: swan files not preprocessed.'
  7610:                    RETURN ! note early return
  7611:                 ENDIF
  7612:           C
  7613:           C     Open each of the subdomain files
  7614: +------>        DO iproc = 1, nproc
  7615: |                  sdu(iproc) = 105 + (iproc-1)
  7616: |+=====>           sdFileName = 'PE0000/'//swanComFile
  7617: |                  CALL IWRITE(sdFileName, 3, 6, iproc-1)
  7618: |                  OPEN (UNIT=SDU(iproc), FILE=TRIM(sdFileName), IOSTAT=ErrorIO)
  7619: |                  IF ( ErrorIO .GT. 0 ) THEN
  7620: |                     WRITE(*,*) "ERROR: Subdomain file '",TRIM(sdFileName),
  7621: |              &         " cannot be opened."
  7622: |                     RETURN ! failed to open at least one subdomain file
  7623: |                  ENDIF
  7624: +------         ENDDO
  7625:           C
  7626:           Casey 090304: Changed the formatting through the next section.
  7627:           
  7628: +------>        DO
  7629: |                  READ(26,'(A)',END=9999) Line
  7630: |+----->           DO IPROC = 1,NPROC
  7631: ||                    WRITE(SDU(IPROC),'(A)') trim(Line)
  7632: |+-----            ENDDO
  7633: +------         ENDDO
  7634:           C
  7635:           C--Close fulldomain file and all the subdomain files
  7636:           C
  7637:            9999 CLOSE (26)
  7638: +------>        DO IPROC=1, NPROC
  7639: |                  CLOSE (SDU(IPROC))
  7640: +------         ENDDO
  7641:           
  7642:                 RETURN
  7643:             60  FORMAT(A60)
  7644:            170  FORMAT(A170)
  7645:            1100 FORMAT(I8,3E13.5)
  7646:            1101 FORMAT(' #')
  7647:           c----------------------------------------------------------------------------
  7648:                 END SUBROUTINE prepUnSWAN


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPUNSWAN
INLINE LIST

  ROOT: PREPUNSWAN (prep.F:7513)
  -> NOINLINE: IWRITE (prep.F:7617)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPUNSWAN
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:7563)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7563)
  LOOP END

  LOOP BEGIN: (prep.F:7574)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7574)
  LOOP END

  LOOP BEGIN: (prep.F:7576)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7576)
  LOOP END

  LOOP BEGIN: (prep.F:7578)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7578)
  LOOP END

  LOOP BEGIN: (prep.F:7581)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7581)
  LOOP END

  LOOP BEGIN: (prep.F:7585)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7585)
  LOOP END

  LOOP BEGIN: (prep.F:7599)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7599)
  LOOP END

  LOOP BEGIN: (prep.F:7602)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7602)
  LOOP END

  LOOP BEGIN: (prep.F:7614)
    <Unvectorized loop.>
    *** Allocation obstructs vectorization. (prep.F:7614)
    *** Deallocation obstructs vectorization. (prep.F:7614)
    *** Vectorization obstructive procedure reference. : IWRITE (prep.F:7614)
    *** I/O statement obstructs vectorization. (prep.F:7614)
    *** Unvectorizable loop structure. (prep.F:7614)

    LOOP BEGIN: (prep.F:7616)
      <Unvectorized loop.>
      *** Unvectorizable data type. (prep.F:7616)
    LOOP END

    LOOP BEGIN: (prep.F:7618)
      <Unvectorized loop.>
      *** Unvectorizable loop structure. (prep.F:7618)
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7620)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7620)
  LOOP END

  LOOP BEGIN: (prep.F:7628)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:7628)

    LOOP BEGIN: (prep.F:7630)
      <Unvectorized loop.>
      *** I/O statement obstructs vectorization. (prep.F:7630)
      *** Allocation obstructs vectorization. (prep.F:7630)
      *** Deallocation obstructs vectorization. (prep.F:7630)

      LOOP BEGIN: (prep.F:7631)
        <Unvectorized loop.>
        *** Unvectorizable loop structure. (prep.F:7631)
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7638)
    <Unvectorized loop.>
    *** I/O statement obstructs vectorization. (prep.F:7638)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:30 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPUNSWAN
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 50 [s0-s12 s15-s16 s18-s41 s53-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 4272 bytes
      Register spill area      :  280 bytes
      Parameter area           :  160 bytes
      Register save area       :  176 bytes
      User data area           : 3656 bytes
      Others                   :    0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:7599)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7602)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7563)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7574)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7585)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7576)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7578)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7581)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:7614)
    *** Estimated execution cycle                       : 234
    *** The number of SCALAR REGISTER SPILL
          Total                                         : 14
            Across calls                                :  7
            Over basic blocks                           :  6
            Others                                      :  1
    *** The number of SCALAR REGISTER RESTORE
          Total                                         : 19
            Across calls                                :  8
            Over basic blocks                           : 10
            Others                                      :  1
    *** The number of SCALAR REGISTER TRANSFER          : 21

    LOOP BEGIN: (prep.F:7616)
      *** Estimated execution cycle                     : 7
    LOOP END

    LOOP BEGIN: (prep.F:7618)
      *** Estimated execution cycle                     : 7
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7628)
    *** Estimated execution cycle                       : 45
    *** The number of SCALAR REGISTER TRANSFER          : 11

    LOOP BEGIN: (prep.F:7630)
      *** Estimated execution cycle                     : 52
      *** The number of SCALAR REGISTER TRANSFER        : 13

      LOOP BEGIN: (prep.F:7631)
        *** Estimated execution cycle                   : 7
      LOOP END
    LOOP END
  LOOP END

  LOOP BEGIN: (prep.F:7638)
    *** Estimated execution cycle                       : 15
    *** The number of SCALAR REGISTER TRANSFER          : 2
  LOOP END

  LOOP BEGIN: (prep.F:7620)
    *** Estimated execution cycle                       : 7
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPNETCDF
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  7847: inl(1222): Inlined: MAKEFILENAME
  7869: inl(1222): Inlined: MAKEFILENAME
  7884: inl(1222): Inlined: MAKEFILENAME
  7899: inl(1222): Inlined: MAKEFILENAME
  7921: inl(1222): Inlined: MAKEFILENAME
  7943: inl(1222): Inlined: MAKEFILENAME
  7958: inl(1222): Inlined: MAKEFILENAME
  7972: inl(1222): Inlined: MAKEFILENAME
  7987: inl(1222): Inlined: MAKEFILENAME
  8004: inl(1222): Inlined: MAKEFILENAME
  8019: inl(1222): Inlined: MAKEFILENAME
  8041: inl(1222): Inlined: MAKEFILENAME
  8052: vec( 103): Unvectorized loop.
  8052: vec( 118): Unvectorizable data type.: WINDVELSTADESCRIPT%FIELD_NAME
  8063: inl(1222): Inlined: MAKEFILENAME
  8078: inl(1222): Inlined: MAKEFILENAME
  8093: inl(1222): Inlined: MAKEFILENAME
  8108: inl(1222): Inlined: MAKEFILENAME
  8122: inl(1222): Inlined: MAKEFILENAME
  8145: inl(1222): Inlined: MAKEFILENAME
  8159: inl(1222): Inlined: MAKEFILENAME
  8175: inl(1222): Inlined: MAKEFILENAME
  8190: inl(1222): Inlined: MAKEFILENAME
  8205: inl(1222): Inlined: MAKEFILENAME
  8224: inl(1222): Inlined: MAKEFILENAME
  8237: vec( 103): Unvectorized loop.
  8237: vec( 118): Unvectorizable data type.: INUNDATIONTIMEDESCRIPT%FIELD_NAME
  8238: vec( 103): Unvectorized loop.
  8238: vec( 118): Unvectorizable data type.: INUNDATIONTIMEDESCRIPT%FILE_BASENAME
  8244: inl(1222): Inlined: MAKEFILENAME
  8255: vec( 103): Unvectorized loop.
  8255: vec( 118): Unvectorizable data type.: MAXINUNDEPTHDESCRIPT%FIELD_NAME
  8256: vec( 103): Unvectorized loop.
  8256: vec( 118): Unvectorizable data type.: MAXINUNDEPTHDESCRIPT%FILE_BASENAME
  8262: inl(1222): Inlined: MAKEFILENAME
  8273: vec( 103): Unvectorized loop.
  8273: vec( 118): Unvectorizable data type.: INITIALLYDRYDESCRIPT%FIELD_NAME
  8274: vec( 103): Unvectorized loop.
  8274: vec( 118): Unvectorizable data type.: INITIALLYDRYDESCRIPT%FILE_BASENAME
  8280: inl(1222): Inlined: MAKEFILENAME
  8291: vec( 103): Unvectorized loop.
  8291: vec( 118): Unvectorizable data type.: ENDRISINGINUNDESCRIPT%FIELD_NAME
  8292: vec( 103): Unvectorized loop.
  8292: vec( 118): Unvectorizable data type.: ENDRISINGINUNDESCRIPT%FILE_BASENAME
  8298: inl(1222): Inlined: MAKEFILENAME
  8316: inl(1222): Inlined: MAKEFILENAME
  8345: vec( 103): Unvectorized loop.
  8345: vec( 118): Unvectorizable data type.: DYNAMICWATERLEVELCORRECTIONSTADESCRIPT%FILE_BASENAME
  8348: inl(1222): Inlined: MAKEFILENAME
  8360: vec( 103): Unvectorized loop.
  8360: vec( 118): Unvectorizable data type.: DYNAMICWATERLEVELCORRECTIONDESCRIPT%FILE_BASENAME
  8363: inl(1222): Inlined: MAKEFILENAME
  8377: vec( 103): Unvectorized loop.
  8377: vec( 118): Unvectorizable data type.: SWANHSDESCRIPT%FILE_NAME
  8380: inl(1222): Inlined: MAKEFILENAME
  8390: vec( 103): Unvectorized loop.
  8390: vec( 118): Unvectorizable data type.: SWANHSMAXDESCRIPT%FIELD_NAME
  8391: vec( 103): Unvectorized loop.
  8391: vec( 118): Unvectorizable data type.: SWANHSMAXDESCRIPT%FILE_NAME
  8393: vec( 103): Unvectorized loop.
  8393: vec( 118): Unvectorizable data type.: SWANHSMAXDESCRIPT%FILE_BASENAME
  8394: inl(1222): Inlined: MAKEFILENAME
  8406: vec( 103): Unvectorized loop.
  8406: vec( 118): Unvectorizable data type.: SWANDIRDESCRIPT%FILE_NAME
  8409: inl(1222): Inlined: MAKEFILENAME
  8419: vec( 103): Unvectorized loop.
  8419: vec( 118): Unvectorizable data type.: SWANDIRMAXDESCRIPT%FIELD_NAME
  8420: vec( 103): Unvectorized loop.
  8420: vec( 118): Unvectorizable data type.: SWANDIRMAXDESCRIPT%FILE_NAME
  8422: vec( 103): Unvectorized loop.
  8422: vec( 118): Unvectorizable data type.: SWANDIRMAXDESCRIPT%FILE_BASENAME
  8423: inl(1222): Inlined: MAKEFILENAME
  8435: vec( 103): Unvectorized loop.
  8435: vec( 118): Unvectorizable data type.: SWANTM01DESCRIPT%FILE_NAME
  8438: inl(1222): Inlined: MAKEFILENAME
  8448: vec( 103): Unvectorized loop.
  8448: vec( 118): Unvectorizable data type.: SWANTM01MAXDESCRIPT%FIELD_NAME
  8449: vec( 103): Unvectorized loop.
  8449: vec( 118): Unvectorizable data type.: SWANTM01MAXDESCRIPT%FILE_NAME
  8451: vec( 103): Unvectorized loop.
  8451: vec( 118): Unvectorizable data type.: SWANTM01MAXDESCRIPT%FILE_BASENAME
  8452: inl(1222): Inlined: MAKEFILENAME
  8464: vec( 103): Unvectorized loop.
  8464: vec( 118): Unvectorizable data type.: SWANTPSDESCRIPT%FILE_NAME
  8467: inl(1222): Inlined: MAKEFILENAME
  8477: vec( 103): Unvectorized loop.
  8477: vec( 118): Unvectorizable data type.: SWANTPSMAXDESCRIPT%FIELD_NAME
  8478: vec( 103): Unvectorized loop.
  8478: vec( 118): Unvectorizable data type.: SWANTPSMAXDESCRIPT%FILE_NAME
  8480: vec( 103): Unvectorized loop.
  8480: vec( 118): Unvectorizable data type.: SWANTPSMAXDESCRIPT%FILE_BASENAME
  8481: inl(1222): Inlined: MAKEFILENAME
  8493: vec( 103): Unvectorized loop.
  8493: vec( 118): Unvectorizable data type.: SWANWINDDESCRIPT%FILE_NAME
  8496: inl(1222): Inlined: MAKEFILENAME
  8506: vec( 103): Unvectorized loop.
  8506: vec( 118): Unvectorizable data type.: SWANWINDMAXDESCRIPT%FIELD_NAME
  8507: vec( 103): Unvectorized loop.
  8507: vec( 118): Unvectorizable data type.: SWANWINDMAXDESCRIPT%FILE_NAME
  8509: vec( 103): Unvectorized loop.
  8509: vec( 118): Unvectorizable data type.: SWANWINDMAXDESCRIPT%FILE_BASENAME
  8510: inl(1222): Inlined: MAKEFILENAME
  8522: vec( 103): Unvectorized loop.
  8522: vec( 118): Unvectorizable data type.: SWANTM02DESCRIPT%FILE_NAME
  8525: inl(1222): Inlined: MAKEFILENAME
  8535: vec( 103): Unvectorized loop.
  8535: vec( 118): Unvectorizable data type.: SWANTM02MAXDESCRIPT%FIELD_NAME
  8536: vec( 103): Unvectorized loop.
  8536: vec( 118): Unvectorizable data type.: SWANTM02MAXDESCRIPT%FILE_NAME
  8538: vec( 103): Unvectorized loop.
  8538: vec( 118): Unvectorizable data type.: SWANTM02MAXDESCRIPT%FILE_BASENAME
  8539: inl(1222): Inlined: MAKEFILENAME
  8550: vec( 103): Unvectorized loop.
  8550: vec( 118): Unvectorizable data type.: SWANTMM10DESCRIPT%FIELD_NAME
  8551: vec( 103): Unvectorized loop.
  8551: vec( 118): Unvectorizable data type.: SWANTMM10DESCRIPT%FILE_NAME
  8553: vec( 103): Unvectorized loop.
  8553: vec( 118): Unvectorizable data type.: SWANTMM10DESCRIPT%FILE_BASENAME
  8554: inl(1222): Inlined: MAKEFILENAME
  8564: vec( 103): Unvectorized loop.
  8564: vec( 118): Unvectorizable data type.: SWANTMM10MAXDESCRIPT%FIELD_NAME
  8565: vec( 103): Unvectorized loop.
  8565: vec( 118): Unvectorizable data type.: SWANTMM10MAXDESCRIPT%FILE_NAME
  8567: vec( 103): Unvectorized loop.
  8567: vec( 118): Unvectorizable data type.: SWANTMM10MAXDESCRIPT%FILE_BASENAME
  8568: inl(1222): Inlined: MAKEFILENAME
  8579: vec( 103): Unvectorized loop.
  8579: vec( 118): Unvectorizable data type.: SIGTSTADESCRIPT%FIELD_NAME
  8589: inl(1222): Inlined: MAKEFILENAME
  8597: vec( 103): Unvectorized loop.
  8597: vec( 118): Unvectorizable data type.: SALSTADESCRIPT%FIELD_NAME
  8612: vec( 103): Unvectorized loop.
  8612: vec( 118): Unvectorizable data type.: TEMPSTADESCRIPT%FIELD_NAME
  8628: vec( 103): Unvectorized loop.
  8628: vec( 118): Unvectorizable data type.: REALQSTADESCRIPT%FIELD_NAME
  8638: inl(1222): Inlined: MAKEFILENAME
  8646: vec( 103): Unvectorized loop.
  8646: vec( 118): Unvectorizable data type.: IMAGINARYQSTADESCRIPT%FIELD_NAME
  8661: vec( 103): Unvectorized loop.
  8661: vec( 118): Unvectorizable data type.: WZSTADESCRIPT%FIELD_NAME
  8677: vec( 103): Unvectorized loop.
  8677: vec( 118): Unvectorizable data type.: Q20STADESCRIPT%FIELD_NAME
  8687: inl(1222): Inlined: MAKEFILENAME
  8710: vec( 103): Unvectorized loop.
  8710: vec( 118): Unvectorizable data type.: EVSTADESCRIPT%FIELD_NAME
  8729: inl(1222): Inlined: MAKEFILENAME
  8744: vec( 103): Unvectorized loop.
  8744: vec( 118): Unvectorizable data type.: TEMPDESCRIPT%FIELD_NAME
  8756: inl(1222): Inlined: MAKEFILENAME
  8764: vec( 103): Unvectorized loop.
  8764: vec( 118): Unvectorizable data type.: IMAGINARYQDESCRIPT%FIELD_NAME
  8783: inl(1222): Inlined: MAKEFILENAME
  8808: inl(1222): Inlined: MAKEFILENAME
  8815: inl(1222): Inlined: MAKEFILENAME
  8912: inl(1212): Source for routine not found.: NETCDFIO::SETADCIRCPARAMETERS
  8933: inl(1212): Source for routine not found.: NETCDFIO::INITNETCDFOUTPUTFILE
  9042: inl(1212): Source for routine not found.: NETCDFIO::INITNETCDFHOTSTART
  9046: inl(1212): Source for routine not found.: NETCDFIO::INITNETCDFHOTSTART3D
  9060: inl(1212): Source for routine not found.: NETCDFIO::INITNETCDFHOTSTARTHARMONIC
  9073: inl(1212): Source for routine not found.: NETCDFIO::INITNETCDFHOTSTARTHARMONICMEANSVARIANCES
  9088: inl(1212): Source for routine not found.: NETCDFIO::FREENETCDFCOORD


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPNETCDF
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  7661:                 SUBROUTINE prepNetCDF()
  7662:           #ifdef ADCNETCDF
  7663:                 use sizes, only : ASCII, XDMF, myproc
  7664:                 USE PRESIZES, ONLY: NM, MNTIF, MNE, MNP
  7665:                 USE HARM, ONLY : IHARIND, CHARMV, NHASE, NHASV, NHAGE, NHAGV
  7666:                 USE VERSION
  7667:                 USE PRE_GLOBAL, ONLY: NSTAE, NOUTE, RUNDES, RUNID, AGRID,
  7668:                &    DTDP, TAU0, STATIM, REFTIM, RNDAY, DRAMP, A00, B00, C00,
  7669:                &    H0, SL0, SF0, CF, ESLM, CORI, DP, NBDV, NBVV,
  7670:                &    SLEL, SFEL, ICS, NT, NTRSPE, IHOT, NOLIBF, NOLIFA, IM,
  7671:                &    XEV,YEV,XEM,YEM,XEL,YEL,X,Y,NELG,DT, NTIF, NODECODE,
  7672:                &    NOLICA, NOLICAT, NWP, NCOR, NTIP, NWS, NRS, NRAMP, NBFR,
  7673:                &    NHARFR, NHY, NOPE, NETA, NBOU, NVEL, G, SL1, SF1,
  7674:                &    NVDLL, NVELL, IBTYPE, IBTYPEE,
  7675:                &    NSTAV, NOUTV, SLEV, SFEV, NTRSPV,
  7676:                &    NSTAM, NOUTM, SLEM, SFEM, NTRSPM,
  7677:                &    NOUTGE, SLAM, SFEA, NDSETSE,
  7678:                &    NOUTGV, NDSETSV,
  7679:                &    NOUTGW, NDSETSW,
  7680:                &    IESTP,NSCOUE,IVSTP,NSCOUV,ICSTP,NSCOUC,IPSTP,IWSTP,NSCOUM,
  7681:                &    IGEP,NSCOUGE,IGVP,NSCOUGV,IGCP,NSCOUGC,IGPP,IGWP,NSCOUGW,
  7682:                &    nhstar,nhsinc,
  7683:                &    title, institution,
  7684:                &    source, history, references, comments, host, convention,
  7685:                &    contact, base_date, NABOUT, NSCREEN, inundationOutput,
  7686:                &    I3DSD, NFEN, NSTA3DD, I3DSV, NSTA3DV, I3DST, NSTA3DT,
  7687:                &    I3DGD, I3DGV, I3DGT, IDEN, islip, kp, z0s, z0b, theta1,
  7688:                &    theta2, ievc, evmin, evcon, alp1, alp2, alp3, igc, nlsd,
  7689:                &    nvsd, nltd, nvtd, alp4, C3D, X3DD, Y3DD, SL3DD, SF3DD,
  7690:                &    X3DV, Y3DV, SL3DV, SF3DV, X3DT, Y3DT, SL3DT, SF3DT, C3D,
  7691:                &    foundCorrectionControlNamelist, NCICE, !GML added NCICE 20210727
  7692:                &    foundVEW1DChannelControlNamelist, meshHasWeir, meshHasInternalWeir,
  7693:                &    meshHasWeirWithPipes
  7694:                 USE NODALATTRIBUTES, ONLY : outputTau0
  7695:                 USE NETCDFIO, ONLY : setADCIRCParameters, initNetCDFOutputFile,
  7696:                &    initNetCDFHotstart3D, initNetCDFHotstart,
  7697:                &    initNetCDFHotstartHarmonic,
  7698:                &    initNetCDFHotstartHarmonicMeansVariances,
  7699:                &    freeNetCDFCoord
  7700:           #ifdef ADCSWAN
  7701:                 USE GLOBAL, ONLY : OutputDataDescript_t, screenUnit,
  7702:                &                   SWAN_OutputHS,SWAN_OutputDIR,SWAN_OutputTM01,
  7703:                &                   SWAN_OutputTPS,SWAN_OutputWIND,SWAN_OutputTM02,
  7704:                &                   SWAN_OutputTMM10,NOUT_TVW,outputWindDrag
  7705:           #else
  7706:                 USE GLOBAL, ONLY : OutputDataDescript_t, screenUnit,
  7707:                &                   NOUT_TVW,outputWindDrag
  7708:           #endif
  7709:           C
  7710:                 IMPLICIT NONE
  7711:                 LOGICAL reterr
  7712:           C
  7713:           C     The initialization of the output data descriptors for each ADCIRC
  7714:           C     output file had to be cut and pasted from write_output.F. At some
  7715:           C     point in the future, adcprep will be part of adcirc, making this
  7716:           C     unfortunate cut-and-paste duplication unnecessary.
  7717:                 !WJP 02.20.2018 Adding capability for fort.51-54
  7718:                 type(OutputDataDescript_t), SAVE :: HaElevStaDescript  ! fort.51
  7719:                 type(OutputDataDescript_t), SAVE :: HaVelStaDescript   ! fort.52
  7720:                 type(OutputDataDescript_t), SAVE :: HaElevDescript     ! fort.53
  7721:                 type(OutputDataDescript_t), SAVE :: HaVelDescript      ! fort.54
  7722:                 type(OutputDataDescript_t), SAVE :: ElevStaDescript    ! fort.61
  7723:                 type(OutputDataDescript_t), SAVE :: VelStaDescript     ! fort.62
  7724:                 type(OutputDataDescript_t), SAVE :: ElevDescript       ! fort.63
  7725:                 type(OutputDataDescript_t), SAVE :: Tau0Descript       ! fort.90
  7726:                 type(OutputDataDescript_t), SAVE :: VelDescript        ! fort.64
  7727:                 type(OutputDataDescript_t), SAVE :: PrStaDescript      ! fort.71
  7728:                 type(OutputDataDescript_t), SAVE :: WindVelStaDescript ! fort.72
  7729:                 type(OutputDataDescript_t), SAVE :: PrDescript         ! fort.73
  7730:                 type(OutputDataDescript_t), SAVE :: windDragDescript   ! winddrag.173
  7731:                 type(OutputDataDescript_t), SAVE :: WindVelDescript    ! fort.74
  7732:           C++ GML 20200605
  7733:                 type(OutputDataDescript_t), SAVE :: IceStaDescript     ! fort.91
  7734:                 type(OutputDataDescript_t), SAVE :: IceAFDescript      ! fort.93
  7735:           C++
  7736:                 type(OutputDataDescript_t), SAVE :: weirElevDescript   ! fort.77
  7737:                 type(OutputDataDescript_t), SAVE :: EtaMaxDescript     ! maxele.63
  7738:                 type(OutputDataDescript_t), SAVE :: UMaxDescript       ! maxvel.63
  7739:                 type(OutputDataDescript_t), SAVE :: PrMinDescript      ! minpr.63
  7740:                 type(OutputDataDescript_t), SAVE :: WVMaxDescript      ! maxwvel.63
  7741:                 type(OutputDataDescript_t), SAVE :: RSMaxDescript
  7742:                 type(OutputDataDescript_t), SAVE :: InundationTimeDescript ! inundationtime.63
  7743:                 type(OutputDataDescript_t), SAVE :: MaxInunDepthDescript   ! maxinundepth.63
  7744:                 type(OutputDataDescript_t), SAVE :: InitiallyDryDescript   ! initiallydry.63
  7745:                 type(OutputDataDescript_t), SAVE :: EndRisingInunDescript  ! endrisinginun.63
  7746:                 type(OutputDataDescript_t), SAVE :: EverDriedDescript      ! everdried.63
  7747:           
  7748:                 type(OutputDataDescript_t), SAVE :: dynamicWaterlevelCorrectionDescript    ! dynamicWaterlevelCorrection.63
  7749:                 type(OutputDataDescript_t), SAVE :: dynamicWaterlevelCorrectionStaDescript ! dynamicWaterlevelCorrection.61
  7750:           
  7751:           !      tcm v50.75 moved RSDescript outside of the ifdef adcswan for use with
  7752:           !      nrs = 3 or nrs= 4 or nrs = 5
  7753:                 type(OutputDataDescript_t), SAVE :: RSDescript
  7754:           
  7755:           #ifdef ADCSWAN
  7756:           Cobell 20120510: SWAN Output Data
  7757:                 type(OutputDataDescript_t), SAVE :: SwanHSDescript
  7758:                 type(OutputDataDescript_t), SAVE :: SwanDIRDescript
  7759:                 type(OutputDataDescript_t), SAVE :: SwanTM01Descript
  7760:                 type(OutputDataDescript_t), SAVE :: SwanTPSDescript
  7761:                 type(OutputDataDescript_t), SAVE :: SwanWindDescript
  7762:                 type(OutputDataDescript_t), SAVE :: SwanTM02Descript
  7763:                 type(OutputDataDescript_t), SAVE :: SwanTMM10Descript
  7764:           !      type(OutputDataDescript_t), SAVE :: RSDescript   ! tcm v50.75 moved
  7765:                 type(OutputDataDescript_t), SAVE :: SwanHSMaxDescript
  7766:                 type(OutputDataDescript_t), SAVE :: SwanDIRMaxDescript
  7767:                 type(OutputDataDescript_t), SAVE :: SwanTM01MaxDescript
  7768:                 type(OutputDataDescript_t), SAVE :: SwanTPSMaxDescript
  7769:                 type(OutputDataDescript_t), SAVE :: SwanWindMaxDescript
  7770:                 type(OutputDataDescript_t), SAVE :: SwanTM02MaxDescript
  7771:                 type(OutputDataDescript_t), SAVE :: SwanTMM10MaxDescript
  7772:           #endif
  7773:           C     3D output data
  7774:                 type(OutputDataDescript_t), save :: SigTStaDescript    ! fort.41
  7775:                 type(OutputDataDescript_t), save :: SalStaDescript
  7776:                 type(OutputDataDescript_t), save :: TempStaDescript
  7777:                 type(OutputDataDescript_t), save :: QSurfKp1Descript
  7778:                 type(OutputDataDescript_t), save :: RealQStaDescript   ! fort.42
  7779:                 type(OutputDataDescript_t), save :: ImaginaryQStaDescript
  7780:                 type(OutputDataDescript_t), save :: WZStaDescript
  7781:                 type(OutputDataDescript_t), save :: Q20StaDescript     ! fort.43
  7782:                 type(OutputDataDescript_t), save :: LStaDescript
  7783:                 type(OutputDataDescript_t), save :: EVStaDescript
  7784:                 type(OutputDataDescript_t), save :: SigTDescript       ! fort.44
  7785:                 type(OutputDataDescript_t), save :: SalDescript
  7786:                 type(OutputDataDescript_t), save :: TempDescript
  7787:                 type(OutputDataDescript_t), save :: RealQDescript      ! fort.45
  7788:                 type(OutputDataDescript_t), save :: ImaginaryQDescript
  7789:                 type(OutputDataDescript_t), save :: WZDescript
  7790:                 type(OutputDataDescript_t), save :: Q20Descript        ! fort.46
  7791:                 type(OutputDataDescript_t), save :: LDescript
  7792:                 type(OutputDataDescript_t), save :: EVDescript
  7793:           C     For hotstart files:
  7794:                 type(OutputDataDescript_t), SAVE :: Elev1Descript
  7795:                 type(OutputDataDescript_t), SAVE :: Elev2Descript
  7796:                 type(OutputDataDescript_t), SAVE :: CH1Descript
  7797:                 type(OutputDataDescript_t), SAVE :: EtaDiscDescript
  7798:                 type(OutputDataDescript_t), SAVE :: NodeCodeDescript
  7799:                 type(OutputDataDescript_t), SAVE :: NOFFDescript
  7800:           C     for hotstart 3D data
  7801:                 type(OutputDataDescript_t),SAVE :: Duudescript
  7802:                 type(OutputDataDescript_t),SAVE :: Duvdescript
  7803:                 type(OutputDataDescript_t),SAVE :: Dvvdescript
  7804:                 type(OutputDataDescript_t),SAVE :: Uudescript
  7805:                 type(OutputDataDescript_t),SAVE :: Vvdescript
  7806:                 type(OutputDataDescript_t),SAVE :: Bsxdescript
  7807:                 type(OutputDataDescript_t),SAVE :: Bsydescript
  7808:           C     for hotstart harmonic analysis
  7809:                 type(OutputDataDescript_t), SAVE :: HarmElevFDLVDescript
  7810:                 type(OutputDataDescript_t), SAVE :: HarmElevSLVDescript
  7811:                 type(OutputDataDescript_t), SAVE :: HarmUVelFDLVDescript
  7812:                 type(OutputDataDescript_t), SAVE :: HarmVVelFDLVDescript
  7813:                 type(OutputDataDescript_t), SAVE :: HarmUVelSLVDescript
  7814:                 type(OutputDataDescript_t), SAVE :: HarmVVelSLVDescript
  7815:           C     for hotstart harmoinc analysis means and variance calculations
  7816:                 type(OutputDataDescript_t), SAVE :: ELAVDescript
  7817:                 type(OutputDataDescript_t), SAVE :: ELVADescript
  7818:                 type(OutputDataDescript_t), SAVE :: XVELAVDescript
  7819:                 type(OutputDataDescript_t), SAVE :: YVELAVDescript
  7820:                 type(OutputDataDescript_t), SAVE :: XVELVADescript
  7821:                 type(OutputDataDescript_t), SAVE :: YVELVADescript
  7822:           C
  7823:                 INTEGER numHotstartWrites ! number writes to hot start files
  7824:                 INTEGER nextLun           ! next LUN to write to, after initial write
  7825:           C
  7826:                 !WJP 02.20.2018 Adding capability for fort.51-54
  7827:           C     fort.51
  7828:                 HaElevStaDescript % specifier            = NHASE
  7829:                 HaElevStaDescript % lun                  = 51
  7830:                 HaElevStaDescript % initial_value        = 0.0
  7831:                 HaElevStaDescript % num_items_per_record = NHARFR
  7832:                 HaElevStaDescript % num_fd_records       = NSTAE
  7833:                 HaElevStaDescript % num_records_this     = NSTAE
  7834:                 HaElevStaDescript % ConsiderWetDry       = .TRUE.
  7835:                 HaElevStaDescript % alternate_value      = -99999.0
  7836: +======>        HaElevStaDescript % field_name           = 'HaElevSta'
  7837:                 IF (ICS.ne.1) THEN
  7838:                    HaElevStaDescript % x_coord           => SLEL
  7839:                    HaElevStaDescript % y_coord           => SFEL
  7840:                 ELSE
  7841:                    HaElevStaDescript % x_coord           => XEL
  7842:                    HaElevStaDescript % y_coord           => YEL
  7843:                 ENDIF
  7844:                 HaElevStaDescript % file_extension       = 51
  7845: +======>        HaElevStaDescript % file_basename        = 'fort'
  7846:                 HaElevStaDescript % readMaxMin           = .false.
  7847:         I       call makeFileName(HaElevStaDescript)
  7848:           C
  7849:           C     fort.52
  7850:                 HaVelStaDescript % specifier            = NHASV
  7851:                 HaVelStaDescript % lun                  = 52
  7852:                 HaVelStaDescript % initial_value        = 0.0
  7853:                 HaVelStaDescript % num_items_per_record = NHARFR
  7854:                 HaVelStaDescript % num_fd_records       = NSTAV
  7855:                 HaVelStaDescript % num_records_this     = NSTAV
  7856:                 HaVelStaDescript % ConsiderWetDry       = .FALSE.
  7857:                 HaVelStaDescript % alternate_value      = 0.0
  7858: +======>        HaVelStaDescript % field_name           = 'HaVelSta'
  7859:                 IF (ICS.ne.1) THEN
  7860:                    HaVelStaDescript % x_coord           => SLEV
  7861:                    HaVelStaDescript % y_coord           => SFEV
  7862:                 ELSE
  7863:                    HaVelStaDescript % x_coord           => XEV
  7864:                    HaVelStaDescript % y_coord           => YEV
  7865:                 ENDIF
  7866:                 HaVelStaDescript % file_extension       = 52
  7867: +======>        HaVelStaDescript % file_basename        = 'fort'
  7868:                 HaVelStaDescript % readMaxMin           = .false.
  7869:         I       call makeFileName(HaVelStaDescript)
  7870:           C
  7871:           C     fort.53
  7872:                 HaElevDescript % specifier            = NHAGE
  7873:                 HaElevDescript % lun                  = 53
  7874:                 HaElevDescript % initial_value        = 0.0
  7875:                 HaElevDescript % num_items_per_record = NHARFR
  7876:                 HaElevDescript % num_fd_records       = MNP
  7877:                 HaElevDescript % num_records_this     = MNP
  7878:                 HaElevDescript % ConsiderWetDry       = .TRUE.
  7879:                 HaElevDescript % alternate_value      = -99999.0
  7880: +======>        HaElevDescript % field_name           = 'HaElev'
  7881:                 HaElevDescript % file_extension       = 53
  7882: +======>        HaElevDescript % file_basename        = 'fort'
  7883:                 HaElevDescript % readMaxMin           = .false.
  7884:         I       call makeFileName(HaElevDescript)
  7885:           C
  7886:           C     fort.54
  7887:                 HaVelDescript % specifier            = NHAGV
  7888:                 HaVelDescript % lun                  = 54
  7889:                 HaVelDescript % initial_value        = 0.0
  7890:                 HaVelDescript % num_items_per_record = NHARFR
  7891:                 HaVelDescript % num_fd_records       = MNP
  7892:                 HaVelDescript % num_records_this     = MNP
  7893:                 HaVelDescript % ConsiderWetDry       = .FALSE.
  7894:                 HaVelDescript % alternate_value      = 0.0
  7895: +======>        HaVelDescript % field_name           = 'HaVel'
  7896:                 HaVelDescript % file_extension       = 54
  7897: +======>        HaVelDescript % file_basename        = 'fort'
  7898:                 HaVelDescript % readMaxMin           = .false.
  7899:         I       call makeFileName(HaVelDescript)
  7900:           C
  7901:           C     fort.61
  7902:                 ElevStaDescript % specifier            = NOUTE
  7903:                 ElevStaDescript % lun                  = 61
  7904:                 ElevStaDescript % initial_value        = 0.0
  7905:                 ElevStaDescript % num_items_per_record = 1
  7906:                 ElevStaDescript % num_fd_records       = abs(NSTAE)
  7907:                 ElevStaDescript % num_records_this     = abs(NSTAE)
  7908:                 ElevStaDescript % ConsiderWetDry       = .TRUE.
  7909:                 ElevStaDescript % alternate_value      = -99999.0
  7910: +======>        ElevStaDescript % field_name           = 'ElevSta'
  7911:                 IF (ICS.ne.1) THEN
  7912:                    ElevStaDescript % x_coord           => SLEL
  7913:                    ElevStaDescript % y_coord           => SFEL
  7914:                 ELSE
  7915:                    ElevStaDescript % x_coord           => XEL
  7916:                    ElevStaDescript % y_coord           => YEL
  7917:                 ENDIF
  7918:                 ElevStaDescript % file_extension       = 61
  7919: +======>        ElevStaDescript % file_basename        = 'fort'
  7920:                 ElevStaDescript % readMaxMin           = .false.
  7921:         I       call makeFileName(ElevStaDescript)
  7922:           C
  7923:           C     fort.62
  7924:                 VelStaDescript % specifier            = NOUTV
  7925:                 VelStaDescript % lun                  = 62
  7926:                 VelStaDescript % initial_value        = 0.0
  7927:                 VelStaDescript % num_items_per_record = 2
  7928:                 VelStaDescript % num_fd_records       = abs(NSTAV)
  7929:                 VelStaDescript % num_records_this     = abs(NSTAV)
  7930:                 VelStaDescript % ConsiderWetDry       = .FALSE.
  7931:                 VelStaDescript % alternate_value      = 0.0
  7932: +======>        VelStaDescript % field_name           = 'VelSta'
  7933:                 IF (ICS.ne.1) THEN
  7934:                    VelStaDescript % x_coord           => SLEV
  7935:                    VelStaDescript % y_coord           => SFEV
  7936:                 ELSE
  7937:                    VelStaDescript % x_coord           => XEV
  7938:                    VelStaDescript % y_coord           => YEV
  7939:                 ENDIF
  7940:                 VelStaDescript % file_extension       = 62
  7941: +======>        VelStaDescript % file_basename        = 'fort'
  7942:                 VelStaDescript % readMaxMin           = .false.
  7943:         I       call makeFileName(VelStaDescript)
  7944:           C
  7945:           C     fort.63
  7946:                 ElevDescript % specifier            = NOUTGE
  7947:                 ElevDescript % lun                  = 63
  7948:                 ElevDescript % initial_value        = 0.0
  7949:                 ElevDescript % num_items_per_record = 1
  7950:                 ElevDescript % num_fd_records       = MNP
  7951:                 ElevDescript % num_records_this     = MNP
  7952:                 ElevDescript % ConsiderWetDry       = .TRUE.
  7953:                 ElevDescript % alternate_value      = -99999.0
  7954: +======>        ElevDescript % field_name           = 'Elev'
  7955:                 ElevDescript % file_extension       = 63
  7956: +======>        ElevDescript % file_basename        = 'fort'
  7957:                 ElevDescript % readMaxMin           = .false.
  7958:         I       call makeFileName(ElevDescript)
  7959:           C
  7960:                 ! fort.90 (tau0)
  7961:                 Tau0Descript % lun                  = 90
  7962:                 Tau0Descript % specifier            = NOUTGE
  7963:                 Tau0Descript % initial_value        = 0.d0
  7964:                 Tau0Descript % num_fd_records       = MNP
  7965:                 Tau0Descript % num_records_this     = MNP
  7966:                 Tau0Descript % ConsiderWetDry       = .false.
  7967:                 Tau0Descript % alternate_value      = -99999.0
  7968: +======>        Tau0Descript % field_name           = 'Tau0'
  7969:                 Tau0Descript % file_extension       = 90
  7970: +======>        Tau0Descript % file_basename        = 'fort'
  7971:                 Tau0Descript % readMaxMin            = .false.
  7972:         I       call makeFileName(Tau0Descript)
  7973:           C
  7974:           C     fort.64
  7975:                 VelDescript % specifier            = NOUTGV
  7976:                 VelDescript % lun                  = 64
  7977:                 VelDescript % initial_value        = 0.0
  7978:                 VelDescript % num_items_per_record = 2
  7979:                 VelDescript % num_fd_records       = MNP
  7980:                 VelDescript % num_records_this     = MNP
  7981:                 VelDescript % ConsiderWetDry       = .FALSE.
  7982:                 VelDescript % alternate_value      = 0.0
  7983: +======>        VelDescript % field_name           = 'Vel'
  7984:                 VelDescript % file_extension       = 64
  7985: +======>        VelDescript % file_basename        = 'fort'
  7986:                 VelDescript % readMaxMin           = .false.
  7987:         I       call makeFileName(VelDescript)
  7988:           C
  7989:           C     maxele.63
  7990:           C     jgf52.08.11: Take absolute value of specifier to avoid overwriting
  7991:           C     (reinitializing) existing min/max file, if any.
  7992:                 EtaMaxDescript % specifier            = abs(NOUTGE)
  7993:                 EtaMaxDescript % lun                  = 311
  7994:                 EtaMaxDescript % initial_value        = -99999.d0
  7995:                 EtaMaxDescript % num_items_per_record = 1
  7996:                 EtaMaxDescript % num_fd_records       = MNP
  7997:                 EtaMaxDescript % num_records_this     = MNP
  7998:                 EtaMaxDescript % ConsiderWetDry       = .FALSE.
  7999:                 EtaMaxDescript % alternate_value      = -99999.d0
  8000: +======>        EtaMaxDescript % field_name           = 'EtaMax'
  8001:                 EtaMaxDescript % file_extension       = 63
  8002: +======>        EtaMaxDescript % file_basename        = 'maxele'
  8003:                 EtaMaxDescript % readMaxMin           = .true.
  8004:         I       call makeFileName(EtaMaxDescript)
  8005:           C
  8006:           C     maxvel.63
  8007:                 UMaxDescript % specifier            = abs(NOUTGV)
  8008:                 UMaxDescript % lun                  = 312
  8009:                 UMaxDescript % initial_value        = 0.0
  8010:                 UMaxDescript % num_items_per_record = 2
  8011:                 UMaxDescript % num_fd_records       = MNP
  8012:                 UMaxDescript % num_records_this     = MNP
  8013:                 UMaxDescript % ConsiderWetDry       = .FALSE.
  8014:                 UMaxDescript % alternate_value      = 0.0
  8015: +======>        UMaxDescript % field_name           = 'UMax'
  8016:                 UMaxDescript % file_extension       = 63
  8017: +======>        UMaxDescript % file_basename        = 'maxvel'
  8018:                 UMaxDescript % readMaxMin           = .true.
  8019:         I       call makeFileName(UMaxDescript)
  8020:           C
  8021:           C     fort.71
  8022:                 PrStaDescript % specifier            = NOUTM
  8023:                 PrStaDescript % lun                  = 71
  8024:                 PrStaDescript % initial_value        = 0.0
  8025:                 PrStaDescript % num_items_per_record = 1
  8026:                 PrStaDescript % num_fd_records       = abs(NSTAM)
  8027:                 PrStaDescript % num_records_this     = abs(NSTAM)
  8028:                 PrStaDescript % ConsiderWetDry       = .FALSE.
  8029:                 PrStaDescript % alternate_value      = 0.0
  8030: +======>        PrStaDescript % field_name           = 'PrSta'
  8031:                 IF (ICS.ne.1) THEN
  8032:                    PrStaDescript % x_coord           => SLEM
  8033:                    PrStaDescript % y_coord           => SFEM
  8034:                 ELSE
  8035:                    PrStaDescript % x_coord           => XEM
  8036:                    PrStaDescript % y_coord           => YEM
  8037:                 ENDIF
  8038:                 PrStaDescript % file_extension       = 71
  8039: +======>        PrStaDescript % file_basename        = 'fort'
  8040:                 PrStaDescript % readMaxMin           = .false.
  8041:         I       call makeFileName(PrStaDescript)
  8042:           C
  8043:           C     fort.72
  8044:                 WindVelStaDescript % specifier            = NOUTM
  8045:                 WindVelStaDescript % lun                  = 72
  8046:                 WindVelStaDescript % initial_value        = 0.0
  8047:                 WindVelStaDescript % num_items_per_record = 2
  8048:                 WindVelStaDescript % num_fd_records       = abs(NSTAM)
  8049:                 WindVelStaDescript % num_records_this     = abs(NSTAM)
  8050:                 WindVelStaDescript % ConsiderWetDry       = .FALSE.
  8051:                 WindVelStaDescript % alternate_value      = 0.0
  8052: +======>        WindVelStaDescript % field_name           = 'WindVelSta'
  8053:                 IF (ICS.ne.1) THEN
  8054:                    WindVelStaDescript % x_coord           => SLEM
  8055:                    WindVelStaDescript % y_coord           => SFEM
  8056:                 ELSE
  8057:                    WindVelStaDescript % x_coord           => XEM
  8058:                    WindVelStaDescript % y_coord           => YEM
  8059:                 ENDIF
  8060:                 WindVelStaDescript % file_extension       = 72
  8061: +======>        WindVelStaDescript % file_basename        = 'fort'
  8062:                 WindVelStaDescript % readMaxMin           = .false.
  8063:         I       call makeFileName(WindVelStaDescript)
  8064:           C
  8065:           C     fort.73
  8066:                 PrDescript % specifier            = NOUTGW
  8067:                 PrDescript % lun                  = 73
  8068:                 PrDescript % initial_value        = 0.0
  8069:                 PrDescript % num_items_per_record = 1
  8070:                 PrDescript % num_fd_records       = MNP
  8071:                 PrDescript % num_records_this     = MNP
  8072:                 PrDescript % ConsiderWetDry       = .FALSE.
  8073:                 PrDescript % alternate_value      = 0.0
  8074: +======>        PrDescript % field_name           = 'Pr'
  8075:                 PrDescript % file_extension       = 73
  8076: +======>        PrDescript % file_basename        = 'fort'
  8077:                 PrDescript % readMaxMin           = .false.
  8078:         I       call makeFileName(PrDescript)
  8079:           C
  8080:           C     fort.74
  8081:                 WindVelDescript % specifier            = NOUTGW
  8082:                 WindVelDescript % lun                  = 74
  8083:                 WindVelDescript % initial_value        = 0.0
  8084:                 WindVelDescript % num_items_per_record = 2
  8085:                 WindVelDescript % num_fd_records       = MNP
  8086:                 WindVelDescript % num_records_this     = MNP
  8087:                 WindVelDescript % ConsiderWetDry       = .FALSE.
  8088:                 WindVelDescript % alternate_value      = 0.0
  8089: +======>        WindVelDescript % field_name           = 'WindVel'
  8090:                 WindVelDescript % file_extension       = 74
  8091: +======>        WindVelDescript % file_basename        = 'fort'
  8092:                 WindVelDescript % readMaxMin           = .false.
  8093:         I       call makeFileName(WindVelDescript)
  8094:           
  8095:           C     windDrag.63
  8096:                 windDragDescript % specifier            = NOUTGW
  8097:                 windDragDescript % lun                  = 173
  8098:                 windDragDescript % initial_value        = 0.0
  8099:                 windDragDescript % num_items_per_record = 1
  8100:                 windDragDescript % num_fd_records       = MNP
  8101:                 windDragDescript % num_records_this     = MNP
  8102:                 windDragDescript % ConsiderWetDry       = .FALSE.
  8103:                 windDragDescript % alternate_value      = -99999.0
  8104: +======>        windDragDescript % field_name           = 'windDrag'
  8105:                 windDragDescript % file_extension       = 173
  8106: +======>        windDragDescript % file_basename        = 'windDrag'
  8107:                 windDragDescript % readMaxMin           = .false.
  8108:         I       call makeFileName(windDragDescript)
  8109:           
  8110:           C     fort.77
  8111:                 WeirElevDescript % specifier            = NOUT_TVW
  8112:                 WeirElevDescript % lun                  = 77
  8113:                 WeirElevDescript % initial_value        = 0.0
  8114:                 WeirElevDescript % num_items_per_record = 1
  8115:                 WeirElevDescript % num_fd_records       = MNP
  8116:                 WeirElevDescript % num_records_this     = MNP
  8117:                 WeirElevDescript % ConsiderWetDry       = .FALSE.
  8118:                 WeirElevDescript % alternate_value      = 0.0
  8119: +======>        WeirElevDescript % field_name           = 'weir_dz'
  8120:                 WeirElevDescript % file_extension       = 77
  8121: +======>        WeirElevDescript % file_basename        = 'fort'
  8122:         I       call makeFileName(weirElevDescript)
  8123:           
  8124:           C++ GML 20200605
  8125:           C     fort.91
  8126:                 IceStaDescript % specifier            = MERGE(NOUTM,0,NCICE > 0)
  8127:                 IceStaDescript % lun                  = 91
  8128:                 IceStaDescript % initial_value        = 0.0
  8129:                 IceStaDescript % num_items_per_record = 1
  8130:                 IceStaDescript % num_fd_records       = abs(NSTAM)
  8131:                 IceStaDescript % num_records_this     = abs(NSTAM)
  8132:                 IceStaDescript % ConsiderWetDry       = .FALSE.
  8133:                 IceStaDescript % alternate_value      = 0.0
  8134: +======>        IceStaDescript % field_name           = 'IceSta'
  8135:                 IF (ICS.eq.2) THEN
  8136:                    IceStaDescript % x_coord           => SLEM
  8137:                    IceStaDescript % y_coord           => SFEM
  8138:                 ELSE
  8139:                    IceStaDescript % x_coord           => XEM
  8140:                    IceStaDescript % y_coord           => YEM
  8141:                 ENDIF
  8142:                 IceStaDescript % file_extension       = 91
  8143: +======>        IceStaDescript % file_basename        = 'fort'
  8144:                 IceStaDescript % readMaxMin           = .false.
  8145:         I       call makeFileName(IceStaDescript)
  8146:           C     fort.93
  8147:                 IceAFDescript % specifier            = MERGE(NOUTGW,0,NCICE > 0)
  8148:                 IceAFDescript % lun                  = 93
  8149:                 IceAFDescript % initial_value        = 0.0
  8150:                 IceAFDescript % num_items_per_record = 1
  8151:                 IceAFDescript % num_fd_records       = MNP
  8152:                 IceAFDescript % num_records_this     = MNP
  8153:                 IceAFDescript % ConsiderWetDry       = .FALSE.
  8154:                 IceAFDescript % alternate_value      = 0.0
  8155: +======>        IceAFDescript % field_name           = 'seaice_af'
  8156:                 IceAFDescript % file_extension       = 93
  8157: +======>        IceAFDescript % file_basename        = 'fort'
  8158:                 WeirElevDescript % readMaxMin           = .false.
  8159:         I       call makeFileName(IceAFDescript)
  8160:           C++
  8161:           C
  8162:           C     minpr.63
  8163:                 PrMinDescript % specifier            = abs(NOUTGW)
  8164:                 PrMinDescript % lun                  = 313
  8165:                 PrMinDescript % initial_value        = 99999.d0
  8166:                 PrMinDescript % num_items_per_record = 1
  8167:                 PrMinDescript % num_fd_records       = MNP
  8168:                 PrMinDescript % num_records_this     = MNP
  8169:                 PrMinDescript % ConsiderWetDry       = .FALSE.
  8170:                 PrMinDescript % alternate_value      = 0.0
  8171: +======>        PrMinDescript % field_name           = 'PrMin'
  8172:                 PrMinDescript % file_extension       = 63
  8173: +======>        PrMinDescript % file_basename        = 'minpr'
  8174:                 PrMinDescript % readMaxMin           = .true.
  8175:         I       call makeFileName(PrMinDescript)
  8176:           C
  8177:           C     maxwvel.63
  8178:                 WVMaxDescript % specifier            = abs(NOUTGW)
  8179:                 WVMaxDescript % lun                  = 314
  8180:                 WVMaxDescript % initial_value        = 0.0
  8181:                 WVMaxDescript % num_items_per_record = 2
  8182:                 WVMaxDescript % num_fd_records       = MNP
  8183:                 WVMaxDescript % num_records_this     = MNP
  8184:                 WVMaxDescript % ConsiderWetDry       = .FALSE.
  8185:                 WVMaxDescript % alternate_value      = 0.0
  8186: +======>        WVMaxDescript % field_name           = 'WVMax'
  8187:                 WVMaxDescript % file_extension       = 63
  8188: +======>        WVMaxDescript % file_basename        = 'maxwvel'
  8189:                 WVMaxDescript % readMaxMin           = .true.
  8190:         I       call makeFileName(WVMaxDescript)
  8191:           
  8192:                 RSMaxDescript % specifier            = abs(NOUTGW)
  8193:                 RSMaxDescript % lun                  = 315
  8194:                 RSMaxDescript % initial_value        = 0.0
  8195:                 RSMaxDescript % num_items_per_record = 2
  8196:                 RSMaxDescript % num_fd_records       = MNP
  8197:                 RSMaxDescript % num_records_this     = MNP
  8198:                 RSMaxDescript % ConsiderWetDry       = .FALSE.
  8199:                 RSMaxDescript % alternate_value      = 0.0
  8200: +======>        RSMaxDescript % field_name           = "RSMax"
  8201: +======>        RSMaxDescript % file_name            = "maxrs.63"
  8202:                 RSMaxDescript % file_extension       = 63
  8203: +======>        RSMaxDescript % file_basename        = 'maxrs'
  8204:                 RSMaxDescript % readMaxMin           = .true.
  8205:         I       call makeFileName(RSMaxDescript)
  8206:           
  8207:           !  tcm v50.75 removed ifdef adcswan to allow for use whenever nrs=3 or nrs=4 or nrs=5
  8208:           !#ifdef ADCSWAN
  8209:           Cobell 20120510: SWAN Output Data
  8210:           C........Radiation Stress
  8211:                 RSDescript % specifier            = NOUTGW
  8212:                 RSDescript % lun                  = 164
  8213:                 RSDescript % initial_value        = 0.0
  8214:                 RSDescript % num_items_per_record = 2
  8215:                 RSDescript % num_fd_records       = MNP
  8216:                 RSDescript % num_records_this     = MNP
  8217:                 RSDescript % ConsiderWetDry       = .FALSE.
  8218:                 RSDescript % alternate_value      = -99999.0
  8219: +======>        RSDescript % field_name           = "rads"
  8220: +======>        RSDescript % file_name            = "rads.64"
  8221:                 RSDescript % file_extension       = 64
  8222: +======>        RSDescript % file_basename        = 'rads'
  8223:                 RSDescript % readMaxMin           = .false.
  8224:         I       call makeFileName(RSDescript)
  8225:                 !
  8226:                 !  D E T A I L E D    I N U N D A T I O N    O U T P U T
  8227:                 !
  8228:                 ! inundationtime.63 (works like a min/max file)
  8229:                 InundationTimeDescript % lun                  = 400
  8230:                 InundationTimeDescript % specifier            = abs(NOUTGE)
  8231:                 InundationTimeDescript % num_items_per_record = 1
  8232:                 InundationTimeDescript % initial_value        = 0.0
  8233:                 InundationTimeDescript % num_fd_records       = MNP
  8234:                 InundationTimeDescript % num_records_this     = MNP
  8235:                 InundationTimeDescript % ConsiderWetDry       = .false.
  8236:                 InundationTimeDescript % alternate_value      = 0.0
  8237: +======>        InundationTimeDescript % field_name           = 'inundationTime'
  8238: +======>        InundationTimeDescript % file_basename        = 'inundationtime'
  8239:                 InundationTimeDescript % file_extension       = 63
  8240:                 InundationTimeDescript % readMaxMin           = .true.
  8241:                 if ( InundationTimeDescript % specifier .eq. XDMF ) then
  8242:                    InundationTimeDescript % specifier = ASCII
  8243:                 endif
  8244:         I       call makeFileName(InundationTimeDescript)
  8245:                 !
  8246:                 ! maxinundepth.63 (works like a min/max file)
  8247:                 MaxInunDepthDescript % lun                  = 401
  8248:                 MaxInunDepthDescript % specifier            = abs(NOUTGE)
  8249:                 MaxInunDepthDescript % initial_value        = 0.0
  8250:                 MaxInunDepthDescript % num_fd_records       = MNP
  8251:                 MaxInunDepthDescript % num_records_this     = MNP
  8252:                 MaxInunDepthDescript % ConsiderWetDry       = .false.
  8253:                 MaxInunDepthDescript % alternate_value      = 0.0
  8254:                 MaxInunDepthDescript % num_items_per_record = 1
  8255: +======>        MaxInunDepthDescript % field_name           = 'maxInunDepth'
  8256: +======>        MaxInunDepthDescript % file_basename        = 'maxinundepth'
  8257:                 MaxInunDepthDescript % file_extension       = 63
  8258:                 MaxInunDepthDescript % readMaxMin           = .true.
  8259:                 if ( MaxInunDepthDescript % specifier .eq. XDMF ) then
  8260:                    MaxInunDepthDescript % specifier = ASCII
  8261:                 endif
  8262:         I       call makeFileName(MaxInunDepthDescript)
  8263:                 !
  8264:                 ! initiallydry.63 (nodes that are deemed dry upon cold start)
  8265:                 InitiallyDryDescript % lun                  = 402
  8266:                 InitiallyDryDescript % specifier            = NOUTGE
  8267:                 InitiallyDryDescript % initial_value        = 0.0
  8268:                 InitiallyDryDescript % num_fd_records       = MNP
  8269:                 InitiallyDryDescript % num_records_this     = MNP
  8270:                 InitiallyDryDescript % ConsiderWetDry       = .false.
  8271:                 InitiallyDryDescript % alternate_value      = 0.0
  8272:                 InitiallyDryDescript % num_items_per_record = 1
  8273: +======>        InitiallyDryDescript % field_name           = 'initiallyDry'
  8274: +======>        InitiallyDryDescript % file_basename        = 'initiallydry'
  8275:                 InitiallyDryDescript % file_extension       = 63
  8276:                 InitiallyDryDescript % isInteger            = .true.
  8277:                 if ( InitiallyDryDescript % specifier .eq. XDMF ) then
  8278:                    InitiallyDryDescript % specifier = ASCII
  8279:                 endif
  8280:         I       call makeFileName(InitiallyDryDescript)
  8281:                 !
  8282:                 ! endrisinginun.63 (1 if water is rising at end of simulation)
  8283:                 EndRisingInunDescript % lun                  = 403
  8284:                 EndRisingInunDescript % specifier            = NOUTGE
  8285:                 EndRisingInunDescript % initial_value        = 0.0
  8286:                 EndRisingInunDescript % num_fd_records       = MNP
  8287:                 EndRisingInunDescript % num_records_this     = MNP
  8288:                 EndRisingInunDescript % ConsiderWetDry       = .false.
  8289:                 EndRisingInunDescript % alternate_value      = 0.0
  8290:                 EndRisingInunDescript % num_items_per_record = 1
  8291: +======>        EndRisingInunDescript % field_name           = 'endRisingInun'
  8292: +======>        EndRisingInunDescript % file_basename        = 'endrisinginun'
  8293:                 EndRisingInunDescript % file_extension       = 63
  8294:                 EndRisingInunDescript % isInteger            = .true.
  8295:                 if ( EndRisingInunDescript % specifier .eq. XDMF ) then
  8296:                    EndRisingInunDescript % specifier = ASCII
  8297:                 endif
  8298:         I       call makeFileName(EndRisingInunDescript)
  8299:                 !
  8300:                 ! everdried.63 (works like a min/max file)
  8301:                 EverDriedDescript % lun                  = 404
  8302:                 EverDriedDescript % specifier            = abs(NOUTGE)
  8303:                 EverDriedDescript % num_items_per_record = 1
  8304:                 EverDriedDescript % initial_value        = 0.0
  8305:                 EverDriedDescript % num_fd_records       = MNP
  8306:                 EverDriedDescript % num_records_this     = MNP
  8307:                 EverDriedDescript % ConsiderWetDry       = .false.
  8308:                 EverDriedDescript % alternate_value      = -99999.d0
  8309: +======>        EverDriedDescript % field_name           = 'EverDried'
  8310: +======>        EverDriedDescript % file_basename        = 'everdried'
  8311:                 EverDriedDescript % file_extension       = 63
  8312:                 EverDriedDescript % readMaxMin           = .true.
  8313:                 if ( EverDriedDescript % specifier .eq. XDMF ) then
  8314:                    EverDriedDescript % specifier = ASCII
  8315:                 endif
  8316:         I       call makeFileName(EverDriedDescript)
  8317:           
  8318:                    weirElevDescript % specifier            = NOUT_TVW
  8319:                    weirElevDescript % initial_value        = 0D0
  8320:                    weirElevDescript % num_items_per_record = 1
  8321:                    weirElevDescript % num_fd_records       = MNP
  8322:                    weirElevDescript % num_records_this     = MNP
  8323:                    weirElevDescript % ConsiderWetDry       = .FALSE.
  8324:                    weirElevDescript % alternate_value      = 0D0
  8325: +======>           weirElevDescript % field_name           = "weir_dz"
  8326: +======>           weirElevDescript % file_name            = "fort.77"
  8327:           C
  8328:           C     dynamicWaterlevelCorrection.61
  8329:                 dynamicWaterlevelCorrectionStaDescript % specifier            = NOUTE
  8330:                 dynamicWaterlevelCorrectionStaDescript % lun                  = 109
  8331:                 dynamicWaterlevelCorrectionStaDescript % initial_value        = 0.0
  8332:                 dynamicWaterlevelCorrectionStaDescript % num_items_per_record = 1
  8333:                 dynamicWaterlevelCorrectionStaDescript % num_fd_records       = abs(NSTAE)
  8334:                 dynamicWaterlevelCorrectionStaDescript % num_records_this     = abs(NSTAE)
  8335:                 dynamicWaterlevelCorrectionStaDescript % alternate_value      = -99999.0
  8336: +======>        dynamicWaterlevelCorrectionStaDescript % field_name           = 'dynamicWaterlevelCorrection'
  8337:                 IF (ICS.ne.1) THEN
  8338:                    dynamicWaterlevelCorrectionStaDescript % x_coord           => SLEL
  8339:                    dynamicWaterlevelCorrectionStaDescript % y_coord           => SFEL
  8340:                 ELSE
  8341:                    dynamicWaterlevelCorrectionStaDescript % x_coord           => XEL
  8342:                    dynamicWaterlevelCorrectionStaDescript % y_coord           => YEL
  8343:                 ENDIF
  8344:                 dynamicWaterlevelCorrectionStaDescript % file_extension       = 61
  8345: +======>        dynamicWaterlevelCorrectionStaDescript % file_basename        = 'dynamicWaterlevelCorrection'
  8346:                 dynamicWaterlevelCorrectionStaDescript % readMaxMin           = .false.
  8347:                 dynamicWaterlevelCorrectionStaDescript % considerWetDry       = .false.
  8348:         I       call makeFileName(dynamicWaterlevelCorrectionStaDescript)
  8349:           C
  8350:           C     dynamicWaterlevelCorrection.63
  8351:                 dynamicWaterlevelCorrectionDescript % specifier            = NOUTGE
  8352:                 dynamicWaterlevelCorrectionDescript % lun                  = 108
  8353:                 dynamicWaterlevelCorrectionDescript % initial_value        = 0.0
  8354:                 dynamicWaterlevelCorrectionDescript % num_items_per_record = 1
  8355:                 dynamicWaterlevelCorrectionDescript % num_fd_records       = MNP
  8356:                 dynamicWaterlevelCorrectionDescript % num_records_this     = MNP
  8357:                 dynamicWaterlevelCorrectionDescript % alternate_value      = -99999.0
  8358: +======>        dynamicWaterlevelCorrectionDescript % field_name           = 'dynamicWaterlevelCorrection'
  8359:                 dynamicWaterlevelCorrectionDescript % file_extension       = 63
  8360: +======>        dynamicWaterlevelCorrectionDescript % file_basename        = 'dynamicWaterlevelCorrection'
  8361:                 dynamicWaterlevelCorrectionDescript % readMaxMin           = .false.
  8362:                 dynamicWaterlevelCorrectionDescript % considerWetDry       = .false.
  8363:         I       call makeFileName(dynamicWaterlevelCorrectionDescript)
  8364:           
  8365:           ! tcm v50.75 moved the ifdef adcswan down past the RSDescript
  8366:           #ifdef ADCSWAN
  8367:           C........Significant Wave Height (HS)
  8368:                 SwanHSDescript % specifier            = NOUTGW
  8369:                 SwanHSDescript % lun                  = 301
  8370:                 SwanHSDescript % initial_value        = 0.0
  8371:                 SwanHSDescript % num_items_per_record = 1
  8372:                 SwanHSDescript % num_fd_records       = MNP
  8373:                 SwanHSDescript % num_records_this     = MNP
  8374:                 SwanHSDescript % ConsiderWetDry       = .FALSE.
  8375:                 SwanHSDescript % alternate_value      = -99999.0
  8376: +======>        SwanHSDescript % field_name           = "swan_HS"
  8377: +======>        SwanHSDescript % file_name            = "swan_HS.63"
  8378:                 SwanHSDescript % file_extension       = 63
  8379: +======>        SwanHSDescript % file_basename        = 'swan_HS'
  8380:         I       call makeFileName(SwanHSDescript)
  8381:           
  8382:                 SwanHSMaxDescript % specifier            = NOUTGW
  8383:                 SwanHSMaxDescript % lun                  = 316
  8384:                 SwanHSMaxDescript % initial_value        = 0.0
  8385:                 SwanHSMaxDescript % num_items_per_record = 1
  8386:                 SwanHSMaxDescript % num_fd_records       = MNP
  8387:                 SwanHSMaxDescript % num_records_this     = MNP
  8388:                 SwanHSMaxDescript % ConsiderWetDry       = .FALSE.
  8389:                 SwanHSMaxDescript % alternate_value      = -99999.0
  8390: +======>        SwanHSMaxDescript % field_name           = "swan_HS_max"
  8391: +======>        SwanHSMaxDescript % file_name            = "swan_HS_max.63"
  8392:                 SwanHSMaxDescript % file_extension       = 63
  8393: +======>        SwanHSMaxDescript % file_basename        = 'swan_HS_max'
  8394:         I       call makeFileName(SwanHSMaxDescript)
  8395:           
  8396:           C........Mean Wave Direction (DIR)
  8397:                 SwanDIRDescript % specifier            = NOUTGW
  8398:                 SwanDIRDescript % lun                  = 302
  8399:                 SwanDIRDescript % initial_value        = 0.0
  8400:                 SwanDIRDescript % num_items_per_record = 1
  8401:                 SwanDIRDescript % num_fd_records       = MNP
  8402:                 SwanDIRDescript % num_records_this     = MNP
  8403:                 SwanDIRDescript % ConsiderWetDry       = .FALSE.
  8404:                 SwanDIRDescript % alternate_value      = -99999.0
  8405: +======>        SwanDIRDescript % field_name           = "swan_DIR"
  8406: +======>        SwanDIRDescript % file_name            = "swan_DIR.63"
  8407:                 SwanDIRDescript % file_extension       = 63
  8408: +======>        SwanDIRDescript % file_basename        = 'swan_DIR'
  8409:         I       call makeFileName(SwanDIRDescript)
  8410:           
  8411:                 SwanDIRMaxDescript % specifier            = NOUTGW
  8412:                 SwanDIRMaxDescript % lun                  = 317
  8413:                 SwanDIRMaxDescript % initial_value        = 0.0
  8414:                 SwanDIRMaxDescript % num_items_per_record = 1
  8415:                 SwanDIRMaxDescript % num_fd_records       = MNP
  8416:                 SwanDIRMaxDescript % num_records_this     = MNP
  8417:                 SwanDIRMaxDescript % ConsiderWetDry       = .FALSE.
  8418:                 SwanDIRMaxDescript % alternate_value      = -99999.0
  8419: +======>        SwanDIRMaxDescript % field_name           = "swan_DIR_max"
  8420: +======>        SwanDIRMaxDescript % file_name            = "swan_DIR_max.63"
  8421:                 SwanDIRMaxDescript % file_extension       = 63
  8422: +======>        SwanDIRMaxDescript % file_basename        = 'swan_DIR_max'
  8423:         I       call makeFileName(SwanDIRMaxDescript)
  8424:           
  8425:           C........Mean Wave Period (TM01)
  8426:                 SwanTM01Descript % specifier            = NOUTGW
  8427:                 SwanTM01Descript % lun                  = 303
  8428:                 SwanTM01Descript % initial_value        = 0.0
  8429:                 SwanTM01Descript % num_items_per_record = 1
  8430:                 SwanTM01Descript % num_fd_records       = MNP
  8431:                 SwanTM01Descript % num_records_this     = MNP
  8432:                 SwanTM01Descript % ConsiderWetDry       = .FALSE.
  8433:                 SwanTM01Descript % alternate_value      = -99999.0
  8434: +======>        SwanTM01Descript % field_name           = "swan_TM01"
  8435: +======>        SwanTM01Descript % file_name            = "swan_TM01.63"
  8436:                 SwanTM01Descript % file_extension       = 63
  8437: +======>        SwanTM01Descript % file_basename        = 'swan_TM01'
  8438:         I       call makeFileName(SwanTM01Descript)
  8439:           
  8440:                 SwanTM01MaxDescript % specifier            = NOUTGW
  8441:                 SwanTM01MaxDescript % lun                  = 318
  8442:                 SwanTM01MaxDescript % initial_value        = 0.0
  8443:                 SwanTM01MaxDescript % num_items_per_record = 1
  8444:                 SwanTM01MaxDescript % num_fd_records       = MNP
  8445:                 SwanTM01MaxDescript % num_records_this     = MNP
  8446:                 SwanTM01MaxDescript % ConsiderWetDry       = .FALSE.
  8447:                 SwanTM01MaxDescript % alternate_value      = -99999.0
  8448: +======>        SwanTM01MaxDescript % field_name           = "swan_TM01_max"
  8449: +======>        SwanTM01MaxDescript % file_name            = "swan_TM01_max.63"
  8450:                 SwanTM01MaxDescript % file_extension       = 63
  8451: +======>        SwanTM01MaxDescript % file_basename        = 'swan_TM01_max'
  8452:         I       call makeFileName(SwanTM01MaxDescript)
  8453:           
  8454:           C........Peak Wave Period (TPS)
  8455:                 SwanTPSDescript % specifier            = NOUTGW
  8456:                 SwanTPSDescript % lun                  = 304
  8457:                 SwanTPSDescript % initial_value        = 0.0
  8458:                 SwanTPSDescript % num_items_per_record = 1
  8459:                 SwanTPSDescript % num_fd_records       = MNP
  8460:                 SwanTPSDescript % num_records_this     = MNP
  8461:                 SwanTPSDescript % ConsiderWetDry       = .FALSE.
  8462:                 SwanTPSDescript % alternate_value      = -99999.0
  8463: +======>        SwanTPSDescript % field_name           = "Swan_TPS"
  8464: +======>        SwanTPSDescript % file_name            = "swan_TPS.63"
  8465:                 SwanTPSDescript % file_extension       = 63
  8466: +======>        SwanTPSDescript % file_basename        = 'swan_TPS'
  8467:         I       call makeFileName(SwanTPSDescript)
  8468:           
  8469:                 SwanTPSMaxDescript % specifier            = NOUTGW
  8470:                 SwanTPSMaxDescript % lun                  = 319
  8471:                 SwanTPSMaxDescript % initial_value        = 0.0
  8472:                 SwanTPSMaxDescript % num_items_per_record = 1
  8473:                 SwanTPSMaxDescript % num_fd_records       = MNP
  8474:                 SwanTPSMaxDescript % num_records_this     = MNP
  8475:                 SwanTPSMaxDescript % ConsiderWetDry       = .FALSE.
  8476:                 SwanTPSMaxDescript % alternate_value      = -99999.0
  8477: +======>        SwanTPSMaxDescript % field_name           = "Swan_TPS_max"
  8478: +======>        SwanTPSMaxDescript % file_name            = "swan_TPS_max.63"
  8479:                 SwanTPSMaxDescript % file_extension       = 63
  8480: +======>        SwanTPSMaxDescript % file_basename        = 'swan_TPS_max'
  8481:         I       call makeFileName(SwanTPSMaxDescript)
  8482:           
  8483:           C........SWAN Wind Values (WINDX,WINDY)
  8484:                 SwanWindDescript % specifier            = NOUTGW
  8485:                 SwanWindDescript % lun                  = 305
  8486:                 SwanWindDescript % initial_value        = 0.0
  8487:                 SwanWindDescript % num_items_per_record = 2
  8488:                 SwanWindDescript % num_fd_records       = MNP
  8489:                 SwanWindDescript % num_records_this     = MNP
  8490:                 SwanWindDescript % ConsiderWetDry       = .FALSE.
  8491:                 SwanWindDescript % alternate_value      = -99999.0
  8492: +======>        SwanWindDescript % field_name           = "swan_WIND"
  8493: +======>        SwanWindDescript % file_name            = "swan_WIND.64"
  8494:                 SwanWindDescript % file_extension       = 64
  8495: +======>        SwanWindDescript % file_basename        = 'swan_WIND'
  8496:         I       call makeFileName(SwanWindDescript)
  8497:           
  8498:                 SwanWindMaxDescript % specifier            = NOUTGW
  8499:                 SwanWindMaxDescript % lun                  = 320
  8500:                 SwanWindMaxDescript % initial_value        = 0.0
  8501:                 SwanWindMaxDescript % num_items_per_record = 1
  8502:                 SwanWindMaxDescript % num_fd_records       = MNP
  8503:                 SwanWindMaxDescript % num_records_this     = MNP
  8504:                 SwanWindMaxDescript % ConsiderWetDry       = .FALSE.
  8505:                 SwanWindMaxDescript % alternate_value      = -99999.0
  8506: +======>        SwanWindMaxDescript % field_name           = "swan_WIND_max"
  8507: +======>        SwanWindMaxDescript % file_name            = "swan_WIND_max.63"
  8508:                 SwanWindMaxDescript % file_extension       = 63
  8509: +======>        SwanWindMaxDescript % file_basename        = 'swan_WIND_max'
  8510:         I       call makeFileName(SwanWindMaxDescript)
  8511:           
  8512:           C........Mean Wave Period (TM02)
  8513:                 SwanTM02Descript % specifier            = NOUTGW
  8514:                 SwanTM02Descript % lun                  = 306
  8515:                 SwanTM02Descript % initial_value        = 0.0
  8516:                 SwanTM02Descript % num_items_per_record = 1
  8517:                 SwanTM02Descript % num_fd_records       = MNP
  8518:                 SwanTM02Descript % num_records_this     = MNP
  8519:                 SwanTM02Descript % ConsiderWetDry       = .FALSE.
  8520:                 SwanTM02Descript % alternate_value      = -99999.0
  8521: +======>        SwanTM02Descript % field_name           = "swan_TM02"
  8522: +======>        SwanTM02Descript % file_name            = "swan_TM02.63"
  8523:                 SwanTM02Descript % file_extension       = 63
  8524: +======>        SwanTM02Descript % file_basename        = 'swan_TM02'
  8525:         I       call makeFileName(SwanTM02Descript)
  8526:           
  8527:                 SwanTM02MaxDescript % specifier            = NOUTGW
  8528:                 SwanTM02MaxDescript % lun                  = 321
  8529:                 SwanTM02MaxDescript % initial_value        = 0.0
  8530:                 SwanTM02MaxDescript % num_items_per_record = 1
  8531:                 SwanTM02MaxDescript % num_fd_records       = MNP
  8532:                 SwanTM02MaxDescript % num_records_this     = MNP
  8533:                 SwanTM02MaxDescript % ConsiderWetDry       = .FALSE.
  8534:                 SwanTM02MaxDescript % alternate_value      = -99999.0
  8535: +======>        SwanTM02MaxDescript % field_name           = "swan_TM02_max"
  8536: +======>        SwanTM02MaxDescript % file_name            = "swan_TM02_max.63"
  8537:                 SwanTM02MaxDescript % file_extension       = 63
  8538: +======>        SwanTM02MaxDescript % file_basename        = 'swan_TM02_max'
  8539:         I       call makeFileName(SwanTM02MaxDescript)
  8540:           
  8541:           C........Mean Wave Period (TMM10)
  8542:                 SwanTMM10Descript % specifier            = NOUTGW
  8543:                 SwanTMM10Descript % lun                  = 307
  8544:                 SwanTMM10Descript % initial_value        = 0.0
  8545:                 SwanTMM10Descript % num_items_per_record = 1
  8546:                 SwanTMM10Descript % num_fd_records       = MNP
  8547:                 SwanTMM10Descript % num_records_this     = MNP
  8548:                 SwanTMM10Descript % ConsiderWetDry       = .FALSE.
  8549:                 SwanTMM10Descript % alternate_value      = -99999.0
  8550: +======>        SwanTMM10Descript % field_name           = "swan_TMM10"
  8551: +======>        SwanTMM10Descript % file_name            = "swan_TMM10.63"
  8552:                 SwanTMM10Descript % file_extension       = 63
  8553: +======>        SwanTMM10Descript % file_basename        = 'swan_TMM10'
  8554:         I       call makeFileName(SwanTMM10Descript)
  8555:           
  8556:                 SwanTMM10MaxDescript % specifier            = NOUTGW
  8557:                 SwanTMM10MaxDescript % lun                  = 322
  8558:                 SwanTMM10MaxDescript % initial_value        = 0.0
  8559:                 SwanTMM10MaxDescript % num_items_per_record = 1
  8560:                 SwanTMM10MaxDescript % num_fd_records       = MNP
  8561:                 SwanTMM10MaxDescript % num_records_this     = MNP
  8562:                 SwanTMM10MaxDescript % ConsiderWetDry       = .FALSE.
  8563:                 SwanTMM10MaxDescript % alternate_value      = -99999.0
  8564: +======>        SwanTMM10MaxDescript % field_name           = "swan_TMM10_max"
  8565: +======>        SwanTMM10MaxDescript % file_name          = "swan_TMM10_max.63"
  8566:                 SwanTMM10MaxDescript % file_extension       = 63
  8567: +======>        SwanTMM10MaxDescript % file_basename        = 'swan_TMM10_max'
  8568:         I       call makeFileName(SwanTMM10MaxDescript)
  8569:           
  8570:           #endif
  8571:           C     3D data
  8572:           C     fort.41
  8573:                 SigTStaDescript % specifier            = I3DSD
  8574:                 SigTStaDescript % lun                  = 41
  8575:                 SigTStaDescript % initial_value        = 0.0
  8576:                 SigTStaDescript % num_items_per_record = NFEN
  8577:                 SigTStaDescript % num_fd_records       = NSTA3DD
  8578:                 SigTStaDescript % num_records_this     = NSTA3DD
  8579: +======>        SigTStaDescript % field_name           = 'SigmaTStations'
  8580:                 IF (ICS.ne.1) THEN
  8581:                    SigTStaDescript % x_coord           => SL3DD
  8582:                    SigTStaDescript % y_coord           => SF3DD
  8583:                 ELSE
  8584:                    SigTStaDescript % x_coord           => X3DD
  8585:                    SigTStaDescript % y_coord           => Y3DD
  8586:                 ENDIF
  8587:                 SigTStaDescript % file_extension       = 41
  8588: +======>        SigTStaDescript % file_basename        = 'fort'
  8589:         I       call makeFileName(SigTStaDescript)
  8590:           
  8591:                 SalStaDescript % specifier            = I3DSD
  8592:                 SalStaDescript % lun                  = 41
  8593:                 SalStaDescript % initial_value        = 0.0
  8594:                 SalStaDescript % num_items_per_record = NFEN
  8595:                 SalStaDescript % num_fd_records       = NSTA3DD
  8596:                 SalStaDescript % num_records_this     = NSTA3DD
  8597: +======>        SalStaDescript % field_name           = 'SalinityStations'
  8598:                 IF (ICS.ne.1) THEN
  8599:                    SalStaDescript % x_coord           => SL3DD
  8600:                    SalStaDescript % y_coord           => SF3DD
  8601:                 ELSE
  8602:                    SalStaDescript % x_coord           => X3DD
  8603:                    SalStaDescript % y_coord           => Y3DD
  8604:                 ENDIF
  8605:           
  8606:                 TempStaDescript % specifier            = I3DSD
  8607:                 TempStaDescript % lun                  = 41
  8608:                 TempStaDescript % initial_value        = 0.0
  8609:                 TempStaDescript % num_items_per_record = NFEN
  8610:                 TempStaDescript % num_fd_records       = NSTA3DD
  8611:                 TempStaDescript % num_records_this     = NSTA3DD
  8612: +======>        TempStaDescript % field_name           = 'TemperatureStations'
  8613:                 IF (ICS.ne.1) THEN
  8614:                    TempStaDescript % x_coord           => SL3DD
  8615:                    TempStaDescript % y_coord           => SF3DD
  8616:                 ELSE
  8617:                    TempStaDescript % x_coord           => X3DD
  8618:                    TempStaDescript % y_coord           => Y3DD
  8619:                 ENDIF
  8620:           C
  8621:           C     fort.42
  8622:                 RealQStaDescript % specifier            =  I3DSV
  8623:                 RealQStaDescript % lun                  =  42
  8624:                 RealQStaDescript % initial_value        =  0.0
  8625:                 RealQStaDescript % num_items_per_record =  NFEN
  8626:                 RealQStaDescript % num_fd_records       =  NSta3DV
  8627:                 RealQStaDescript % num_records_this     =  NSta3DV
  8628: +======>        RealQStaDescript % field_name           = 'RealQStations'
  8629:                 IF (ICS.ne.1) THEN
  8630:                    RealQStaDescript % x_coord           => SL3DV
  8631:                    RealQStaDescript % y_coord           => SF3DV
  8632:                 ELSE
  8633:                    RealQStaDescript % x_coord           => X3DV
  8634:                    RealQStaDescript % y_coord           => Y3DV
  8635:                 ENDIF
  8636:                 RealQStaDescript % file_extension       = 42
  8637: +======>        RealQStaDescript % file_basename        = 'fort'
  8638:         I       call makeFileName(RealQStaDescript)
  8639:           
  8640:                 ImaginaryQStaDescript % specifier            =  I3DSV
  8641:                 ImaginaryQStaDescript % lun                  =  42
  8642:                 ImaginaryQStaDescript % initial_value        =  0.0
  8643:                 ImaginaryQStaDescript % num_items_per_record =  NFEN
  8644:                 ImaginaryQStaDescript % num_fd_records       =  NSTA3DV
  8645:                 ImaginaryQStaDescript % num_records_this     =  NSTA3DV
  8646: +======>        ImaginaryQStaDescript % field_name      ='ImaginaryQStations'
  8647:                 IF (ICS.ne.1) THEN
  8648:                    ImaginaryQStaDescript % x_coord           => SL3DV
  8649:                    ImaginaryQStaDescript % y_coord           => SF3DV
  8650:                 ELSE
  8651:                    ImaginaryQStaDescript % x_coord           => X3DV
  8652:                    ImaginaryQStaDescript % y_coord           => Y3DV
  8653:                 ENDIF
  8654:           
  8655:                 WZStaDescript % specifier            =  I3DSV
  8656:                 WZStaDescript % lun                  =  42
  8657:                 WZStaDescript % initial_value        =  0.0
  8658:                 WZStaDescript % num_items_per_record =  NFEN
  8659:                 WZStaDescript % num_fd_records       =  NSTA3DV
  8660:                 WZStaDescript % num_records_this     =  NSTA3DV
  8661: +======>        WZStaDescript % field_name           = 'WZStations'
  8662:                 IF (ICS.ne.1) THEN
  8663:                    WZStaDescript % x_coord           => SL3DV
  8664:                    WZStaDescript % y_coord           => SF3DV
  8665:                 ELSE
  8666:                    WZStaDescript % x_coord           => X3DV
  8667:                    WZStaDescript % y_coord           => Y3DV
  8668:                 ENDIF
  8669:           C
  8670:           C     fort.43
  8671:                 Q20StaDescript % specifier            =  I3DST
  8672:                 Q20StaDescript % lun                  =  43
  8673:                 Q20StaDescript % initial_value        =  0.0
  8674:                 Q20StaDescript % num_items_per_record =  NFEN
  8675:                 Q20StaDescript % num_fd_records       =  NSta3DT
  8676:                 Q20StaDescript % num_records_this     =  NSta3DT
  8677: +======>        Q20StaDescript % field_name           = 'q20Stations'
  8678:                 IF (ICS.ne.1) THEN
  8679:                    Q20StaDescript % x_coord           => SL3DT
  8680:                    Q20StaDescript % y_coord           => SF3DT
  8681:                 ELSE
  8682:                    Q20StaDescript % x_coord           => X3DT
  8683:                    Q20StaDescript % y_coord           => Y3DT
  8684:                 ENDIF
  8685:                 Q20StaDescript % file_extension       = 43
  8686: +======>        Q20StaDescript % file_basename        = 'fort'
  8687:         I       call makeFileName(Q20StaDescript)
  8688:           
  8689:                 LStaDescript % specifier            =  I3DST
  8690:                 LStaDescript % lun                  =  43
  8691:                 LStaDescript % initial_value        =  0.0
  8692:                 LStaDescript % num_items_per_record =  NFEN
  8693:                 LStaDescript % num_fd_records       =  NSTA3DT
  8694:                 LStaDescript % num_records_this     =  NSTA3DT
  8695: +======>        LStaDescript % field_name           = 'LStations'
  8696:                 IF (ICS.ne.1) THEN
  8697:                    LStaDescript % x_coord           => SL3DT
  8698:                    LStaDescript % y_coord           => SF3DT
  8699:                 ELSE
  8700:                    LStaDescript % x_coord           => X3DT
  8701:                    LStaDescript % y_coord           => Y3DT
  8702:                 ENDIF
  8703:           
  8704:                 EVStaDescript % specifier            =  I3DST
  8705:                 EVStaDescript % lun                  =  43
  8706:                 EVStaDescript % initial_value        =  0.0
  8707:                 EVStaDescript % num_items_per_record =  NFEN
  8708:                 EVStaDescript % num_fd_records       =  NSTA3DT
  8709:                 EVStaDescript % num_records_this     =  NSTA3DT
  8710: +======>        EVStaDescript % field_name           = 'EVStations'
  8711:                 IF (ICS.ne.1) THEN
  8712:                    EVStaDescript % x_coord           => SL3DT
  8713:                    EVStaDescript % y_coord           => SF3DT
  8714:                 ELSE
  8715:                    EVStaDescript % x_coord           => X3DT
  8716:                    EVStaDescript % y_coord           => Y3DT
  8717:                 ENDIF
  8718:           C
  8719:           C     fort.44
  8720:                 SigTDescript % specifier            =  I3DGD
  8721:                 SigTDescript % lun                  =  44
  8722:                 SigTDescript % initial_value        =  0.0
  8723:                 SigTDescript % num_items_per_record =  NFEN
  8724:                 SigTDescript % num_fd_records        =  MNP
  8725:                 SigTDescript % num_records_this     =  MNP
  8726: +======>        SigTDescript % field_name           = 'SigmaT'
  8727:                 SigTDescript % file_extension       = 44
  8728: +======>        SigTDescript % file_basename        = 'fort'
  8729:         I       call makeFileName(SigTDescript)
  8730:           
  8731:                 SalDescript % specifier            =  I3DGD
  8732:                 SalDescript % lun                  =  44
  8733:                 SalDescript % initial_value        =  0.0
  8734:                 SalDescript % num_items_per_record =  NFEN
  8735:                 SalDescript % num_fd_records       =  MNP
  8736:                 SalDescript % num_records_this     =  MNP
  8737: +======>        SalDescript % field_name           = 'Salinity'
  8738:                 TempDescript % specifier            =  I3DGD
  8739:                 TempDescript % lun                  =  44
  8740:                 TempDescript % initial_value        =  0.0
  8741:                 TempDescript % num_items_per_record =  NFEN
  8742:                 TempDescript % num_fd_records       =  MNP
  8743:                 TempDescript % num_records_this     =  MNP
  8744: +======>        TempDescript % field_name           = 'Temperature'
  8745:           C
  8746:           C     fort.45
  8747:                 RealQDescript % specifier            =  I3DGV
  8748:                 RealQDescript % lun                  =  45
  8749:                 RealQdescript % initial_value        =  0.0
  8750:                 RealQDescript % num_items_per_record =  NFEN
  8751:                 RealQDescript % num_fd_records       =  MNP
  8752:                 RealQDescript % num_records_this     =  MNP
  8753: +======>        RealQDescript % field_name           = 'RealQ'
  8754:                 RealQDescript % file_extension       = 45
  8755: +======>        RealQDescript % file_basename        = 'fort'
  8756:         I       call makeFileName(RealQDescript)
  8757:           
  8758:                 ImaginaryQDescript % specifier            =  I3DGV
  8759:                 ImaginaryQDescript % lun                  =  45
  8760:                 ImaginaryQDescript % initial_value        =  0.0
  8761:                 ImaginaryQDescript % num_items_per_record =  NFEN
  8762:                 ImaginaryQDescript % num_fd_records       =  MNP
  8763:                 ImaginaryQDescript % num_records_this     =  MNP
  8764: +======>        ImaginaryQDescript % field_name           = 'ImaginaryQ'
  8765:                 WZDescript % specifier            =  I3DGV
  8766:                 WZDescript % lun                  =  45
  8767:                 WZDescript % initial_value        =  0.0
  8768:                 WZDescript % num_items_per_record =  NFEN
  8769:                 WZDescript % num_fd_records       =  MNP
  8770:                 WZDescript % num_records_this     =  MNP
  8771: +======>        WZDescript % field_name           = 'WZ'
  8772:           C
  8773:           C     fort.46
  8774:                 Q20Descript % specifier            =  I3DGT
  8775:                 Q20Descript % lun                  =  46
  8776:                 Q20Descript % initial_value        =  0.0
  8777:                 Q20Descript % num_items_per_record =  NFEN
  8778:                 Q20Descript % num_fd_records       =  MNP
  8779:                 Q20Descript % num_records_this     =  MNP
  8780: +======>        Q20Descript % field_name           = 'q20'
  8781:                 Q20Descript % file_extension       = 46
  8782: +======>        Q20Descript % file_basename        = 'fort'
  8783:         I       call makeFileName(Q20Descript)
  8784:           
  8785:                 LDescript % specifier            =  I3DGT
  8786:                 LDescript % lun                  =  46
  8787:                 LDescript % initial_value        =  0.0
  8788:                 LDescript % num_items_per_record =  NFEN
  8789:                 LDescript % num_fd_records       =  MNP
  8790:                 LDescript % num_records_this     =  MNP
  8791: +======>        LDescript % field_name           = 'L'
  8792:                 EVDescript % specifier            =  I3DGT
  8793:                 EVDescript % lun                  =  46
  8794:                 EVDescript % initial_value        =  0.0
  8795:                 EVDescript % num_items_per_record =  NFEN
  8796:                 EVDescript % num_fd_records       =  MNP
  8797:                 EVDescript % num_records_this     =  MNP
  8798: +======>        EVDescript % field_name           = 'EV'
  8799:           C
  8800:           C     fort.47
  8801:                 QSurfKp1Descript % specifier            =  I3DGD
  8802:                 QSurfKp1Descript % lun                  =  47
  8803:                 QSurfKp1Descript % initial_value        =  0.0
  8804:                 QSurfKp1Descript % num_items_per_record =  1
  8805:                 QSurfKp1Descript % num_fd_records     =  MNP
  8806:                 QSurfKp1Descript % num_records_this   =  MNP
  8807: +======>        QSurfKp1Descript % field_name           = 'qsurfkp1'
  8808:         I       call makeFileName(QSurfKp1Descript)
  8809:           C
  8810:           C     fort.67 and fort.68
  8811:                 Elev1Descript % specifier            = NHSTAR
  8812:                 Elev1Descript % initial_value        = 0.0
  8813: +======>        Elev1Descript % file_basename        = 'fort'
  8814:                 Elev1Descript % file_extension       = 67
  8815:         I       call makeFileName(Elev1Descript)
  8816:                 Elev2Descript % specifier            = NHSTAR
  8817:                 Elev2Descript % initial_value        = 0.0
  8818:                 CH1Descript % specifier            = NHSTAR
  8819:                 CH1Descript % initial_value        = 0.0
  8820:                 EtaDiscDescript % specifier            = NHSTAR
  8821:                 EtaDiscDescript % initial_value        = 0.0
  8822:                 NodeCodeDescript % specifier            = NHSTAR
  8823:                 NodeCodeDescript % initial_value        = 0.d0
  8824:                 NOFFDescript % specifier            = NHSTAR
  8825:                 NOFFDescript % initial_value        = 0.d0
  8826:           C     hotstart 3D
  8827:                 Duudescript % specifier            =  NHSTAR
  8828:                 Duudescript % initial_value        =  0.0
  8829:                 Duudescript % num_items_per_record =  1
  8830:                 Duudescript % num_fd_records       =  MNP
  8831:                 Duudescript % num_records_this     =  MNP
  8832:                 Duvdescript % specifier            =  NHSTAR
  8833:                 Duvdescript % initial_value        =  0.0
  8834:                 Duvdescript % num_items_per_record =  1
  8835:                 Duvdescript % num_fd_records       =  MNP
  8836:                 Duvdescript % num_records_this     =  MNP
  8837:                 Dvvdescript % specifier            =  NHSTAR
  8838:                 Dvvdescript % initial_value        =  0.0
  8839:                 Dvvdescript % num_items_per_record =  1
  8840:                 Dvvdescript % num_fd_records       =  MNP
  8841:                 Dvvdescript % num_records_this     =  MNP
  8842:                 Uudescript % specifier            =  NHSTAR
  8843:                 Uudescript % initial_value        =  0.0
  8844:                 Uudescript % num_items_per_record =  1
  8845:                 Uudescript % num_fd_records       =  MNP
  8846:                 Uudescript % num_records_this     =  MNP
  8847:                 Vvdescript % specifier            =  NHSTAR
  8848:                 Vvdescript % initial_value        =  0.0
  8849:                 Vvdescript % num_items_per_record =  1
  8850:                 Vvdescript % num_fd_records       =  MNP
  8851:                 Vvdescript % num_records_this     =  MNP
  8852:                 Bsxdescript % specifier            =  NHSTAR
  8853:                 Bsxdescript % initial_value        =  0.0
  8854:                 Bsxdescript % num_items_per_record =  1
  8855:                 Bsxdescript % num_fd_records       =  MNP
  8856:                 Bsxdescript % num_records_this     =  MNP
  8857:                 Bsydescript % specifier            =  NHSTAR
  8858:                 Bsydescript % initial_value        =  0.0
  8859:                 Bsydescript % num_items_per_record =  1
  8860:                 Bsydescript % num_fd_records       =  MNP
  8861:                 Bsydescript % num_records_this     =  MNP
  8862:           C     hotstart harmonic analysis
  8863:                 HarmElevFDLVDescript % specifier            = NHSTAR
  8864:                 HarmElevFDLVDescript % initial_value        = 0.0
  8865:                 HarmElevFDLVDescript % num_fd_records       = MNP
  8866:                 HarmElevSLVDescript % specifier            = NHSTAR
  8867:                 HarmElevSLVDescript % initial_value        = 0.0
  8868:                 HarmElevSLVDescript % num_fd_records       = abs(NSTAE)
  8869:                 HarmUVelFDLVDescript % specifier            = NHSTAR
  8870:                 HarmUVelFDLVDescript % initial_value        = 0.0
  8871:                 HarmUVelFDLVDescript % num_fd_records       = MNP
  8872:                 HarmVVelFDLVDescript % specifier            = NHSTAR
  8873:                 HarmVVelFDLVDescript % initial_value        = 0.0
  8874:                 HarmVVelFDLVDescript % num_fd_records       = MNP
  8875:                 HarmUvelSLVDescript % specifier            = NHSTAR
  8876:                 HarmUVelSLVDescript % initial_value        = 0.0
  8877:                 HarmUVelSLVDescript % num_fd_records       = abs(NSTAV)
  8878:                 HarmVVelSLVDescript % specifier            = NHSTAR
  8879:                 HarmVVelSLVDescript % initial_value        = 0.0
  8880:                 HarmVVelSLVDescript % num_fd_records       = abs(NSTAV)
  8881:           C     hotstart means and variance calculations
  8882:                 ELAVDescript % specifier            = NHSTAR
  8883:                 ELAVDescript % initial_value        = 0.0
  8884:                 ELAVDescript % num_fd_records       = MNP
  8885:                 ELVADescript % specifier            = NHSTAR
  8886:                 ELVADescript % initial_value        = 0.0
  8887:                 ELVADescript % num_fd_records       = MNP
  8888:                 XVELAVDescript % specifier            = NHSTAR
  8889:                 XVELAVDescript % initial_value        = 0.0
  8890:                 XVELAVDescript % num_fd_records       = MNP
  8891:                 YVELAVDescript % specifier            = NHSTAR
  8892:                 YVELAVDescript % initial_value        = 0.0
  8893:                 YVELAVDescript % num_fd_records       = MNP
  8894:                 XVELVADescript % specifier            = NHSTAR
  8895:                 XVELVADescript % initial_value        = 0.0
  8896:                 XVELVADescript % num_fd_records       = MNP
  8897:                 YVELVADescript % specifier            = NHSTAR
  8898:                 YVELVADescript % initial_value        = 0.0
  8899:                 YVELVADescript % num_fd_records       = MNP
  8900:           C
  8901:           C     Need to populate the global and nodal attributes modules with
  8902:           C     these parameters, since the netcdfio module relies on those
  8903:           C     modules, rather than the pre_global module. Some day, adcprep
  8904:           C     will be integrated with ADCIRC and this subroutine call will
  8905:           C     not be needed.
  8906:                 IF (.not.ALLOCATED(NODECODE)) THEN
  8907:                    ALLOCATE(NODECODE(MNP))
  8908:                 ENDIF
  8909:           C
  8910:           C     jgf49.44: Set parameters in global module based on the data
  8911:           C     we collected in read_global.F and stored in pre_global.F.
  8912:                 CALL setADCIRCParameters(
  8913:                &   base_date, MNE, NBOU,
  8914:                &   NVEL, NOPE, MNP, SL0, SF0, NBVV, NVDLL, NBDV, NVELL, X, Y,
  8915:                &   IBTYPE, IBTYPEE, SL1, SF1, NODECODE, G, FileFmtRev,
  8916:                &   FileFmtMinor, FileFmtMajor, im, iestp, nscoue, ivstp, nscouv,
  8917:                &   icstp, nscouc, ipstp, iwstp, nscoum, igep, nscouge, igvp,
  8918:                &   nscougv, igcp, nscougc, igpp, igwp, nscougw, NM,
  8919:                &   DP, RUNDES, AGRID, title, institution, source, history,
  8920:                &   references, comments, host, convention, contact, DT, ihot,
  8921:                &   ics, nolifa, nolica, nolicat, ncor, ntip, nws, nramp, statim,
  8922:                &   reftim, rnday, dramp, a00, b00, c00, h0, cori, ntif, nbfr,
  8923:                &   myProc, screenUnit, nolibf, nwp, tau0, cf, eslm,
  8924:                &   abs(nstae), abs(nstav), abs(nstam), neta, nabout, nscreen,
  8925:                &   nfen, iden, islip, kp, z0s, z0b, theta1, theta2,
  8926:                &   ievc, evmin, evcon, alp1, alp2, alp3, igc, nlsd, nvsd, nltd,
  8927:                &   nvtd, alp4, C3D, runid)
  8928:           
  8929:           !     Create NetCDF output files for those output files where NetCDF
  8930:           !     was specified.
  8931:                 reterr = .false.
  8932:                 !WJP 02.20.2018 Adding capability for fort.51-54
  8933:                 CALL initNetCDFOutputFile(HaElevStaDescript, reterr)
  8934:                 CALL initNetCDFOutputFile(HaVelStaDescript, reterr)
  8935:                 CALL initNetCDFOutputFile(HaElevDescript, reterr)
  8936:                 CALL initNetCDFOutputFile(HaVelDescript, reterr)
  8937:                 CALL initNetCDFOutputFile(ElevStaDescript, reterr)
  8938:                 CALL initNetCDFOutputFile(VelStaDescript, reterr)
  8939:                 CALL initNetCDFOutputFile(ElevDescript, reterr)
  8940:                 if (outputTau0.eqv..true.) then
  8941:                    CALL initNetCDFOutputFile(Tau0Descript, reterr)
  8942:                 endif
  8943:                 CALL initNetCDFOutputFile(VelDescript, reterr)
  8944:                 CALL initNetCDFOutputFile(PrStaDescript, reterr)
  8945:                 CALL initNetCDFOutputFile(WindVelStaDescript, reterr)
  8946:                 CALL initNetCDFOutputFile(PrDescript, reterr)
  8947:                 CALL initNetCDFOutputFile(WindVelDescript, reterr)
  8948:           C ++ GML 20200605
  8949:                 CALL initNetCDFOutputFile(IceStaDescript, reterr)
  8950:                 CALL initNetCDFOutputFile(IceAFDescript, reterr)
  8951:           C++
  8952:                 CALL initNetCDFOutputFile(WeirElevDescript, reterr)
  8953:                 CALL initNetCDFOutputFile(EtaMaxDescript, reterr)
  8954:                 CALL initNetCDFOutputFile(UMaxDescript, reterr)
  8955:                 CALL initNetCDFOutputFile(PrMinDescript, reterr)
  8956:                 CALL initNetCDFOutputFile(WVMaxDescript, reterr)
  8957:                 CALL initNetCDFOutputFile(RSMaxDescript,reterr)
  8958:                 if (inundationOutput.eqv..true.) then
  8959:                    CALL initNetCDFOutputFile(InundationTimeDescript,reterr)
  8960:                    CALL initNetCDFOutputFile(MaxInunDepthDescript,reterr)
  8961:                    CALL initNetCDFOutputFile(InitiallyDryDescript,reterr)
  8962:                    CALL initNetCDFOutputFile(EndRisingInunDescript,reterr)
  8963:                    CALL initNetCDFOutputFile(EverDriedDescript,reterr)
  8964:                 endif
  8965:                 if (outputWindDrag.eqv..true.)then
  8966:                    CALL initNetCDFOutputFile(windDragDescript,reterr)
  8967:                 endif
  8968:                 if ( foundCorrectionControlNamelist.eqv..true. ) then
  8969:                    if ( NOUTE.ne.0 ) then
  8970:                       CALL initNetCDFOutputFile(dynamicWaterlevelCorrectionStaDescript,reterr)
  8971:                    endif
  8972:                    if ( NOUTGE.ne.0 ) then
  8973:                       CALL initNetCDFOutputFile(dynamicWaterlevelCorrectionDescript,reterr)
  8974:                    endif
  8975:                 endif
  8976:                 !
  8977:                 ! tcm v50.75 moved ifdef adcswan below RSDescript only to allow
  8978:                 ! for use whenever nrs=3 or nrs=4 or nrs=5
  8979:                 ! Cobell 20120510: Added for SWAN NetCDF
  8980:                 ! dw: added NRS == 5 for NEMS support
  8981:                 IF ((NRS.EQ.3).OR.(NRS.EQ.4).OR.(NRS.EQ.5)) THEN
  8982:                   CALL initNetCDFOutputFile(RSDescript,reterr)
  8983:                 ENDIF
  8984:                 ! tcm v50.75 moved ifdef adcswan to here
  8985:           #ifdef ADCSWAN
  8986:                 ! Cobell 20120510: Added for SWAN NetCDF
  8987:                 IF(NRS.EQ.3)THEN
  8988:                   IF(SWAN_OutputHS)THEN
  8989:                       CALL initNetCDFOutputFile(SwanHSDescript,reterr)
  8990:                       CALL initNetCDFOutputFile(SwanHSMaxDescript,reterr)
  8991:                   ENDIF
  8992:                   IF(SWAN_OutputDIR)THEN
  8993:                       CALL initNetCDFOutputFile(SwanDIRDescript,reterr)
  8994:                       CALL initNetCDFOutputFile(SwanDIRMaxDescript,reterr)
  8995:                   ENDIF
  8996:                   IF(SWAN_OutputTM01)THEN
  8997:                       CALL initNetCDFOutputFile(SwanTM01Descript,reterr)
  8998:                       CALL initNetCDFOutputFile(SwanTM01MaxDescript,reterr)
  8999:                   ENDIF
  9000:                   IF(SWAN_OutputTPS)THEN
  9001:                       CALL initNetCDFOutputFile(SwanTPSDescript,reterr)
  9002:                       CALL initNetCDFOutputFile(SwanTPSMaxDescript,reterr)
  9003:                   ENDIF
  9004:                   IF(SWAN_OutputWIND)THEN
  9005:                       CALL initNetCDFOutputFile(SwanWINDDescript,reterr)
  9006:                       CALL initNetCDFOutputFile(SwanWINDMaxDescript,reterr)
  9007:                   ENDIF
  9008:                   IF(SWAN_OutputTM02)THEN
  9009:                       CALL initNetCDFOutputFile(SwanTM02Descript,reterr)
  9010:                       CALL initNetCDFOutputFile(SwanTM02MaxDescript,reterr)
  9011:                   ENDIF
  9012:                   IF(SWAN_OutputTMM10)THEN
  9013:                       CALL initNetCDFOutputFile(SwanTMM10Descript,reterr)
  9014:                       CALL initNetCDFOutputFile(SwanTMM10MaxDescript,reterr)
  9015:                   ENDIF
  9016:                 ENDIF
  9017:           #endif
  9018:           C
  9019:                 IF (C3D.eqv..true.) THEN
  9020:                    CALL initNetCDFOutputFile(SigTStaDescript, reterr,
  9021:                &       SalStaDescript, TempStaDescript)
  9022:                    CALL initNetCDFOutputFile(RealQStaDescript, reterr,
  9023:                &      ImaginaryQStaDescript, WZStaDescript)
  9024:                    CALL initNetCDFOutputFile(Q20StaDescript, reterr,
  9025:                &      LStaDescript, EVStaDescript)
  9026:                    CALL initNetCDFOutputFile(SigTDescript, reterr,
  9027:                &      SalDescript, TempDescript)
  9028:                    CALL initNetCDFOutputFile(RealQDescript, reterr,
  9029:                &      ImaginaryQDescript, WZDescript)
  9030:                    CALL initNetCDFOutputFile(Q20Descript, reterr,
  9031:                &      LDescript, EVDescript)
  9032:                    CALL initNetCDFOutputFile(QSurfKp1Descript, reterr)
  9033:                 ENDIF
  9034:           C
  9035:           C     Create NetCDF hotstart files if NetCDF was specified.
  9036:                 IF ((abs(NHSTAR).EQ.3).OR.(NHSTAR.EQ.367).OR.(NHSTAR.EQ.368).OR.
  9037:                & (abs(NHSTAR).EQ.5).OR.(NHSTAR.EQ.567).OR.(NHSTAR.EQ.568)) THEN
  9038:                    ! must init both hotstart files ... there is not enough information
  9039:                    ! available to determine if they will both be needed
  9040:                    IF ((IHOT.ne.367).and.(IHOT.ne.567)) THEN
  9041: +======>              Elev1Descript % file_name = 'fort.67'
  9042:                       CALL initNetCDFHotstart(67, Elev1Descript,
  9043:                &         Elev2Descript, VelDescript, CH1Descript, EtaDiscDescript,
  9044:                &         NodeCodeDescript, NOFFDescript, reterr)
  9045:                       IF (C3D.eqv..true.) THEN
  9046:                          CALL initNetCDFHotstart3D(67,NHSTAR)
  9047:                       ENDIF
  9048:                    ENDIF
  9049:                    IF ((IHOT.ne.368).and.(IHOT.ne.568)) THEN
  9050: +======>              Elev1Descript % file_name = 'fort.68'
  9051:                       CALL initNetCDFHotstart(68, Elev1Descript,
  9052:                &         Elev2Descript, VelDescript, CH1Descript, EtaDiscDescript,
  9053:                &         NodeCodeDescript, NOFFDescript, reterr)
  9054:                       IF (C3D.eqv..true.) THEN
  9055:                          CALL initNetCDFHotstart3D(68,NHSTAR)
  9056:                       ENDIF
  9057:                    ENDIF
  9058:                    IF (IHARIND.eq.1) THEN
  9059:                       IF ((IHOT.ne.367).and.(IHOT.ne.567)) THEN
  9060:                          CALL initNetCDFHotstartHarmonic(67,
  9061:                &            HarmElevFDLVDescript, HarmElevSLVDescript,
  9062:                &            HarmUVelFDLVDescript, HarmVVelFDLVDescript,
  9063:                &            HarmUVelSLVDescript, HarmVVelSLVDescript, reterr)
  9064:                       ENDIF
  9065:                       IF ((IHOT.ne.368).and.(IHOT.ne.568)) THEN
  9066:                          CALL initNetCDFHotstartHarmonic(68,
  9067:                &            HarmElevFDLVDescript, HarmElevSLVDescript,
  9068:                &            HarmUVelFDLVDescript, HarmVVelFDLVDescript,
  9069:                &            HarmUVelSLVDescript, HarmVVelSLVDescript, reterr)
  9070:                       ENDIF
  9071:                       IF (CHARMV.eqv..true.) THEN
  9072:                          IF ((IHOT.ne.367).and.(IHOT.ne.567)) THEN
  9073:                             CALL initNetCDFHotstartHarmonicMeansVariances(
  9074:                &               67, ELAVDescript, ELVADescript,
  9075:                &               XVELAVDescript, YVELAVDescript, XVELVADescript,
  9076:                &               YVELVADescript, reterr)
  9077:                          ENDIF
  9078:                          IF ((IHOT.ne.368).and.(IHOT.ne.568)) THEN
  9079:                             CALL initNetCDFHotstartHarmonicMeansVariances(
  9080:                &               68, ELAVDescript, ELVADescript,
  9081:                &               XVELAVDescript, YVELAVDescript, XVELVADescript,
  9082:                &               YVELVADescript, reterr)
  9083:                          ENDIF
  9084:                       ENDIF
  9085:                    ENDIF
  9086:                 ENDIF
  9087:                 ! free up memory allocated for mesh and boundaries
  9088:                 CALL freeNetCDFCoord()
  9089:           #endif
  9090:           c----------------------------------------------------------------------------
  9091:                 END SUBROUTINE prepNetCDF


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPNETCDF
INLINE LIST

  ROOT: PREPNETCDF (prep.F:7661)
  -> INLINE: MAKEFILENAME (prep.F:7847)
  -> INLINE: MAKEFILENAME (prep.F:7869)
  -> INLINE: MAKEFILENAME (prep.F:7884)
  -> INLINE: MAKEFILENAME (prep.F:7899)
  -> INLINE: MAKEFILENAME (prep.F:7921)
  -> INLINE: MAKEFILENAME (prep.F:7943)
  -> INLINE: MAKEFILENAME (prep.F:7958)
  -> INLINE: MAKEFILENAME (prep.F:7972)
  -> INLINE: MAKEFILENAME (prep.F:7987)
  -> INLINE: MAKEFILENAME (prep.F:8004)
  -> INLINE: MAKEFILENAME (prep.F:8019)
  -> INLINE: MAKEFILENAME (prep.F:8041)
  -> INLINE: MAKEFILENAME (prep.F:8063)
  -> INLINE: MAKEFILENAME (prep.F:8078)
  -> INLINE: MAKEFILENAME (prep.F:8093)
  -> INLINE: MAKEFILENAME (prep.F:8108)
  -> INLINE: MAKEFILENAME (prep.F:8122)
  -> INLINE: MAKEFILENAME (prep.F:8145)
  -> INLINE: MAKEFILENAME (prep.F:8159)
  -> INLINE: MAKEFILENAME (prep.F:8175)
  -> INLINE: MAKEFILENAME (prep.F:8190)
  -> INLINE: MAKEFILENAME (prep.F:8205)
  -> INLINE: MAKEFILENAME (prep.F:8224)
  -> INLINE: MAKEFILENAME (prep.F:8244)
  -> INLINE: MAKEFILENAME (prep.F:8262)
  -> INLINE: MAKEFILENAME (prep.F:8280)
  -> INLINE: MAKEFILENAME (prep.F:8298)
  -> INLINE: MAKEFILENAME (prep.F:8316)
  -> INLINE: MAKEFILENAME (prep.F:8348)
  -> INLINE: MAKEFILENAME (prep.F:8363)
  -> INLINE: MAKEFILENAME (prep.F:8380)
  -> INLINE: MAKEFILENAME (prep.F:8394)
  -> INLINE: MAKEFILENAME (prep.F:8409)
  -> INLINE: MAKEFILENAME (prep.F:8423)
  -> INLINE: MAKEFILENAME (prep.F:8438)
  -> INLINE: MAKEFILENAME (prep.F:8452)
  -> INLINE: MAKEFILENAME (prep.F:8467)
  -> INLINE: MAKEFILENAME (prep.F:8481)
  -> INLINE: MAKEFILENAME (prep.F:8496)
  -> INLINE: MAKEFILENAME (prep.F:8510)
  -> INLINE: MAKEFILENAME (prep.F:8525)
  -> INLINE: MAKEFILENAME (prep.F:8539)
  -> INLINE: MAKEFILENAME (prep.F:8554)
  -> INLINE: MAKEFILENAME (prep.F:8568)
  -> INLINE: MAKEFILENAME (prep.F:8589)
  -> INLINE: MAKEFILENAME (prep.F:8638)
  -> INLINE: MAKEFILENAME (prep.F:8687)
  -> INLINE: MAKEFILENAME (prep.F:8729)
  -> INLINE: MAKEFILENAME (prep.F:8756)
  -> INLINE: MAKEFILENAME (prep.F:8783)
  -> INLINE: MAKEFILENAME (prep.F:8808)
  -> INLINE: MAKEFILENAME (prep.F:8815)
  -> NOINLINE: NETCDFIO::SETADCIRCPARAMETERS (prep.F:8912)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8933)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8934)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8935)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8936)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8937)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8938)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8939)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8941)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8943)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8944)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8945)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8946)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8947)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8949)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8950)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8952)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8953)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8954)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8955)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8956)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8957)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8959)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8960)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8961)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8962)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8963)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8966)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8970)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8973)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8982)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8989)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8990)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8993)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8994)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8997)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:8998)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9001)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9002)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9005)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9006)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9009)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9010)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9013)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9014)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9020)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9022)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9024)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9026)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9028)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9030)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFOUTPUTFILE (prep.F:9032)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTART (prep.F:9042)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTART3D (prep.F:9046)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTART (prep.F:9051)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTART3D (prep.F:9055)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTARTHARMONIC (prep.F:9060)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTARTHARMONIC (prep.F:9066)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTARTHARMONICMEANSVARIANCES (prep.F:9073)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::INITNETCDFHOTSTARTHARMONICMEANSVARIANCES (prep.F:9079)
     *** Source for routine not found.
  -> NOINLINE: NETCDFIO::FREENETCDFCOORD (prep.F:9088)
     *** Source for routine not found.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPNETCDF
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:7836)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAELEVSTADESCRIPT%FIELD_NAME (prep.F:7836)
  LOOP END

  LOOP BEGIN: (prep.F:7845)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAELEVSTADESCRIPT%FILE_BASENAME (prep.F:7845)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7858)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAVELSTADESCRIPT%FIELD_NAME (prep.F:7858)
  LOOP END

  LOOP BEGIN: (prep.F:7867)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAVELSTADESCRIPT%FILE_BASENAME (prep.F:7867)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7880)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAELEVDESCRIPT%FIELD_NAME (prep.F:7880)
  LOOP END

  LOOP BEGIN: (prep.F:7882)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAELEVDESCRIPT%FILE_BASENAME (prep.F:7882)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7895)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAVELDESCRIPT%FIELD_NAME (prep.F:7895)
  LOOP END

  LOOP BEGIN: (prep.F:7897)
    <Unvectorized loop.>
    *** Unvectorizable data type. : HAVELDESCRIPT%FILE_BASENAME (prep.F:7897)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7910)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEVSTADESCRIPT%FIELD_NAME (prep.F:7910)
  LOOP END

  LOOP BEGIN: (prep.F:7919)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEVSTADESCRIPT%FILE_BASENAME (prep.F:7919)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7932)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VELSTADESCRIPT%FIELD_NAME (prep.F:7932)
  LOOP END

  LOOP BEGIN: (prep.F:7941)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VELSTADESCRIPT%FILE_BASENAME (prep.F:7941)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7954)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEVDESCRIPT%FIELD_NAME (prep.F:7954)
  LOOP END

  LOOP BEGIN: (prep.F:7956)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEVDESCRIPT%FILE_BASENAME (prep.F:7956)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7968)
    <Unvectorized loop.>
    *** Unvectorizable data type. : TAU0DESCRIPT%FIELD_NAME (prep.F:7968)
  LOOP END

  LOOP BEGIN: (prep.F:7970)
    <Unvectorized loop.>
    *** Unvectorizable data type. : TAU0DESCRIPT%FILE_BASENAME (prep.F:7970)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:7983)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VELDESCRIPT%FIELD_NAME (prep.F:7983)
  LOOP END

  LOOP BEGIN: (prep.F:7985)
    <Unvectorized loop.>
    *** Unvectorizable data type. : VELDESCRIPT%FILE_BASENAME (prep.F:7985)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8000)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ETAMAXDESCRIPT%FIELD_NAME (prep.F:8000)
  LOOP END

  LOOP BEGIN: (prep.F:8002)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ETAMAXDESCRIPT%FILE_BASENAME (prep.F:8002)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8015)
    <Unvectorized loop.>
    *** Unvectorizable data type. : UMAXDESCRIPT%FIELD_NAME (prep.F:8015)
  LOOP END

  LOOP BEGIN: (prep.F:8017)
    <Unvectorized loop.>
    *** Unvectorizable data type. : UMAXDESCRIPT%FILE_BASENAME (prep.F:8017)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8030)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRSTADESCRIPT%FIELD_NAME (prep.F:8030)
  LOOP END

  LOOP BEGIN: (prep.F:8039)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRSTADESCRIPT%FILE_BASENAME (prep.F:8039)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8052)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8052)
  LOOP END

  LOOP BEGIN: (prep.F:8052)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDVELSTADESCRIPT%FIELD_NAME (prep.F:8052)
  LOOP END

  LOOP BEGIN: (prep.F:8061)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDVELSTADESCRIPT%FILE_BASENAME (prep.F:8061)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8074)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRDESCRIPT%FIELD_NAME (prep.F:8074)
  LOOP END

  LOOP BEGIN: (prep.F:8076)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRDESCRIPT%FILE_BASENAME (prep.F:8076)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8089)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDVELDESCRIPT%FIELD_NAME (prep.F:8089)
  LOOP END

  LOOP BEGIN: (prep.F:8091)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDVELDESCRIPT%FILE_BASENAME (prep.F:8091)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8104)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDDRAGDESCRIPT%FIELD_NAME (prep.F:8104)
  LOOP END

  LOOP BEGIN: (prep.F:8106)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WINDDRAGDESCRIPT%FILE_BASENAME (prep.F:8106)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8119)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WEIRELEVDESCRIPT%FIELD_NAME (prep.F:8119)
  LOOP END

  LOOP BEGIN: (prep.F:8121)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WEIRELEVDESCRIPT%FILE_BASENAME (prep.F:8121)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8134)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ICESTADESCRIPT%FIELD_NAME (prep.F:8134)
  LOOP END

  LOOP BEGIN: (prep.F:8143)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ICESTADESCRIPT%FILE_BASENAME (prep.F:8143)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8155)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ICEAFDESCRIPT%FIELD_NAME (prep.F:8155)
  LOOP END

  LOOP BEGIN: (prep.F:8157)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ICEAFDESCRIPT%FILE_BASENAME (prep.F:8157)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8171)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRMINDESCRIPT%FIELD_NAME (prep.F:8171)
  LOOP END

  LOOP BEGIN: (prep.F:8173)
    <Unvectorized loop.>
    *** Unvectorizable data type. : PRMINDESCRIPT%FILE_BASENAME (prep.F:8173)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8186)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WVMAXDESCRIPT%FIELD_NAME (prep.F:8186)
  LOOP END

  LOOP BEGIN: (prep.F:8188)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WVMAXDESCRIPT%FILE_BASENAME (prep.F:8188)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8200)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSMAXDESCRIPT%FIELD_NAME (prep.F:8200)
  LOOP END

  LOOP BEGIN: (prep.F:8201)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSMAXDESCRIPT%FILE_NAME (prep.F:8201)
  LOOP END

  LOOP BEGIN: (prep.F:8203)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSMAXDESCRIPT%FILE_BASENAME (prep.F:8203)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8219)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSDESCRIPT%FIELD_NAME (prep.F:8219)
  LOOP END

  LOOP BEGIN: (prep.F:8220)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSDESCRIPT%FILE_NAME (prep.F:8220)
  LOOP END

  LOOP BEGIN: (prep.F:8222)
    <Unvectorized loop.>
    *** Unvectorizable data type. : RSDESCRIPT%FILE_BASENAME (prep.F:8222)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8237)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8237)
  LOOP END

  LOOP BEGIN: (prep.F:8238)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8238)
  LOOP END

  LOOP BEGIN: (prep.F:8238)
    <Unvectorized loop.>
    *** Unvectorizable data type. : INUNDATIONTIMEDESCRIPT%FILE_BASENAME (prep.F:8238)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8255)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8255)
  LOOP END

  LOOP BEGIN: (prep.F:8256)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8256)
  LOOP END

  LOOP BEGIN: (prep.F:8256)
    <Unvectorized loop.>
    *** Unvectorizable data type. : MAXINUNDEPTHDESCRIPT%FILE_BASENAME (prep.F:8256)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8273)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8273)
  LOOP END

  LOOP BEGIN: (prep.F:8274)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8274)
  LOOP END

  LOOP BEGIN: (prep.F:8274)
    <Unvectorized loop.>
    *** Unvectorizable data type. : INITIALLYDRYDESCRIPT%FILE_BASENAME (prep.F:8274)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8291)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8291)
  LOOP END

  LOOP BEGIN: (prep.F:8292)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8292)
  LOOP END

  LOOP BEGIN: (prep.F:8292)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ENDRISINGINUNDESCRIPT%FILE_BASENAME (prep.F:8292)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8309)
    <Unvectorized loop.>
    *** Unvectorizable data type. : EVERDRIEDDESCRIPT%FIELD_NAME (prep.F:8309)
  LOOP END

  LOOP BEGIN: (prep.F:8310)
    <Unvectorized loop.>
    *** Unvectorizable data type. : EVERDRIEDDESCRIPT%FILE_BASENAME (prep.F:8310)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8325)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WEIRELEVDESCRIPT%FIELD_NAME (prep.F:8325)
  LOOP END

  LOOP BEGIN: (prep.F:8326)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WEIRELEVDESCRIPT%FILE_NAME (prep.F:8326)
  LOOP END

  LOOP BEGIN: (prep.F:8336)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8336)
  LOOP END

  LOOP BEGIN: (prep.F:8345)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8345)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8358)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8358)
  LOOP END

  LOOP BEGIN: (prep.F:8360)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8360)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8376)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANHSDESCRIPT%FIELD_NAME (prep.F:8376)
  LOOP END

  LOOP BEGIN: (prep.F:8377)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8377)
  LOOP END

  LOOP BEGIN: (prep.F:8377)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANHSDESCRIPT%FILE_NAME (prep.F:8377)
  LOOP END

  LOOP BEGIN: (prep.F:8379)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANHSDESCRIPT%FILE_BASENAME (prep.F:8379)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8390)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8390)
  LOOP END

  LOOP BEGIN: (prep.F:8391)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8391)
  LOOP END

  LOOP BEGIN: (prep.F:8391)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANHSMAXDESCRIPT%FILE_NAME (prep.F:8391)
  LOOP END

  LOOP BEGIN: (prep.F:8393)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8393)
  LOOP END

  LOOP BEGIN: (prep.F:8393)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANHSMAXDESCRIPT%FILE_BASENAME (prep.F:8393)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8405)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANDIRDESCRIPT%FIELD_NAME (prep.F:8405)
  LOOP END

  LOOP BEGIN: (prep.F:8406)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8406)
  LOOP END

  LOOP BEGIN: (prep.F:8406)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANDIRDESCRIPT%FILE_NAME (prep.F:8406)
  LOOP END

  LOOP BEGIN: (prep.F:8408)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANDIRDESCRIPT%FILE_BASENAME (prep.F:8408)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8419)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8419)
  LOOP END

  LOOP BEGIN: (prep.F:8420)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8420)
  LOOP END

  LOOP BEGIN: (prep.F:8420)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANDIRMAXDESCRIPT%FILE_NAME (prep.F:8420)
  LOOP END

  LOOP BEGIN: (prep.F:8422)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8422)
  LOOP END

  LOOP BEGIN: (prep.F:8422)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANDIRMAXDESCRIPT%FILE_BASENAME (prep.F:8422)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8434)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM01DESCRIPT%FIELD_NAME (prep.F:8434)
  LOOP END

  LOOP BEGIN: (prep.F:8435)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8435)
  LOOP END

  LOOP BEGIN: (prep.F:8435)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM01DESCRIPT%FILE_NAME (prep.F:8435)
  LOOP END

  LOOP BEGIN: (prep.F:8437)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM01DESCRIPT%FILE_BASENAME (prep.F:8437)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8448)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8448)
  LOOP END

  LOOP BEGIN: (prep.F:8449)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8449)
  LOOP END

  LOOP BEGIN: (prep.F:8449)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM01MAXDESCRIPT%FILE_NAME (prep.F:8449)
  LOOP END

  LOOP BEGIN: (prep.F:8451)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8451)
  LOOP END

  LOOP BEGIN: (prep.F:8451)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM01MAXDESCRIPT%FILE_BASENAME (prep.F:8451)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8463)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTPSDESCRIPT%FIELD_NAME (prep.F:8463)
  LOOP END

  LOOP BEGIN: (prep.F:8464)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8464)
  LOOP END

  LOOP BEGIN: (prep.F:8464)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTPSDESCRIPT%FILE_NAME (prep.F:8464)
  LOOP END

  LOOP BEGIN: (prep.F:8466)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTPSDESCRIPT%FILE_BASENAME (prep.F:8466)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8477)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8477)
  LOOP END

  LOOP BEGIN: (prep.F:8478)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8478)
  LOOP END

  LOOP BEGIN: (prep.F:8478)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTPSMAXDESCRIPT%FILE_NAME (prep.F:8478)
  LOOP END

  LOOP BEGIN: (prep.F:8480)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8480)
  LOOP END

  LOOP BEGIN: (prep.F:8480)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTPSMAXDESCRIPT%FILE_BASENAME (prep.F:8480)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8492)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANWINDDESCRIPT%FIELD_NAME (prep.F:8492)
  LOOP END

  LOOP BEGIN: (prep.F:8493)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8493)
  LOOP END

  LOOP BEGIN: (prep.F:8493)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANWINDDESCRIPT%FILE_NAME (prep.F:8493)
  LOOP END

  LOOP BEGIN: (prep.F:8495)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANWINDDESCRIPT%FILE_BASENAME (prep.F:8495)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8506)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8506)
  LOOP END

  LOOP BEGIN: (prep.F:8507)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8507)
  LOOP END

  LOOP BEGIN: (prep.F:8507)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANWINDMAXDESCRIPT%FILE_NAME (prep.F:8507)
  LOOP END

  LOOP BEGIN: (prep.F:8509)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8509)
  LOOP END

  LOOP BEGIN: (prep.F:8509)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANWINDMAXDESCRIPT%FILE_BASENAME (prep.F:8509)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8521)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM02DESCRIPT%FIELD_NAME (prep.F:8521)
  LOOP END

  LOOP BEGIN: (prep.F:8522)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8522)
  LOOP END

  LOOP BEGIN: (prep.F:8522)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM02DESCRIPT%FILE_NAME (prep.F:8522)
  LOOP END

  LOOP BEGIN: (prep.F:8524)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM02DESCRIPT%FILE_BASENAME (prep.F:8524)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8535)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8535)
  LOOP END

  LOOP BEGIN: (prep.F:8536)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8536)
  LOOP END

  LOOP BEGIN: (prep.F:8536)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM02MAXDESCRIPT%FILE_NAME (prep.F:8536)
  LOOP END

  LOOP BEGIN: (prep.F:8538)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8538)
  LOOP END

  LOOP BEGIN: (prep.F:8538)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTM02MAXDESCRIPT%FILE_BASENAME (prep.F:8538)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8550)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8550)
  LOOP END

  LOOP BEGIN: (prep.F:8550)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTMM10DESCRIPT%FIELD_NAME (prep.F:8550)
  LOOP END

  LOOP BEGIN: (prep.F:8551)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8551)
  LOOP END

  LOOP BEGIN: (prep.F:8551)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTMM10DESCRIPT%FILE_NAME (prep.F:8551)
  LOOP END

  LOOP BEGIN: (prep.F:8553)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8553)
  LOOP END

  LOOP BEGIN: (prep.F:8553)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTMM10DESCRIPT%FILE_BASENAME (prep.F:8553)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8564)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8564)
  LOOP END

  LOOP BEGIN: (prep.F:8565)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8565)
  LOOP END

  LOOP BEGIN: (prep.F:8565)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTMM10MAXDESCRIPT%FILE_NAME (prep.F:8565)
  LOOP END

  LOOP BEGIN: (prep.F:8567)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8567)
  LOOP END

  LOOP BEGIN: (prep.F:8567)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SWANTMM10MAXDESCRIPT%FILE_BASENAME (prep.F:8567)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8579)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8579)
  LOOP END

  LOOP BEGIN: (prep.F:8588)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SIGTSTADESCRIPT%FILE_BASENAME (prep.F:8588)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8597)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8597)
  LOOP END

  LOOP BEGIN: (prep.F:8612)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8612)
  LOOP END

  LOOP BEGIN: (prep.F:8628)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8628)
  LOOP END

  LOOP BEGIN: (prep.F:8637)
    <Unvectorized loop.>
    *** Unvectorizable data type. : REALQSTADESCRIPT%FILE_BASENAME (prep.F:8637)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8646)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8646)
  LOOP END

  LOOP BEGIN: (prep.F:8661)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8661)
  LOOP END

  LOOP BEGIN: (prep.F:8661)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WZSTADESCRIPT%FIELD_NAME (prep.F:8661)
  LOOP END

  LOOP BEGIN: (prep.F:8677)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8677)
  LOOP END

  LOOP BEGIN: (prep.F:8686)
    <Unvectorized loop.>
    *** Unvectorizable data type. : Q20STADESCRIPT%FILE_BASENAME (prep.F:8686)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8695)
    <Unvectorized loop.>
    *** Unvectorizable data type. : LSTADESCRIPT%FIELD_NAME (prep.F:8695)
  LOOP END

  LOOP BEGIN: (prep.F:8710)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8710)
  LOOP END

  LOOP BEGIN: (prep.F:8710)
    <Unvectorized loop.>
    *** Unvectorizable data type. : EVSTADESCRIPT%FIELD_NAME (prep.F:8710)
  LOOP END

  LOOP BEGIN: (prep.F:8726)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SIGTDESCRIPT%FIELD_NAME (prep.F:8726)
  LOOP END

  LOOP BEGIN: (prep.F:8728)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SIGTDESCRIPT%FILE_BASENAME (prep.F:8728)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8737)
    <Unvectorized loop.>
    *** Unvectorizable data type. : SALDESCRIPT%FIELD_NAME (prep.F:8737)
  LOOP END

  LOOP BEGIN: (prep.F:8744)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8744)
  LOOP END

  LOOP BEGIN: (prep.F:8753)
    <Unvectorized loop.>
    *** Unvectorizable data type. : REALQDESCRIPT%FIELD_NAME (prep.F:8753)
  LOOP END

  LOOP BEGIN: (prep.F:8755)
    <Unvectorized loop.>
    *** Unvectorizable data type. : REALQDESCRIPT%FILE_BASENAME (prep.F:8755)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8764)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:8764)
  LOOP END

  LOOP BEGIN: (prep.F:8764)
    <Unvectorized loop.>
    *** Unvectorizable data type. : IMAGINARYQDESCRIPT%FIELD_NAME (prep.F:8764)
  LOOP END

  LOOP BEGIN: (prep.F:8771)
    <Unvectorized loop.>
    *** Unvectorizable data type. : WZDESCRIPT%FIELD_NAME (prep.F:8771)
  LOOP END

  LOOP BEGIN: (prep.F:8780)
    <Unvectorized loop.>
    *** Unvectorizable data type. : Q20DESCRIPT%FIELD_NAME (prep.F:8780)
  LOOP END

  LOOP BEGIN: (prep.F:8782)
    <Unvectorized loop.>
    *** Unvectorizable data type. : Q20DESCRIPT%FILE_BASENAME (prep.F:8782)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8791)
    <Unvectorized loop.>
    *** Unvectorizable data type. : LDESCRIPT%FIELD_NAME (prep.F:8791)
  LOOP END

  LOOP BEGIN: (prep.F:8798)
    <Unvectorized loop.>
    *** Unvectorizable data type. : EVDESCRIPT%FIELD_NAME (prep.F:8798)
  LOOP END

  LOOP BEGIN: (prep.F:8807)
    <Unvectorized loop.>
    *** Unvectorizable data type. : QSURFKP1DESCRIPT%FIELD_NAME (prep.F:8807)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:8813)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEV1DESCRIPT%FILE_BASENAME (prep.F:8813)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9041)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEV1DESCRIPT%FILE_NAME (prep.F:9041)
  LOOP END

  LOOP BEGIN: (prep.F:9050)
    <Unvectorized loop.>
    *** Unvectorizable data type. : ELEV1DESCRIPT%FILE_NAME (prep.F:9050)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: PREPNETCDF
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 61 [s0-s12 s15-s16 s18-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 121792 bytes
      Register spill area      :   4912 bytes
      Parameter area           :    992 bytes
      Register save area       :    176 bytes
      User data area           : 115712 bytes
      Others                   :      0 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:7836)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7845)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7858)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7867)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7880)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7882)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7895)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7897)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7910)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7919)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7932)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7941)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7954)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7956)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7968)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7970)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7983)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:7985)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8000)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8002)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8015)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8017)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8030)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8039)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8052)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8052)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8061)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8074)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8076)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8089)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8091)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8104)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8106)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8119)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8121)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8134)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8143)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8155)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8157)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8171)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8173)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8186)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8188)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8200)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8201)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8203)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8219)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8220)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8222)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8237)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8238)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8238)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8255)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8256)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8256)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8273)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8274)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8274)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8291)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8292)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8292)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8309)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8310)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8325)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8326)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8336)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8345)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8358)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8360)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8376)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8377)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8377)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8379)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8390)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8391)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8391)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8393)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8393)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8405)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8406)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8406)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8408)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8419)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8420)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8420)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8422)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8422)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8434)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8435)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8435)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8437)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8448)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8449)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8449)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8451)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8451)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8463)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8464)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8464)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8466)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8477)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8478)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8478)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8480)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8480)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8492)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8493)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8493)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8495)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8506)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8507)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8507)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8509)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8509)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8521)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8522)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8522)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8524)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8535)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8536)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8536)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8538)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8538)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8550)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8550)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8551)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8551)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8553)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8553)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8564)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8565)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8565)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8567)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8567)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8579)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8588)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8597)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8612)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8628)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8637)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8646)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8661)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8661)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8677)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8686)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8695)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8710)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8710)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8726)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8728)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8737)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8744)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8753)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8755)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8764)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:8764)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8771)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8780)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8782)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8791)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8798)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8807)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:8813)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9041)
    *** Estimated execution cycle                       : 5
  LOOP END

  LOOP BEGIN: (prep.F:9050)
    *** Estimated execution cycle                       : 5
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: MAKEFILENAME
DIAGNOSTIC LIST

 LINE              DIAGNOSTIC MESSAGE

  9108: vec( 103): Unvectorized loop.
  9108: vec( 108): Unvectorizable loop structure.
  9108: vec( 118): Unvectorizable data type.: FILE_NAME


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: MAKEFILENAME
FORMAT LIST

 Loop Mark                              Line Mark
 ---------                              ---------
 C - Conditionally Vectorized           C - Vector Scatter
 P - Parallelized                       F - Fused-multiply-add
 S - Partially Vectorized               G - Vector Gather
 U - Unrolled                           I - Inlined
 V - Vectorized                         M - Vector Matrix Multiply
 W - Collapsed and Vectorized           R - Retain
 Y - Parallelized and Vectorized        V - Vreg
 X - Interchanged and Vectorized        
 + - Not Vectorized                     
 * - Expanded                           

 LINE   LOOP      STATEMENT

  9101:                 subroutine makeFileName(descript)
  9102:                 use global, only : OutputDataDescript_t
  9103:                 implicit none
  9104:                 type(OutputDataDescript_t), intent(inout) :: descript
  9105:                 character(len=10) :: extString
  9106:           
  9107:                 write(extString,'(i0)') descript % file_extension
  9108: +======>        descript % file_name = trim(descript % file_basename) //
  9109:                &         '.' // trim(extString)
  9110:           c----------------------------------------------------------------------------
  9111:                 end subroutine makeFileName


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: MAKEFILENAME
INLINE LIST

  No message.


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: MAKEFILENAME
VECTORIZATION LIST

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable loop structure. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. (prep.F:9108)
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    <Unvectorized loop.>
    *** Unvectorizable data type. : FILE_NAME (prep.F:9108)
  LOOP END


NEC Fortran Compiler (5.2.0) for Vector Engine   Mon Jun 10 14:44:34 2024
FILE NAME: /S/home01/G6012/d0954/DATA/model_run/adcirc_src/prep/prep.F

PROCEDURE NAME: MAKEFILENAME
CODE GENERATION LIST

  Hardware registers
    Reserved                   : 10 [sl fp lr sp s12 s13 tp got plt s17]
    Callee-saved               : 16 [s18-s33]
    Assigned
      Scalar registers         : 28 [s0-s4 s8-s12 s15-s16 s18-s19 s23-s31 s59-s63]
      Vector registers         :  0
      Vector mask registers    :  0
      VREG directive           :  0

  Routine stack
    Total size                 : 2320 bytes
      Register spill area      :    8 bytes
      Parameter area           :   40 bytes
      Register save area       :  176 bytes
      User data area           : 2088 bytes
      Others                   :    8 bytes

    Note: Total size of Routine stack does not include
          the size extended by alloca() and so on.

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 7
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 6
  LOOP END

  LOOP BEGIN: (prep.F:9108)
    *** Estimated execution cycle                       : 5
  LOOP END


